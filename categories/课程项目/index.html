<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>分类: 课程项目 - Homepage of Jinghua Xu</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Homepage of Jinghua Xu"><meta name="msapplication-TileImage" content="/img/photo.jpg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Homepage of Jinghua Xu"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="/img/photo.jpg"><meta name="description" content="重庆大学2022级明月科创实验班人工智能专业本科在读"><meta property="og:type" content="blog"><meta property="og:title" content="Homepage of Jinghua Xu"><meta property="og:url" content="http://asgard-tim.github.io/"><meta property="og:site_name" content="Homepage of Jinghua Xu"><meta property="og:description" content="重庆大学2022级明月科创实验班人工智能专业本科在读"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://asgard-tim.github.io/img/og_image.png"><meta property="article:author" content="Tim"><meta property="article:tag" content="Blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://asgard-tim.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://Asgard-Tim.github.io"},"headline":"Homepage of Jinghua Xu","image":["http://asgard-tim.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tim"},"publisher":{"@type":"Organization","name":"Homepage of Jinghua Xu","logo":{"@type":"ImageObject","url":"http://asgard-tim.github.io/img/title1.png"}},"description":"重庆大学2022级明月科创实验班人工智能专业本科在读"}</script><link rel="icon" href="/img/photo.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/xt256.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/title1.png" alt="Homepage of Jinghua Xu" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Contect me on GitHub" href="https://github.com/Asgard-Tim"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">课程项目</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2025-04-22T18:07:03.000Z" title="2025/4/23 02:07:03">2025-04-23</time>发表</span><span class="level-item"><time datetime="2025-04-29T15:58:08.821Z" title="2025/4/29 23:58:08">2025-04-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">工程数值分析</a></span><span class="level-item">1 小时读完 (大约8883个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/23/project02/">图像插值算法及其优化</a></p><div class="content"><div id="postchat_postcontent"><h2 id="研究背景及其意义"><a href="#研究背景及其意义" class="headerlink" title="研究背景及其意义"></a>研究背景及其意义</h2><p>图像<strong>放大</strong>与<strong>旋转</strong>是数字图像处理中最基础的几何变换操作，其核心在于如何通过插值算法重建原始图像中不存在的像素信息。当对图像进行放大操作时，输出图像的像素网格会超出原始图像的采样范围，需要通过插值来填补这些新增像素点的颜色值；而在旋转操作中，即使保持图像尺寸不变，原始像素的整数坐标经过旋转变换后也会落在新图像的非整数位置，同样需要通过插值来重新确定每个输出像素的颜色值。</p>
<p>图像插值是利用原图像中的颜色值通过一定的方法计算出待插入像素点的颜色值的过程。对图像进行插值一般有两个步骤：首先定义一个图像插值公式，然后利用该插值公式计算待插入点的颜色值。常见的图像插值算法有双线性法、最近邻法、非均匀法、双三次卷积插值法、双立方法、Lagrange法、 样条插值法、 克里金（Krijing） 插值法等。这些插值方法通常定义一个插值数据点的隐式函数，再提取该函数的等值面作为图像插值方法，常用的插值核包括线性插值核、样条插值核等。</p>
<ul>
<li><strong>最近邻插值</strong>作为最简单的算法，直接将距离待插值点最近的已知像素值作为结果，虽然计算效率极高（时间复杂度O(1)），但会产生明显的块状伪影（“马赛克”）和锯齿形边缘；</li>
<li><strong>双线性插值</strong>通过考虑2×2邻域内四个像素的加权平均，在计算成本（O(n)）和视觉效果之间取得平衡，但仍会导致高频信息丢失和边缘模糊；</li>
<li>更高阶的<strong>双三次插值</strong>（使用4×4邻域）和样条插值虽然能提供更平滑的结果，但计算复杂度显著增加（O(n²)），且可能引入不必要的振铃效应。</li>
</ul>
<p>现有算法的根本<strong>局限</strong>在于<strong>采用统一的插值核函数处理整幅图像，忽视了图像不同区域的特征差异</strong>。例如，在平坦区域使用复杂插值会造成计算资源浪费，而在纹理丰富区域使用简单插值又会导致细节损失。基于此，我们希望通过改良的<strong>四平面插值</strong>算法对图像的放大与旋转效果进行优化，<strong>根据图像局部特征自适应地选择不同的插值策略</strong>，以规避用同一个插值公式对所有像素进行插值存在的不足。</p>
<h2 id="常用图像插值算法"><a href="#常用图像插值算法" class="headerlink" title="常用图像插值算法"></a>常用图像插值算法</h2><p>课本在6.5节中提到，在插值节点数量较多时，为避免Runge振荡现象的发生，并不提倡用高次多项式进行插值，而宁可用低次多项式作分段插值。在图像处理这一特定的应用场景中，需要处理的图像尺寸规模往往较大，且同一行（列）的所有像素颜色值显然并不具有可以用一个多项式函数显式表达的规律，但相邻的像素点颜色值之间又存在一定的关联性，因此分段插值仅考虑局部特征的特性在这里能够良好地契合所需性能。根据对于待插入像素点周围已有的像素点信息的利用情况，这里列举了几种常见的图像插值算法：</p>
<ul>
<li>最近邻法：仅利用待插值像素点转换至原图像坐标后距离其最近的一个像素点的颜色值，将其直接作为待插值像素点的颜色值</li>
<li>双线性法：利用待插值像素点转换至原图像坐标后距离其最近的四个像素点的颜色值，加权平均后作为待插值像素点的颜色值</li>
<li>双立方法：利用待插值像素点转换至原图像坐标后距离其最近的十六个像素点的颜色值，加权平均后作为待插值像素点的颜色值</li>
</ul>
<h3 id="最近邻法"><a href="#最近邻法" class="headerlink" title="最近邻法"></a>最近邻法</h3><p><img src="/images/project2/3.png" alt="一维最近邻插值示意图"></p>
<p>如上图所示，在一维最近邻插值中，坐标轴上各点 xi-1，xi，xi+1 … 两两对半等分间隔 (红色虚线划分)，从而非边界的各坐标点都有一个等宽的邻域，并根据每个坐标点的值构成一个类似分段函数的函数约束，从而使各插值坐标点的值等同于所在邻域原坐标点的值。例如，插值点 x 坐落于 坐标点 xi 的邻域，那么其值 f(x) 就等于 f(xi)。</p>
<p>在二维的图像插值场景中，可以对上述一维最近邻插值进行推广，如下图所示：</p>
<p><img src="/images/project2/4.png" alt="二维最近邻插值示意图"></p>
<p>可以看到，(x0, y0)、(x0, y1)、(x1, y0)、(x1, y1) 都是原图像上的坐标点，颜色值分别对应为 Q11、Q12、Q21、Q22。而颜色值未知的插值点 (x, y)（需转换至原图像坐标），根据最近邻插值方法的约束，其与坐标点 (x0, y0) 位置最接近 (即位于  (x0, y0) 的邻域内)，故插值点 (x, y) 的颜色值 P = Q11。</p>
<p>总而言之，最近邻法的基本思想即：<strong>将待插入点的坐标进行四舍五入，再以该行列坐标都是整数点的颜色值（灰度值）替代待插入点(x, y)处的颜色值。</strong>事实上，这也正是机器学习中KNN（K-Nearest Neighbor）算法在K=1时的情形。</p>
<p>基于以上算法思想，编写python函数代码实现图像放缩与旋转过程中的最近邻法插值：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最近邻法插值实现图像放缩</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nearest_neighbor_interpolation</span>(<span class="params">image, scale_factor</span>):</span><br><span class="line">    h, w, channel = image.shape</span><br><span class="line">    new_h, new_w = <span class="built_in">int</span>(h * scale_factor), <span class="built_in">int</span>(w * scale_factor)</span><br><span class="line">    resized_image = np.zeros((new_h, new_w, <span class="built_in">int</span>(channel)), dtype=image.dtype)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(new_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(new_w):</span><br><span class="line">            src_i = <span class="built_in">int</span>(<span class="built_in">round</span>((i + <span class="number">1</span>) / scale_factor, <span class="number">0</span>))</span><br><span class="line">            src_j = <span class="built_in">int</span>(<span class="built_in">round</span>((j + <span class="number">1</span>) / scale_factor, <span class="number">0</span>))</span><br><span class="line">            resized_image[i, j] = image[src_i - <span class="number">1</span>, src_j - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resized_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最近邻法插值实现图像旋转</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nearest_neighbor_rotation</span>(<span class="params">image, angle</span>):</span><br><span class="line">    h, w, channel = image.shape</span><br><span class="line">    angle_rad = math.radians(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算旋转后的图像尺寸</span></span><br><span class="line">    cos_theta = <span class="built_in">abs</span>(math.cos(angle_rad))</span><br><span class="line">    sin_theta = <span class="built_in">abs</span>(math.sin(angle_rad))</span><br><span class="line">    new_w = <span class="built_in">int</span>(h * sin_theta + w * cos_theta)</span><br><span class="line">    new_h = <span class="built_in">int</span>(h * cos_theta + w * sin_theta)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 旋转中心</span></span><br><span class="line">    cx, cy = w / <span class="number">2</span>, h / <span class="number">2</span></span><br><span class="line">    new_cx, new_cy = new_w / <span class="number">2</span>, new_h / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    rotated_image = np.zeros((new_h, new_w, channel), dtype=image.dtype)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(new_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(new_w):</span><br><span class="line">            <span class="comment"># 将新图像坐标转换回原图像坐标</span></span><br><span class="line">            x = (j - new_cx) * math.cos(angle_rad) + (i - new_cy) * math.sin(angle_rad) + cx</span><br><span class="line">            y = -(j - new_cx) * math.sin(angle_rad) + (i - new_cy) * math.cos(angle_rad) + cy</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 最近邻插值</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; w <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; h:</span><br><span class="line">                src_x = <span class="built_in">int</span>(<span class="built_in">round</span>(x))</span><br><span class="line">                src_y = <span class="built_in">int</span>(<span class="built_in">round</span>(y))</span><br><span class="line">                rotated_image[i, j] = image[src_y - <span class="number">1</span>, src_x - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rotated_image</span><br></pre></td></tr></tbody></table></figure>

<h3 id="双线性法"><a href="#双线性法" class="headerlink" title="双线性法"></a>双线性法</h3><p><img src="/images/project2/5.png" alt="一维线性插值示意图"></p>
<p>如上图所示，在一维的线性插值中，坐标轴上各点 xi-1，xi，xi+1 … 的值“两两直接相连”为线段，从而构成了一条连续的约束函数。而插值坐标点例如 x，根据约束函数其值应为 f(x)。因为每两个坐标点之间的约束函数曲线是一次线性的线段，对插值结果而言是“线性” 的，所以该方法称为线性插值。基于线性函数的特性，可以便捷地求取原图像上的两个像素点间任一待插值点的颜色值：</p>
<p><img src="/images/project2/6.png" alt="一维线性插值计算示意图"></p>
<p>可以看到，图中 x0 和 x1 都是原有的坐标点，颜色值分别对应为 y0 和 y1，此时根据线性插值法约束，在 (x0, y0) 和 (x1, y1) 构成的一次函数上，颜色值未知的插值点 x的颜色值 y 即为：<br>$$<br>y=y_0+(x-x_0)\frac{y_1-y_0}{x_1-x_0}=y_0+\frac{(x-x_0)y_1-(x-x_0)y_0}{x_1-x_0}<br>$$<br>实际上，即便 x 不在 x0 与 x1 之间，该公式也成立（此时为线性外插），但图像处理中不需涉及此情形。 </p>
<p>从一维的线性插值出发，很容易拓展到二维图像的双线性插值，通过三次一阶线性插值（本质为加权求和）获得最终结果，下图便展示了该过程的定性斜视与定量俯视示意图：</p>
<p><img src="/images/project2/7.png" alt="二维线性插值定性斜视示意图"></p>
<p><img src="/images/project2/8.png" alt="二维线性插值定量俯视示意图"></p>
<p>其中，(x0, y0)、(x0, y1)、(x1, y0)、(x1, y1) 均为原图像上的像素坐标点，颜色值分别对应为 f(x0, y0)、f(x0, y1)、f(x1, y0)、f(x1, y1)。而颜色值未知的插值点 (x, y)，根据双线性插值法的约束，可以先由像素坐标点 (x0, y0) 和 (x0, y1) 在 y 轴向作一维线性插值得到 f(x0, y)、由像素坐标点 (x1, y0) 和 (x1, y1) 在 y 轴向作一维线性插值得到 f(x1, y)，然后再由 (x0, y) 和 (x1, y) 在 x 轴向作一维线性插值得到插值点 (x, y) 的灰度值 f(x, y)。</p>
<p>事实上，一维线性插值先作 x 轴向再作 y 轴向，得到的结果完全相同，仅为顺序先后的区别。这里不妨先由像素坐标点 (x0, y0) 和 (x1, y0) 在 x 轴向作一维线性插值得到 f(x, y0)、由像素坐标点 (x0, y1) 和 (x1, y1) 在 x 轴向作一维线性插值得到 f(x, y1)：<br>$$<br>f(x,y_0)=\frac{x_1-x}{x_1-x_0}f(x_0,y_0)+\frac{x-x_0}{x_1-x_0}f(x_1,y_0)<br>$$</p>
<p>$$<br>f(x,y_1)=\frac{x_1-x}{x_1-x_0}f(x_0,y_1)+\frac{x-x_0}{x_1-x_0}f(x_1,y_1)<br>$$</p>
<p>然后再由 (x, y0) 和 (x, y1) 在 y 轴向作一维线性插值得到插值点 (x, y) 的灰度值 f(x, y)：<br>$$<br>f(x,y)=\frac{y_1-y}{y_1-y_0}f(x,y_0)+\frac{y-y_0}{y_1-y_0}f(x,y_1)<br>$$<br>合并上述式子，得到最终的双线性插值结果：<br>$$<br>f(x,y)=\frac{(y_1-y)(x_1-x)}{(y_1-y_0)(x_1-x_0)}f(x_0,y_0)+\frac{(y_1-y)(x-x_0)}{(y_1-y_0)(x_1-x_0)}f(x_1,y_0)+\frac{(y-y_0)(x_1-x)}{(y_1-y_0)(x_1-x_0)}f(x_0,y_1)+\frac{(y-y_0)(x-x_0)}{(y_1-y_0)(x_1-x_0)}<br>$$<br>值得注意的是，在实际的图像插值处理过程中，为尽量保证插值效果的准确性，往往仅采用距离待插值点（转换至原图像坐标）最近的四个点，即:（[]符号表示待插值点转换至原图像坐标后向下取整）<br>$$<br>x_0=[x]，y_0=[y]<br>$$</p>
<p>$$<br>x_1=x_0+1，y_1=y_0+1<br>$$</p>
<p>从加权求和的角度理解，可以进一步地将双线性插值结果改写为如下形式：<br>$$<br>p=x-[x], q=y-[y]<br>$$</p>
<p>$$<br>\begin{array}{rcl}f(x,y)=(1-q){(1-p)f([x][y])+pf([x]+1,[y])}+q{(1-p)f([x],[y]+1)+pf([x]+1,[y]+1)}\end{array}<br>$$</p>
<p><img src="/images/project2/9.png" alt="二维线性插值加权求和角度示意图"></p>
<p>基于以上算法思想，编写python函数代码实现图像放缩与旋转过程中的双线性法插值：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双线性法插值实现图像放缩</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bilinear_interpolation</span>(<span class="params">image, scale_factor</span>):</span><br><span class="line">    h, w, channel = image.shape</span><br><span class="line">    new_h, new_w = <span class="built_in">int</span>(h * scale_factor), <span class="built_in">int</span>(w * scale_factor)</span><br><span class="line">    resized_image = np.zeros((new_h, new_w, <span class="built_in">int</span>(channel)), dtype=image.dtype)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(new_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(new_w):</span><br><span class="line">            x = (j + <span class="number">1</span>) / scale_factor</span><br><span class="line">            y = (i + <span class="number">1</span>) / scale_factor</span><br><span class="line">            x1 = <span class="built_in">int</span>(x)</span><br><span class="line">            y1 = <span class="built_in">int</span>(y)</span><br><span class="line">            x2 = x1 + <span class="number">1</span></span><br><span class="line">            y2 = y1 + <span class="number">1</span></span><br><span class="line">            p = x - x1</span><br><span class="line">            q = y - y1</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 边界问题处理</span></span><br><span class="line">            <span class="keyword">if</span> x2 == w + <span class="number">1</span>:</span><br><span class="line">                x2 = x1</span><br><span class="line">            <span class="keyword">if</span> y2 == h + <span class="number">1</span>:</span><br><span class="line">                y2 = y1</span><br><span class="line">                </span><br><span class="line">            resized_image[i ,j] = (<span class="number">1</span> - q) * ((<span class="number">1</span> - p) * image[y1 - <span class="number">1</span>, x1 - <span class="number">1</span>] + p * image[y1 - <span class="number">1</span>, x2 - <span class="number">1</span>]) + q * ((<span class="number">1</span> - p) * image[y2 - <span class="number">1</span>, x1 - <span class="number">1</span>] + p * image[y2 - <span class="number">1</span>, x2 - <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resized_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双线性法插值实现图像旋转</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bilinear_rotation</span>(<span class="params">image, angle</span>):</span><br><span class="line">    h, w, channel = image.shape</span><br><span class="line">    angle_rad = math.radians(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算旋转后的图像尺寸</span></span><br><span class="line">    cos_theta = <span class="built_in">abs</span>(math.cos(angle_rad))</span><br><span class="line">    sin_theta = <span class="built_in">abs</span>(math.sin(angle_rad))</span><br><span class="line">    new_w = <span class="built_in">int</span>(h * sin_theta + w * cos_theta)</span><br><span class="line">    new_h = <span class="built_in">int</span>(h * cos_theta + w * sin_theta)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 旋转中心</span></span><br><span class="line">    cx, cy = w / <span class="number">2</span>, h / <span class="number">2</span></span><br><span class="line">    new_cx, new_cy = new_w / <span class="number">2</span>, new_h / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    rotated_image = np.zeros((new_h, new_w, channel), dtype=image.dtype)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(new_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(new_w):</span><br><span class="line">            <span class="comment"># 将新图像坐标转换回原图像坐标</span></span><br><span class="line">            x = (j - new_cx) * math.cos(angle_rad) + (i - new_cy) * math.sin(angle_rad) + cx</span><br><span class="line">            y = -(j - new_cx) * math.sin(angle_rad) + (i - new_cy) * math.cos(angle_rad) + cy</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 双线性插值</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; w-<span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; h-<span class="number">1</span>:</span><br><span class="line">                x1, y1 = <span class="built_in">int</span>(x), <span class="built_in">int</span>(y)</span><br><span class="line">                x2, y2 = <span class="built_in">min</span>(x1 + <span class="number">1</span>, w - <span class="number">1</span>), <span class="built_in">min</span>(y1 + <span class="number">1</span>, h - <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算权重</span></span><br><span class="line">                a = x - x1</span><br><span class="line">                b = y - y1</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 边界处理</span></span><br><span class="line">                <span class="keyword">if</span> x2 &gt;= w:</span><br><span class="line">                    x2 = x1</span><br><span class="line">                <span class="keyword">if</span> y2 &gt;= h:</span><br><span class="line">                    y2 = y1</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 插值计算</span></span><br><span class="line">                rotated_image[i, j] = (<span class="number">1</span> - a) * (<span class="number">1</span> - b) * image[y1, x1] + \</span><br><span class="line">                                     a * (<span class="number">1</span> - b) * image[y1, x2] + \</span><br><span class="line">                                     (<span class="number">1</span> - a) * b * image[y2, x1] + \</span><br><span class="line">                                     a * b * image[y2, x2]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rotated_image    </span><br></pre></td></tr></tbody></table></figure>

<h3 id="双立方法"><a href="#双立方法" class="headerlink" title="双立方法"></a>双立方法</h3><p>双立方法插值又称立方卷积插值/双三次插值，这也是数值分析中最常用的二维插值方法。在这种方法中，插值点 (x, y) 的像素颜色值 f(x, y) 通过矩形网格中最近的十六个采样点的加权平均得到，而各采样点的权重由该点到待求插值点的距离确定，此距离包括水平和竖直两个方向上的距离。相比之下，双线性插值仅由周围的四个采样点加权得到。</p>
<p><img src="/images/project2/10.png" alt="双立方法插值示意图"></p>
<p>如上图所示，设（转换至原图像中）待求插值点坐标为 (i+u, j+v)【i、j为整数部分，u、v为小数部分】，已知其周围的 16 个像素坐标点 (网格) 的颜色值，还需要计算 16 个点各自的权重。以像素坐标点 (i, j) 为例，因为该点在 y 轴和 x 轴方向上与待求插值点 (i+u, j+v) 的距离分别为 u 和 v，所以其权重为 w(u) × w(v)，其中 w(·) 是插值权重核 (可以理解为定义的权重函数)。同理可得其余 15 个像素坐标点各自的权重。那么，待求插值点 (i+u, j+v) 的颜色值 f(i+u, j+v) 将通过如下计算得到：<br>$$<br>f(i+u,j+v)=A\times B\times C<br>$$<br>其中各项由向量或矩阵表示为：<br>$$<br>\mathrm{A}=[w(1+u)w(u)w(1-u)w(2-u)]<br>$$</p>
<p>$$<br>\mathrm{B}=\begin{bmatrix}f(i-1,j-1)&amp;f(i-1,j+0)&amp;f(i-1,j+1)&amp;f(i-1,j+2)\f(i+0,j-1)&amp;f(i+0,j+0)&amp;f(i+0,j+1)&amp;f(i+0,j+2)\f(i+1,j-1)&amp;f(i+1,j+0)&amp;f(i+1,j+1)&amp;f(i+1,j+2)\f(i+2,j-1)&amp;f(i+2,j+0)&amp;f(i+2,j+1)&amp;f(i+2,j+2)\end{bmatrix}<br>$$</p>
<p>$$<br>\mathbb{C}=[w(1+v)w(v)w(1-v)w(2-v)]^T<br>$$</p>
<p>插值权重核 w(·) 为：<br>$$<br>w(x)=\begin{cases}1-2|x|^2+|x|^3&amp;,|x|&lt;1\4-8|x|+5|x|^2-|x|^3&amp;,1\leq|x|&lt;2\0&amp;,|x|\geq2&amp;\end{cases}<br>$$<br>插值权重核 w(·) 的函数图像：</p>
<p><img src="/images/project2/11.png" alt="双立方法插值权重核函数图像"></p>
<p>为方便后续算法实现，将以上加权求和过程各步骤展开，合并后化简得到待插入点的颜色值计算公式：<br>$$<br>f(i+u,j+v)=\sum_{m=0}^{3}\sum_{n=0}^{3}a_{mn}u^{m}v^{n}<br>$$<br>其中多项式的系数a_{mn}计算公式如下：(式中p <em>{qr}与上述矩阵B中元素一一对应，如p <em>00=f(i-1,j-1))<br>$$<br>\begin{aligned}<br>&amp;a</em>{00}=p</em>{11}\&amp;a_{01}=-\frac{1}{2}p_{10}+\frac{1}{2}p_{12}\&amp;a_{02}=p_{10}-\frac{5}{2}p_{11}+2p_{12}-\frac{1}{2}p_{13}\&amp;a_{03}=-\frac{1}{2}p_{10}+\frac{3}{2}p_{11}-\frac{3}{2}p_{12}+\frac{1}{2}p_{13}\&amp;a_{10}=-\frac{1}{2}p_{01}+\frac{1}{2}p_{21}\&amp;a_{11}=\frac{1}{4}p_{00}-\frac{1}{4}p_{02}-\frac{1}{4}p_{20}+\frac{1}{4}p_{22}\&amp;a_{12}=-\frac{1}{2}p_{00}+\frac{1}{4}p_{01}-p_{02}+\frac{1}{4}p_{03}+\frac{1}{2}p_{20}-\frac{5}{4}p_{21}+p_{22}-\frac{1}{4}p_{23}\&amp;a_{13}=\frac{1}{4}p_{00}-\frac{3}{4}p_{01}+\frac{3}{4}p_{02}-\frac{1}{4}p_{03}-\frac{1}{4}p_{20}+\frac{3}{4}p_{21}-\frac{3}{4}p_{22}+\frac{1}{4}p_{23}\<br>&amp;a_{20}=p_{01}-\frac{5}{2}p_{11}+2p_{21}-\frac{1}{2}p_{31}\<br>&amp;a_{21}=-\frac{1}{2}p_{00}+\frac{1}{2}p_{02}+\frac{5}{4}p_{10}-\frac{5}{4}p_{12}-p_{20}+p_{22}+\frac{1}{4}p_{30}-\frac{1}{4}p_{32}\&amp;a_{22}=p_{00}-\frac{5}{2}p_{01}+2p_{02}-\frac{1}{2}p_{03}-\frac{5}{2}p_{10}+\frac{25}{4}p_{11}-5p_{12}+\frac{5}{4}p_{13}+2p_{20}-5p_{21}+4p_{22}-p_{23}-\frac{1}{2}p_{30}+\frac{5}{4}p_{31}-p_{32}+\frac{1}{4}p_{33}\<br>&amp;a_{23}=-\frac{1}{2}p_{00}+\frac{3}{2}p_{01}-\frac{3}{2}p_{02}+\frac{1}{2}p_{03}+\frac{5}{4}p_{10}-\frac{15}{4}p_{11}+\frac{15}{4}p_{12}-\frac{5}{4}p_{13}-p_{20}+3p_{21}-3p_{22}+p_{23}+\frac{1}{4}p_{30}-\frac{3}{4}p_{31}+\frac{3}{4}p_{32}-\frac{1}{4}p_{33}\<br>&amp;a_{30}=-\frac{1}{2}p_{01}+\frac{3}{2}p_{11}-\frac{3}{2}p_{21}+\frac{1}{2}p_{31}\<br>&amp;a_{31}=\frac{1}{4}p_{00}-\frac{1}{4}p_{02}-\frac{3}{4}p_{10}+\frac{3}{4}p_{12}+\frac{3}{4}p_{20}-\frac{3}{4}p_{22}-\frac{1}{4}p_{30}+\frac{1}{4}p_{32}\&amp;a_{32}=-\frac{1}{2}p_{00}+\frac{5}{4}p_{01}-p_{02}+\frac{1}{4}p_{03}+\frac{3}{2}p_{10}-\frac{15}{4}p_{11}+3p_{12}-\frac{3}{4}p_{13}-\frac{3}{2}p_{20}+\frac{15}{4}p_{21}-3p_{22}+\frac{3}{4}p_{23}+\frac{1}{2}p_{30}-\frac{5}{4}p_{31}+p_{32}-\frac{1}{4}p_{33}\&amp;a_{33}=\frac{1}{4}p_{00}-\frac{3}{4}p_{01}+\frac{3}{4}p_{02}-\frac{1}{4}p_{03}-\frac{3}{4}p_{10}+\frac{9}{4}p_{11}-\frac{9}{4}p_{12}+\frac{3}{4}p_{13}+\frac{3}{4}p_{20}-\frac{9}{4}p_{21}+\frac{9}{4}p_{22}-\frac{3}{4}p_{23}-\frac{1}{4}p_{30}+\frac{3}{4}p_{31}-\frac{3}{4}p_{32}+\frac{1}{4}p_{33}<br>\end{aligned}<br>$$<br>基于以上算法思想，编写python函数代码实现图像放缩与旋转过程中的双立方法插值：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双立方法插值实现图像放缩</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bicubic_interpolation</span>(<span class="params">image, scale_factor</span>):</span><br><span class="line">    h, w, channel = image.shape</span><br><span class="line">    new_h, new_w = <span class="built_in">int</span>(h * scale_factor), <span class="built_in">int</span>(w * scale_factor)</span><br><span class="line">    resized_image = np.zeros((new_h, new_w, channel))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(new_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(new_w):</span><br><span class="line">            x = i / scale_factor</span><br><span class="line">            y = j / scale_factor</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 确定16个邻域像素的坐标</span></span><br><span class="line">            x0 = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">int</span>(np.floor(x)) - <span class="number">1</span>)</span><br><span class="line">            x1 = x0 + <span class="number">1</span></span><br><span class="line">            x2 = x0 + <span class="number">2</span></span><br><span class="line">            x3 = <span class="built_in">min</span>(w-<span class="number">1</span>, x0 + <span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">            y0 = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">int</span>(np.floor(y)) - <span class="number">1</span>)</span><br><span class="line">            y1 = y0 + <span class="number">1</span></span><br><span class="line">            y2 = y0 + <span class="number">2</span></span><br><span class="line">            y3 = <span class="built_in">min</span>(h-<span class="number">1</span>, y0 + <span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取16个邻域像素的值</span></span><br><span class="line">            p = np.zeros((<span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>))</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                    xi = x0 + n</span><br><span class="line">                    yi = y0 + m</span><br><span class="line">                    xi = <span class="built_in">min</span>(<span class="built_in">max</span>(xi, <span class="number">0</span>), w-<span class="number">1</span>)  <span class="comment"># 边界处理</span></span><br><span class="line">                    yi = <span class="built_in">min</span>(<span class="built_in">max</span>(yi, <span class="number">0</span>), h-<span class="number">1</span>)</span><br><span class="line">                    p[m, n] = image[yi, xi]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算相对位置</span></span><br><span class="line">            dx = x - x1</span><br><span class="line">            dy = y - y1</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 系数</span></span><br><span class="line">            a = np.zeros((<span class="number">4</span>, <span class="number">4</span>, channel))</span><br><span class="line">            a[<span class="number">0</span>, <span class="number">0</span>] = p[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">            a[<span class="number">0</span>, <span class="number">1</span>] = -<span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">            a[<span class="number">0</span>, <span class="number">2</span>] = p[<span class="number">1</span>, <span class="number">0</span>] - <span class="number">2.5</span>*p[<span class="number">1</span>, <span class="number">1</span>] + <span class="number">2</span>*p[<span class="number">1</span>, <span class="number">2</span>] - <span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">            a[<span class="number">0</span>, <span class="number">3</span>] = -<span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">1.5</span>*p[<span class="number">1</span>, <span class="number">1</span>] - <span class="number">1.5</span>*p[<span class="number">1</span>, <span class="number">2</span>] + <span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">            </span><br><span class="line">            a[<span class="number">1</span>, <span class="number">0</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">0.5</span>*p[<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">            a[<span class="number">1</span>, <span class="number">1</span>] = <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">0</span>] + <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">            a[<span class="number">1</span>, <span class="number">2</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">0</span>] + <span class="number">1.25</span>*p[<span class="number">0</span>, <span class="number">1</span>] - p[<span class="number">0</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">3</span>] + <span class="number">0.5</span>*p[<span class="number">2</span>, <span class="number">0</span>] - <span class="number">1.25</span>*p[<span class="number">2</span>, <span class="number">1</span>] + p[<span class="number">2</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">            a[<span class="number">1</span>, <span class="number">3</span>] = <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">0.75</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">0.75</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">3</span>] - <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">0</span>] + <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">1</span>] - <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">            </span><br><span class="line">            a[<span class="number">2</span>, <span class="number">0</span>] = p[<span class="number">0</span>, <span class="number">1</span>] - <span class="number">2.5</span>*p[<span class="number">1</span>, <span class="number">1</span>] + <span class="number">2</span>*p[<span class="number">2</span>, <span class="number">1</span>] - <span class="number">0.5</span>*p[<span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">            a[<span class="number">2</span>, <span class="number">1</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">0</span>] + <span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">2</span>] + <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">0</span>] - <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">2</span>] - p[<span class="number">2</span>, <span class="number">0</span>] + p[<span class="number">2</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">0</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">            a[<span class="number">2</span>, <span class="number">2</span>] = p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">2.5</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">2</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">3</span>] - <span class="number">2.5</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">6.25</span>*p[<span class="number">1</span>, <span class="number">1</span>] - <span class="number">5</span>*p[<span class="number">1</span>, <span class="number">2</span>] + <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">3</span>] + <span class="number">2</span>*p[<span class="number">2</span>, <span class="number">0</span>] - <span class="number">5</span>*p[<span class="number">2</span>, <span class="number">1</span>] + <span class="number">4</span>*p[<span class="number">2</span>, <span class="number">2</span>] - p[<span class="number">2</span>, <span class="number">3</span>] - <span class="number">0.5</span>*p[<span class="number">3</span>, <span class="number">0</span>] + <span class="number">1.25</span>*p[<span class="number">3</span>, <span class="number">1</span>] - p[<span class="number">3</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">            a[<span class="number">2</span>, <span class="number">3</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">0</span>] + <span class="number">1.5</span>*p[<span class="number">0</span>, <span class="number">1</span>] - <span class="number">1.5</span>*p[<span class="number">0</span>, <span class="number">2</span>] + <span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">3</span>] + <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">0</span>] - <span class="number">3.75</span>*p[<span class="number">1</span>, <span class="number">1</span>] + <span class="number">3.75</span>*p[<span class="number">1</span>, <span class="number">2</span>] - <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">3</span>] - p[<span class="number">2</span>, <span class="number">0</span>] + <span class="number">3</span>*p[<span class="number">2</span>, <span class="number">1</span>] - <span class="number">3</span>*p[<span class="number">2</span>, <span class="number">2</span>] + p[<span class="number">2</span>, <span class="number">3</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">0</span>] - <span class="number">0.75</span>*p[<span class="number">3</span>, <span class="number">1</span>] + <span class="number">0.75</span>*p[<span class="number">3</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">            </span><br><span class="line">            a[<span class="number">3</span>, <span class="number">0</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">1.5</span>*p[<span class="number">1</span>, <span class="number">1</span>] - <span class="number">1.5</span>*p[<span class="number">2</span>, <span class="number">1</span>] + <span class="number">0.5</span>*p[<span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">            a[<span class="number">3</span>, <span class="number">1</span>] = <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">2</span>] + <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">0</span>] - <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">0</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">            a[<span class="number">3</span>, <span class="number">2</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">0</span>] + <span class="number">1.25</span>*p[<span class="number">0</span>, <span class="number">1</span>] - p[<span class="number">0</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">3</span>] + <span class="number">1.5</span>*p[<span class="number">1</span>, <span class="number">0</span>] - <span class="number">3.75</span>*p[<span class="number">1</span>, <span class="number">1</span>] + <span class="number">3</span>*p[<span class="number">1</span>, <span class="number">2</span>] - <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">3</span>] - <span class="number">1.5</span>*p[<span class="number">2</span>, <span class="number">0</span>] + <span class="number">3.75</span>*p[<span class="number">2</span>, <span class="number">1</span>] - <span class="number">3</span>*p[<span class="number">2</span>, <span class="number">2</span>] + <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">3</span>] + <span class="number">0.5</span>*p[<span class="number">3</span>, <span class="number">0</span>] - <span class="number">1.25</span>*p[<span class="number">3</span>, <span class="number">1</span>] + p[<span class="number">3</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">            a[<span class="number">3</span>, <span class="number">3</span>] = <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">0.75</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">0.75</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">3</span>] - <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">2.25</span>*p[<span class="number">1</span>, <span class="number">1</span>] - <span class="number">2.25</span>*p[<span class="number">1</span>, <span class="number">2</span>] + <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">3</span>] + <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">0</span>] - <span class="number">2.25</span>*p[<span class="number">2</span>, <span class="number">1</span>] + <span class="number">2.25</span>*p[<span class="number">2</span>, <span class="number">2</span>] - <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">3</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">0</span>] + <span class="number">0.75</span>*p[<span class="number">3</span>, <span class="number">1</span>] - <span class="number">0.75</span>*p[<span class="number">3</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算插值结果</span></span><br><span class="line">            value = np.zeros(channel)</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                    value += a[m, n] * (dx**n) * (dy**m)</span><br><span class="line">            </span><br><span class="line">            resized_image[i, j] = np.clip(value, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resized_image.astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双立方法插值实现图像旋转</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bicubic_rotation</span>(<span class="params">image, angle</span>):</span><br><span class="line">    h, w, channel = image.shape</span><br><span class="line">    angle_rad = math.radians(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算旋转后的图像尺寸</span></span><br><span class="line">    cos_theta = <span class="built_in">abs</span>(math.cos(angle_rad))</span><br><span class="line">    sin_theta = <span class="built_in">abs</span>(math.sin(angle_rad))</span><br><span class="line">    new_w = <span class="built_in">int</span>(h * sin_theta + w * cos_theta)</span><br><span class="line">    new_h = <span class="built_in">int</span>(h * cos_theta + w * sin_theta)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 旋转中心</span></span><br><span class="line">    cx, cy = w / <span class="number">2</span>, h / <span class="number">2</span></span><br><span class="line">    new_cx, new_cy = new_w / <span class="number">2</span>, new_h / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    rotated_image = np.zeros((new_h, new_w, channel))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(new_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(new_w):</span><br><span class="line">            <span class="comment"># 将新图像坐标转换回原图像坐标</span></span><br><span class="line">            x = (j - new_cx) * math.cos(angle_rad) + (i - new_cy) * math.sin(angle_rad) + cx</span><br><span class="line">            y = -(j - new_cx) * math.sin(angle_rad) + (i - new_cy) * math.cos(angle_rad) + cy</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; w <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; h:</span><br><span class="line">                <span class="comment"># 确定16个邻域像素的坐标</span></span><br><span class="line">                x0 = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">int</span>(np.floor(x)) - <span class="number">1</span>)</span><br><span class="line">                x1 = x0 + <span class="number">1</span></span><br><span class="line">                x2 = x0 + <span class="number">2</span></span><br><span class="line">                x3 = <span class="built_in">min</span>(w-<span class="number">1</span>, x0 + <span class="number">3</span>)</span><br><span class="line">                </span><br><span class="line">                y0 = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">int</span>(np.floor(y)) - <span class="number">1</span>)</span><br><span class="line">                y1 = y0 + <span class="number">1</span></span><br><span class="line">                y2 = y0 + <span class="number">2</span></span><br><span class="line">                y3 = <span class="built_in">min</span>(h-<span class="number">1</span>, y0 + <span class="number">3</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 获取16个邻域像素的值</span></span><br><span class="line">                p = np.zeros((<span class="number">4</span>, <span class="number">4</span>, channel))</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                        xi = x0 + n</span><br><span class="line">                        yi = y0 + m</span><br><span class="line">                        xi = <span class="built_in">min</span>(<span class="built_in">max</span>(xi, <span class="number">0</span>), w-<span class="number">1</span>)  <span class="comment"># 边界处理</span></span><br><span class="line">                        yi = <span class="built_in">min</span>(<span class="built_in">max</span>(yi, <span class="number">0</span>), h-<span class="number">1</span>)</span><br><span class="line">                        p[m, n] = image[yi, xi]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算相对位置</span></span><br><span class="line">                dx = x - x1</span><br><span class="line">                dy = y - y1</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 系数</span></span><br><span class="line">                a = np.zeros((<span class="number">4</span>, <span class="number">4</span>, channel))</span><br><span class="line">                a[<span class="number">0</span>, <span class="number">0</span>] = p[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">                a[<span class="number">0</span>, <span class="number">1</span>] = -<span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">                a[<span class="number">0</span>, <span class="number">2</span>] = p[<span class="number">1</span>, <span class="number">0</span>] - <span class="number">2.5</span>*p[<span class="number">1</span>, <span class="number">1</span>] + <span class="number">2</span>*p[<span class="number">1</span>, <span class="number">2</span>] - <span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">                a[<span class="number">0</span>, <span class="number">3</span>] = -<span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">1.5</span>*p[<span class="number">1</span>, <span class="number">1</span>] - <span class="number">1.5</span>*p[<span class="number">1</span>, <span class="number">2</span>] + <span class="number">0.5</span>*p[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">                </span><br><span class="line">                a[<span class="number">1</span>, <span class="number">0</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">0.5</span>*p[<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">                a[<span class="number">1</span>, <span class="number">1</span>] = <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">0</span>] + <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">                a[<span class="number">1</span>, <span class="number">2</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">0</span>] + <span class="number">1.25</span>*p[<span class="number">0</span>, <span class="number">1</span>] - p[<span class="number">0</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">3</span>] + <span class="number">0.5</span>*p[<span class="number">2</span>, <span class="number">0</span>] - <span class="number">1.25</span>*p[<span class="number">2</span>, <span class="number">1</span>] + p[<span class="number">2</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">                a[<span class="number">1</span>, <span class="number">3</span>] = <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">0.75</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">0.75</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">3</span>] - <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">0</span>] + <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">1</span>] - <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">                </span><br><span class="line">                a[<span class="number">2</span>, <span class="number">0</span>] = p[<span class="number">0</span>, <span class="number">1</span>] - <span class="number">2.5</span>*p[<span class="number">1</span>, <span class="number">1</span>] + <span class="number">2</span>*p[<span class="number">2</span>, <span class="number">1</span>] - <span class="number">0.5</span>*p[<span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">                a[<span class="number">2</span>, <span class="number">1</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">0</span>] + <span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">2</span>] + <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">0</span>] - <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">2</span>] - p[<span class="number">2</span>, <span class="number">0</span>] + p[<span class="number">2</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">0</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">                a[<span class="number">2</span>, <span class="number">2</span>] = p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">2.5</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">2</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">3</span>] - <span class="number">2.5</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">6.25</span>*p[<span class="number">1</span>, <span class="number">1</span>] - <span class="number">5</span>*p[<span class="number">1</span>, <span class="number">2</span>] + <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">3</span>] + <span class="number">2</span>*p[<span class="number">2</span>, <span class="number">0</span>] - <span class="number">5</span>*p[<span class="number">2</span>, <span class="number">1</span>] + <span class="number">4</span>*p[<span class="number">2</span>, <span class="number">2</span>] - p[<span class="number">2</span>, <span class="number">3</span>] - <span class="number">0.5</span>*p[<span class="number">3</span>, <span class="number">0</span>] + <span class="number">1.25</span>*p[<span class="number">3</span>, <span class="number">1</span>] - p[<span class="number">3</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">                a[<span class="number">2</span>, <span class="number">3</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">0</span>] + <span class="number">1.5</span>*p[<span class="number">0</span>, <span class="number">1</span>] - <span class="number">1.5</span>*p[<span class="number">0</span>, <span class="number">2</span>] + <span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">3</span>] + <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">0</span>] - <span class="number">3.75</span>*p[<span class="number">1</span>, <span class="number">1</span>] + <span class="number">3.75</span>*p[<span class="number">1</span>, <span class="number">2</span>] - <span class="number">1.25</span>*p[<span class="number">1</span>, <span class="number">3</span>] - p[<span class="number">2</span>, <span class="number">0</span>] + <span class="number">3</span>*p[<span class="number">2</span>, <span class="number">1</span>] - <span class="number">3</span>*p[<span class="number">2</span>, <span class="number">2</span>] + p[<span class="number">2</span>, <span class="number">3</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">0</span>] - <span class="number">0.75</span>*p[<span class="number">3</span>, <span class="number">1</span>] + <span class="number">0.75</span>*p[<span class="number">3</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">                </span><br><span class="line">                a[<span class="number">3</span>, <span class="number">0</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">1.5</span>*p[<span class="number">1</span>, <span class="number">1</span>] - <span class="number">1.5</span>*p[<span class="number">2</span>, <span class="number">1</span>] + <span class="number">0.5</span>*p[<span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">                a[<span class="number">3</span>, <span class="number">1</span>] = <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">2</span>] + <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">0</span>] - <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">0</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">                a[<span class="number">3</span>, <span class="number">2</span>] = -<span class="number">0.5</span>*p[<span class="number">0</span>, <span class="number">0</span>] + <span class="number">1.25</span>*p[<span class="number">0</span>, <span class="number">1</span>] - p[<span class="number">0</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">3</span>] + <span class="number">1.5</span>*p[<span class="number">1</span>, <span class="number">0</span>] - <span class="number">3.75</span>*p[<span class="number">1</span>, <span class="number">1</span>] + <span class="number">3</span>*p[<span class="number">1</span>, <span class="number">2</span>] - <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">3</span>] - <span class="number">1.5</span>*p[<span class="number">2</span>, <span class="number">0</span>] + <span class="number">3.75</span>*p[<span class="number">2</span>, <span class="number">1</span>] - <span class="number">3</span>*p[<span class="number">2</span>, <span class="number">2</span>] + <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">3</span>] + <span class="number">0.5</span>*p[<span class="number">3</span>, <span class="number">0</span>] - <span class="number">1.25</span>*p[<span class="number">3</span>, <span class="number">1</span>] + p[<span class="number">3</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">                a[<span class="number">3</span>, <span class="number">3</span>] = <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">0</span>] - <span class="number">0.75</span>*p[<span class="number">0</span>, <span class="number">1</span>] + <span class="number">0.75</span>*p[<span class="number">0</span>, <span class="number">2</span>] - <span class="number">0.25</span>*p[<span class="number">0</span>, <span class="number">3</span>] - <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">0</span>] + <span class="number">2.25</span>*p[<span class="number">1</span>, <span class="number">1</span>] - <span class="number">2.25</span>*p[<span class="number">1</span>, <span class="number">2</span>] + <span class="number">0.75</span>*p[<span class="number">1</span>, <span class="number">3</span>] + <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">0</span>] - <span class="number">2.25</span>*p[<span class="number">2</span>, <span class="number">1</span>] + <span class="number">2.25</span>*p[<span class="number">2</span>, <span class="number">2</span>] - <span class="number">0.75</span>*p[<span class="number">2</span>, <span class="number">3</span>] - <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">0</span>] + <span class="number">0.75</span>*p[<span class="number">3</span>, <span class="number">1</span>] - <span class="number">0.75</span>*p[<span class="number">3</span>, <span class="number">2</span>] + <span class="number">0.25</span>*p[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算插值结果</span></span><br><span class="line">                value = np.zeros(channel)</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                        value += a[m, n] * (dx**n) * (dy**m)</span><br><span class="line">                </span><br><span class="line">                rotated_image[i, j] = np.clip(value, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rotated_image.astype(np.uint8)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="图像插值算法优化：基于四平面"><a href="#图像插值算法优化：基于四平面" class="headerlink" title="图像插值算法优化：基于四平面"></a>图像插值算法优化：基于四平面</h2><p>在上述的多种基于分段插值的图像插值算法中，均采用f(i, j)来表示图像的像素点坐标处的颜色值，其中ｉ表示行坐标，ｊ表示列坐标。为进一步地体现图像的局部特征差异并将其用于插值过程，我们引入“平面”的概念，并对图像数据进行升维处理，用三维空间点(i, j, f(i, j))来表示一个像素，并将其对应至空间坐标系中的一个点(x, y, z)。</p>
<p>对一个待插入点而言，可以通过坐标平移将其周围4 个像素点转换为：（注意：此处z0<del>z3为像素坐标点s0</del>s3的颜色值，下同）<br>$$<br>s_0(0,0,z_0),s_1(0,1,z_1),s_2(1,0,z_2),s_3(1,1,z_3)<br>$$<br>从上述４个点的坐标可以看出它们任意３个点一定不在同一条直线上， 不在同一直线上的３个点可以确定一个平面， 下面讨论具体的插值方法：</p>
<ol>
<li><p>先求出这４个点可能的４个平面方程</p>
<p>已知空间平面的一般方程为：<br>$$<br>Ax+By+Cz+D=0<br>$$<br>将s0、s1、s2分别带入上式可得：<br>$$<br>\begin{cases}Cz_0+D=0\B+Cz_1+D=0\A+Cz_2+D=0&amp;\end{cases}<br>$$<br>则有：<br>$$<br>D=-Cz_0,B=C(z_0-z_1),A=C(z_0-z_2)<br>$$<br>再将其带回空间平面方程，整理后用f(x, y)代替z得到插值公式：<br>$$<br>f(x,y)=(z_{2}-z_{0})x+(z_{1}-z_{2})y+z_{0}<br>$$<br>同理，将s0、s1、s3带入空间平面方程可得插值公式：<br>$$<br>f(x,y)=(z_{3}-z_{1})x+(z_{1}-z_{0})y+z_{0}<br>$$<br>将s0、s2、s3带入空间平面方程可得插值公式：<br>$$<br>f(x,y)=(z_{2}-z_{0})x+(z_{3}-z_{2})y+z_{0}<br>$$<br>将s1、s2、s3带入空间平面方程可得插值公式：<br>$$<br>f(x,y)=(z_{3}-z_{1})x+(z_{3}-z_{2})y+(z_{2}+z_{1}-z_{3})<br>$$</p>
</li>
<li><p>如果s0、s1、s2、s3这４ 个点在同一平面上， 则使用上述任意一个插值公式进行插值均可。 【平面法】</p>
<blockquote>
<p>判断这４个点是否在同一平面上， 只需要比较z1+z2 与 z0+z3是否相等：</p>
<p>线段s0s3中点坐标为<br>$$<br>(\frac12,\frac12,\frac{z_0+z_3}2)<br>$$<br>线段s1s2中点坐标为<br>$$<br>(\frac12,\frac12,\frac{z_1+z_2}2)<br>$$<br>如果它们的中点坐标相同，则说明两条线段相交，相交的两条直线可以决定一个平面，即如果待插人点周围的四个点满足：<br>$$<br>z_1+z_2=z_0+z_3<br>$$<br>则这它们就是同一平面上的 4 个点，否则就不是同一平面上的 4 个点。</p>
</blockquote>
</li>
<li><p>从４个可能的平面中选择一个平面进行插值【四平面法】</p>
<p>如果它们不是同一平面上的４个点， 情况比较复杂， 需认真讨论，s0、s1、s2、s3４个点的位置关系如下图所示：</p>
<p><img src="/images/project2/12.png" alt="四点不在同一平面"></p>
<p>在插值的过程中如果一半的区域选择由s0、s1、s2 所确定的平面进行插值， 则另一半必须选择由s1、s2、s3所确定的平面进行插值， 以保证对角线的每一边都是在同一个平面上， 避免出现 “锯齿形” 边缘，为了便于描述， 称s0、s1、s2所确定的平面为 “左下平面”，s1、s2、s3 所确定的平面为 “右上平面”，s0、s1、s3 所确定的平面 “左上平面”，s0、s2、s3所确定的平面 “右下平面”。 为此， 需要参考周围其他点的情况以决定选择哪个平面进行插值。 具体情况如下图所示（黑点是待插入点周围的４个点，白点是参考点）：</p>
<p><img src="/images/project2/13.png" alt="待插入点周围的像素点"></p>
<ol>
<li>对于“左下平面”， 只能参考s0、s1、s2三点左面和下面的点， 即s0、s1、s2三点与s4、s5、s6、s8四个点中的任意一点在同一平面上即可。 </li>
<li>对于“右上平面”，只能参考s1、s2、s3三点右面和上面的点， 即s1、s2、s3三点与s7、s9、s10、s11四个点中的任意一点在同一平面上即可。</li>
<li>对于 “左上平面”，只能参考s0、s1、s3三点左面和上面的点， 即s0、s1、s3三点与s6、s8、s10、s11四个点中的任意一点在同一平面上即可。 </li>
<li>对于 “右下平面”，只能参考s0、s2、s3三点右面和下面的点， 即s0、s2、s3三点与s4、s5、s7、s9四 个点中的任意一点在同一平面上即可。</li>
</ol>
<p>针对1、2两种情况， 当y = 1 + x时，用 “左下平面” 进行插值， 否则用 “右上平面” 进行插值；针对3、4两种情况， 当y = x ^ 3时，用 “左上平面” 进行插值， 否则用 “右下平面” 进行插值。</p>
<blockquote>
<p>判断４个点在同一平面上的方法：（以情况1为例）</p>
<ul>
<li><p>对于判断s0、s2、s1、s8 ４ 点是否在同一平面上， 只需要判断z0 + z1与z2 + z8是否相等即可； </p>
</li>
<li><p>对于s0、s1、s2、s5 ４点， 只需要判断z0 + z2与z1 + z5是否相等即可； </p>
</li>
<li><p>对于s0、s1、s2、s6 ４点：如果s0、s2、s6 ３点在同一直线上， 则直线外一点s1与该直线就可以确定一个平面，而要判断这三点是否在同一直线上，只需判断z2 + z6与2 * z0是否相等即可【线段s2(1, 0, z2) s6(-1, 0, z6) 的中点坐标为(0, 0, z2 + z6)，若z2 + z6 = 2 * z0， 则点s0(0, 0, z0)就是它们的中点坐标，当然这３点就在同一条直线上】； </p>
</li>
<li><p>对于s0、s1、s2、s4   ４点， 与s0、s1、s2、s6 ４ 点的情况相同。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>如果2和3两点中的情形均不满足， 说明待插入点周围的情况太复杂（不符合平面插值）， 此时采用<strong>双线性法</strong>进行插值。</p>
</li>
</ol>
<p>基于以上算法思想，编写python函数代码实现图像放缩与旋转过程中的四平面法插值：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 四平面法插值实现图像放缩</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">four_plane_interpolation</span>(<span class="params">img, scale</span>):</span><br><span class="line">    H, W, C = img.shape</span><br><span class="line">    new_H, new_W = <span class="built_in">int</span>(H * scale), <span class="built_in">int</span>(W * scale)</span><br><span class="line">    output = np.zeros((new_H, new_W, C), dtype=img.dtype)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(new_H):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(new_W):</span><br><span class="line">            <span class="comment"># 计算原图对应坐标（浮点数）</span></span><br><span class="line">            src_x = x / scale</span><br><span class="line">            src_y = y / scale</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取周围4个整数坐标点</span></span><br><span class="line">            x0, y0 = <span class="built_in">int</span>(np.floor(src_x)), <span class="built_in">int</span>(np.floor(src_y))</span><br><span class="line">            x1, y1 = <span class="built_in">min</span>(x0 + <span class="number">1</span>, W - <span class="number">1</span>), <span class="built_in">min</span>(y0 + <span class="number">1</span>, H - <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取4个点的颜色值（z坐标）</span></span><br><span class="line">            s0 = img[y0, x0]</span><br><span class="line">            s1 = img[y0, x1]</span><br><span class="line">            s2 = img[y1, x0]</span><br><span class="line">            s3 = img[y1, x1]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算相对位置（归一化到[0,1]）</span></span><br><span class="line">            dx = src_x - x0</span><br><span class="line">            dy = src_y - y0</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断四点是否共面（z1 + z2 ≈ z0 + z3）</span></span><br><span class="line">            <span class="keyword">if</span> np.allclose(s1 + s2, s0 + s3, atol=<span class="number">1e-6</span>):</span><br><span class="line">                <span class="comment"># 共面时，选择任意平面（此处用左下平面）</span></span><br><span class="line">                interpolated = s0 + (s2 - s0) * dx + (s1 - s0) * dy</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 不共面时，动态选择平面</span></span><br><span class="line">                <span class="comment"># 获取周围12个参考点（简化实现，仅取最近邻）</span></span><br><span class="line">                <span class="comment"># 注：论文中需判断参考点是否共面，此处简化逻辑</span></span><br><span class="line">                <span class="keyword">if</span> dy &gt; <span class="number">1</span> - dx:  <span class="comment"># 对角线 y = 1 - x 上方</span></span><br><span class="line">                    <span class="comment"># 选择右上平面</span></span><br><span class="line">                    interpolated = (s3 - s1) * dx + (s3 - s2) * dy + (s2 + s1 - s3)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 选择左下平面</span></span><br><span class="line">                    interpolated = s0 + (s2 - s0) * dx + (s1 - s0) * dy</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 边界检查</span></span><br><span class="line">            interpolated = np.clip(interpolated, <span class="number">0</span>, <span class="number">255</span> <span class="keyword">if</span> img.dtype == np.uint8 <span class="keyword">else</span> <span class="number">1.0</span>)</span><br><span class="line">            output[y, x] = interpolated</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 四平面法插值实现图像旋转</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">four_plane_rotation</span>(<span class="params">image, angle</span>):</span><br><span class="line">    h, w, channel = image.shape</span><br><span class="line">    angle_rad = math.radians(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算旋转后的图像尺寸</span></span><br><span class="line">    cos_theta = <span class="built_in">abs</span>(math.cos(angle_rad))</span><br><span class="line">    sin_theta = <span class="built_in">abs</span>(math.sin(angle_rad))</span><br><span class="line">    new_w = <span class="built_in">int</span>(h * sin_theta + w * cos_theta)</span><br><span class="line">    new_h = <span class="built_in">int</span>(h * cos_theta + w * sin_theta)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 旋转中心</span></span><br><span class="line">    cx, cy = w / <span class="number">2</span>, h / <span class="number">2</span></span><br><span class="line">    new_cx, new_cy = new_w / <span class="number">2</span>, new_h / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    rotated_image = np.zeros((new_h, new_w, channel), dtype=image.dtype)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(new_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(new_w):</span><br><span class="line">            <span class="comment"># 将新图像坐标转换回原图像坐标</span></span><br><span class="line">            x = (j - new_cx) * math.cos(angle_rad) + (i - new_cy) * math.sin(angle_rad) + cx</span><br><span class="line">            y = -(j - new_cx) * math.sin(angle_rad) + (i - new_cy) * math.cos(angle_rad) + cy</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 边界检查</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; w <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; h:</span><br><span class="line">                <span class="comment"># 获取周围4个整数坐标点</span></span><br><span class="line">                x0, y0 = <span class="built_in">int</span>(np.floor(x)), <span class="built_in">int</span>(np.floor(y))</span><br><span class="line">                x1, y1 = <span class="built_in">min</span>(x0 + <span class="number">1</span>, w - <span class="number">1</span>), <span class="built_in">min</span>(y0 + <span class="number">1</span>, h - <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 获取4个点的颜色值</span></span><br><span class="line">                s0 = image[y0, x0]</span><br><span class="line">                s1 = image[y0, x1]</span><br><span class="line">                s2 = image[y1, x0]</span><br><span class="line">                s3 = image[y1, x1]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算相对位置</span></span><br><span class="line">                dx = x - x0</span><br><span class="line">                dy = y - y0</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 判断四点是否共面</span></span><br><span class="line">                <span class="keyword">if</span> np.allclose(s1 + s2, s0 + s3, atol=<span class="number">1e-6</span>):</span><br><span class="line">                    <span class="comment"># 共面时，选择任意平面（此处用左下平面）</span></span><br><span class="line">                    interpolated = s0 + (s2 - s0) * dy + (s1 - s0) * dx</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 不共面时，动态选择平面</span></span><br><span class="line">                    <span class="keyword">if</span> dy &gt; <span class="number">1</span> - dx:  <span class="comment"># 对角线 y = 1 - x 上方</span></span><br><span class="line">                        <span class="comment"># 选择右上平面</span></span><br><span class="line">                        interpolated = (s3 - s1) * dx + (s3 - s2) * dy + (s2 + s1 - s3)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 选择左下平面</span></span><br><span class="line">                        interpolated = s0 + (s2 - s0) * dy + (s1 - s0) * dx</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 边界检查</span></span><br><span class="line">                interpolated = np.clip(interpolated, <span class="number">0</span>, <span class="number">255</span> <span class="keyword">if</span> image.dtype == np.uint8 <span class="keyword">else</span> <span class="number">1.0</span>)</span><br><span class="line">                rotated_image[i, j] = interpolated</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rotated_image</span><br></pre></td></tr></tbody></table></figure>

<h2 id="实验测试结果分析"><a href="#实验测试结果分析" class="headerlink" title="实验测试结果分析"></a>实验测试结果分析</h2><p>一个理想的插值算法对一幅图像逆时针旋转若干度，再顺时针旋转若干度，应该与原图像相同；同理，对一幅图像放大若干倍，再缩小若干倍，也应该与原图像相同。 基于此，将下面的4幅图像分别用4种算法先逆时针旋转45°，再顺时针旋转45°；先放大４倍，再缩小４倍，然后分别用峰值信噪比（PSNR）验证各算法的优劣。 </p>
<p><img src="/images/project2/5.jpg" alt="1琳娜"></p>
<p><img src="/images/project2/6.jpg" alt="2辣椒"></p>
<p><img src="/images/project2/7.jpg" alt="3狒狒"></p>
<p><img src="/images/project2/8.jpg" alt="4房子"></p>
<p>从定性实验的效果角度，上述四幅图像通过常用的三种分段插值算法完成上述的放大与旋转任务后得到的结果如下图所示：</p>
<p><img src="/images/project2/Figure_1.png" alt="1琳娜传统result"></p>
<p><img src="/images/project2/Figure_2.png" alt="2辣椒传统result"></p>
<p><img src="/images/project2/Figure_3.png" alt="3狒狒传统result"></p>
<p><img src="/images/project2/Figure_4.png" alt="4房子传统result"></p>
<p>从实验结果上来看，最近邻算法的边缘颜色“最醒目”，且出现了较为严重的“锯齿形”边缘现象；双线性算法的边缘颜色“最暗淡”；双线性算法和双三次算法也有“锯齿形”边缘现象， 但视觉效果相比最近邻算法而言并不明显。</p>
<p>通过改进的四平面插值算法，对上述四幅图像完成上述的放大与旋转任务后得到的结果如下图所示：</p>
<p><img src="/images/project2/Figure_5.png" alt="1琳娜四平面result"></p>
<p><img src="/images/project2/Figure_6.png" alt="2辣椒四平面result"></p>
<p><img src="/images/project2/Figure_7.png" alt="3狒狒四平面result"></p>
<p><img src="/images/project2/Figure_8.png" alt="4房子四平面result"></p>
<p>可以看到，四平面插值算法处理后的图像斜线边缘部分是 “光滑连续” 的， 视觉效果比较好，同时有效避免了“锯齿形”边缘现象和“马赛克”现象。</p>
<p>从定量实验的数据角度，我们对于各图像用不同算法完成上述旋转与放缩任务后得到的图像峰值信噪比与算法运行时间进行了计算与统计，结果如下表所示：</p>
<blockquote>
<p>峰值信噪比(PSNR)用于表示信号的最大可能功率与影响其表示的保真度的破坏噪声的功率之间的比率。PSNR在图像处理上主要用于量化受有损压缩影响的图像和视频的重建质量。</p>
<p>PSNR 通过均方误差( MSE ) 定义。</p>
<p>给定一个无噪声的m×n单色图像I及其噪声近似值K，MSE定义为：<br>$$<br>MSE=\frac{1}{mn}\sum_{i=0}^{m-1}\sum_{j=0}^{n-1}[I(i,j)-K(i,j)]^2.<br>$$<br>故PSNR定义为：<br>$$<br>\begin{aligned}\mathrm{PSNR}&amp;=10\cdot\log_{10}\left(\frac{MAX_I^2}{MSE}\right)\&amp;=20\cdot\log_{10}\left(\frac{MAX_I}{\sqrt{MSE}}\right)\&amp;=20\cdot\log_{10}(MAX_I)-10\cdot\log_{10}(MSE).\end{aligned}<br>$$<br>一般而言，通过PSNR来判断处理后图像的失真情况有如下通用结论：</p>
<ul>
<li>PSNR &gt; 30 dB：图像质量较好，失真不明显。</li>
<li>PSNR 20~30 dB：中等质量，存在可察觉失真。</li>
<li>PSNR &lt; 20 dB：质量较差，失真显著。</li>
</ul>
<p>实际计算时，采用opencv自带的PSNR方法cv2.PSNR(img, output)对原始图像与处理后图像的PSNR进行比较计算。</p>
</blockquote>
<table>
<thead>
<tr>
<th>测试图像</th>
<th>最近邻插值PSNR</th>
<th>双线性插值PSNR</th>
<th>双立方插值PSNR</th>
<th>四平面插值PSNR</th>
</tr>
</thead>
<tbody><tr>
<td>琳娜（269*269）</td>
<td>20.74217399</td>
<td>27.11906575</td>
<td>29.36532325</td>
<td>36.70765842</td>
</tr>
<tr>
<td>辣椒（268*268）</td>
<td>22.92424674</td>
<td>27.91435345</td>
<td>31.04713312</td>
<td>39.25866529</td>
</tr>
<tr>
<td>狒狒（268*268）</td>
<td>21.8194312</td>
<td>28.06968286</td>
<td>29.12614241</td>
<td>38.2193871</td>
</tr>
<tr>
<td>房子（256*256）</td>
<td>22.34146151</td>
<td>26.21366716</td>
<td>30.67389681</td>
<td>38.8204405</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>插值算法</th>
<th>最近邻法</th>
<th>双线性法</th>
<th>双立方法</th>
<th>四平面法</th>
</tr>
</thead>
<tbody><tr>
<td>算法运行平均用时</td>
<td>0.678485751</td>
<td>3.293492556</td>
<td>92.66596091</td>
<td>15.02119243</td>
</tr>
</tbody></table>
<p>通过对比上述定量实验结果可以发现，在传统的三种分段插值算法中，随着运算阶数（采样待插值点周围的原图像像素点颜色值信息）的增加，图像经过放缩与旋转处理后的失真程度有明显降低，但仍大致处于存在可察觉失真的区间，且算法运行用时也逐渐增加（事实上双立方法的实现可以在编程层面实现优化，这里只是为更直观地展现O（n^2）时间复杂度在图像大小达到一定规模时的显著影响）；而引入的四平面算法不仅在失真程度上较传统的插值算法均有显著改善，算法运行用时也明显优于传统算法中效果最好的双立方法。</p>
<p>综合以上的定性与定量实验结果及分析，本文提出的基于四平面的图像插值算法在图像处理效果（失真）与运行效率上均较传统算法有明显提升，这充分证明了该算法的有效性。</p>
<p>将上文提到的全部四种算法及旋转与放缩两种功能集成到基于python的gui可视化系统中，并打包成exe可执行文件，制作了一个基于插值的图像处理系统，基本功能演示如下图所示：</p>
<p><img src="/images/project2/1.png" alt="gui演示1"></p>
<p><img src="/images/project2/2.png" alt="gui演示2"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 王开荣,杨大地编著.应用数值分析[M].高等教育出版社,2010.</p>
<p>[2] 毛伟伟,于素萍,石念峰.一种基于四平面的图像插值算法[J].洛阳理工学院学报(自然科学版),2024,34(01):76-81.</p>
<p>[3] 刘显德,李笑.任意大小图像的量子描述及双线性插值方法[J].计算机工程与设计,2024,45(08):2423-2432.</p>
<p>[4] 张喜民,詹海生.基于双三次插值的Canny-Devernay亚像素图像边缘检测算法[J].现代制造工程,2025,(03):107-114.</p>
<p>[5] 陈玲玲,周宁,殷永,等.插值方法在光声图像重建中的应用[J].计算机与数字工程,2013,41(10):1676-1677+1694.</p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2025-04-10T09:44:03.000Z" title="2025/4/10 17:44:03">2025-04-10</time>发表</span><span class="level-item"><time datetime="2025-04-29T15:56:14.086Z" title="2025/4/29 23:56:14">2025-04-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">工程数值分析</a></span><span class="level-item">1 小时读完 (大约6923个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/10/project01/">求矩阵特征值与特征向量：乘幂法及其改进算法</a></p><div class="content"><div id="postchat_postcontent"><h2 id="研究背景意义"><a href="#研究背景意义" class="headerlink" title="研究背景意义"></a>研究背景意义</h2><p>矩阵的特征值计算虽然有比较可靠的理论方法，但是，理论方法只适合于矩阵规模很小或者只是在理论证明中起作用，而实际问题的数据规模都比较大，不太可能采用常规的理论解法。计算机擅长处理大量的数值计算，所以通过适当的数值计算理论，写成程序，让计算机处理，是一种处理大规模矩阵的方法，而且是一种好的方法。乘幂法（又称幂法）是求矩阵按模最大特征值的常用方法，其结构简单、便于使用，在实际工程中应用广泛：</p>
<ul>
<li>在数值分析和优化问题中，乘幂法可通过求解矩阵按模最大特征值来得到其谱半径，从而帮助分析迭代算法的收敛性；</li>
<li>在物理学和工程学中，特征值问题常用于分析系统的稳定性、振动频率和模态分析，乘幂法能够有效求解系统的最大特征值，从而帮助理解系统的动态行为；</li>
<li>在图像处理中，特征值分解用于图像压缩、特征提取和模式识别，乘幂法可用于求解图像矩阵的最大特征值，从而实现高效的图像处理算法；</li>
<li>……</li>
</ul>
<p>但该方法也存在一定的局限性，其只适用于求矩阵按模最大的特征值，而在实际问题中往往需要求矩阵全部特征值，如在主成分分析中需要求相关矩阵的全部特征值以确定各主成分的贡献率，在求解线性微分方程组中通过求系数矩阵的全部特征值以确定其基础解系；同时该方法在求特定矩阵（如具有一对互为相反数的按模最大特征值的矩阵等）的按模最大特征值时是不收敛的。因此，我们希望以乘幂法基本思想为出发点，在此基础上提出一些改进算法以对其进行泛化，使其能够解决更为广泛且通用的应用场景下的实际问题。</p>
<h2 id="算法基本思想"><a href="#算法基本思想" class="headerlink" title="算法基本思想"></a>算法基本思想</h2><p>设n阶矩阵A具有n个线性无关的特征向量<br>$$<br>x_1,x_2,…,x_n<br>$$<br>相应的特征值<br>$$<br>\lambda_1,\lambda_2,…,\lambda_n<br>$$<br>满足：<br>$$<br>\left|\lambda_1\right|&gt;\left|\lambda_2\right|\geq\left|\lambda_3\right|\geq…\geq\left|\lambda_n\right|<br>$$<br>现任取一非零向量u_0，作迭代<br>$$<br>u_k=Au_{k-1}, k=0,1,2,…<br>$$<br>得到向量序列{u_k}(k=0,1,2,…)。因各特征向量线性无关，故n维向量u_0必可由他们线性表示，即：<br>$$<br>u_0=\alpha_{1}x_{1}+\alpha_{n}x_{2}+…+\alpha_{n}x_{n}<br>$$<br>显然有：<br>$$<br>\begin{aligned}u_{k}&amp;=A^{k}v_{0}=\alpha_{1}A^{k}x_{1}+\alpha_{2}A^{k}x_{2}+\cdots+\alpha_{n}A^{k}x_{n}=\alpha_{1}\lambda_{1}^{k}x_{1}+\alpha_{2}\lambda_{2}^{k}x_{2}+\cdots+\alpha_{n}\lambda_{n}^{k}x_{n}\&amp;=\lambda_{1}^{k}\left[\alpha_{1}x_{1}+\alpha_{2}\left(\frac{\lambda_{2}}{\lambda_{1}}\right)^{k}x_{2}+\cdots+\alpha_{n}\left(\frac{\lambda_{n}}{\lambda_{1}}\right)^{k}x_{n}\right]\end{aligned}<br>$$<br>设<br>$$<br>\alpha_{1} \neq 0<br>$$<br>由<br>$$<br>\left|\frac{\lambda_{i}}{\lambda_{1}}\right|&lt;1,i=2,3,\cdots,n<br>$$<br>可得：<br>$$<br>\operatorname*{lim}<em>{k\to\infty}\frac{u</em>{k}}{\lambda_{1}^{k}}=\operatorname*{lim}<em>{k\to\infty}\frac{\lambda</em>{1}^{k}\left[\alpha_{1}x_{1}+\sum_{i=2}^{n}\alpha_{i}\left(\frac{\lambda_{i}}{\lambda_{1}}\right)^{k}x_{i}\right]}{\lambda_{1}^{k}}=\operatorname*{lim}<em>{k\to\infty}\left[\alpha</em>{1}x_{1}+\sum_{i=2}^{n}\alpha_{i}\left(\frac{\lambda_{i}}{\lambda_{1}}\right)^{k}x_{i}\right]=\alpha_{1}x_{1}<br>$$</p>
<p>$$<br>\operatorname*{lim}<em>{k\to\infty}\frac{\left(u</em>{k+1}\right)<em>{m}}{\left(u</em>{k}\right)<em>{m}}=\operatorname*{lim}</em>{k\to\infty}\frac{\left{\lambda_{1}^{k+1}\left[\alpha_{1}x_{1}+\sum_{i=2}^{n}\alpha_{i}\left(\frac{\lambda_{i}}{\lambda_{1}}\right)^{k+1}x_{i}\right]\right}<em>{m}}{\left{\lambda</em>{1}^{k}\left[\alpha_{1}x_{1}+\sum_{i=2}^{n}\alpha_{i}\left(\frac{\lambda_{i}}{\lambda_{i}}\right)^{k}x_{i}\right]\right}<em>{m}}=\lambda</em>{1}\frac{\left(x_{1}\right)<em>{m}}{\left(x</em>{1}\right)<em>{m}}=\lambda</em>{1}<br>$$</p>
<p>这表明向量序列u_k具有收敛性，其收敛速度由比值<br>$$<br>\left|\frac{\lambda_{2}}{\lambda_{1}}\right|<br>$$<br>确定，该比值越小说明收敛速度越快，比值越接近于1收敛速度就越慢。</p>
<p>同时，该结论表明，当k取得足够大时（在实际应用时往往认为某次迭代前后误差小于设定的误差限即满足该条件），有：<br>$$<br>u_{k}≈\lambda_{1}^{k}\alpha_{1}x_{1}, \lambda_{1}≈\frac{\left(u_{k+1}\right)}{\left(u_{k}\right)}<br>$$<br>即u_ k可近似看作特征值λ_ 1对应的特征向量（较原特征向量x_ 1而言仅乘上了有限的常数系数，其结果仍为该特征值对应的特征向量），而对应的按模最大特征值λ_ 1的估计值可由前后两次迭代的特征向量u_ k相除得到。</p>
<p>当矩阵的按模最大特征值是重根时，上述结论仍然成立。设λ_ 1为r重根，即：<br>$$<br>\lambda_{1}=\lambda_{2}=\cdots=\lambda_{r}<br>$$<br>且满足条件<br>$$<br>\mid\lambda_{r}\mid&gt;\mid\lambda_{r+1}\mid\geq\cdots\geq\mid\lambda_{n}\mid<br>$$<br>则有：<br>$$<br>u_{k}=A^{k}u_{0}=\lambda_{1}^{k}\left[\sum_{i=1}^{r}\alpha_{i}x_{i}+\sum_{j=r+1}^{n}\alpha_{j}\left(\frac{\lambda_{j}}{\lambda_{1}}\right)^{k}x_{j}\right]<br>$$<br>易推得（式中(u_ k)_ m表示向量u_ k的第m个分量）：<br>$$<br>\lim_{k\to\infty}\frac{u_{k}}{\lambda_{i}^{k}}=\sum_{i=1}^{^{r}}\alpha_{i}x_{i},\lim_{k\to\infty}\frac{\left(u_{k+1}\right)<em>{m}}{\left(u</em>{k}\right)<em>{m}}=\lambda</em>{1}<br>$$<br>与一般情况略有不同的是，此时<br>$$<br>u_{k}≈\lambda_{i}^{k}\sum_{i=1}^{^{r}}\alpha_{i}x_{i}<br>$$<br>但事实上我们并没有办法在求解之前事先预知一个矩阵是否具有r重按模最大特征值，因此在实际操作的过程中采用与一般情形相同的处理方式（即认为r=1），所得的向量序列u_k仍然收敛，不影响求解结果。</p>
<p>基于以上的算法原理，可以编写如下MATLAB程序，实现一般情况下矩阵按模最大特征值及其对应特征向量的计算：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculatePowerMethod</span><span class="params">(matrixEdit, iterEdit)</span></span></span><br><span class="line">    <span class="comment">% 获取用户输入的矩阵matrixEdit和最大迭代次数iterEdit</span></span><br><span class="line">    A = str2num(matrixEdit.Value); <span class="comment">% 将字符串转换为矩阵</span></span><br><span class="line">    n = <span class="built_in">length</span>(A);</span><br><span class="line">    V = <span class="built_in">rand</span>(n,<span class="number">1</span>);  <span class="comment">% 以随机方式初始化迭代向量u0</span></span><br><span class="line">    max_iter = iterEdit.Value;    <span class="comment">% 获取迭代次数</span></span><br><span class="line"></span><br><span class="line">    Eps = <span class="number">1E-4</span>; <span class="comment">% 迭代精度</span></span><br><span class="line">    k = <span class="number">0</span>; <span class="comment">% 初始迭代次数</span></span><br><span class="line">    lambda0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 乘幂法迭代，求得矩阵按模最大特征值lambda及其对应特征向量v</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= max_iter - <span class="number">1</span></span><br><span class="line">        v = A * V;</span><br><span class="line">        [vmax, <span class="built_in">i</span>] = <span class="built_in">max</span>(<span class="built_in">abs</span>(v));</span><br><span class="line">        lambda = v(<span class="built_in">i</span>) / V(<span class="built_in">i</span>);</span><br><span class="line">        V = v;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(lambda - lambda0)&lt;Eps</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        lambda0 = lambda;</span><br><span class="line">        k = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="改进的乘幂法"><a href="#改进的乘幂法" class="headerlink" title="改进的乘幂法"></a>改进的乘幂法</h2><p>在实际应用层面，上述的算法逻辑只在一小部分的常规矩阵上对于矩阵的按模最大特征值求解有较好效果。事实上，仅依托以上的代码逻辑进行求解往往会出现以下几大问题：</p>
<ol>
<li>当矩阵A不具有n个线性无关的特征向量时（事先无法判断），乘幂法不适用。</li>
<li>当待求取的按模最大特征值abs(λ_ 1)&gt;1时，迭代向量u_ k的各个分量可能会随着abs(λ_ 1)^k变得很大而使计算机“上溢”；而当待求取的按模最大特征值abs(λ_ 1)&lt;1时，迭代向量u_ k的各个分量可能会随着abs(λ_ 1)^k变得很小使u_k成为零向量。</li>
<li>矩阵的按模最大特征值是一对相反数。</li>
<li>矩阵的按模最大特征值是一对共轭复数。</li>
</ol>
<p>（上述算法中还给出了α_1≠0的假设，事实上如果不满足这一点也不影响乘幂法的成功使用。因为舍入误差的影响，在迭代某一步会产生u_k在x_1方向上的分量不为零，以后的迭代仍会收敛）</p>
<p>针对问题1，我们暂时无法提出具有针对性的解决方案，但后续的实际测试证明，当迭代次数k足够大时，我们针对问题3所提出的改进方案在该种情况下相比基本算法能够有更好的收敛性（收敛更快）；针对问题2，我们可以通过将向量序列u_k进行规范化处理，限制向量的模在特定小范围内，防止计算机运算的上下溢出；针对问题3，我们在原有的乘幂法算法思想的基础上进行了改进，改进后的算法能够有效对原算法无法求解（不收敛）的按模最大特征值互为相反数的矩阵的按模最大特征值进行有效求解；针对问题4，我们目前还没有找到有效的解决方案。</p>
<h3 id="迭代向量的归一化"><a href="#迭代向量的归一化" class="headerlink" title="迭代向量的归一化"></a>迭代向量的归一化</h3><p>设迭代向量u为非零向量，将其归一化得到向量<br>$$<br>y=\frac{u}{max(u)}<br>$$<br>其中max(u)表示向量u的模最大的分量（即向量的无穷范数）。这样的规范化会保证每一次迭代后得到的新的迭代向量的模最大分量均为1，这有效起到了限制迭代向量分量范围的作用，能够很好地解决上述提到的问题2。值得注意的是，对向量规范化的方式并不只有归一化这一种，实际上可以使用任意一种范数对向量进行规范化处理，如2范数等。可以证明，对于基于不同范数的归一化都有相同的向量序列收敛结论，下面以无穷范数为例给出基本的证明。（显然这样的规范化只是在原有的向量基础上除以了某一个常数，这并不会改变向量序列的收敛性）</p>
<p>取初始向量<br>$$<br>u_{0}\neq0<br>$$<br>规范化得<br>$$<br>y_{0}=\frac{u_{0}}{\max(u_{0})}<br>$$<br>构造向量序列：<br>$$<br>\begin{aligned}<br>&amp;u_{1}=Ay_{0}=\frac{Au_{0}}{\max(u_{0})},<br>&amp;y_{1}=\frac{u_{1}}{\max(u_{1})}=\frac{Au_{0}}{\max(Au_{0})}\<br>&amp;u_{2}=Ay_{1}=\frac{A^{2}u_{0}}{\max(Au_{0})},<br>&amp;y_{2}=\frac{u_{2}}{\max(u_{2})}=\frac{A^{2}u_{0}}{\max(A^{2}u_{0})}\<br>&amp;……\<br>&amp;u_{<em>k}=Ay</em>{<em>{k-1}}=\frac{A^{k}u</em>{0}}{\max(A^{k-1}u_{0})},<br>&amp;\quad y_{k}=\frac{u_{k}}{\max(u_{k})}=\frac{A^{k}u_{0}}{\max(A^{k}u_{0})}<br>\end{aligned}<br>$$<br>结合乘幂法基本算法中已经证明的结论<br>$$<br>A^{k}u_{0}=u_{k}≈\lambda_{1}^{k}\alpha_{1}x_{1}<br>$$<br>则有：<br>$$<br>\lim_{k\to\infty}y_{k}=\frac{x_{1}}{\max(x_{1})},<br>\lim_{k\to\infty}\max(u_{k})=\lambda_{1}<br>$$<br>这表明此时y_ k可近似看作特征值λ_ 1对应的特征向量（较原特征向量x_ 1而言仅进行了归一化处理，其结果仍为该特征值对应的特征向量），而对应的按模最大特征值λ_ 1的估计值可近似看作未归一化前的迭代向量最大分量值max(u_k)。</p>
<p>基于以上的算法原理，可以编写如下MATLAB程序，实现归一化处理下矩阵按模最大特征值及其对应特征向量的计算：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculatePowerMethod</span><span class="params">(matrixEdit, iterEdit)</span></span></span><br><span class="line">    <span class="comment">% 获取用户输入的矩阵matrixEdit和最大迭代次数iterEdit</span></span><br><span class="line">    A = str2num(matrixEdit.Value); <span class="comment">% 将字符串转换为矩阵</span></span><br><span class="line">    n = <span class="built_in">length</span>(A);</span><br><span class="line">    V = <span class="built_in">rand</span>(n,<span class="number">1</span>);  <span class="comment">% 以随机方式初始化迭代向量u0</span></span><br><span class="line">    max_iter = iterEdit.Value;    <span class="comment">% 获取迭代次数</span></span><br><span class="line"></span><br><span class="line">    Eps = <span class="number">1E-4</span>; <span class="comment">% 迭代精度</span></span><br><span class="line">    k = <span class="number">0</span>; <span class="comment">% 初始迭代次数</span></span><br><span class="line">    lambda0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 乘幂法迭代，求得矩阵按模最大特征值lambda及其对应特征向量v</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= max_iter - <span class="number">1</span></span><br><span class="line">        v = A * V;</span><br><span class="line">        [vmax, <span class="built_in">i</span>] = <span class="built_in">max</span>(<span class="built_in">abs</span>(v));</span><br><span class="line">        lambda = v(<span class="built_in">i</span>);</span><br><span class="line">        V = v / lambda;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(lambda - lambda0)&lt;Eps</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        lambda0 = lambda;</span><br><span class="line">        k = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="归一化乘幂法的进一步改进"><a href="#归一化乘幂法的进一步改进" class="headerlink" title="归一化乘幂法的进一步改进"></a>归一化乘幂法的进一步改进</h3><p>针对问题3，从其基本情形出发（其他条件与先前保持一致），即有：<br>$$<br>\mid\lambda_1\mid=\mid\lambda_2\mid&gt;\mid\lambda_3\mid\geqslant\cdotp\cdotp\cdotp\geqslant\mid\lambda_n\mid，\lambda_1=-\lambda_2<br>$$<br>在矩阵按模最大特征值为一对相反数的情况下，原迭代向量序列中各相邻向量的比值极限发散：<br>$$<br>\lim_{k\to\infty}\frac{\boldsymbol{u}_{k+1}}{\boldsymbol{u}<em>k}=\lambda_1\lim</em>{k\to\infty}\frac{a_1\boldsymbol{x}_1+(-1)^{k+1}a_2\boldsymbol{x}<em>2+\boldsymbol{\varepsilon}</em>{k+2}}{a_1\boldsymbol{x}_1+(-1)^ka_2\boldsymbol{x}_2+\boldsymbol{\varepsilon}_k}<br>$$<br>说明在该种情况下，采用原有的乘幂法基本算法，得到的迭代向量序列并不收敛，无法得到稳定的矩阵按模最大特征值数值求解结果。</p>
<p>我们在原有算法的基础上进行了一定的改进，构造了新的迭代向量序列，使其对于矩阵按模最大特征值为一对相反数的情况也能保证收敛，从而可以对该情况下的矩阵按模最大特征值进行有效求解。</p>
<p>先从较为简单的非归一化迭代入手，同样取迭代向量序列u_k，其初始非零向量u_0满足：<br>$$<br>u_0=\alpha_{1}x_{1}+\alpha_{n}x_{2}+…+\alpha_{n}x_{n}(\alpha_{1}\neq0)<br>$$<br>则有：<br>$$<br>\boldsymbol{u}<em>{k}=\boldsymbol{A}^{k}\left(\sum</em>{i=1}^{n}a_{i}\boldsymbol{x}<em>{i}\right)=\lambda</em>{1}^{k}\left(a_{1}\boldsymbol{x}<em>{1}+(-1)^{k}a</em>{2}\boldsymbol{x}<em>{2}+\sum</em>{i=3}^{n}\left(\frac{\lambda_{i}}{\lambda_{1}}\right)^{k}a_{i}\boldsymbol{x}<em>{i}\right)=\lambda</em>{1}^{k}(a_{1}\boldsymbol{x}<em>{1}+(-1)^{k}a</em>{2}\boldsymbol{x}<em>{2}+\boldsymbol{\varepsilon}</em>{k}),\lim_{k\to\infty}\varepsilon_{k}=0<br>$$<br>于是可得到：<br>$$<br>\lim_{k\to\infty}\frac{u_{k+2}}{u_{k}}=\lambda_{1}^{2}\lim_{k\to\infty}\frac{\alpha_{1}x_{1}+(-1)^{k+2}\alpha_{2}x_{2}+\varepsilon_{k+2}}{\alpha_{1}x_{1}+(-1)^{k}\alpha_{2}x_{2}+\varepsilon_{k}}=\lambda_{1}^{2}<br>$$<br>且有：<br>$$<br>\lim_{k\to\infty}\frac{u_{k+1}+\lambda_1u_k}{\lambda_1^{k+1}}=2\alpha_1x_1<br>$$<br>以上结果说明，在矩阵按模最大特征值为一对相反数（正值λ_ 1，负值λ_ 2）的情形下，若采用原有的迭代向量序列，对序列中的向量一隔一取出，构成的新序列是收敛的，且新序列中的相邻两项向量的比值极限为矩阵按模最大特征值的平方；同时，u_ {k+1}+λ_ {1}u_ {k}可近似看作λ_ {1}的特征向量，同理u_ {k+1}+λ_ {2}u_ {k}也可近似看作λ_ {2}的特征向量。</p>
<p>易证该方法对于规范化后的向量序列也具有相同的收敛性，在此不额外给出证明。</p>
<p>在实际编程实现算法时，为尽可能地节省算力与内存并提高计算效率，我们不会预先求取最大迭代次数内每一次迭代的结果再将其分为两个向量序列判断其是否收敛（相邻向量插值小于设定误差限），而是需要结合上述改进算法与逐步迭代过程，对于每一次迭代的求解过程进行逻辑优化，优化后的逻辑如下所示（u_k代表规范化后的迭代向量序列，采用2范数方式进行规范化，k=1,2,…）：</p>
<ul>
<li><p>若<br>$$<br>\left|\frac{\left(\boldsymbol{u}_{k+2}^{(1)}\right)_i}{\left(\boldsymbol{u}_k^{(1)}\right)<em>i}-\frac{\left(\boldsymbol{u}</em>{k+1}^{(1)}\right)<em>i}{\left(\boldsymbol{u}</em>{k-1}^{(1)}\right)_i}\right|&lt;\varepsilon:,</p>
<p>\left|\frac{\left(\boldsymbol{u}_{k+2}^{(1)}\right)<em>i}{\left(\boldsymbol{u}</em>{k+1}^{(1)}\right)<em>i}-\frac{\left(\boldsymbol{u}</em>{k+1}^{(1)}\right)_i}{\left(\boldsymbol{u}_k^{(1)}\right)<em>i}\right|&lt;\varepsilon:<br>$$<br>则取矩阵按模最大特征值<br>$$<br>\lambda_1=\frac{(\boldsymbol{u}</em>{k+2}^{(1)})<em>i}{(\boldsymbol{u}</em>{k+1}^{(1)})<em>i}<br>$$<br>对应的特征向量<br>$$<br>x_1=u</em>{k+2}^{(1)}<br>$$</p>
</li>
<li><p>若<br>$$<br>\left|\frac{\left(\boldsymbol{u}_{k+2}^{(1)}\right)_i}{\left(\boldsymbol{u}_k^{(1)}\right)<em>i}-\frac{\left(\boldsymbol{u}</em>{k+1}^{(1)}\right)<em>i}{\left(\boldsymbol{u}</em>{k-1}^{(1)}\right)_i}\right|&lt;\varepsilon:,</p>
<p>\left|\frac{(\boldsymbol{u}<em>{k+2}^{(1)})<em>i}{(\boldsymbol{u}</em>{k+1}^{(1)})<em>i}-\frac{(\boldsymbol{u}</em>{k+1}^{(1)})<em>i}{(\boldsymbol{u}<em>k^{(1)})<em>i}\right|&gt;\varepsilon:<br>$$<br>则取矩阵按模最大特征值<br>$$<br>\lambda_1=\pm\sqrt{\frac{(\boldsymbol{u}</em>{k+2}^{(1)})<em>i}{(\boldsymbol{u}</em>{k}^{(1)})<em>i}}<br>$$<br>对应的特征向量<br>$$<br>x_1=\frac{u</em>{k+2}^{(1)}+\lambda_1u</em>{k+1}^{(1)}}{\parallel u</em>{k+2}^{(1)}+\lambda_1u</em>{k+1}^{(1)}\parallel_2}<br>$$</p>
</li>
</ul>
<p>基于以上的算法原理，可以编写如下MATLAB程序，实现矩阵按模最大特征值及其对应特征向量求解的改进算法，以解决矩阵按模最大特征值可能为一对相反数的特殊情况：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculatePowerMethod1</span><span class="params">(matrixEdit, iterEdit, fig)</span></span></span><br><span class="line">    <span class="comment">% 获取用户输入的矩阵matrixEdit和最大迭代次数iterEdit</span></span><br><span class="line">    A = str2num(matrixEdit.Value); <span class="comment">% 将字符串转换为矩阵</span></span><br><span class="line">    n = <span class="built_in">length</span>(A);</span><br><span class="line">    V = <span class="built_in">rand</span>(n,<span class="number">1</span>);  <span class="comment">% 以随机方式初始化迭代向量u0</span></span><br><span class="line">    max_iter = iterEdit.Value;    <span class="comment">% 获取迭代次数</span></span><br><span class="line"></span><br><span class="line">    Eps = <span class="number">1E-4</span>; <span class="comment">% 迭代精度</span></span><br><span class="line">    k = <span class="number">0</span>; <span class="comment">% 初始迭代次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 乘幂法迭代，求得矩阵按模最大特征值lambda及其对应特征向量v</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= max_iter - <span class="number">1</span></span><br><span class="line">        v = A * V;</span><br><span class="line">        v1 = A * v;</span><br><span class="line">        v_2 =norm(v, <span class="number">2</span>);</span><br><span class="line">        minus1 = A * v1 ./ v - v1 ./ V;</span><br><span class="line">        minus2 = A * v1 ./ v1 - v1 ./ v;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(<span class="built_in">abs</span>(minus1(:))) &lt; Eps</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">max</span>(<span class="built_in">abs</span>(minus2(:))) &lt; Eps</span><br><span class="line">                lambda0 = A * v1 ./ v1;</span><br><span class="line">                lambda = <span class="built_in">max</span>(lambda0(:));</span><br><span class="line">                v2_2 = norm(A * v1, <span class="number">2</span>);       </span><br><span class="line">                v = A * v1 / v2_2;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lambda0 = A * v1 ./ v;</span><br><span class="line">                lambda = <span class="built_in">sqrt</span>(<span class="built_in">max</span>(lambda0(:)));</span><br><span class="line">                v3 = A * v1 + lambda * v1;</span><br><span class="line">                v3_2 = norm(v3, <span class="number">2</span>);</span><br><span class="line">                v = v3 / v3_2;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        k = k + <span class="number">1</span>;</span><br><span class="line">        V = v / v_2;</span><br><span class="line">        lambda0 = A * v1 ./ v1;</span><br><span class="line">        lambda = <span class="built_in">max</span>(lambda0(:));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="求实对称矩阵的全部特征值"><a href="#求实对称矩阵的全部特征值" class="headerlink" title="求实对称矩阵的全部特征值"></a>求实对称矩阵的全部特征值</h3><p>我们知道，实对称矩阵的不同特征值对应的特征向量一定是正交的，因此，可以通过幂法迭代得到矩阵的主特征值λ_ 1和主特征向量x_ 1 ，再重新给出一个新的与v_ 0线性无关的初始迭代向量v_ 1，使v_ 1和x_ 1正交化， 则可以由幂法迭代出矩阵的特征值λ_ 2和特征向量x_ 2。同样使新给出的初始迭代向量v_ 3和x_ 1、x_ 2正交 化，则可以由幂法得到λ_ 3和x_ 3。以此类推，可以计算出矩阵的全部特征值和特征向量。具体证明过程详见参考文献[3]，这里仅给出基于上述改进算法的完整算法逻辑：</p>
<p>令<br>$$<br>A_j=\mathbf{A}<em>{j-1}-\lambda</em>{j-1}\boldsymbol{x}<em>{j-1}\boldsymbol{x}</em>{j-1}^{\mathrm{T}}(j=2,3,\cdots n)<br>$$<br>采取与先前完全相同的迭代向量序列构造方式，有如下判断逻辑（u_k代表规范化后的迭代向量序列，采用2范数方式进行规范化，k=1,2,…）：</p>
<ul>
<li><p>若<br>$$<br>\left|\frac{(u_{k+2}^{(j)})<em>i}{(u_k^{(j)})<em>i}-\frac{(u</em>{k+1}^{(j)})<em>i}{(u</em>{k-1}^{(j)})<em>i}\right|&lt;\varepsilon:,\quad\left|\frac{(u</em>{k+2}^{(j)})<em>i}{(u</em>{k+1}^{(j)})<em>i}-\frac{(u</em>{k+1}^{(j)})<em>i}{(u_k^{(j)})<em>i}\right|&lt;\varepsilon:,<br>$$<br>且满足<br>$$<br>{|x</em>{m}^{\mathrm{T}}v</em>{k+2}^{(j)}|&lt;\varepsilon}\left(m=1,2,\cdots,j-1\right)<br>$$<br>则取矩阵按模最大特征值<br>$$<br>{\lambda</em>{j}}=\frac{\left(\boldsymbol{u}<em>{k+2}^{(j)}\right)</em>{i}}{\left(\boldsymbol{u}<em>{k+1}^{(j)}\right)</em>{i}}<br>$$<br>对应的特征向量<br>$$<br>x_{j}=\boldsymbol{u}_{k+2}^{(j)}<br>$$</p>
</li>
<li><p>若<br>$$<br>\left|\frac{(u_{k+2}^{(j)})<em>i}{(u_k^{(j)})<em>i}-\frac{(u</em>{k+1}^{(j)})<em>i}{(u</em>{k-1}^{(j)})<em>i}\right|&lt;\varepsilon:,\quad\left|\frac{(u_{k+2}^{(j)})_i}{(u_{k+1}^{(j)})_i}-\frac{(u_{k+1}^{(j)})_i}{(u_k^{(j)})_i}\right|&gt;\varepsilon:,<br>$$<br>且满足<br>$$<br>\left|\boldsymbol{x}</em>{m}^{\mathrm{T}}\frac{\boldsymbol{u}</em>{k+2}^{(j)}+\lambda_{j}\boldsymbol{u}<em>{k+1}^{(j)}}{\parallel\boldsymbol{u}</em>{k+2}^{(j)}+\lambda_{j}\boldsymbol{u}<em>{k+1}^{(j)}\parallel</em>{2}}\right|&lt;\varepsilon\quad(m=1,2,\cdots,j-1)<br>$$<br>则取矩阵按模最大特征值<br>$$<br>\lambda_{j}=\pm\sqrt{\frac{(\boldsymbol{u}<em>{k+2}^{(j)})</em>{i}}{(\boldsymbol{u}<em>{k}^{(j)})</em>{i}}}<br>$$<br>对应的特征向量<br>$$<br>\quad x_{j}=\frac{\boldsymbol{u}<em>{k+2}^{(j)}+\lambda</em>{j}\boldsymbol{u}<em>{k+1}^{(j)}}{\parallel\boldsymbol{u}</em>{k+2}^{(j)}+\lambda_{j}\boldsymbol{u}<em>{k+1}^{(j)}\parallel</em>{2}}<br>$$</p>
</li>
</ul>
<p>基于以上的算法原理，可以编写如下MATLAB程序，实现矩阵按模最大特征值及其对应特征向量求解的改进算法，并对于实对称矩阵的全部特征值进行依次求解（每次运行该函数进行一个特征值的求解，代码中省去了存储用于求解下一个特征值的矩阵作为全局变量的部分）：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculatePowerMethod2</span><span class="params">(iterEdit, fig)</span></span></span><br><span class="line">    <span class="comment">% 从存储的全局变量中读取需要求解主特征值的新矩阵data.matrix</span></span><br><span class="line">    A = data.matrix; <span class="comment">% 将字符串转换为矩阵</span></span><br><span class="line">    n = <span class="built_in">length</span>(A);</span><br><span class="line">    V = <span class="built_in">rand</span>(n,<span class="number">1</span>); </span><br><span class="line">    max_iter = iterEdit.Value;    <span class="comment">% 获取迭代次数</span></span><br><span class="line"></span><br><span class="line">    Eps = <span class="number">1E-4</span>; <span class="comment">% 迭代精度</span></span><br><span class="line">    k = <span class="number">0</span>; <span class="comment">% 初始迭代次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 乘幂法迭代，求得矩阵按模最大特征值lambda及其对应特征向量v</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= max_iter - <span class="number">1</span></span><br><span class="line">        v = A * V;</span><br><span class="line">        v1 = A * v;</span><br><span class="line">        v_2 =norm(v, <span class="number">2</span>);</span><br><span class="line">        v2_2 = norm(A * v1, <span class="number">2</span>);</span><br><span class="line">        v2 = A * v1 / v2_2;</span><br><span class="line">        lambda0 = A * v1 ./ v;</span><br><span class="line">        lambda = <span class="built_in">sqrt</span>(<span class="built_in">max</span>(lambda0(:)));</span><br><span class="line">        v3 = A * v1 + lambda * v1;</span><br><span class="line">        v3_2 = norm(v3, <span class="number">2</span>);</span><br><span class="line">        minus1 = A * v1 ./ v - v1 ./ V;</span><br><span class="line">        minus2 = A * v1 ./ v1 - v1 ./ v;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(<span class="built_in">abs</span>(minus1(:)))&lt;Eps</span><br><span class="line">            num1 = <span class="number">0</span>;</span><br><span class="line">            num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> l = <span class="number">1</span> : <span class="built_in">j</span></span><br><span class="line">                x = full_V(:,l);</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">max</span>(<span class="built_in">abs</span>(minus2(:))) &lt; Eps &amp;&amp; <span class="built_in">abs</span>(x' * v2) &lt; Eps</span><br><span class="line">                    num1 = num1 + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">elseif</span> <span class="built_in">max</span>(<span class="built_in">abs</span>(minus2(:))) &gt; Eps &amp;&amp; <span class="built_in">abs</span>(x' * v3 / v3_2) &lt; Eps</span><br><span class="line">                    num2 = num2 + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> num1 == <span class="built_in">j</span></span><br><span class="line">                lambda0 = A * v1 ./ v1;</span><br><span class="line">                lambda = <span class="built_in">max</span>(lambda0(:));</span><br><span class="line">                v = A * v1 / v2_2;</span><br><span class="line">                k = k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">elseif</span> num2 == <span class="built_in">j</span></span><br><span class="line">                lambda0 = A * v1 ./ v;</span><br><span class="line">                lambda = <span class="built_in">sqrt</span>(<span class="built_in">max</span>(lambda0(:)));</span><br><span class="line">                v = v3 / v3_2;</span><br><span class="line">                k = k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        k = k + <span class="number">1</span>;</span><br><span class="line">        V = v / v_2;</span><br><span class="line">        lambda0 = A * v1 ./ v1;</span><br><span class="line">        lambda = <span class="built_in">max</span>(lambda0(:));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="数据测试实验"><a href="#数据测试实验" class="headerlink" title="数据测试实验"></a>数据测试实验</h2><p>针对以上提到的乘幂法及其改进算法，将其MATLAB求解代码整合进GUI中，并对求解过程中矩阵按模最大特征值随迭代次数增加的收敛情况进行可视化，基本界面如下：</p>
<p><img src="/images/project01/1.png" alt="1"></p>
<h3 id="乘幂法基础算法"><a href="#乘幂法基础算法" class="headerlink" title="乘幂法基础算法"></a>乘幂法基础算法</h3><p>将待求解的矩阵按照格式要求输入框体内，并指定最大迭代次数（默认为100次），按下“计算”控件可以利用基础的乘幂法（归一化版本）对矩阵按模最大特征值及其对应特征向量进行求解，同时会调用MATLAB中自带的矩阵特征值求解函数eig()对求解结果进行验证。</p>
<h4 id="例：矩阵（特征值为-1、3、5）"><a href="#例：矩阵（特征值为-1、3、5）" class="headerlink" title="例：矩阵（特征值为-1、3、5）"></a>例：矩阵（特征值为-1、3、5）</h4><p>$$<br>A=\begin{pmatrix}1&amp;-1&amp;2\-2&amp;0&amp;5\6&amp;-3&amp;6\end{pmatrix}<br>$$</p>
<p>程序求解与可视化结果：</p>
<p><img src="/images/project01/2.png" alt="2"></p>
<p>可以发现，估计的主特征值与实际的主特征值在限定的精度内基本一致，对应的特征向量相差了相同的倍数，也可视为正确求解。</p>
<h3 id="乘幂法改进算法"><a href="#乘幂法改进算法" class="headerlink" title="乘幂法改进算法"></a>乘幂法改进算法</h3><p>将待求解的矩阵按照格式要求输入框体内，并指定最大迭代次数（默认为100次），按下“优化计算”控件可以利用改进的乘幂法（归一化版本）对矩阵按模最大特征值及其对应特征向量进行求解，同时会调用MATLAB中自带的矩阵特征值求解函数eig()对求解结果进行验证。</p>
<h4 id="例1：矩阵（特征值为-1、3、5）"><a href="#例1：矩阵（特征值为-1、3、5）" class="headerlink" title="例1：矩阵（特征值为-1、3、5）"></a>例1：矩阵（特征值为-1、3、5）</h4><p>$$<br>A=\begin{pmatrix}1&amp;-1&amp;2\-2&amp;0&amp;5\6&amp;-3&amp;6\end{pmatrix}<br>$$</p>
<p>程序求解与可视化结果：</p>
<p><img src="/images/project01/3.png" alt="3"></p>
<p>可以发现，估计的主特征值与实际的主特征值在限定的精度内保持一致，通过该算法计算得到的对应特征向量也与MATLAB自带函数（基于 Cholesky 分解/QR分解方法的特征值求解）的求解结果在限定精度内完全一致，但计算需要的迭代次数较基础算法而言有明显增加。</p>
<h4 id="例2：矩阵（特征值为3、-3、1，按模最大特征值为一对相反数）"><a href="#例2：矩阵（特征值为3、-3、1，按模最大特征值为一对相反数）" class="headerlink" title="例2：矩阵（特征值为3、-3、1，按模最大特征值为一对相反数）"></a>例2：矩阵（特征值为3、-3、1，按模最大特征值为一对相反数）</h4><p>$$<br>A=\begin{pmatrix}3&amp;-2&amp;4\0&amp;-3&amp;2\0&amp;0&amp;1\end{pmatrix}<br>$$</p>
<p>程序求解与可视化结果：</p>
<p>调用乘幂法基本算法：</p>
<p><img src="/images/project01/4.png" alt="4"></p>
<p>调用乘幂法改进算法：</p>
<p><img src="/images/project01/5.png" alt="5"></p>
<p>可以发现：</p>
<ul>
<li>调用基础算法时，迭代向量序列在设定的最大迭代次数内并不收敛，最终的求解结果也与实际按模最大特征值有较大误差；</li>
<li>而调用改进算法时，尽管从主特征值收敛过程的可视化结果中无法确定向量序列的收敛性（实际上原序列仍发散），但序列中的向量一隔一选取构成的新序列（图像中对应迭代次数全为奇数/偶数的震荡单边）已由程序判断收敛，且估计的主特征值与实际的主特征值在限定的精度内保持一致，通过该算法计算得到的对应特征向量也与MATLAB自带函数（基于 Cholesky 分解/QR分解方法的特征值求解）的求解结果在限定精度内完全一致。</li>
</ul>
<h4 id="例3：3阶矩阵（特征值为3（重根），但不具有3个线性无关的特征向量）"><a href="#例3：3阶矩阵（特征值为3（重根），但不具有3个线性无关的特征向量）" class="headerlink" title="例3：3阶矩阵（特征值为3（重根），但不具有3个线性无关的特征向量）"></a>例3：3阶矩阵（特征值为3（重根），但不具有3个线性无关的特征向量）</h4><p>$$<br>A=\begin{pmatrix}3&amp;1&amp;0\0&amp;3&amp;1\0&amp;0&amp;3\end{pmatrix}<br>$$</p>
<p>程序求解与可视化结果：</p>
<p>调用乘幂法基本算法（最大迭代次数100）：</p>
<p><img src="/images/project01/6.png" alt="6"></p>
<p>调用乘幂法改进算法（最大迭代次数100）：</p>
<p><img src="/images/project01/7.png" alt="7"></p>
<p>调用乘幂法基本算法（最大迭代次数10000）：</p>
<p><img src="/images/project01/8.png" alt="8"></p>
<p>调用乘幂法改进算法（最大迭代次数10000）：</p>
<p><img src="/images/project01/9.png" alt="9"></p>
<p>可以发现，当矩阵不具有n个线性无关的特征向量时，乘幂法从理论上讲不再适用（不满足假设条件），但实际测试可以发现：</p>
<ul>
<li>当最大迭代次数设置较小（100）时，两种方法均未呈现数值上的收敛（两次迭代间误差不超过设定误差限10^(-4)），所求得的主特征值与对应特征向量与真实值之间均有明显误差；</li>
<li>当最大迭代次数设置足够大（10000）时，两种方法在迭代次数达到10^2数量级时实现了数值上的收敛（两次迭代间误差不超过设定误差限10^(-4)），但在停止迭代后，通过乘幂法基础算法求得的主特征值与对应特征向量与真实值之间仍有明显误差，而通过改进算法求得的主特征值与对应特征向量与真实值已经基本接近，但改进算法所需要的迭代次数也明显更多。</li>
</ul>
<p>但总的来说，从理论角度出发，在这种情况下乘幂法已不再适用，本例的情况仅为收敛较慢，此时改进算法相较于基础算法有更好的精度；但也会有不收敛的情况，此时两种方法均会有比较大的误差，而这是无法事先判断的，因此在使用乘幂法时还是尽量避免该种情况，或者说在优化算法仍然无法快速收敛的情况下需要注意到矩阵不具有n个线性无关的特征向量的特殊情况，此时应选取其他合适的特征值求解算法。</p>
<h4 id="例4：矩阵（特征值为1-2i、1-2i、0-5，按模最大特征值为一对共轭复数）"><a href="#例4：矩阵（特征值为1-2i、1-2i、0-5，按模最大特征值为一对共轭复数）" class="headerlink" title="例4：矩阵（特征值为1+2i、1-2i、0.5，按模最大特征值为一对共轭复数）"></a>例4：矩阵（特征值为1+2i、1-2i、0.5，按模最大特征值为一对共轭复数）</h4><p>$$<br>A=\begin{pmatrix}1&amp;-2&amp;0\2&amp;1&amp;0\0&amp;0&amp;0.5\end{pmatrix}<br>$$</p>
<p>程序求解与可视化结果：</p>
<p>调用乘幂法基本算法：</p>
<p><img src="/images/project01/10.png" alt="10"></p>
<p>调用乘幂法改进算法：</p>
<p><img src="/images/project01/11.png" alt="11"></p>
<p>此情况下两种乘幂法均呈现了极大的不稳定性，无法正确求解。</p>
<h3 id="求实对称矩阵的全部特征值-1"><a href="#求实对称矩阵的全部特征值-1" class="headerlink" title="求实对称矩阵的全部特征值"></a>求实对称矩阵的全部特征值</h3><h4 id="例1：矩阵（特征值为-1、3、5）-1"><a href="#例1：矩阵（特征值为-1、3、5）-1" class="headerlink" title="例1：矩阵（特征值为-1、3、5）"></a>例1：矩阵（特征值为-1、3、5）</h4><p>$$<br>A=\begin{pmatrix}1&amp;-1&amp;2\-2&amp;0&amp;5\6&amp;-3&amp;6\end{pmatrix}<br>$$</p>
<p>程序求解与可视化结果：</p>
<p><img src="/images/project01/12.png" alt="12"></p>
<p>该矩阵不为对称矩阵，无法通过上述算法实现全部特征值的求解，为排错示例。</p>
<h4 id="例2：对称矩阵（特征值为1、2、4）"><a href="#例2：对称矩阵（特征值为1、2、4）" class="headerlink" title="例2：对称矩阵（特征值为1、2、4）"></a>例2：对称矩阵（特征值为1、2、4）</h4><p>$$<br>A=\begin{pmatrix}3&amp;1&amp;1\1&amp;2&amp;0\1&amp;0&amp;2\end{pmatrix}<br>$$</p>
<p>程序求解与可视化结果：</p>
<p><img src="/images/project01/13.png" alt="13"></p>
<p><img src="/images/project01/14.png" alt="14"></p>
<p><img src="/images/project01/15.png" alt="15"></p>
<p><img src="/images/project01/16.png" alt="16"></p>
<p>可以看到，该算法可以用于正确求取实对称矩阵的所有特征值及其相应的特征向量，求解结果与MATLAB自带函数（基于 Cholesky 分解/QR分解方法的特征值求解）的求解结果在限定精度内完全一致。</p>
<h4 id="例3：对称矩阵（特征值为2、1、-1）"><a href="#例3：对称矩阵（特征值为2、1、-1）" class="headerlink" title="例3：对称矩阵（特征值为2、1、-1）"></a>例3：对称矩阵（特征值为2、1、-1）</h4><p>$$<br>A=\begin{pmatrix}1&amp;1&amp;0\1&amp;0&amp;1\0&amp;1&amp;1\end{pmatrix}<br>$$</p>
<p>程序求解与可视化结果：</p>
<p><img src="/images/project01/17.png" alt="17"></p>
<p><img src="/images/project01/18.png" alt="18"></p>
<p><img src="/images/project01/19.png" alt="19"></p>
<p><img src="/images/project01/20.png" alt="20"></p>
<p>可以看到，即使在矩阵的次主特征值为一对相反数的情况下，该算法也可以用于正确求取实对称矩阵的所有特征值及其相应的特征向量，求解结果与MATLAB自带函数（基于 Cholesky 分解/QR分解方法的特征值求解）的求解结果在限定精度内完全一致。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 王开荣,杨大地编著.应用数值分析[M].高等教育出版社,2010.</p>
<p>[2] 曹连英,曲智林,杨瑞智.基于幂法的求实对称矩阵特征值的注记[J].大学数学,2024,40(04):67-72.</p>
<p>[3] 曾莉,肖明.计算实对称矩阵特征值特征向量的幂法[J].南昌大学学报(理科版),2016,40(04):399-402.</p>
<p>[4] 张青,苟国楷,吕崇德.乘幂法的改进算法[J].应用数学与计算数学学报,1997,(01):51-55.</p>
<p>[5] 马志勇,方珑.矩阵特征值求解及其在图像压缩中的应用[J].上海第二工业大学学报,2012,29(04):315-318.</p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2025-01-11T12:58:03.000Z" title="2025/1/11 20:58:03">2025-01-11</time>发表</span><span class="level-item"><time datetime="2025-03-03T11:45:12.258Z" title="2025/3/3 19:45:12">2025-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/">数学物理方法</a></span><span class="level-item">2 小时读完 (大约17125个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/11/smoke/">烟雾扩散问题</a></p><div class="content"><div id="postchat_postcontent"><h2 id="1-研究背景简介"><a href="#1-研究背景简介" class="headerlink" title="1 研究背景简介"></a>1 研究背景简介</h2><h3 id="1-1-研究背景与意义"><a href="#1-1-研究背景与意义" class="headerlink" title="1.1 研究背景与意义"></a>1.1 研究背景与意义</h3><p>香烟烟雾中含有数千种化学物质，其中包括一氧化碳、尼古丁、苯等多种对人体有害的成分。这些物质在室内封闭环境中容易积聚，对人体健康构成显著威胁，尤其是二手烟和三手烟的危害已引起广泛关注。报告显示，2018年中国不吸烟者的二手烟暴露率为68.1%，其中家庭和工作场所是二手烟暴露的主要场所，这表明室内烟雾污染已成为影响公众健康的重要问题。因此，我们希望通过研究烟雾在室内环境中的扩散规律，为烟雾的控制、空气污染防治或室内空气质量管理提供参考，并帮助优化通风设计或制定健康防护措施。</p>
<p>烟雾的扩散过程受到室内温湿度、气流模式、房间结构及家具布置等多种因素的影响，具有较高的复杂性和随机性。深入研究烟雾扩散的传输机制，可以帮助揭示其污染范围与浓度分布，为优化室内空气质量管理提供理论支持。但在估计和预测吸入暴露风险时，由于与生物伦理学和动物保护相关的潜在限制，涉及人类志愿者和其他用于毒理学研究的哺乳动物替代模型的体内研究存在局限性。出于这样的考虑，我们希望通过理论分析建模与数值模拟的方式，得到烟雾扩散的一般规律，从而为提出可能的防控手段提供理论依据。</p>
<p>通过实验和仿真研究，能够验证不同通风方案对烟雾扩散的控制效果，为改善居住环境提供技术支持；利用数值模拟，可以精确再现不同环境下烟雾的扩散过程，从而更直观地评估各类干预措施的有效性。这种方法不仅降低了研究成本，还能为制定更加科学、精确的室内空气污染防控策略提供强有力的支持。</p>
<p><img src="/images/smoke/media/image2.png" alt="图1.1：烟草烟雾中的有毒有害物质"></p>
<p><img src="/images/smoke/media/image3.jpeg" alt="图1.2：长期吸入二手烟对人体健康的危害"></p>
<h3 id="1-2-研究目标"><a href="#1-2-研究目标" class="headerlink" title="1.2 研究目标"></a>1.2 研究目标</h3><p>本研究旨在探讨室内封闭环境下烟雾的扩散特性，基于扩散方程等物理原理与数学物理方法对烟雾的扩散情况进行解析求解与数值模拟，重点分析烟雾的流动路径、扩散速率和浓度分布，以优化空气管理和烟雾控制策略。</p>
<p>在具体的研究过程中，我们主要采用特定尺寸的密封容器来模拟室内封闭环境以便于实验开展与现象观察；同时，我们的研究主要关注扩散过程中烟雾的扩散效果、扩散速度以及不同时刻的浓度分布这三个要素，并通过定量计算测量与定性观察现象相结合的方式，得到烟雾扩散浓度空间分布随时间变化的的一般数学物理规律，从而为设计室内烟雾浓度控制系统提供理论依据。</p>
<p><img src="/images/smoke/media/image4.png" alt="图1.3 研究区域示意图"></p>
<h2 id="2-理论分析求解"><a href="#2-理论分析求解" class="headerlink" title="2 理论分析求解"></a>2 理论分析求解</h2><h3 id="2-1-研究对象"><a href="#2-1-研究对象" class="headerlink" title="2.1 研究对象"></a>2.1 研究对象</h3><p>在实际研究过程中，为方便实验的开展，我们选择了粒径分布在0.1~10微米范围内的植物甘油（丙三醇）气雾作为研究对象，这也是电子烟烟雾的主要成分之一。之所以使用植物甘油气雾来代替香烟烟雾进行研究，主要出于以下考量：</p>
<ul>
<li><p>安全性：植物甘油为食品级材料，无健康与环境污染风险</p>
</li>
<li><p>可控性：植物甘油气雾生成过程可控，可进行定量化分析</p>
</li>
<li><p>易获取性：价格低廉，易于获取</p>
</li>
<li><p>可重复性：物质纯度高，化学性质稳定</p>
</li>
</ul>
<p>具体而言，植物甘油气雾具有以下几条显著的理化特性：</p>
<ul>
<li><p>无色无臭，有甜味，极易溶于水</p>
</li>
<li><p>密度（25℃）：1.26 g/cm^3</p>
</li>
<li><p>分子量： 92.09 g/mol</p>
</li>
<li><p>主要粒径属于典型气溶胶粒径范围</p>
</li>
<li><p>挥发性极低，以小颗粒悬浮于空气中</p>
</li>
</ul>
<p>在研究过程中进行这样的材料替换，具有如下的合理性：</p>
<ul>
<li><p>植物甘油气雾与香烟烟雾的气溶胶形成机制相同（蒸发-冷凝），二者在扩散和湍流行为上具有共性</p>
</li>
<li><p>二者粒径分布相似，具备相似的扩散动力学特征</p>
</li>
<li><p>二者在扩散过程中的视觉效果接近，便于追踪扩散行为</p>
</li>
</ul>
<p>在本研究的理论分析部分，重点关注植物甘油气雾的浓度（即单位体积中该种物质颗粒的质量）ρ(x, y, z, t)这一物理量在研究区域（长为x_0 = 40cm，宽为y_0 = 50cm，高为z_0 = 60cm的长方体规则区域）空间范围内的分布情况及其随时间的变化情况。</p>
<h3 id="2-2-数学物理方程的导出"><a href="#2-2-数学物理方程的导出" class="headerlink" title="2.2 数学物理方程的导出"></a>2.2 数学物理方程的导出</h3><p>针对烟雾扩散这一常见现象，有现成的实验规律——菲克定律（又称扩散定律）可以直接使用，其基本公式如下：</p>
<p>$$<br>\overrightarrow{q} = - D\nabla\rho<br>$$<br>其中：</p>
<ul>
<li>式中负号代表扩散转移的方向（浓度减小的方向）和浓度梯度（浓度增大的方向）相反；</li>
<li>D：扩散系数，与物质的种类以及环境温度有关；</li>
<li>∇ρ：浓度梯度，描述浓度不均匀分布的程度；</li>
<li>扩散流强度，即单位时间通过单位（横截）面积的质量，描述扩散运动的强度：</li>
</ul>
<p>$$<br>\overrightarrow{q} = \frac{dm_{g}}{dVdt}<br>$$<br>在本研究中，针对常温环境（25℃）下植物甘油气雾在空气中的扩散系数，可进一步通过Chapman-Enskog方程<br>$$<br>D_{AB} = \frac{0.00143 \times T^{1.75} \times \sqrt{\frac{1}{M_{A}} + \frac{1}{M_{B}}}}{P \times \sigma_{AB}^{2} \times \Omega_{D}}<br>$$<br>进行估算，代入空气的平均分子量28.97 g/mol和估计的分子直径0.5nm可计算得到此时的扩散系数约为：<br>$$<br>D = 0.0962{cm}^{2}/s<br>$$<br>由于我们的研究区域是一个长方体的三维规则区域，故在研究坐标系的选择上，以长方体区域的底端顶点为原点，长、宽、高延伸方向作为$x、y、z$正方向建立空间直角坐标系，原点在长方体上的对角顶点坐标为$(x_{0},\ y_{0},z_{0})$。针对三个不同方向，还可以进一步地给出菲克定律的分量形式：</p>
<p>$$<br>q_{x} = - D\frac{\partial\rho}{\partial x},\ \ q_{y} = - D\frac{\partial\rho}{\partial y},\ \ q_{z} = - D\frac{\partial\rho}{\partial z}<br>$$<br>接下来将基于菲克定律和质量守恒定律给出三维扩散方程，即本研究涉及的数学物理方程：</p>
<p>对于空间中任一点(x, y, z)附近的无穷小空间而言：该空间内浓度变化取决于穿过其表面的扩散流。</p>
<p>考虑单位时间内x方向的扩散流：</p>
<p>左表面流入流量<br>$$<br>\left. \ q_{x} \right|<em>{x}dydz<br>$$<br>右表面流出流量<br>$$<br>\left. \ q</em>{x} \right|<em>{x + dx}dydz<br>$$<br>故在单位时间内x方向净流入流量为<br>$$<br>\left. \ q</em>{x} \right|<em>{x}dydz - \left. \ q</em>{x} \right|_{x + dx}dydz<br>$$<br><img src="/images/smoke/media/image5.png" alt="图2.1 无穷小空间示意图"></p>
<p>由于取无穷小空间，dx足够小，于是有<br>$$<br>\frac{\partial q_{x}}{\partial x} = \frac{\left. \ q_{x} \right|<em>{x + dx} - \left. \ q</em>{x} \right|<em>{x}}{dx} 即 \left. \ q</em>{x} \right|<em>{x + dx} - \left. \ q</em>{x} \right|<em>{x} = \frac{\partial q</em>{x}}{\partial x}dx<br>$$<br>代入化简后可以得到单位时间内x方向净流入流量为<br>$$<br>D\frac{\partial^{2}\rho}{\partial x^{2}}dxdydz<br>$$<br>同理可得：单位时间内y方向净流入流量为<br>$$<br>D\frac{\partial^{2}\rho}{\partial y^{2}}dxdydz<br>$$<br>单位时间内z方向净流入流量为<br>$$<br>D\frac{\partial^{2}\rho}{\partial z^{2}}dxdydz<br>$$<br>在本研究中，出于解析求解可行性的考虑，在理论分析部分暂时仅考虑常压下有源无汇的理想场景（即仅在某固定坐标点(x_0, y_0, z_0)处有一恒定扩散源，其强度（单位时间内单位体积产生的气体质量）为F(x,y, z,t)），而在后续数值求解与仿真模拟时才会把负压源视作汇的产生原因从而进一步补充对流的相关条件（对流项）。</p>
<p>在此条件下，基于质量守恒定律，单位时间在该无穷小空间内增加的气体质量等于单位时间内净流入的气体质量与扩散源产生的气体质量，其中扩散源产生的气体质量F(x,y, z,t)仅在(x_0, y_0, z_0)处有恒定值F_0而在其余空间各处均为0。于是列出并化简得到如下三维扩散方程（相比通用控制方程暂时不考虑对流项）：</p>
<p>$$<br>\frac{\partial\rho}{\partial t} - D\left( \frac{\partial^{2}\rho}{\partial x^{2}} + \frac{\partial^{2}\rho}{\partial y^{2}} + \frac{\partial^{2}\rho}{\partial z^{2}} \right) = \rho_{t} - D\nabla^{2}\rho = 0, 0 &lt; x &lt; x_{0}, 0 &lt; y &lt; y_{0}, 0 &lt; z &lt; z_{0}<br>$$<br>其中：</p>
<ul>
<li><p>浓度的时间增长率（关于时间t的偏导数），即单位时间该无穷小空间内增加的气体质量:<br>$$<br>\frac{\partial\rho}{\partial t}<br>$$</p>
</li>
<li><p>扩散系数D仅与物质种类和温度有关，若研究某种特定气体在理想的均匀介质（温度在空间各处保持一致且不随时间变化）条件下的扩散，该系数值为常数；反之则其也应表示为关于空间坐标与时间的函数D(x, y, z, t)（在确定气体类型时仅与温度的分布函数T(x, y, z, t)有关）。</p>
</li>
</ul>
<h3 id="2-3-初始条件与边界条件"><a href="#2-3-初始条件与边界条件" class="headerlink" title="2.3 初始条件与边界条件"></a>2.3 初始条件与边界条件</h3><p>该问题的初始条件是显然的：研究区域空间内在初始状态（t = 0）没有该种烟雾气体分布，且在某固定点处有一恒定扩散源，始终以恒定的扩散强度（单位时间内单位体积产生的气体质量）产生气体并向区域空间内扩散。将这样的初始条件写成数学表达式的形式：</p>
<p>$$<br>\rho(x,y,\ z,0) = F_{0}\delta(x - \frac{x_{0}}{2})\delta(y - \ \frac{y_{0}}{2})\delta(z - 0)<br>$$<br>式中F_0表示在固定坐标端点<br>$$<br>\left( \frac{x_{0}}{2},\ \frac{y_{0}}{2},\ 0 \right)<br>$$<br>处的恒定扩散源的扩散强度。结合实验时采用的实验装置，参考其技术文档可知，其值约为5g/cm^3。</p>
<p>关于边界条件，针对我们所研究的扩散问题，通常采用Dirichlet边界条件：<br>$$<br>\frac{\partial\rho}{\partial n} = 0<br>$$<br>显然这是一个齐次边界条件，也是一个典型的第二类边界条件。为方便后续求解处理，针对我们所建立的空间直角坐标系，可以将其进一步写成分量形式：</p>
<p>$$<br>\left{ \begin{array}{r}<br>\left. \ \frac{\partial\rho}{\partial x} \right|<em>{x = 0} = \left. \ \frac{\partial\rho}{\partial x} \right|</em>{x = x_{0}} = 0 \<br>\left. \ \frac{\partial\rho}{\partial y} \right|<em>{y = 0} = \left. \ \frac{\partial\rho}{\partial y} \right|</em>{y = y_{0}} = 0 \<br>\left. \ \frac{\partial\rho}{\partial z} \right|<em>{z = 0} = \left. \ \frac{\partial\rho}{\partial z} \right|</em>{z = z_{0}} = 0<br>\end{array} \right.<br>$$</p>
<h3 id="2-4-数学物理方程求解"><a href="#2-4-数学物理方程求解" class="headerlink" title="2.4 数学物理方程求解"></a>2.4 数学物理方程求解</h3><p>针对2.2节提出的数学物理方程，可以通过分离变数法，结合2.3节给出的边界条件与初始条件，得到本征值问题的解和本征值的取值，并将多个本征值问题的解依次相乘得到本征解，再对所有可能的本征值求和，即可得到级数解。更进一步的，通过2.3节给出的初始条件，还可以对于级数解中的常数系数进行进一步确定，从而得到该数学物理方程完整的级数解解析表达式。</p>
<h4 id="2-4-1-变量分离"><a href="#2-4-1-变量分离" class="headerlink" title="2.4.1 变量分离"></a>2.4.1 变量分离</h4><p>对于扩散的烟雾而言，虽然其浓度会在空间中的不同位置随时间而变化，但时间与空间这两者在浓度瞬态变化的过程中实际上可以看作是相互独立的，即浓度随时间变化的速率ρ_t与浓度在空间分布中的变化速率∇ρ无关。</p>
<p>基于这样的假设，可以对烟雾浓度函数ρ(x, y, z, t)做如下的变量分离：</p>
<p>$$<br>\rho(x, y, z, t) = v(x,y,z) \bullet T(t)<br>$$</p>
<ul>
<li><p>空间部分v(x,y,z)：描述烟雾浓度在三维空间中的分布，可以认为它与时间无关，或者说在某个时刻，密度的空间分布是静态的；</p>
</li>
<li><p>时间部分T(t)：描述烟雾密度随时间的变化，通常假设它是一个仅依赖于时间的函数，反映了扩散过程中气体密度随时间的衰减或增长。</p>
</li>
</ul>
<p>在该式中，自变数x, y, z只出现于v之中，自变数t只出现于T之中，烟雾浓度的一般表示式具有分离变数的形式。</p>
<p>更进一步的，由于在空间中x、y、 z方向上的烟雾浓度变化情况也彼此独立，还可以对于空间部分v(x,y,z)做进一步的变量分离，即：</p>
<p>$$<br>v(x,y,z) = X\left( x) \bullet Y(y) \bullet Z(z \right)<br>$$<br>其中，X(x)为烟雾浓度在空间中x方向的分布情况，Y(y)为烟雾浓度在空间中y方向的分布情况，Z(z)为烟雾浓度在空间中z方向的分布情况。</p>
<h4 id="2-4-2-常微分方程与本征值问题"><a href="#2-4-2-常微分方程与本征值问题" class="headerlink" title="2.4.2 常微分方程与本征值问题"></a>2.4.2 常微分方程与本征值问题</h4><p>显然三维扩散方程<br>$$<br>\rho_{t} - D\nabla^{2}\rho = 0<br>$$<br>为齐次方程，对于该齐次方程，可以将分离变量后的烟雾浓度代入三维扩散方程中，化简得到如下式子：</p>
<p>$$<br>T_{t}(t)v(x,y,z) = DT(t)\nabla^{2}v(x,y,z)，即\frac{T_{t}(t)}{DT(t)} = \frac{\nabla^{2}v(x,y,z)}{v(x,y,z)} = \frac{X^{‘’}(x)}{X(x)} = \frac{Y^{‘’}(y)}{Y(y)} = \frac{Z^{‘’}(z)}{Z(z)}<br>$$<br>其中，左边均为关于时间t的函数，与坐标位置x, y, z无关；右边则是关于坐标位置x, y, z的函数，与时间t无关。两边相等是显然不可能的，除非两边实际上是同一个常数，不妨将其记为-λ，于是有：</p>
<p>$$<br>\frac{T_{t}}{DT} = \frac{X^{‘’}}{X} = \frac{Y^{‘’}}{Y} = \frac{Z^{‘’}}{Z} = - \lambda<br>$$<br>将该式关于空间部分X(x)、Y(y)、Z(z)与时间部分T(t)分别分离，可以得到关于X、Y、Z以及关于T的一系列常微分方程：</p>
<p>$$<br>\left{ \begin{array}{r}<br>T^{‘} + \lambda DT = 0 \<br>\nabla^{2}v + \lambda v = 0<br>\end{array} \right.\  即 \left{ \begin{array}{r}<br>T^{‘} + \lambda DT = 0 \<br>X^{‘’} + \lambda X = 0 \<br>Y^{‘’} + \lambda Y = 0 \<br>Z^{‘’} + \lambda Z = 0<br>\end{array} \right.<br>$$<br>考虑2.3节给出的齐次边界条件即Dirichlet边界条件：边界处<br>$$<br>\frac{\partial\rho}{\partial n} = 0<br>$$<br>有：</p>
<p>$$<br>\left{ \begin{array}{r}<br>X^{‘}(0) = X^{‘}\left( x_{0} \right) = 0 \<br>Y^{‘}(0) = Y^{‘}\left( y_{0} \right) = 0 \<br>Z^{‘}(0) = Z^{‘}\left( z_{0} \right) = 0<br>\end{array} \right.\<br>$$<br>以上常微分方程与齐次边界条件共同构成了本征值问题。</p>
<h4 id="2-4-3-本征值问题求解"><a href="#2-4-3-本征值问题求解" class="headerlink" title="2.4.3 本征值问题求解"></a>2.4.3 本征值问题求解</h4><p>首先，对于第一个方程<br>$$<br>\mathbf{T}^{‘} + \mathbf{\lambda DT} = \mathbf{0}<br>$$<br>而言，该方程为一阶常微分方程，可直接进行求解，结合初始条件<br>$$<br>\rho(x,y,\ z,0) = F_{0}\delta(x - \frac{x_{0}}{2})\delta(y - \ \frac{y_{0}}{2})\delta(z - 0)<br>$$<br>可得到：</p>
<p>$$<br>\mathbf{T}\left( \mathbf{t} \right) = \mathbf{F}_{\mathbf{0}}(\mathbf{1} - \mathbb{e}^{- \mathbf{\lambda Dt}})（C为某常数）<br>$$<br>其物理意义上的合理性如下：</p>
<ul>
<li><p>初始时刻t = 0：<br>$$<br>T(0) = F_{0}\left( 1 - \mathbb{e}^{- 0} \right) = 0<br>$$<br>即空间内在初始状态下（t = 0）没有该种烟雾气体分布，与初始条件吻合；</p>
</li>
<li><p>稳定时刻t-&gt;∞：<br>$$<br>T(\infty) = F_{0}\left( 1 - \mathbb{e}^{- \infty} \right) = F_{0}<br>$$<br>即浓度达到稳定值F_0，与扩散物理过程实际现象一致；</p>
</li>
<li><p>时间项指数因子-λDt决定了扩散速度，其中D为扩散系数，越大扩散越快，λ为空间模态本征值，模态越高衰减越快，这也符合实际物理扩散过程。</p>
</li>
</ul>
<p>而针对后面三个方程，与对应的齐次边界条件形成了三组本征值问题，由于其形式完全一致，下面将以其中一组本征值问题<br>$$<br>\left{ \begin{array}{r}<br>X^{‘’} + \lambda X = 0 \<br>X^{‘}(0) = X^{‘}\left( x_{0} \right) = 0<br>\end{array} \right.\<br>$$<br>为例，利用幂级数法求得其本征解：</p>
<p>选定点x_1 = 0，显然常微分方程<br>$$<br>X^{‘’} + \lambda X = 0<br>$$<br>的系数函数在该点领域内是解析的，因此该点为方程<br>$$<br>X^{‘’} + \lambda X = 0<br>$$<br>的常点。针对常点x_1，可以给出X(x)在该点邻域上的泰勒级数形式：</p>
<p>$$<br>X(x) = \sum_{k = 0}^{\infty}{a_{k}{(x - x_{1})}^{k}}<br>$$<br>将其代入常微分方程可得：<br>$$<br>\sum_{k = 0}^{\infty}{\lbrack(k + 2)(k + 1)a_{k + 2} + \lambda}a_{k}\rbrack{(x - x_{1})}^{k} = 0<br>$$<br>于是有：<br>$$<br>(k + 2)(k + 1)a_{k + 2} + {\lambda a}<em>{k} = 0,\ k = 0,1,2\ldots<br>$$<br>可进一步得到系数递推公式：<br>$$<br>a</em>{k + 2} = \frac{- \lambda}{(k + 2)(k + 1)}a_{k}<br>$$<br>推得：<br>$$<br>\left{ \begin{array}{r}<br>a_{2k} = \frac{\lambda^{k}{( - 1)}^{k}}{(2k)!}a_{0} \<br>a_{2k + 1} = \frac{\lambda^{k}{( - 1)}^{k}}{(2k + 1)!}a_{1}<br>\end{array} \right.\ ,\ k = 1,2,3\ldots<br>$$<br>因此可得到常微分方程<br>$$<br>X^{‘’} + \lambda X = 0<br>$$<br>的解：</p>
<p>$$<br>X(x) = a_{0}X_{0}(x) + a_{1}X_{1}(x)<br>$$<br>其中：</p>
<p>$$<br>X_{0}(x) = 1 + \frac{- \lambda}{2!}x^{2} + \frac{\lambda^{2}}{4!}x^{4} + \ldots + \frac{\lambda^{k}( - 1)^{k}}{(2k)!}x^{2k} + \ldots = \sum_{k = 0}^{\infty}{\frac{\lambda^{k}( - 1)^{k}}{(2k)!}x^{2k}} = \cos(\sqrt{\lambda}x)<br>$$</p>
<p>$$<br>X_{1}(x) = x + \frac{- \lambda}{3!}x^{3} + \frac{\lambda^{2}}{5!}x^{5} + \ldots + \frac{\lambda^{k}( - 1)^{k}}{(2k + 1)!}x^{2k + 1} + \ldots = \sum_{k = 0}^{\infty}{\frac{\lambda^{k}( - 1)^{k}}{(2k + 1)!}x^{2k + 1}} = \frac{\sin(\sqrt{\lambda}x)}{\sqrt{\lambda}}<br>$$</p>
<p>此时的收敛半径为<br>$$<br>R = \lim_{n \rightarrow \infty}\left| \frac{a_{n}}{a_{n + 2}} \right| = \lim_{n \rightarrow \infty}\left| \frac{(n + 2)(n + 1)}{- \lambda} \right| = \infty<br>$$<br>即级数解X_0(x)$和X_1(x)在复数域上始终收敛。X_0(x)仅含x的偶次幂，为偶函数；X_1(x)仅含x的奇次幂，为奇函数。同时，式中含有sqrt（λ）项，这要求λ≥0。</p>
<p>于是有：<br>$$<br>X^{‘}(x) = - a_{0}\sqrt{\lambda}\sin(\sqrt{\lambda}x) + a_{1}\cos(\sqrt{\lambda}x)<br>$$<br>将齐次边界条件<br>$$<br>X^{‘}(0) = X^{‘}\left( x_{0} \right) = 0<br>$$<br>代入可得:</p>
<p>$$<br>\left{ \begin{array}{r}<br>a_{1} = 0 \a_{0}\sqrt{\lambda}\sin(\sqrt{\lambda}x_{0}) + a_{1}\cos(\sqrt{\lambda}x_{0}) = 0<br>\end{array} \right.\<br>$$<br>显然有a_1= 0，但对于a_0而言，如果a_0也为0，这样的解是没有意义的；而要使得a_0不为零，就要求<br>$$<br>\lambda = 0或\sin\left( \sqrt{\lambda}x_{0} \right) = 0<br>$$<br>恒成立，这意味着<br>$$<br>\sqrt{\lambda}x_{0} = k\pi<br>$$<br>由于<br>$$<br>x_{0} &gt; 0、\sqrt{\lambda} \geq 0<br>$$<br>于是k的可取值为<br>$$<br>k = 0,1,2,\ldots<br>$$<br>在这样的条件下，由于x_0与π均为定值，本征值λ则有常数k唯一确定，此时不妨将常数k视为新的本征值。于是可得到该本征值问题的本征解：</p>
<p>$$<br>X(x) = a_{0}\cos\left( \sqrt{\lambda}x \right) = a_{0x}\cos\left( \frac{k\pi}{x_{0}}x \right)，k = 0,1,2,\ldots<br>$$<br>与此类似的，另外两个本征值问题的本征解为：</p>
<p>$$<br>Y(y) = a_{0y}\cos\left( \frac{m\pi}{y_{0}}y \right)，m = 0,1,2,\ldots<br>$$</p>
<p>$$<br>Z(z) = a_{0z}\cos\left( \frac{n\pi}{z_{0}}z \right)，n = 0,1,2,\ldots<br>$$</p>
<p>值得注意的是，三个本征值问题中出现了三个新的本征值k、m、n，他们分别与时间部分涉及到的本征值λ有定量关系，但是当他们取不同值时，原本征值λ也会有不同的取值，即本质上有三个不同的本征值k、m、n取代了原先的本征值λ。</p>
<p>基于以上本征值问题的解和本征值的取值，可以将其各部分相乘得到本征解，再对本征解按照所有可能的本征值求和，即可得到烟雾浓度的级数解：</p>
<p>$$<br>\rho(x,\ y,\ z,\ t) = \sum_{k = 0}^{\infty}{\sum_{m = 0}^{\infty}{\sum_{n = 0}^{\infty}{a_{0x}a_{0y}a_{0z}F_{0}\cos\left( \frac{k\pi}{x_{0}}x \right)\cos\left( \frac{m\pi}{y_{0}}y \right)\cos\left( \frac{n\pi}{z_{0}}z \right)}}}(1 - \mathbb{e}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}t})<br>$$<br>由于式中a_0x、a_0y、a_0z、F_0均为常数（可由初始条件<br>$$<br>\rho(x,y,\ z,0) = F_{0}\delta(x - \frac{x_{0}}{2})\delta(y - \ \frac{y_{0}}{2})\delta(z - 0)<br>$$<br>进一步确定），不妨将其替换为某一常数<br>$$<br>A = a_{0x}a_{0y}a_{0z}F_{0}<br>$$<br>以便于后续计算，即此时可得到级数解为：<br>$$<br>\rho(x,\ y,\ z,\ t) = \sum_{k = 0}^{\infty}{\sum_{m = 0}^{\infty}{\sum_{n = 0}^{\infty}{A\cos\left( \frac{k\pi}{x_{0}}x \right)\cos\left( \frac{m\pi}{y_{0}}y \right)\cos\left( \frac{n\pi}{z_{0}}z \right)}}}(1 - \mathbb{e}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}t})<br>$$</p>
<h4 id="2-4-4-级数解常数系数的确定"><a href="#2-4-4-级数解常数系数的确定" class="headerlink" title="2.4.4 级数解常数系数的确定"></a>2.4.4 级数解常数系数的确定</h4><p>需要指出，函数<br>$$<br>\varnothing_{kmn} = \cos\left( \frac{k\pi}{x_{0}}x \right)\cos\left( \frac{m\pi}{y_{0}}y \right)\cos\left( \frac{n\pi}{z_{0}}z \right)<br>$$<br>是定义在长方体区域<br>$$<br>x \in \left\lbrack 0,x_{0} \right\rbrack,\ \ y \in \left\lbrack 0,y_{0} \right\rbrack,z \in \lbrack 0,z_{0}\rbrack<br>$$<br>上的一组正交基函数，其满足如下正交性与归一化条件：</p>
<p>$$<br>\int_{0}^{z_{0}}{\int_{0}^{y_{0}}{\int_{0}^{x_{0}}{\varnothing_{kmn}\varnothing_{k^{‘}m^{‘}n^{‘}}dxdydz}}} = \left{ \begin{array}{r}<br>x_{0}y_{0}z_{0},\ (k,m,n) = (k^{‘},m^{‘},n^{‘}) \<br>0,(k,m,n) \neq (k^{‘},m^{‘},n^{‘})<br>\end{array} \right.\<br>$$<br>对于级数解<br>$$<br>\rho(x,\ y,\ z,\ t) = \sum_{k = 0}^{\infty}{\sum_{m = 0}^{\infty}{\sum_{n = 0}^{\infty}{A\cos\left( \frac{k\pi}{x_{0}}x \right)\cos\left( \frac{m\pi}{y_{0}}y \right)\cos\left( \frac{n\pi}{z_{0}}z \right)}}}\mathbb{e}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}t} = \sum_{k = 0}^{\infty}{\sum_{m = 0}^{\infty}{\sum_{n = 0}^{\infty}{A\varnothing_{kmn}}}}{(1 - \mathbb{e}}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}t})<br>$$<br>而言，将两侧同时与Φ_k’m’n’相乘，并在区域内积分：</p>
<p>$$<br>\int_{0}^{z_{0}}{\int_{0}^{y_{0}}{\int_{0}^{x_{0}}{\rho(x,\ y,\ z,\ t)\varnothing_{k^{‘}m^{‘}n^{‘}}dxdydz}}} = \int_{0}^{z_{0}}{\int_{0}^{y_{0}}{\int_{0}^{x_{0}}{(\sum_{k = 0}^{\infty}{\sum_{m = 0}^{\infty}{\sum_{n = 0}^{\infty}{A\varnothing_{kmn}}}}\mathbb{e}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}t})\varnothing_{k^{‘}m^{‘}n^{‘}}dxdydz}}}<br>$$<br>利用正交性条件，上述式子右边仅保留(k,m,n) = (k’, m’, n’)的项，其余项积分为0：</p>
<p>$$<br>\int_{0}^{z_{0}}{\int_{0}^{y_{0}}{\int_{0}^{x_{0}}{\rho(x,\ y,\ z,\ t)\varnothing_{kmn}dxdydz}}} = A(1 - \mathbb{e}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}t})x_{0}y_{0}z_{0}<br>$$<br>代入初始条件<br>$$<br>\rho(x,y,\ z,0) = F_{0}\delta(x - \frac{x_{0}}{2})\delta(y - \ \frac{y_{0}}{2})\delta(z - 0)<br>$$<br>即可在t = 0处解出系数<br>$$<br>A = \frac{\int_{0}^{z_{0}}{\int_{0}^{y_{0}}{\int_{0}^{x_{0}}{\rho(x,\ y,\ z,\ t)\varnothing_{kmn}dxdydz}}}}{\left( 1 - \mathbb{e}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}t} \right)x_{0}y_{0}z_{0}}<br>$$<br>由于分子分母在t = 0处均为0，故利用洛必达法则上下对时间$t$求导得：</p>
<p>$$<br>\rho_{t} = T^{‘} = \mathbb{e}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)Dt}（忽略系数）<br>$$</p>
<p>$$<br>A = \frac{\left. \rho_{t} \right|<em>{t = 0}\int</em>{0}^{z_{0}}{\int_{0}^{y_{0}}{\int_{0}^{x_{0}}{\rho(x, y, z, 0)\varnothing_{kmn}dxdydz}}}}{\left( {\left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}\mathbb{e}}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}t} \right)x_{0}y_{0}z_{0}}<br>= \frac{F_{0}}{D\left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)\pi^{2}x_{0}y_{0}z_{0}}\varnothing_{kmn}\left( \frac{x_{0}}{2},\frac{y_{0}}{2},0 \right)<br>= \frac{F_{0}}{D\left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)\pi^{2}x_{0}y_{0}z_{0}}\cos\left( \frac{k\pi}{x_{0}}\frac{x_{0}}{2} \right)\cos\left( \frac{m\pi}{y_{0}}\frac{y_{0}}{2} \right)\cos\left( \frac{n\pi}{z_{0}}0  \right) = \frac{F_{0}}{D\left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)\pi^{2}x_{0}y_{0}z_{0}}\cos\left( \frac{k\pi}{2} \right)\cos\left( \frac{m\pi}{2} \right)，其值随k,m,n的变化而变化<br>$$</p>
<p>最后，将其代入2.4.3节解得的级数解，可以最终得到植物甘油气雾浓度的解析表达式为：</p>
<p>$$<br>\rho(x,\ y,\ z,\ t) = \frac{F_{0}}{Dx_{0}y_{0}z_{0}}\sum_{k = 0}^{\infty}{\sum_{m = 0}^{\infty}{\sum_{n = 0}^{\infty}{\frac{1}{\left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)\pi^{2}}\cos\left( \frac{k\pi}{2} \right)\cos\left( \frac{m\pi}{2} \right)\cos\left( \frac{k\pi}{x_{0}}x \right)\cos\left( \frac{m\pi}{y_{0}}y \right)\cos\left( \frac{n\pi}{z_{0}}z \right)}}}(1 - \mathbb{e}^{- \left( \frac{k^{2}}{x_{0}^{2}} + \frac{m^{2}}{y_{0}^{2}} + \frac{n^{2}}{z_{0}^{2}} \right)D\pi^{2}t})<br>$$</p>
<h3 id="2-5-基于MATLAB的级数解可视化"><a href="#2-5-基于MATLAB的级数解可视化" class="headerlink" title="2.5 基于MATLAB的级数解可视化"></a>2.5 基于MATLAB的级数解可视化</h3><p>基于上述求解过程得到的烟雾浓度解析表达式，编写了对应的MATLAB程序，将不同时刻烟雾浓度在空间内各点处的分布情况进行计算与可视化。值得注意的是，由于级数解本质是无限项求和，而在MATLAB程序实际计算中需要指定求和项数，在此综合考虑计算精度与算力需求，选取$k,m,n$三个本征值各10项进行计算与可视化；除此之外，为与实际实验相对应，计算的扩散时间设置为30秒，同时为直观观察扩散过程中烟雾浓度随时间的变化，设置计算步长为1秒。</p>
<p>代入相应的数值并运行程序可以得到如下的可视化结果（代码详见附件1）：</p>
<p><img src="/images/smoke/media/image6.png" alt="图2.2 扩散时间分别为0s、10s、20s、30s时的解析求解可视化结果"><br><img src="/images/smoke/media/image7.png" alt="图2.2 扩散时间分别为0s、10s、20s、30s时的解析求解可视化结果"></p>
<p><img src="/images/smoke/media/image8.png" alt="图2.2 扩散时间分别为0s、10s、20s、30s时的解析求解可视化结果"><img src="/images/smoke/media/image9.png" alt="图2.2 扩散时间分别为0s、10s、20s、30s时的解析求解可视化结果"></p>
<p>可以看到，随着时间的推移，烟雾的可见范围越来越大（设定可见浓度为0.3mg/cm^3），且浓度从扩散中心点向四周呈递减趋势，这与我们的生活经验高度一致；在扩散时间为0s（即扩散未开始）时，空间区域内烟雾浓度均为零，这也与我们设定的初始条件相一致。以上事实初步验证了理论推导结果的正确性。</p>
<p>除此之外，为与后续的实验过程相对应，还记录了特定测量点(x_0/2, 0, z_0)处的烟雾浓度随时间的变化情况，并根据换算公式<br>$$<br>ppm = \frac{C \times 10^{6}}{\rho}<br>$$<br>将原有的气雾质量浓度C（单位：g/cm^3）换算为体积比ppm（百万分之一），得到的结果如下：</p>
<p><img src="/images/smoke/media/image10.png" alt="图2.3 测量点(x_0/2, 0, z_0)处的烟雾浓度随时间变化情况（单位：ppm）"></p>
<p>可以看到，由于该处离扩散中心点较远，此处烟雾浓度大概在扩散时间20s后达到基本稳定，稳定时的烟雾浓度值约为380ppm。</p>
<h2 id="3-数值仿真模拟"><a href="#3-数值仿真模拟" class="headerlink" title="3 数值仿真模拟"></a>3 数值仿真模拟</h2><h3 id="3-1-数值分析方法：有限元法"><a href="#3-1-数值分析方法：有限元法" class="headerlink" title="3.1 数值分析方法：有限元法"></a>3.1 数值分析方法：有限元法</h3><p>由于严格的解析求解对于方程的复杂度以及初始条件与边界条件等都具有一定的要求，第2章所涉及到的理论分析也仅仅是围绕简化后的烟雾扩散问题展开。相比于真实的场景，这样的理论分析忽略了很多现实环境中的复杂变量（比如对流）。为使得我们的研究更具有实用价值，我们需要对于更加泛化的数学物理模型，采用数值求解的方法去模拟真实的扩散情况。</p>
<p>在这一部分，我们主要考虑到，2.3节提到的初始条件中烟雾源处视为单点并采用δ函数进行数学表示的做法过于理想化。与实验相对应的，我们采用的烟雾发生器的烟雾出口也不仅仅是一个单点，而是一个半径约为0.6cm的圆面。因此，我们希望通过有限元这一数值求解方法，对于初始条件迭代后的问题进行数值模拟分析。</p>
<p><img src="/images/smoke/media/image11.jpeg" alt="图3.1 烟雾发生器烟雾出口孔径测量"></p>
<p>图3.1 烟雾发生器烟雾出口孔径测量</p>
<p>基于有限元法的基本思想，我们主要按照如下的方法步骤进行数值分析：</p>
<p><img src="/images/smoke/media/image12.png" alt="图3.2 有限元法数值分析步骤"></p>
<p>首先进行区域剖分，将长方体研究区域Ω划分为有限个小单元，用于构建离散有限元模型。在划分单元时，采用长方体网格剖分方式，将区域划分为n_x * n_y * n_z个小立方体。每个小立方体单元有8个顶点，因此共有N = (n_x+1) * (n_y+1) * (n_z+1)个节点。对这些节点按列优先顺序进行编号，依次为1、2、…、N，同时对于各单元按体积分块顺序编号，编号为1、2、…、E。</p>
<p><img src="/images/smoke/media/image13.png" alt="图3.3 区域剖分示意图"></p>
<p>接下来需要选择合适的单元基函数以表示单元内的浓度分布。在此我们选取基函数Φ_ i(x,y,z)近似表示浓度：<br>$$<br>\rho(x,\ y,\ z,\ t) \approx \sum_{i = 1}^{N}{c_{i}(t)\phi_{i}(x,y,z)}（c_{i}(t)表示节点i处的浓度值）<br>$$<br>并采用线性插值基函数（梯形单元），即单元内任意一点的浓度由8个顶点的浓度值线性插值（符号根据顶点位置的坐标取正或负）：<br>$$<br>\phi_{i}(x,y,z) = \frac{1}{8}(1 \pm x)(1 \pm y)(1 \pm z),\ i = 1,2,\ldots,8<br>$$<br>值得注意的是，在单元内，基函数在对应节点取值为1，其余节点取值为0，同时基函数也满足局部支撑性，即在单元外为零。</p>
<p>基于划分好的单元和选取的单元基函数，可以写出对应的单元积分表达式。通过对单元内的质量矩阵、刚度矩阵和源项向量进行积分，单元积分表达式应使得方程余量最小、本质边界条件余量最小、自然边界条件余量最小。将扩散方程乘以任意测试函数Φ_j(x,y,z)后，对区域Ω积分即可得到单元积分表达式：</p>
<p>$$<br>\int_{\Omega}^{}{\phi_{j}\frac{\partial\rho}{\partial t}\mathbb{d}\Omega} = D\int_{\Omega}^{}{\phi_{j}\nabla^{2}\rho\mathbb{d}\Omega} + \int_{\Omega}^{}{\phi_{j}F\mathbb{d}\Omega}<br>$$<br>该表达式中共有三项：</p>
<ul>
<li><p>时间导数项（差分离散）：<br>$$<br>\int_{\Omega}^{}{\phi_{j}\frac{\partial\rho}{\partial t}\mathbb{d}\Omega} \approx \int_{\Omega}^{}{\phi_{j}\frac{\rho^{n + 1} - \rho^{n}}{\mathrm{\Delta}t}\mathbb{d}\Omega}<br>$$</p>
</li>
<li><p>空间扩散项：通过分部积分，将扩散项转化为：</p>
</li>
</ul>
<p>$$<br>\int_{\Omega}^{}{\phi_{j}\nabla^{2}\rho\mathbb{d}\Omega} = - \int_{\Omega}^{}{\nabla\phi_{j}\nabla\rho d\Omega} + \int_{\partial\Omega}^{}{\phi_{j}\nabla\rho \bullet \overrightarrow{n}dS}<br>$$</p>
<p>在齐次边界条件下，边界项为0。</p>
<ul>
<li>离散形式：代入插值函数近似：</li>
</ul>
<p>$$<br>\int_{\Omega}^{}{\phi_{j}\frac{\rho^{n + 1} - \rho^{n}}{\mathrm{\Delta}t}\mathbb{d}\Omega} = D\int_{\Omega}^{}{\nabla\phi_{j}\nabla(\sum_{i = 1}^{N}{C_{i}^{n + 1}\phi_{i}})\mathbb{d}\Omega} + \int_{\Omega}^{}{\phi_{j}F\mathbb{d}\Omega}<br>$$</p>
<p>基于列出的单元积分表达式，可以对各个单元进行分析，计算其对应的质量矩阵、刚度矩阵与源项向量，从而建立有限元方程。将离散化方程写为矩阵形式：</p>
<p>$$<br>M\frac{c^{n + 1} - c^{n}}{\Delta t} + Kc^{n + 1} = F<br>$$<br>其中：</p>
<ul>
<li><p>质量矩阵：<br>$$<br>M_{\mathbb{i}j} = \int_{\Omega}^{}{\phi_{i}\phi_{j}d\Omega}<br>$$</p>
</li>
<li><p>刚度矩阵：<br>$$<br>K_{\mathbb{i}j} = D\int_{\Omega}^{}{\nabla\phi_{i}\nabla\phi_{j}d\Omega}<br>$$</p>
</li>
<li><p>源项向量：<br>$$<br>F_{\mathbb{i}} = \int_{\Omega}^{}{F\phi_{i}d\Omega}<br>$$</p>
</li>
</ul>
<p>进而可以将单元积分表达式更新为有限元方程：</p>
<p>$$<br>(M + \Delta tk)c^{n + 1} = Mc^{n} + \Delta tF<br>$$<br>将每个单元映射到标准立方体单元（边长为2，中心为原点），可以根据基函数梯度<br>$$<br>\nabla\phi_{i} = (\frac{\partial\phi_{i}}{\partial x},\ \frac{\partial\phi_{i}}{\partial y},\ \frac{\partial\phi_{i}}{\partial z})<br>$$<br>在这些标准单元上使用高斯积分进行质量矩阵和刚度矩阵的计算：</p>
<p>$$<br>M_{\mathbb{i}j}^{(e)} = \int_{\Omega_{e}}^{}{\phi_{i}\phi_{j}d\Omega}<br>$$</p>
<p>$$<br>K_{\mathbb{i}j}^{(e)} = D\int_{\Omega_{e}}^{}{\nabla\phi_{i}\nabla\phi_{j}d\Omega}<br>$$</p>
<p>将源项向量<br>$$<br>F_{\mathbb{i}}^{(e)} = \int_{\Omega_{e}}^{}{F\phi_{i}d\Omega}<br>$$<br>离散化为节点的平均值后，也可以通过插值基函数对其进行积分。</p>
<p>完成单元分析后，可以将单元矩阵的局部节点编号1、2、…、8映射到总体矩阵的全局节点编号，并在每个单元中将其局部质量矩阵M^e、刚度矩阵K^e和源项向量F^e加入到总体矩阵M、K和向量F中，进行总体合成。</p>
<p>在对于总体有限元方程进行求解之前，还需要在总体矩阵方程中施加边界条件。在此我们采用消行修正法：对于齐次边界条件，将其带入总体有限元方程，并将边界上的节点浓度固定置零，同时修改总体矩阵对应行列为单位矩阵，右端项置零；对于非齐次边界条件（即初始条件），在边界节点区域（以扩散源中心（x_0/2, y_0/2, 0）为圆心，半径为0.6cm的圆面）中给定固定浓度值F_0，并对应调整右端向量F（已在单元积分中满足）：<br>$$<br>F_{i} \Leftarrow F_{i} - k_{ij}F_{0}<br>$$<br>最后，对于总体有限元线性方程</p>
<p>$$<br>(M + \Delta tk)c^{n + 1} = Mc^{n} + \Delta tF<br>$$<br>可以采用迭代方法进行求解：</p>
<ul>
<li><p>初始条件：<br>$$<br>c^{0} = 0<br>$$</p>
</li>
<li><p>时间步进：对于每个时间步，首先计算右端向量<br>$$<br>Mc^{n} + \Delta tF<br>$$<br>再采用稀疏矩阵求解器计算下一步的浓度<br>$$<br>c^{n + 1}<br>$$</p>
</li>
<li><p>迭代终止：当时间达到设定终止时间T时，终止求解过程。</p>
</li>
</ul>
<h3 id="3-2-基于Python的有限元数值仿真"><a href="#3-2-基于Python的有限元数值仿真" class="headerlink" title="3.2 基于Python的有限元数值仿真"></a>3.2 基于Python的有限元数值仿真</h3><p>基于3.1节提出的有限元分析方法，利用Python中的MeshPy依赖库进行网格生成，并编写对应Python代码进行有限元数值仿真的计算与可视化。出于程序运行的稳定性等方面考虑，数值计算时仅选取原长方体区域的四分之一（高度不变，长宽各取一半，坐标原点即为扩散源中心）作为扩散区域。</p>
<p>运行程序（代码详见附录2），得到以下数值仿真结果：</p>
<p><img src="/images/smoke/media/image14.png" alt="图3.4 扩散时间分别为0s、10s、20s、30s时，x = x_0/2处垂直截面内的有限元仿真结果"><br><img src="/images/smoke/media/image15.png" alt="图3.4 扩散时间分别为0s、10s、20s、30s时，x = x_0/2处垂直截面内的有限元仿真结果"></p>
<p><img src="/images/smoke/media/image16.png" alt="图3.4 扩散时间分别为0s、10s、20s、30s时，x = x_0/2处垂直截面内的有限元仿真结果"><img src="/images/smoke/media/image17.png" alt="图3.4 扩散时间分别为0s、10s、20s、30s时，x = x_0/2处垂直截面内的有限元仿真结果"></p>
<p><img src="/images/smoke/media/image18.png" alt="图3.5 扩散时间分别为0s、10s、20s、30s时，原长方体四分之一区域内有限元仿真结果"><img src="/images/smoke/media/image19.png" alt="图3.5 扩散时间分别为0s、10s、20s、30s时，原长方体四分之一区域内有限元仿真结果"></p>
<p><img src="/images/smoke/media/image20.png" alt="图3.5 扩散时间分别为0s、10s、20s、30s时，原长方体四分之一区域内有限元仿真结果"><img src="/images/smoke/media/image21.png" alt="图3.5 扩散时间分别为0s、10s、20s、30s时，原长方体四分之一区域内有限元仿真结果"></p>
<p>可以看到，有限元仿真Python程序的运行结果能够较好地反映扩散过程中烟雾浓度分布的变化情况，基本与理论分析可视化中展现的趋势一致，在此不再赘述。相较于理论分析的可视化结果而言，有限元仿真的结果更加精细也更加丰富，特别是在截面的浓度分布上，很好地反映了扩散过程的基本特点，但在空间中的浓度分布可能受到了边界条件的过分影响，导致其明显呈现沿容器边缘扩散的趋势，而在容器内部的扩散范围较为有限。</p>
<h3 id="3-3-基于COMSOL仿真软件的有限元数值仿真"><a href="#3-3-基于COMSOL仿真软件的有限元数值仿真" class="headerlink" title="3.3 基于COMSOL仿真软件的有限元数值仿真"></a>3.3 基于COMSOL仿真软件的有限元数值仿真</h3><p>尽管对于初始条件进行了一定的修正，但上述的有限元数值模拟仍然缺乏对于对流项的考虑，这可能是导致其结果受边界条件影响较大的原因之一。除此之外，上述的理论分析与数值计算也仅仅对于烟雾扩散过程中的浓度分布变化进行计算与模拟，而缺乏了烟雾扩散速度方面的计算分析，这也受到了解析求解方法的限制。因此，我们希望借助成熟的商业有限元仿真软件COMSOL进行更进一步的数值仿真，以分别模拟常压扩散与负压吸附两种情况下的植物甘油气雾颗粒扩散情况，并得到常压扩散情况下的扩散速度场与压力分布情况，帮助我们进一步完善烟雾扩散的基本模型。</p>
<p>为更加真实地反映实际扩散过程中的复杂物理环境，我们需要在COMSOL软件中指定相应的物理场模型：</p>
<ul>
<li><p>湍流模型：帮助模拟湍流流动对气体扩散过程的影响，增加流体混合、热量传递和物质扩散等过程的复杂性；</p>
</li>
<li><p>RANS模型：通过对Navier-Stokes方程进行时间平均，简化了直接求解瞬时湍流方程的复杂度，计算成本相对较低，同时可以较为准确地描述气体扩散过程中湍流对流场的影响，尤其是在稳态流动情况下；</p>
</li>
<li><p>低雷诺数k-ω模型：采用湍动能（k）和湍流频率（ω）作为主要变量，能够较好地捕捉近壁区和低雷诺数流动特性，在复杂的流动区域中能更好地描述气体的湍流行为，提供更准确的边界层模拟，从而提高气体扩散的模拟精度。</p>
</li>
</ul>
<p><img src="/images/smoke/media/image22.png" alt="图3.6 物理场模型部分参数设置"></p>
<p>除此之外，我们还需要使用温度场模型来模拟扩散过程中粒子的运动情况。对于烟雾产生端，采用650~750K的的随机梯度划分以达到不同速度的效果。</p>
<p><img src="/images/smoke/media/image23.png" alt="图3.7 温度场模型参数设置"></p>
<p>为了模拟出烟雾粒子扩散过程中的运动状态，我们还需要模拟出颗粒的流动。由于实际实验中采用的植物甘油气雾本质上是一种固体烟雾颗粒，所以在仿真中，我们选取遵循一阶牛顿规则的粒子，并给予每个颗粒一定的质量（与植物甘油气雾的理化性质相一致，设置其密度为1.26g/cm^3）。</p>
<p><img src="/images/smoke/media/image24.png" alt="图3.8 扩散粒子参数设置"></p>
<p>处于仿真计算的复杂度与运行时间考虑，我们仅在x = x_0/2处的垂直截面区域内（50cm*60cm）进行仿真，并设置仿真时间为6秒、时间步长为0.1秒、网格单元大小为1cm。同时与实验环境保持一致，温度设置为25℃（298.15K）。</p>
<p><img src="/images/smoke/media/image25.png" alt="图3.9 COMSOL仿真基本设置"></p>
<p>考虑到需要对于常压扩散与负压吸附两种情形分别进行仿真，还需要对于仿真边界（壁）进行一定的设置：</p>
<ul>
<li><p>常压扩散：将各边设置为壁，壁条件设置为满散射；</p>
</li>
<li><p>负压吸附：将上边界设置为出口，边界条件设置为静压力（-0.02MPa）</p>
</li>
</ul>
<p>完成了以上的所有设置流程，可以点击”计算”运行有限元仿真，仿真结果如下所示：</p>
<p><img src="/images/smoke/media/image26.png" alt="图3.10 COMSOL有限元仿真结果：常压扩散下的三角网格划分与稳定后的压力空间分布"><br><img src="/images/smoke/media/image27.png" alt="图3.10 COMSOL有限元仿真结果：常压扩散下的三角网格划分与稳定后的压力空间分布"></p>
<p><img src="/images/smoke/media/image28.png" alt="图3.11 COMSOL有限元仿真结果：常压扩散下稳定后的速度场强度及其空间分布"><img src="/images/smoke/media/image29.png" alt="图3.11 COMSOL有限元仿真结果：常压扩散下稳定后的速度场强度及其空间分布"></p>
<p><img src="/images/smoke/media/image30.png" alt="图3.12 COMSOL仿真结果：扩散3s时常压扩散（上）与负压吸附（下）的粒子运动轨迹"><br><img src="/images/smoke/media/image31.png" alt="图3.12 COMSOL仿真结果：扩散3s时常压扩散（上）与负压吸附（下）的粒子运动轨迹"></p>
<p>可以看到，通过COMSOL软件进行有限元数值仿真，可以有效划分三角网格并准确模拟出常压扩散情况下的扩散速度场及其强度分布情况，同时仿真得到的粒子运动轨迹大体趋势也与先前的解析求解与有限元数值计算较为吻合。仿真结果成功验证了先前理论模型推导的有效性，并在扩散速度方面进行了有力补充。</p>
<h2 id="4-实验现象验证"><a href="#4-实验现象验证" class="headerlink" title="4 实验现象验证"></a>4 实验现象验证</h2><h3 id="4-1-预实验：常压封闭环境下的水雾扩散"><a href="#4-1-预实验：常压封闭环境下的水雾扩散" class="headerlink" title="4.1 预实验：常压封闭环境下的水雾扩散"></a>4.1 预实验：常压封闭环境下的水雾扩散</h3><p>在进行理论模型的推导与演算前，为更准确地把握初始条件、边界条件以及部分环境因素的设置，并对于烟雾扩散的具体现象进行初步了解，我们首先基于手头已有的实验材料进行了定性观察的预实验。在预实验中，我们使用香薰机作为烟雾发生装置，但由于装置限制，仅采用纯净水作为烟雾发生原料以产生水雾，通过观察水雾扩散现象来初步把握扩散过程的基本特征。</p>
<p><img src="/images/smoke/media/image32.jpeg" alt="图4.1 预实验装置：香薰机（用于产生水雾）"><img src="/images/smoke/media/image33.jpeg" alt="图4.1 预实验装置：香薰机（用于产生水雾）">{width=”1.466816491688539in”<br>height=”1.9565212160979877in”}</p>
<p><img src="/images/smoke/media/image34.jpeg" alt="图4.2 水雾发生原料：农夫山泉纯净水100mL"></p>
<p><img src="/images/smoke/media/image35.jpeg" alt="图4.3 40cm\*50cm\*60cm的亚克力长方体容器，底部有半径3cm的开孔供烟雾通入"></p>
<p>基于以上预实验装置，搭建如下的实验装置场景：</p>
<p><img src="/images/smoke/media/image36.jpeg" alt="图4.4 水雾扩散预实验环境场景搭建"></p>
<p>启动香薰机，开始产生水雾，并通过长方体容器底部开孔向容器内部区域空间进行烟雾扩散。设置扩散时间为10分钟，拍摄视频记录扩散实验现象。</p>
<p><img src="/images/smoke/media/image37.png" alt="图4.5 扩散时间为0min、5min、10min时的水雾扩散现象"><img src="/images/smoke/media/image38.png" alt="图4.5 扩散时间为0min、5min、10min时的水雾扩散现象"></p>
<p><img src="/images/smoke/media/image39.png" alt="图4.5 扩散时间为0min、5min、10min时的水雾扩散现象"></p>
<p>可以看到，随着扩散时间的推移，容器内聚集的水雾越来越多，且越靠近底部、越靠近扩散源中心，水雾的浓度也就越高（从现象来看，可以认为水雾团越密集的地方浓度越高），且当扩散时间达到一定程度时，容器内的水雾逐渐达到饱和，开始向容器底部沉降，并在容器底部呈聚集态势。</p>
<p>预实验的定性观察帮助我们对于烟雾扩散的基本现象有了宏观上的认知，并通过实物实验的方式让我们对于研究对象以及研究区域有了更加具象的认识，这对于我们后续理论模型推导与数值计算仿真的有序推进打下了良好的基础。但定性实验只能帮助我们认识现象，要对于理论模型的研究成果进行更加严谨的实证评估，还需要进行定量化的实验与测量。</p>
<h3 id="4-2-正式实验：常压封闭环境下的植物甘油气雾扩散"><a href="#4-2-正式实验：常压封闭环境下的植物甘油气雾扩散" class="headerlink" title="4.2 正式实验：常压封闭环境下的植物甘油气雾扩散"></a>4.2 正式实验：常压封闭环境下的植物甘油气雾扩散</h3><p>在完成了理论模型的推导以及解析求解与数值仿真计算之后，我们还希望通过实际定量实验的测量结果来验证理论模型的合理性。为进行定量化实验，我们将预实验中的部分实验装置进行了替换，以严格定量控制烟雾的产生过程并实时测量特定测量点位处的烟雾浓度，从而与理论计算与仿真结果进行比照。</p>
<p>对于烟雾发生器而言，为达到定量产生植物甘油气雾的效果，选取了Selens手持烟雾发生器作为新的实验器材，该款烟雾发生器可以产生固定强度的植物甘油气雾，查阅其产品技术文档可知，其固定产生烟雾的强度约为F_0 ≈ 5g/cm^3（与先前理论推导采用相同符号）；同时为定量测量定点(x_0/2,0,z_0)处（与2.5节一致）的烟雾浓度，选取了MQ-2烟雾浓度传感器进行测量，通过STM32F1开发板对传感器进行供电，同时将数据传输至PC端并实时在屏幕上显示测量到的烟雾浓度值（单位：ppm，与g/cm^3的换算关系在2.5节已提及）。</p>
<p><img src="/images/smoke/media/image40.jpeg" alt="图4.6 MQ-2烟雾浓度传感器实物图及其灵敏度特性"><img src="/images/smoke/media/image41.png" alt="图4.6 MQ-2烟雾浓度传感器实物图及其灵敏度特性"></p>
<p><img src="/images/smoke/media/image42.jpeg" alt="图4.7 Selens手持烟雾发生器实物图（出雾弹直径约40mm）"><img src="/images/smoke/media/image43.jpeg" alt="图4.7 Selens手持烟雾发生器实物图（出雾弹直径约40mm）"></p>
<p><img src="/images/smoke/media/image44.jpeg" alt="图4.8 STM32F1开发板实物图"></p>
<p>需要注意的是，由于该款传感器读取烟雾浓度的过程是渐变而非突变，因此在使用前需要一定的预热（初始化）时间，且初始化完成后，在还未开始烟雾扩散实验时，读取到的烟雾浓度也并不为零，因此在后续数据处理时还需要移除对应的偏移量，实测平均偏移量在180ppm左右。</p>
<p><img src="/images/smoke/media/image45.jpeg" alt="图4.9 初始化后的烟雾传感器读取浓度数值"></p>
<p>基于以上实验装置，搭建如下的实验装置场景：</p>
<p><img src="/images/smoke/media/image46.jpeg" alt="图4.10 常压下植物甘油气雾扩散实验环境场景搭建"></p>
<p><img src="/images/smoke/media/image47.jpeg" alt="图4.11 传感器实际装置安装局部图"></p>
<p><img src="/images/smoke/media/image48.jpeg" alt="图4.12 烟雾发生器实际装置安装局部图"></p>
<p>对于该款手持烟雾发生器而言，需要手动长按开关才可持续发生烟雾，且该产品具有安全保护机制，最多只能连续产生30s的植物甘油气雾。启动装置后即开始进行烟雾扩散实验，烟雾通过长方体容器底部开孔向容器内部区域空间不断进行扩散。拍摄视频记录扩散实验现象与扩散过程中屏幕上显示的烟雾浓度的实时变化数值及曲线。</p>
<p><img src="/images/smoke/media/image49.png" alt="图4.13 实验过程中LCD屏幕上显示烟雾传感器测量到的浓度值"></p>
<p><img src="/images/smoke/media/image50.png" alt="图4.14 常压下扩散时间分别为0s、10s、20s、30s时的烟雾扩散现象"><img src="/images/smoke/media/image51.png" alt="图4.14 常压下扩散时间分别为0s、10s、20s、30s时的烟雾扩散现象"><img src="/images/smoke/media/image52.png" alt="图4.14 常压下扩散时间分别为0s、10s、20s、30s时的烟雾扩散现象"><br><img src="/images/smoke/media/image53.png" alt="图4.14 常压下扩散时间分别为0s、10s、20s、30s时的烟雾扩散现象"></p>
<p><img src="/images/smoke/media/image54.png" alt="图4.15 常压下停止烟雾发生30s后容器内的烟雾聚集状况"></p>
<p>可以发现，随着扩散时间的增加，容器内聚集的植物甘油气雾也越来越多，且扩散的过程与理论解析求解可视化以及有限元数值仿真展示的烟雾扩散趋势基本一致。同时，在常压状态下，相较于水雾扩散而言，容器内聚集的植物甘油气雾在停止发生一段时间后仍然没有明显消散，这是由于植物甘油独特的理化性质所导致的，也比水雾扩散实验的结果更加接近香烟烟雾扩散的实际情况。</p>
<p>将烟雾传感器读取到的烟雾浓度数值实时传输到PC端保存，利用MATLAB进行可视化并与理论解析求解计算的定点测量结果进行比照，结果如下：</p>
<p><img src="/images/smoke/media/image55.png" alt="图4.16 测量点(x_0/2,0,z_0)处理论计算与实验测量的烟雾浓度随时间变化比照（单位：ppm）蓝线为测量结果，红线为计算结果"></p>
<p>可以看到，通过烟雾传感器测量得到的烟雾浓度同样在20s左右达到基本稳定，且两者达到稳定后的浓度数值基本接近（在5%的误差允许范围内，约为380ppm），这说明我们的理论模型能够较好地解释实验测量结果；但比较而言，相比起实际测量的数据，理论求解得到的浓度在达到稳定前均高于实际测量结果，这一方面可能由于理论计算时进行了部分近似假设造成了偏差，另一方面也可能是实际测量时在传感器测量与数据读取传输过程中产生了一定的延迟。</p>
<p>通过理论求解计算结果与实验测量观察结果的比照可以发现，我们建立的理论模型对于烟雾扩散情况的模拟效果无论从现象（可视化效果）上还是从浓度数值上都能对于实际的烟雾扩散现象进行较好的模拟，这充分证明了我们理论解析求解模型研究的有效性。</p>
<h3 id="4-3-正式实验：封闭环境中负压作用下的植物甘油气雾扩散"><a href="#4-3-正式实验：封闭环境中负压作用下的植物甘油气雾扩散" class="headerlink" title="4.3 正式实验：封闭环境中负压作用下的植物甘油气雾扩散"></a>4.3 正式实验：封闭环境中负压作用下的植物甘油气雾扩散</h3><p>在正式实验阶段，除了在常压条件下进行烟雾扩散实验以验证烟雾扩散理论模型的准确性之外，为了后续进一步地提出可能的烟雾吸附方案并验证其有效性，我们还在负压环境下进行了对应的植物甘油气雾扩散实验，为后续开发提供参考。</p>
<p>在负压源的选取上，我们采用了涵道风机来营造负压环境。该款涵道风机可以通过旋钮调节产生不同档位强度的负压，通过查阅该产品技术文档可知，我们在实验时次啊用的最低档位负压值为P_0≈-0.02MPa，在通过COMSOL有限元仿真对于负压环境下的烟雾扩散进行数值模拟时也采用了相同的参数。其余的实验装置保持不变。</p>
<p><img src="/images/smoke/media/image56.jpeg" alt="图4.17 涵道风机实物图（上图为出风口一侧，下图为进风口一侧）"><img src="/images/smoke/media/image57.jpeg" alt="图4.17 涵道风机实物图（上图为出风口一侧，下图为进风口一侧）"></p>
<p>基于常压实验中搭建好的实验装置，在原烟雾发生处的开口对侧开出一个相同大小（半径3cm）的圆孔，并将涵道风机进风口对准该圆孔，完成负压吸附环境下植物甘油气雾扩散实验环境的搭建：</p>
<p><img src="/images/smoke/media/image58.jpeg" alt="图4.18 负压环境下植物甘油气雾扩散实验场景搭建"></p>
<p>通过STM32F1开发板驱动涵道风机（供电）并通过旋钮将其调至最低档位，并采用与常压环境下实验相同的实验步骤与实验条件，拍摄视频记录扩散实验现象与扩散过程中屏幕上显示的烟雾浓度的实时变化数值及曲线。</p>
<p><img src="/images/smoke/media/image59.png" alt="图4.19 负压作用下扩散时间分别为0s、10s、20s、30s时的烟雾扩散现象"><img src="/images/smoke/media/image60.png" alt="图4.19 负压作用下扩散时间分别为0s、10s、20s、30s时的烟雾扩散现象"><img src="/images/smoke/media/image61.png" alt="图4.19 负压作用下扩散时间分别为0s、10s、20s、30s时的烟雾扩散现象"><img src="/images/smoke/media/image62.png" alt="图4.19 负压作用下扩散时间分别为0s、10s、20s、30s时的烟雾扩散现象"></p>
<p><img src="/images/smoke/media/image63.jpeg" alt="图4.20 负压作用下停止烟雾发生30s后容器内的烟雾聚集状况"></p>
<p>可以发现，随着扩散时间的增加，容器内聚集的植物甘油气雾越来越多，但没有像常压状态下一样出现大量烟雾的堆积与沉降现象，且整体扩散方向受负压源牵引作用明显，这点与COMSOL有限元仿真得到的烟雾粒子运动轨迹基本一致；同时可以注意到，同样是在停止烟雾发生30秒后（期间持续进行负压吸附），在负压吸附的持续作用下容器内聚集的植物甘油气雾迅速地被排出容器外，而不像常压环境下的扩散那样会长时间堆积在容器内难以消散，这也充分验证了负压吸附这一解决方案的可行性与有效性，为后续的开发应用提供了良好的实验基础。</p>
<p>将烟雾传感器读取到的烟雾浓度数值实时传输到PC端保存，利用MATLAB进行可视化并与理论解析求解计算的定点测量结果进行比照，结果如下：</p>
<p><img src="/images/smoke/media/image64.png" alt="图4.21 负压环境下测量点(x_0/2,0,z_0)处实验测量的烟雾浓度随时间变化结果（单位：ppm）"></p>
<p>可以看到，相较于常压环境中的烟雾扩散，在负压作用下测量点处的植物甘油气雾浓度达到基本稳定的速度明显变快（大概在10s左右），且稳定后测得的烟雾浓度数值（100ppm左右）相较于常压下的稳定测量结果（380ppm左右）有明显下降，这样的数值结果在实验现象的基础上更进一步地验证了负压吸附这一解决方案的可行性与有效性，同时为后续的开发应用提供了良好的实验数据基础。</p>
<h2 id="5-研究结论应用"><a href="#5-研究结论应用" class="headerlink" title="5 研究结论应用"></a>5 研究结论应用</h2><h3 id="5-1-研究结论"><a href="#5-1-研究结论" class="headerlink" title="5.1 研究结论"></a>5.1 研究结论</h3><p>基于以上对于植物甘油气雾扩散问题在解析求解、数值模拟以及实验测量方面的深入研究，针对1.2节提出的研究目标，可以给出如下三点主要的研究结论：</p>
<ul>
<li><p>在扩散过程中不同时刻的浓度分布方面，针对常压下密闭环境中的烟雾扩散现象，通过理论计算得到了不同时刻空间内各点处的浓度分布，并结合实验测试结果，印证了理论分析的高精度，在20s后空间内浓度分布基本稳定；</p>
</li>
<li><p>在扩散过程中烟雾的扩散速度方面，通过COMSOL有限元仿真软件对常压下密闭环境中的烟雾扩散进行数值模拟，得到扩散处于基本稳定状态下空间截面内速度场的分布，为分析浓度分布变化趋势提供参考；</p>
</li>
<li><p>在扩散过程中的烟雾扩散效果与除烟效果方面，将常压下和负压吸附下的COMSOL有限元仿真结果与实际实验现象进行对照，可以发现理论分析、数值求解以及实际实验三者的扩散现象结果基本一致，且在引入负压对流后，稳定后的烟雾浓度整体较常压时明显降低，且在烟雾发生停止后能够迅速清除残余的烟雾，具有良好的除烟效果。</p>
</li>
</ul>
<p>除此之外，在这三点研究结论的基础上，我们还通过理论、仿真与实验的有机结合，得到了植物甘油气雾扩散的一般规律与数学物理模型，可以通过该理论模型对于实际的烟雾扩散情况进行定量化的数值模拟分析，从而对于烟雾扩散过程进行更精准的把控与必要的干预管理，并通过多种手段对该理论模型的有效性进行了充分验证，这也为我们后续应用产品的开发打下了良好的理论与实验基础。</p>
<h3 id="5-2-研究成果应用：室内烟雾浓度控制系统"><a href="#5-2-研究成果应用：室内烟雾浓度控制系统" class="headerlink" title="5.2 研究成果应用：室内烟雾浓度控制系统"></a>5.2 研究成果应用：室内烟雾浓度控制系统</h3><p>基于数值分析结果与研究结论，我们开发了一套简易的闭环控制系统作为原型样机，通过实时检测监测点处的烟雾浓度，实现对于风机吸附功率的灵活动态调控，以优化用户体验。</p>
<p>在该系统的开发方面，采用STM32F1开发板作为系统主控，通过ADC实时读取MQ-2传感器返回的烟雾浓度数值，并通过PID闭环控制实时调控给涵道风机供电的PWM占空比，从而实现对于风机吸附功率的实施调控。</p>
<p><img src="/images/smoke/media/image65.jpeg" alt="图5.1 室内烟雾浓度闭环控制系统装置实物图（主要是上面部分）"></p>
<p>通过运行该闭环控制系统并测试其烟雾浓度控制效果，可以发现该系统对于烟雾有着较高的灵敏度，并在检测到高浓度烟雾后能够迅速调动涵道电机作出反应，快速吸附容器内的植物甘油气雾并始终维持空间内的烟雾浓度低于150ppm，说明样机能够初步满足用户的基本除烟需求。</p>
<h2 id="6-课程收获感悟"><a href="#6-课程收获感悟" class="headerlink" title="6 课程收获感悟"></a>6 课程收获感悟</h2><p>通过本次数学物理方法课程的学习，以及烟雾扩散课程项目的开展，我们通过在实际项目中运用课程中学习到的理论知识，在扩散过程中烟雾浓度分布的定量化求解过程中，对于数学物理方程的导出、边界与初始条件的确定以及基于变量分离与本征值方法求解级数解的过程有了更加深刻的认识与理解，同时通过课程中介绍的数值求解有限元方法对于更加泛化的情况进行了数值模拟与讨论。在解析与数值求解的理论分析基础上，我们还利用成熟的COMSOL有限元仿真软件对于烟雾扩散的粒子运动轨迹以及速度场分布进行数值仿真以作为对我们理论模型的补充，并通过定量化的实验测量进一步验证了理论模型的有效性，为我们后续进行实际的产品开发与应用提供了良好的理论与实验基础。</p>
<p>在本次课程项目报告的最后，再次感谢老师的耐心指导以及提出的宝贵意见，也希望我们能够将数学物理方法教给我们的定量化分析思维带入到未来的项目研究与学习工作中，对我们未来的项目开展与人生成长起到帮助。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Gao, Naiping and Jianlei Niu. “Modeling particle dispersion and deposition in indoor environments.”&nbsp;Atmospheric Environment (Oxford, England : 1994)&nbsp;41 (2007): 3862 - 3876.</p>
<p>[2] Hoegg U. R. (1972). Cigarette smoke in closed spaces.&nbsp;Environmental health perspectives,&nbsp;2, 117–128.</p>
<p>[3] Kuga K, Ito K, Yoo S-J, et al. First- and second-hand smoke dispersion analysis from e-cigarettes using a computer-simulated person with a respiratory tract model. Indoor and Built Environment. 2018;27(7):898-916.</p>
<p>[4] Holmberg, S., &amp; Li, Y. (1998). Modelling of the Indoor Environment – Particle Dispersion and Deposition.&nbsp;Indoor Air, 8, 113-122.</p>
<p>[5] Al-sarraf, A.A., Yassin, M.F. &amp; Bouhamra, W. Experimental and computational study of particulate matter of secondhand smoke in indoor environment.&nbsp;Int. J. Environ. Sci. Technol.&nbsp;12, 73–86 (2015).</p>
<p>[6] 陈占秀,陈冠益,王艳,等.丙三醇与1,6-己二醇混合物降温凝固过程的分子动力学模拟[J].化工学报,2013,64(07):2316-2321.</p>
<p>[7] 沈玉峰,孟强龙.基于物理模型的烟雾扩散模拟[J].电子技术,2011,38(03):61-63.</p>
<p>[8] 李强,普小云.用毛细管成像法测量液相扩散系数——等折射率薄层测量方法[J].物理学报,2013,62(09):185-191.</p>
<p>[9] 杜青青.室内烟雾扩散模拟技术研究与实现[D].北京工业大学,2018.</p>
<p>[10] 梁昆淼编.数学物理方法[M].北京：高等教育出版社,1978:593页.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-MATLAB解析求解可视化代码"><a href="#1-MATLAB解析求解可视化代码" class="headerlink" title="1 MATLAB解析求解可视化代码"></a>1 MATLAB解析求解可视化代码</h3><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 参数定义</span></span><br><span class="line">x0 = <span class="number">40</span>; <span class="comment">% 长方体的长度</span></span><br><span class="line">y0 = <span class="number">50</span>; <span class="comment">% 长方体的宽度</span></span><br><span class="line">z0 = <span class="number">60</span>; <span class="comment">% 长方体的高度</span></span><br><span class="line">F0 = <span class="number">0.5</span>;  <span class="comment">% 源项强度 g/cm3</span></span><br><span class="line">D = <span class="number">0.0962</span>;   <span class="comment">% 扩散系数</span></span><br><span class="line">x_s = x0 / <span class="number">2</span>; <span class="comment">% 点源的 x 坐标</span></span><br><span class="line">y_s = y0 / <span class="number">2</span>; <span class="comment">% 点源的 y 坐标</span></span><br><span class="line">z_s = <span class="number">0</span>; <span class="comment">% 点源的 z 坐标</span></span><br><span class="line">t_max = <span class="number">30</span> * <span class="number">40</span>; <span class="comment">% 最大时间</span></span><br><span class="line">num_time_steps = <span class="number">31</span>; <span class="comment">% 时间步数</span></span><br><span class="line">num_terms = <span class="number">10</span>; <span class="comment">% 级数项数</span></span><br><span class="line"><span class="comment">% 创建空间网格</span></span><br><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, x0, <span class="number">50</span>);</span><br><span class="line">y = <span class="built_in">linspace</span>(<span class="number">0</span>, y0, <span class="number">50</span>);</span><br><span class="line">z = <span class="built_in">linspace</span>(<span class="number">0</span>, z0, <span class="number">50</span>);</span><br><span class="line">[X, Y, Z] = <span class="built_in">meshgrid</span>(x, y, z);</span><br><span class="line">time_steps = <span class="built_in">linspace</span>(<span class="number">0</span>, t_max, num_time_steps);   <span class="comment">% 时间步长</span></span><br><span class="line">rho = <span class="built_in">zeros</span>(<span class="built_in">length</span>(x), <span class="built_in">length</span>(y), <span class="built_in">length</span>(z), num_time_steps);   <span class="comment">% 计算解的函数</span></span><br><span class="line"><span class="comment">% 测量点坐标 (x0/2, 0, z0)</span></span><br><span class="line">x_measure = x0 / <span class="number">2</span>;</span><br><span class="line">y_measure = <span class="number">0</span>;</span><br><span class="line">z_measure = z0;</span><br><span class="line">rho_measure = <span class="built_in">zeros</span>(<span class="number">1</span>, num_time_steps);   <span class="comment">% 初始化存储测量点浓度的数组</span></span><br><span class="line"><span class="keyword">for</span> t_idx = <span class="number">1</span>:num_time_steps</span><br><span class="line">    t = time_steps(t_idx);  <span class="comment">% 当前时间</span></span><br><span class="line">    <span class="comment">% 级数求解</span></span><br><span class="line">    sum_term = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> l = <span class="number">1</span>:num_terms</span><br><span class="line">        <span class="keyword">for</span> m = <span class="number">1</span>:num_terms</span><br><span class="line">            <span class="keyword">for</span> n = <span class="number">1</span>:num_terms</span><br><span class="line">                <span class="comment">% 计算级数各项</span></span><br><span class="line">                lambda = (l^<span class="number">2</span> * <span class="built_in">pi</span>^<span class="number">2</span> / x0^<span class="number">2</span>) + (m^<span class="number">2</span> * <span class="built_in">pi</span>^<span class="number">2</span> / y0^<span class="number">2</span>) + (n^<span class="number">2</span> * <span class="built_in">pi</span>^<span class="number">2</span> / z0^<span class="number">2</span>);</span><br><span class="line">                term = <span class="built_in">cos</span>(l * <span class="built_in">pi</span> * X / x0) .* <span class="built_in">cos</span>(m * <span class="built_in">pi</span> * Y / y0) .* <span class="built_in">cos</span>(n * <span class="built_in">pi</span> * Z / z0) .* ...</span><br><span class="line">                       <span class="built_in">cos</span>(l * <span class="built_in">pi</span> * x_s / x0) .* <span class="built_in">cos</span>(m * <span class="built_in">pi</span> * y_s / y0) .* <span class="built_in">cos</span>(n * <span class="built_in">pi</span> * z_s / z0) .* ...</span><br><span class="line">                       (<span class="number">1</span> - <span class="built_in">exp</span>(-D * lambda * t)) ./ lambda;</span><br><span class="line">                sum_term = sum_term + term;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    rho(:, :, :, t_idx) = (F0 / (x0 * y0 * z0 * D)) * sum_term;   <span class="comment">% 乘上源强度项和常数因子</span></span><br><span class="line">    <span class="comment">% 计算测量点处的浓度</span></span><br><span class="line">    rho_measure(t_idx) = interp3(X, Y, Z, rho(:, :, :, t_idx), x_measure, y_measure, z_measure); </span><br><span class="line">    rho_measure(t_idx) = rho_measure(t_idx) * <span class="number">10</span>^<span class="number">6</span> / <span class="number">1.26</span>;   <span class="comment">% 单位换算：g/cm^3 -&gt; ppm</span></span><br><span class="line">    <span class="built_in">disp</span>(t_idx)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">time_steps = time_steps / <span class="number">40</span>;</span><br><span class="line"><span class="comment">% 创建视频对象</span></span><br><span class="line">video_file = <span class="string">'fog_diffusion.avi'</span>; </span><br><span class="line">v = VideoWriter(video_file);</span><br><span class="line">v.FrameRate = <span class="number">5</span>; <span class="comment">% 设置帧率</span></span><br><span class="line">open(v); <span class="comment">% 打开视频文件</span></span><br><span class="line"><span class="comment">% 绘制动态可视化</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="keyword">for</span> t_select = <span class="number">1</span>:num_time_steps <span class="comment">% 遍历时间步</span></span><br><span class="line">    value = rho(:, :, :, t_select);</span><br><span class="line">    <span class="comment">% 筛选出非零值及其对应的坐标</span></span><br><span class="line">    non_zero_indices = value &gt;= <span class="number">0.0003</span>; <span class="comment">% 设定阈值：可见浓度0.3mg/cm3</span></span><br><span class="line">    X_nonzero = X(non_zero_indices);</span><br><span class="line">    Y_nonzero = Y(non_zero_indices);</span><br><span class="line">    Z_nonzero = Z(non_zero_indices);</span><br><span class="line">    Value_nonzero = value(non_zero_indices);</span><br><span class="line">    <span class="comment">% 绘制非零值的散点图</span></span><br><span class="line">    <span class="built_in">scatter3</span>(X_nonzero, Y_nonzero, Z_nonzero, <span class="number">20</span>, Value_nonzero, <span class="string">'filled'</span>); <span class="comment">% 绘制散点图</span></span><br><span class="line">    colormap jet; <span class="comment">% 设置颜色图</span></span><br><span class="line">    colorbar; <span class="comment">% 显示颜色条</span></span><br><span class="line">    xlabel(<span class="string">'x'</span>);</span><br><span class="line">    ylabel(<span class="string">'y'</span>);</span><br><span class="line">    zlabel(<span class="string">'z'</span>);</span><br><span class="line">    title([<span class="string">'3D Scatter Plot of Values at t = '</span> num2str(time_steps(t_select))]);</span><br><span class="line">    grid on;</span><br><span class="line">    view(<span class="number">3</span>); <span class="comment">% 设置三维视角</span></span><br><span class="line">    <span class="comment">% 固定坐标轴长度</span></span><br><span class="line">    axis([<span class="number">0</span>, x0, <span class="number">0</span>, y0, <span class="number">0</span>, z0]); <span class="comment">% 设置 x, y, z 的范围</span></span><br><span class="line">    <span class="comment">% 将当前帧保存到视频</span></span><br><span class="line">    frame = getframe(gcf);</span><br><span class="line">    writeVideo(v, frame);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">close(v);   <span class="comment">% 关闭视频文件</span></span><br><span class="line"><span class="comment">% 绘制测量点浓度随时间的变化</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(time_steps, rho_measure, <span class="string">'-o'</span>, <span class="string">'LineWidth'</span>, <span class="number">2</span>);</span><br><span class="line">xlabel(<span class="string">'Time (s)'</span>);</span><br><span class="line">ylabel(<span class="string">'\rho at (x0/2, 0, z0) (ppm)'</span>);</span><br><span class="line">title(<span class="string">'Concentration at Measurement Point over Time'</span>);</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'视频已保存为: '</span>, video_file]);</span><br><span class="line"><span class="comment">% 将测量点浓度数据保存到txt文件</span></span><br><span class="line">output_file = <span class="string">'rho_measurement_data.txt'</span>;</span><br><span class="line">fileID = fopen(output_file, <span class="string">'w'</span>);</span><br><span class="line">fprintf(fileID, <span class="string">'Time(s)\tConcentration(ppm)\n'</span>); <span class="comment">% 表头</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(time_steps)</span><br><span class="line">    fprintf(fileID, <span class="string">'%.2f\t%.6f\n'</span>, time_steps(<span class="built_in">i</span>), rho_measure(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fileID);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'测量点数据已保存为: '</span>, output_file]);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-Python有限元仿真代码"><a href="#2-Python有限元仿真代码" class="headerlink" title="2 Python有限元仿真代码"></a>2 Python有限元仿真代码</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> lil_matrix</span><br><span class="line"><span class="keyword">from</span> scipy.sparse.linalg <span class="keyword">import</span> spsolve</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> Normalize</span><br><span class="line"><span class="keyword">import</span> matplotlib.animation <span class="keyword">as</span> animation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网格生成函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_mesh</span>(<span class="params">x0, y0, z0, nx, ny, nz</span>):</span><br><span class="line">    <span class="keyword">from</span> meshpy.tet <span class="keyword">import</span> MeshInfo, build</span><br><span class="line">    points = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (x0, <span class="number">0</span>, <span class="number">0</span>), (x0, y0, <span class="number">0</span>), (<span class="number">0</span>, y0, <span class="number">0</span>),(<span class="number">0</span>, <span class="number">0</span>, z0), (x0, <span class="number">0</span>, z0), (x0, y0, z0), (<span class="number">0</span>, y0, z0)]</span><br><span class="line">    facets = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>]]</span><br><span class="line">    mesh_info = MeshInfo()</span><br><span class="line">    mesh_info.set_points(points)</span><br><span class="line">    mesh_info.set_facets(facets)</span><br><span class="line">    mesh = build(mesh_info, max_volume=(x0/nx) * (y0/ny) * (z0/nz))</span><br><span class="line">    <span class="keyword">return</span> mesh</span><br><span class="line"><span class="comment"># 全局矩阵组装</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">assemble_global_matrices</span>(<span class="params">mesh, D</span>):</span><br><span class="line">    num_nodes = <span class="built_in">len</span>(mesh.points)</span><br><span class="line">    M_global = lil_matrix((num_nodes, num_nodes))</span><br><span class="line">    K_global = lil_matrix((num_nodes, num_nodes))</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> mesh.elements:</span><br><span class="line">        node_ids = element</span><br><span class="line">        vertices = np.array([mesh.points[i] <span class="keyword">for</span> i <span class="keyword">in</span> node_ids])</span><br><span class="line">        B, volume = compute_B_matrix(vertices)</span><br><span class="line">        K_element = D * volume * (B.T @ B)</span><br><span class="line">        M_element = volume * np.eye(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                M_global[node_ids[i], node_ids[j]] += M_element[i, j]</span><br><span class="line">                K_global[node_ids[i], node_ids[j]] += K_element[i, j]</span><br><span class="line">    boundary_indices = find_boundary_nodes(mesh)</span><br><span class="line">    apply_boundary_conditions(M_global, K_global, boundary_indices)</span><br><span class="line">    <span class="keyword">return</span> M_global, K_global</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_B_matrix</span>(<span class="params">vertices</span>):</span><br><span class="line">    A = np.ones((<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">    A[:, <span class="number">1</span>:] = vertices</span><br><span class="line">    volume = <span class="built_in">abs</span>(np.linalg.det(A)) / <span class="number">6.0</span></span><br><span class="line">    B = np.zeros((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        sub_matrix = np.delete(A, i, axis=<span class="number">0</span>)</span><br><span class="line">        coeffs = np.linalg.det(sub_matrix[:, <span class="number">1</span>:])</span><br><span class="line">        B[:, i] = coeffs</span><br><span class="line">    B /= (<span class="number">6</span> * volume)</span><br><span class="line">    <span class="keyword">return</span> B, volume</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_boundary_nodes</span>(<span class="params">mesh</span>):</span><br><span class="line">    boundary_indices = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> facet <span class="keyword">in</span> mesh.facets:</span><br><span class="line">        boundary_indices.update(facet)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(boundary_indices)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_boundary_conditions</span>(<span class="params">M_global, K_global, boundary_indices</span>):</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> boundary_indices:</span><br><span class="line">        M_global[idx, :] = <span class="number">0</span></span><br><span class="line">        M_global[:, idx] = <span class="number">0</span></span><br><span class="line">        K_global[idx, :] = <span class="number">0</span></span><br><span class="line">        M_global[idx, idx] = <span class="number">1</span></span><br><span class="line">        K_global[idx, idx] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 时间步进求解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_diffusion</span>(<span class="params">mesh, M_global, K_global, F0, D, t_max, num_time_steps</span>):</span><br><span class="line">    num_nodes = <span class="built_in">len</span>(mesh.points)</span><br><span class="line">    rho = np.zeros((num_nodes, num_time_steps))</span><br><span class="line">    dt = t_max / (num_time_steps - <span class="number">1</span>)</span><br><span class="line">    center = np.array([x0/<span class="number">2</span>, y0/<span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line">    radius = <span class="number">0.6</span></span><br><span class="line">    <span class="keyword">for</span> t_idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_time_steps):</span><br><span class="line">        A = M_global + dt * K_global</span><br><span class="line">        F = F0 * np.ones(num_nodes)</span><br><span class="line">        <span class="keyword">for</span> idx, point <span class="keyword">in</span> <span class="built_in">enumerate</span>(mesh.points):</span><br><span class="line">            <span class="keyword">if</span> np.linalg.norm(point - center) &lt; radius:</span><br><span class="line">                F[idx] += F0</span><br><span class="line">        b = M_global @ rho[:, t_idx-<span class="number">1</span>] + dt * F</span><br><span class="line">        rho[:, t_idx] = spsolve(A, b)</span><br><span class="line">    <span class="keyword">return</span> rho</span><br><span class="line"><span class="comment"># 可视化与动画</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_animation</span>(<span class="params">mesh, rho, time_steps, output_file</span>):</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">'3d'</span>)</span><br><span class="line">    points = np.array(mesh.points)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_plot</span>(<span class="params">frame_idx</span>):</span><br><span class="line">        ax.clear()</span><br><span class="line">        rho_t = rho[:, frame_idx]</span><br><span class="line">        norm = Normalize(vmin=<span class="number">0.005</span>, vmax=<span class="number">0.01</span>)</span><br><span class="line">        ax.scatter(points[:, <span class="number">0</span>], points[:, <span class="number">1</span>], points[:, <span class="number">2</span>], c=rho_t, cmap=<span class="string">'jet'</span>, norm=norm, s=<span class="number">10</span>)</span><br><span class="line">        ax.set_title(<span class="string">f"Concentration at t = <span class="subst">{time_steps[frame_idx]:<span class="number">.2</span>f}</span>"</span>)</span><br><span class="line">        ax.set_xlim(<span class="number">0</span>, x0)</span><br><span class="line">        ax.set_ylim(<span class="number">0</span>, y0)</span><br><span class="line">        ax.set_zlim(<span class="number">0</span>, z0)</span><br><span class="line">    ani = animation.FuncAnimation(fig, update_plot, frames=<span class="built_in">len</span>(time_steps), interval=<span class="number">500</span>)</span><br><span class="line">    ani.save(output_file, writer=<span class="string">'ffmpeg'</span>, fps=<span class="number">5</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 参数</span></span><br><span class="line">    x0, y0, z0 = <span class="number">20</span>, <span class="number">25</span>, <span class="number">60</span></span><br><span class="line">    nx, ny, nz = <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span></span><br><span class="line">    D = <span class="number">0.0962</span></span><br><span class="line">    F0 = <span class="number">0.5</span></span><br><span class="line">    t_max = <span class="number">30</span></span><br><span class="line">    num_time_steps = <span class="number">31</span></span><br><span class="line">    mesh = generate_mesh(x0, y0, z0, nx, ny, nz)   <span class="comment"># 网格生成</span></span><br><span class="line">    M_global, K_global = assemble_global_matrices(mesh, D)   <span class="comment"># 矩阵组装</span></span><br><span class="line">    <span class="comment"># 求解</span></span><br><span class="line">    time_steps = np.linspace(<span class="number">0</span>, t_max, num_time_steps)</span><br><span class="line">    rho = solve_diffusion(mesh, M_global, K_global, F0, D, t_max, num_time_steps)</span><br><span class="line">    create_animation(mesh, rho, time_steps, <span class="string">"diffusion_animation.mp4"</span>)   <span class="comment"># 生成动画</span></span><br></pre></td></tr></tbody></table></figure>

</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2025-01-04T17:02:03.000Z" title="2025/1/5 01:02:03">2025-01-05</time>发表</span><span class="level-item"><time datetime="2025-03-01T18:06:45.232Z" title="2025/3/2 02:06:45">2025-03-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">智能图像处理</a></span><span class="level-item">1 小时读完 (大约7630个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/05/graph/">基于自编码器和卷积网络的肺炎图像识别</a></p><div class="content"><div id="postchat_postcontent"><h2 id="1-项目背景与研究意义"><a href="#1-项目背景与研究意义" class="headerlink" title="1 项目背景与研究意义"></a>1 项目背景与研究意义</h2><h3 id="1-1-项目背景"><a href="#1-1-项目背景" class="headerlink" title="1.1 项目背景"></a>1.1 项目背景</h3><p>肺炎作为一种常见的呼吸系统疾病，对人类健康构成了长期威胁，特别是随着COVID-19新冠肺炎疫情的全球爆发，其公共健康影响更为显著。COVID-19肺炎具有传播速度快、感染范围广、诊断难度大的特点，对全球医疗系统和社会经济产生了深远影响。特别是在疫情高峰期，医疗资源的短缺和诊断效率的瓶颈，进一步突显了快速、准确诊断工具的重要性。</p>
<p>传统肺炎诊断方法主要依赖医生对胸部X光片或CT图像的人工分析，既耗时又容易受到经验和疲劳的影响，尤其在COVID-19疫情期间，大量影像数据的涌现使得人工诊断难以满足需求。与此同时，COVID-19的影像表现与其他类型肺炎的重叠性增加了诊断的复杂性，这进一步加剧了对智能化诊断系统的需求。</p>
<p>随着人工智能技术的快速发展，深度学习为医疗影像分析带来了全新的解决方案。卷积神经网络（Convolutional Neural Network, CNN）凭借其强大的图像特征提取能力，在自动化诊断中展现了巨大潜力。同时，由于不同医疗机构的CT扫描设备性能差异显著，特别是在医疗资源较为匮乏的地区，CT影像常常受到设备老化、分辨率低或操作不规范等因素的影响，图像质量参差不齐，这不仅增加了诊断的复杂性，还对自动化系统的鲁棒性提出了更高要求；而自编码器（Autoencoder）作为一种有效的降噪工具，为医疗影像数据预处理提供了重要支持。通过自编码器的引入，可以有效消除图像中的噪声干扰，减少不同设备间的成像差异，为后续的分类和识别模型提供高质量的输入数据。因此，本项目提出结合自编码器和卷积神经网络的深度学习框架，开发一套针对肺炎（包括COVID-19）CT影像识别的智能诊断系统。</p>
<p><img src="/images/graph/media/image1.jpeg" alt="图1.1：新冠肺炎疫情概况（主要症状、防治措施与传播状况）"></p>
<p><img src="/images/graph/media/image2.jpeg" alt="图1.2：新冠肺炎患者的肺部CT影像"></p>
<h3 id="1-2-研究意义"><a href="#1-2-研究意义" class="headerlink" title="1.2 研究意义"></a>1.2 研究意义</h3><p>本项目以新型冠状病毒肺炎为切入点，面向未来医学智能化需求，开发的诊断系统不仅能够应对当下疫情挑战，还具有推广至其他医学影像诊断场景的潜力，从而为全球公共健康事业的发展提供有力支持。</p>
<p>面向新冠肺炎疫情期间大规模肺部影像数据的快速诊断需求，本系统依托深度学习技术，有效提升了诊断效率，为疫情防控和患者管理提供重要的技术支持。通过先进的模型算法，系统能够精准识别肺部CT影像中的病变特征，减少人为误差，确保诊断结果的准确性和一致性，大幅降低不同医疗机构和医生之间的诊断差异，避免误诊和漏诊风险，从而更好地保障患者安全。</p>
<p>针对基层医院或偏远地区医疗资源匮乏的现状，本系统可作为一种可靠的辅助诊断工具，为医生提供科学的决策支持，帮助缓解诊断能力不足带来的压力。其高效的处理能力不仅提高了基层医疗服务水平，也为疫情防控的全面推进提供了技术保障，为应对紧急医疗需求的地区解决实际困难。</p>
<p>此外，本系统在高效处理和分析海量肺部CT影像数据的基础上，还为研究新冠肺炎的病理特征及流行规律提供了宝贵的数据支持。这些分析结果可进一步应用于疫情传播趋势预测和公共卫生政策制定，为疫情防控策略的科学性和有效性奠定了坚实基础。</p>
<p>同时，本系统也为患者病情的动态管理提供了重要帮助。通过智能分析新冠肺炎影像特征的变化趋势，系统能够为临床医生提供精确的病情评估建议，有助于及时调整治疗方案。这种基于影像数据的技术支持，不仅提高了患者管理的科学性和有效性，还为医疗资源的合理分配提供了重要依据，进一步推动了疫情防控工作的高效开展。</p>
<h2 id="2-数据集获取与预处理"><a href="#2-数据集获取与预处理" class="headerlink" title="2 数据集获取与预处理"></a>2 数据集获取与预处理</h2><h3 id="2-1-数据集介绍"><a href="#2-1-数据集介绍" class="headerlink" title="2.1 数据集介绍"></a>2.1 数据集介绍</h3><p>本项目使用的肺部X-光片数据集从Kaggle网站（链接：<a target="_blank" rel="noopener" href="https://www.kaggle.com/datasets/alsaniipe/chest-x-ray-image">https://www.kaggle.com/datasets/alsaniipe/chest-x-ray-image</a>）获取，共分为三类标签：新冠肺炎COVID19、正常NORMAL和普通肺炎PNEUMONIA，该数据集已经事先划分好了训练集与测试集。此外，为测试模型对于不同质量CT影像的识别精度，还对测试集中的部分图像使用高斯噪声进行扰动，以模拟实际CT扫描的成像质量差异。</p>
<p><img src="/images/graph/media/image3.png" alt="图2.1：肺部CT影像数据集概况"><br><img src="/images/graph/media/image4.png" alt="图2.2：肺部CT影像数据集概况"></p>
<p><img src="/images/graph/media/image5.png" alt="图2.3：数据集中部分肺部CT影像展示（上行为训练集（干净），下行为含噪声测试集）"></p>
<p>数据分布如下表所示：</p>
<p>表2.1：数据集数据分布情况</p>
<table>
<thead>
<tr>
<th></th>
<th>COVID19</th>
<th>NORMAL</th>
<th>PNEUMONIA</th>
</tr>
</thead>
<tbody><tr>
<td>Train</td>
<td>460</td>
<td>1266</td>
<td>3418</td>
</tr>
<tr>
<td>Test</td>
<td>116</td>
<td>317</td>
<td>855</td>
</tr>
<tr>
<td>Noisy_Test</td>
<td>26</td>
<td>20</td>
<td>20</td>
</tr>
</tbody></table>
<h3 id="2-2-编程环境搭建"><a href="#2-2-编程环境搭建" class="headerlink" title="2.2 编程环境搭建"></a>2.2 编程环境搭建</h3><p>本项目中所有的代码编写与运行均是在配备NVIDIA GeForce RTX 3060显卡、16GB运行内存、12th Gen Inter(R) Core(TM) <a href="mailto:i7-12700@2.10GHz">i7-12700@2.10GHz</a>处理器与Microsoft Windows 11操作系统的工作站上使用Python编程语言完成的。</p>
<p>软件环境方面，采用Conda进行环境管理，在控制台中通过命令”conda create -n covid python=3.12”创建虚拟环境，并在激活环境后使用pip install命令依次安装所需的各种依赖库；全部安装并测试完成后，通过命令”pip freeze &gt;<br>requirements.txt”将虚拟环境中安装的所有依赖库及对应版本写入文件requirements.txt，后续移植时可在新的运行环境中运行命令”pip install -r requirements.txt”完成环境的一键配置。</p>
<p>值得注意的是，在PyTorch（包括torch、torchvision与torchaudio库）安装时需要根据自己电脑使用的CUDA版本（使用CPU则直接在命令行中使用pip install安装即可）在<a target="_blank" rel="noopener" href="https://pytorch.org/">PyTorch官网</a>中找到对应的安装命令进行安装。我使用的CUDA版本为12.6，安装命令的选取如下图所示：</p>
<p><img src="/images/graph/media/image6.png" alt="图2.4：PyTorch官网获取对应CUDA版本的安装命令"></p>
<p>下面对于项目中使用到的主要依赖库进行简要介绍：</p>
<p><img src="/images/graph/media/image7.png" alt="图2.5：项目中使用的主要依赖库"></p>
<p>其中，plt用于绘图，nn中包含了用于构建神经网络的隐藏层（全连接层、卷积层等），F中包含了各种激活函数（ReLu、Sigmoid等），DataLoader用于在训练时加载数据，datasets和transforms用于读取和处理数据集，tqdm用于进度条可视化，torchmetrics用于模型精度的测试，torchviz和torchsummary用于以图形与文字的方式描述模型架构概况。</p>
<h3 id="2-3-图像数据读取"><a href="#2-3-图像数据读取" class="headerlink" title="2.3 图像数据读取"></a>2.3 图像数据读取</h3><p>torch对于一些常用的数据集做了封装，可以直接调用，例如datasets.MNIST()。但此处我们使用的是本地的图片数据，可以使用ImageFolder将一个文件夹下的图片读取成数据集并完成数据增强工作。在读取完数据集后，还需要定义DataLoader用于加载数据为可分批次（batch）读取的迭代器以供后续使用。为使得代码更加简洁，将上述的数据读取与加载过程为封装在getDataLoader函数中，并在主函数中通过指定不同的目录加载训练集、测试集或是含噪声测试集。</p>
<p><img src="/images/graph/media/image8.png" alt="图2.6：数据加载函数getDataLoader代码"></p>
<p>可以看到，其中构建了数据增强器transform，在读取数据时进行相应处理：</p>
<ul>
<li><p>Grayscale: 指以灰度图的形式读取。</p>
</li>
<li><p>Resize: 由于图像尺寸各不相同，在训练前需将它们重塑成相同尺寸256*256。</p>
</li>
<li><p>ToTensor: 将图片格式转换成张量形式，torch的计算以张量的形式进行。</p>
</li>
</ul>
<p>除此之外，在构建数据加载器时需要指定一个批次（batch）中的图片数据数量batch_size，在模型训练时训练批次大小TRAIN_BATCH_SIZE也是会影响最终模型性能的重要超参数之一。在训练过程中，设定TRAIN_BATCH_SIZE为32，而在测试过程中，为提高测试效率，将TEST_BATCH_SIZE设置为66并对函数进行对应修改。</p>
<h3 id="2-4-叠加噪声函数"><a href="#2-4-叠加噪声函数" class="headerlink" title="2.4 叠加噪声函数"></a>2.4 叠加噪声函数</h3><p>不论是构建噪声测试集，还是在利用无噪声的训练集进行训练时，都需要手动添加噪声，故编写add_noise函数，默认的噪声强度为0.5，并在添加噪声后进行归一化以确保图像值位于[0,1]范围内。</p>
<p><img src="/images/graph/media/image9.png" alt="图2.7：加噪函数add_noise代码"></p>
<p><img src="/images/graph/media/image10.JPG" alt="图2.8：加噪前后效果对比"></p>
<h2 id="3-模型构建与网络训练"><a href="#3-模型构建与网络训练" class="headerlink" title="3 模型构建与网络训练"></a>3 模型构建与网络训练</h2><h3 id="3-1-整体模型框架"><a href="#3-1-整体模型框架" class="headerlink" title="3.1 整体模型框架"></a>3.1 整体模型框架</h3><p>整体模型框架由两个核心部分组成，分别是用于去噪的数据预处理模块和负责分类的卷积神经网络（CNN）。去噪模块采用自编码器（Autoencoder）的架构，专注于从输入数据中去除噪声，以提升后续分类的准确性；分类模块基于卷积神经网络，其强大的特征提取和模式识别能力使其成为分类任务的理想选择。</p>
<p>两个模块相辅相成，通过有效的数据处理和特征提取，确保模型能够在噪声干扰较大的环境中实现高精度分类。噪声数据首先经过自编码器处理，生成质量优化的特征表示，然后被CNN接收并完成分类任务。这一整体框架设计非常适合肺炎图像识别任务，通过结合去噪和分类两大模块的优势，模型不仅能够有效提高数据质量，还能充分挖掘数据中的有用特征，从而能够在复杂的医学影像处理中表现出卓越的鲁棒性和准确性，满足肺炎诊断的实际需求。</p>
<p><img src="/images/graph/media/image11.png" alt="图3.1：模型框架图示"></p>
<h3 id="3-2-自编码器"><a href="#3-2-自编码器" class="headerlink" title="3.2 自编码器"></a>3.2 自编码器</h3><p>自编码器模型用于处理输入数据中的噪声问题，提升后续分类的准确性。其核心思想是通过编码器将输入数据压缩至低维潜在表示（latent representation），再由解码器将其还原至去噪后的重构数据，从而实现降噪效果。</p>
<h4 id="3-2-1-网络结构设计"><a href="#3-2-1-网络结构设计" class="headerlink" title="3.2.1 网络结构设计"></a>3.2.1 网络结构设计</h4><p><img src="/images/graph/media/image12.png" alt="图3.2：自编码器模型结构"></p>
<p>自编码器网络结构由编码器encoder与解码器decoder组成：</p>
<ul>
<li><p>编码器由两层卷积（Conv2d）和两次池化（MaxPool2d）操作组成，用于提取特征；</p>
</li>
<li><p>解码器通过两次反卷积（ConvTranspose2d）和两次上采样（UpsamplingNearest2d）逐步恢复图像尺寸到原始大小；</p>
</li>
<li><p>最后使用Sigmoid激活函数将输出值限制在[0,1]区间。</p>
</li>
</ul>
<p>模型定义代码如下：</p>
<p><img src="/images/graph/media/image13.png" alt="图3.3：自编码器模型定义代码"></p>
<p>模型继承自nn.Module类，在__init__()函数中定义模型的结构，在forward()函数中定义模型的前向传播过程。</p>
<p>通过调用torchviz和torchsummary库，可以输出该模型结构的基本信息：</p>
<p><img src="/images/graph/media/image14.png" alt="图3.4：调用torchsummary库输出自编码器网络结构的文字信息"></p>
<p><img src="/images/graph/media/image15.JPG" alt="图3.5：调用torchviz库输出自编码器网络结构的架构图示"></p>
<h4 id="3-2-2-模型训练"><a href="#3-2-2-模型训练" class="headerlink" title="3.2.2 模型训练"></a>3.2.2 模型训练</h4><p>基本的训练流程集成在函数train_autoencoder_process中，如下图所示：</p>
<p><img src="/images/graph/media/image16.png" alt="图3.6：自编码器模型训练函数train_autoencoder_process代码"></p>
<p>其中指定优化器optimizer为Adam，损失函数为均方误差MSE，并使用超参数：训练轮数Epochs=50、学习率lr=0.001。每轮（Epoch）训练中均需要以多个batch的形式遍历训练集中的所有数据，并在每个batch后对模型进行更新，具体而言每次更新均需执行如下操作：</p>
<ul>
<li><p>从加载器中获取输入数据</p>
</li>
<li><p>使用add_noise函数对干净图像加噪</p>
</li>
<li><p>将加噪后图像输入自编码器模型并计算模型输出</p>
</li>
<li><p>根据模型输出和标签计算损失Loss</p>
</li>
<li><p>清空梯度</p>
</li>
<li><p>反向传播</p>
</li>
<li><p>更新模型</p>
</li>
</ul>
<p>值得注意的是，由于用于训练的图像数据没有噪声，因此训练时首先需要对输入的图像进行加噪处理，再输入自编码器模型进行训练。</p>
<p>训练过程中还利用tqdm进度条函数对训练进程进行可视化，并在每轮训练完成后打印出当轮训练过程中模型的平均损失：</p>
<p><img src="/images/graph/media/image17.png" alt="图3.7：自编码器模型训练过程进度条（前5个Epoch）"></p>
<p>在训练过程中，将每轮训练的平均损失存储在列表中，并在训练结束后将平均损失的变化过程以图像形式呈现：</p>
<p><img src="/images/graph/media/image18.JPG" alt="图3.8：自编码器模型训练损失变化"></p>
<p>可以看到，经过多轮训练，模型的损失函数值在不断减小且逐渐趋近于0，这意味着该自编码器的模型训练过程是收敛的，模型具有较稳定的工作性能。</p>
<h3 id="3-3-卷积神经网络"><a href="#3-3-卷积神经网络" class="headerlink" title="3.3 卷积神经网络"></a>3.3 卷积神经网络</h3><p>卷积神经网络负责从图像中提取多层次的空间特征，通过逐步减少图像尺寸和增加特征通道来捕捉关键信息，从而实现去噪后肺部CT图像的分类功能。CNN以其强大的特征提取能力，能够有效处理图像的局部依赖性和空间不变性，高效处理结构化数据（如图像、时序数据）。模型简单且高效，具有较强的泛化能力，适合处理小规模数据集的图像分类问题。</p>
<h4 id="3-3-1-网络结构设计"><a href="#3-3-1-网络结构设计" class="headerlink" title="3.3.1 网络结构设计"></a>3.3.1 网络结构设计</h4><p><img src="/images/graph/media/image19.png" alt="图3.9：卷积神经网络模型结构"></p>
<p>卷积神经网络结构（如上图，通过<a target="_blank" rel="noopener" href="http://alexlenail.me/NN-SVG/AlexNet.html">NN-SVG工具</a>绘制）由两层卷积层（Conv2d）和池化层（MaxPool2d）组成，激活函数均选用ReLU，逐步提取特征并将输入图像的尺寸从原始大小减小到64×64。卷积后的特征图展平后通过三个全连接层（Linear），分别将特征维度从32×64×64降至128，再降至32，最后输出3个类别（Covid19、Normal、Pneumonia）的预测结果。</p>
<p>模型定义代码如下：</p>
<p><img src="/images/graph/media/image20.png" alt="图3.10：卷积神经网络模型定义代码"></p>
<p>模型继承自nn.Module类，在__init__()函数中定义模型的结构，在forward()函数中定义模型的前向传播过程。</p>
<p>通过调用torchviz和torchsummary库，可以输出该模型结构的基本信息：</p>
<p><img src="/images/graph/media/image21.png" alt="图3.11：调用torchsummary库输出卷积神经网络结构的文字信息"></p>
<p><img src="/images/graph/media/image22.png" alt="图3.12：调用torchviz库输出卷积神经网络结构的架构图示"></p>
<h4 id="3-3-2-模型训练"><a href="#3-3-2-模型训练" class="headerlink" title="3.3.2 模型训练"></a>3.3.2 模型训练</h4><p>基本的训练流程集成在函数train_cnn_process中，如下图所示：</p>
<p><img src="/images/graph/media/image23.png" alt="图3.13：卷积神经网络模型训练函数train_cnn_process代码"></p>
<p>其中指定优化器optimizer为Adam，损失函数为交叉熵损失CrossEntropy，并使用超参数：训练轮数Epochs=50、学习率lr=0.001。每轮（Epoch）训练中均需要以多个batch的形式遍历训练集中的所有数据，并在每个batch后对模型进行更新，具体而言每次更新均需执行如下操作：</p>
<ul>
<li><p>从加载器中获取输入数据</p>
</li>
<li><p>使用add_noise函数对干净图像加噪</p>
</li>
<li><p>将加噪后图像输入训练好的自编码器模型trained_autoencoder_model</p>
</li>
<li><p>将经过自编码器去噪后的图像输入CNN模型并计算模型输出</p>
</li>
<li><p>根据模型输出和标签计算损失Loss</p>
</li>
<li><p>清空梯度</p>
</li>
<li><p>反向传播</p>
</li>
<li><p>更新模型</p>
</li>
</ul>
<p>值得注意的是，由于用于训练的图像数据没有噪声，为与实际的输入情况一致，首先需要对输入的图像进行加噪处理，再利用训练好的自编码器模型进行降噪（为了不在更新CNN的同时更新自编码器，这一步不需要产生梯度），才能输入CNN分类模型进行训练。</p>
<p>训练过程中还利用tqdm进度条函数对训练进程进行可视化，并在每轮训练完成后打印出当轮训练过程中模型的平均损失与在训练集上的测试精度：</p>
<p><img src="/images/graph/media/image24.png" alt="图3.14：卷积神经网络模型训练过程进度条（最后5个Epoch）"></p>
<p>在训练过程中，将每轮训练的平均损失与模型在训练集上的测试精度存储在列表中，并在训练结束后将两者的变化过程以图像形式呈现：</p>
<p><img src="/images/graph/media/image25.png" alt="图3.15：卷积神经网络模型训练损失变化"></p>
<p><img src="/images/graph/media/image26.png" alt="图3.16：卷积神经网络模型训练过程中在训练集上的精度变化"></p>
<p>可以看到，经过多轮训练，模型的损失函数值在不断减小且逐渐趋近于0，这意味着该自编码器的模型训练过程是收敛的，模型具有较稳定的工作性能；同时随着训练轮数增加，模型在训练集上的精度也逐渐增高（波动上升），在模型训练完成时，卷积神经网络在训练集上的分类精度已经可以达到99.59%（一度达到99.90%），接近百分之百，说明模型的分类能力较好。</p>
<h2 id="4-模型测试及应用"><a href="#4-模型测试及应用" class="headerlink" title="4 模型测试及应用"></a>4 模型测试及应用</h2><h3 id="4-1-自编码器降噪效果"><a href="#4-1-自编码器降噪效果" class="headerlink" title="4.1 自编码器降噪效果"></a>4.1 自编码器降噪效果</h3><p>在自编码器模型的训练过程中，每隔10轮对模型参数进行了一次存档；在测试过程中，分别使用训练轮数为10、20、30、40、50的自编码器模型对于加噪后的模型进行降噪处理，效果如下图所示：</p>
<p><img src="/images/graph/media/image27.png" alt="图4.1：训练轮数Epoch=10的自编码器模型降噪效果"></p>
<p><img src="/images/graph/media/image28.png" alt="图4.2：训练轮数Epoch=20的自编码器模型降噪效果"></p>
<p><img src="/images/graph/media/image29.png" alt="图4.3：训练轮数Epoch=30的自编码器模型降噪效果"></p>
<p><img src="/images/graph/media/image30.png" alt="图4.4：训练轮数Epoch=40的自编码器模型降噪效果"></p>
<p><img src="/images/graph/media/image31.png" alt="图4.5：训练轮数Epoch=50的自编码器模型降噪效果"></p>
<p>通过对比不同训练轮数的自编码器模型降噪效果可以发现，随着训练轮数的增加，自编码器模型的降噪效果在逐渐提升，但在Epoch到达30之后，训练带来的降噪效果提升就不如先前显著了。尽管由于较大的噪声强度（0.5）导致降噪后的图像仍然比较模糊，但通过肉眼还是能粗略观察处肺部骨骼的轮廓等特征，后续实验也证明了卷积神经网络确实可以从这样清晰度的图像中提取相应的特征来进行分类，该自编码器模型的设计有效。</p>
<h3 id="4-2-卷积神经网络分类精度"><a href="#4-2-卷积神经网络分类精度" class="headerlink" title="4.2 卷积神经网络分类精度"></a>4.2 卷积神经网络分类精度</h3><p>在卷积神经网络的分类精度上，训练过程中已经实时对于每一轮训练后的模型在训练集上进行了精度测试（3.2.2节中已有提及），而在测试集上，可以编写与训练过程类似的代码利用torchmetrics库对模型分类精度进行测试，只是不会更新模型，代码如下：</p>
<p><img src="/images/graph/media/image32.png" alt="图4.6：卷积神经网络分类精度在测试集上的测试函数代码"></p>
<p>可以看到，由于我们的测试集分为含噪声和不含噪声两类，因此编写了不同的函数对模型分类精度进行测试。两个函数的主要差别就在于，由于含噪声测试集是已经加噪的图片（噪声与手动通过add_noise函数添加的不同），因此在含噪声测试集的测试代码中不必再次手动添加噪声，而是直接将图像输入自编码器降噪后再输入CNN分类模型中进行分类；而对于不含噪声的测试集而言，为模拟与训练集同样的处理流程，会先进行手动加噪再通过自编码器降噪之后才输入CNN分类模型中进行分类。</p>
<p>运行测试代码后，得到模型在含噪测试集上的分类精度为96.97%，在不含噪声的测试集上的分类精度为94.57%，在两个测试集上的分类精度水平均较高，说明该模型具有良好的分类效果。</p>
<h3 id="4-3-模型应用：基于CT影像的肺炎诊断Web服务"><a href="#4-3-模型应用：基于CT影像的肺炎诊断Web服务" class="headerlink" title="4.3 模型应用：基于CT影像的肺炎诊断Web服务"></a>4.3 模型应用：基于CT影像的肺炎诊断Web服务</h3><p>通过对比多组超参数的模型降噪与分类效果，最终选定如下的超参数：</p>
<ul>
<li><p>训练轮数Epochs=50；</p>
</li>
<li><p>学习率LR=0.001；</p>
</li>
<li><p>训练批次大小Train_Batch_Size=32。</p>
</li>
</ul>
<p>选定参数后，将整体代码抽离为model.py（包含模型定义类代码），run.py（服务端代码）和train.py（训练函数），并将模型部署到实际应用中，使用Flask作为服务端，以Web形式用户提供操作接口以上传图片进行诊断。由于主要功能是提供接口，故网页只做了很简易的一个index.html，给用户提供上传图片的按钮，并在用户上传有噪声的CT影像后返回诊断结果及去噪后的图像。除此之外，还将挂载在本地端口上的Web通过内网穿透映射到公网，以供实时访问。</p>
<p>网页初始界面如下图所示：</p>
<p><img src="/images/graph/media/image33.png" alt="图4.7：网页初始界面"></p>
<p>接下来分别测试当输入COVID19、NORMAL和PNEUMONIA三个组别的图片，模型能否正确判断：</p>
<p><img src="/images/graph/media/image34.png" alt="图4.8：输入类型为COVID19，识别为COVID19（正确）"></p>
<p><img src="/images/graph/media/image35.png" alt="图4.9：输入类型为COVID19，识别为PNEUMONIA（错误）"></p>
<p><img src="/images/graph/media/image36.png" alt="图4.10：输入类型为NORMAL，识别为NORMAL（正确）"></p>
<p><img src="/images/graph/media/image37.png" alt="图4.11：输入类型为PNEUMONIA，识别为PNEUMONIA（正确）"></p>
<p>可以发现，模型在大多数情况下可以正确识别图像来源，但也会出现错误识别的情况，这和Test 集上的Accuracy相符合；此外，在测试时还注意到，模型识别结果偶尔会出现不稳定的现象，即输入同一张图像有时识别为某一类别，有时又会识别为另一类别，这是由模型内部部分随机参数导致的，这也反映了模型在一些模棱两可的情况下（两类别概率接近）做出判断时的不稳定性。在实际应用中，为尽可能减少误诊对于患者带来的各方面影响，还需要采取更多优化措施提升模型性能，并对模型在模棱两可的情况下做出的判断进行合理的限制。</p>
<h2 id="5-总结与展望"><a href="#5-总结与展望" class="headerlink" title="5 总结与展望"></a>5 总结与展望</h2><p>本项目全部代码（不包含数据集）已上传至Github仓库，仓库URL地址：<a target="_blank" rel="noopener" href="https://github.com/Asgard-Tim/Pneumonia-Image-Recognition">https://github.com/Asgard-Tim/Pneumonia-Image-Recognition</a></p>
<h3 id="5-1-项目总结"><a href="#5-1-项目总结" class="headerlink" title="5.1 项目总结"></a>5.1 项目总结</h3><p>本项目基于深度学习技术，结合自编码器和卷积神经网络，开发了一套智能诊断系统，用于快速、高效地识别肺部的CT影像并判断该患者是否患有肺炎（包括COVID-19）。自编码器模块有效去除了噪声，提升了图像质量，而卷积神经网络以其强大的特征提取能力，实现了高精度的分类。本项目在数据预处理、模型设计、网络训练及测试等环节中均采用了创新性的技术方案，最终实现了在含噪声测试集上96.97%和在无噪声测试集上94.57%的分类精度，表现出了较高的鲁棒性和实用价值。同时，系统已通过Flask框架部署为Web服务，能够实时接收CT影像并给出诊断结果，为疫情期间大规模影像数据的快速诊断及基层医疗资源匮乏地区的医疗支持提供了重要的技术保障。</p>
<h3 id="5-2-课程收获与反思"><a href="#5-2-课程收获与反思" class="headerlink" title="5.2 课程收获与反思"></a>5.2 课程收获与反思</h3><p>本次选修《智能图像处理》这门课程确实让我学到了很多东西，其实自己之前也自己看过一些机器学习方面的内容，有一定的知识基础与环境搭建经验，但由于各方面原因总是没有系统性的去学习计算机视觉的相关知识，也缺乏足够的实战代码与项目经验。通过这门课程的学习，很大程度上锻炼了我Python的代码能力，也在Coding的过程中不断熟悉OpenCV、Pytorch等库的使用，更在实践的过程中不断加深对于各种算法模型（AlexNet、ResNet、YOLO等）的理解。</p>
<p>本次项目让我完整地经历了从数据集获取、论文调研及算法代码实现，再到代码调试与模型训练测试，最终将模型应用到实际系统中的全过程，在项目实现的过程中收获了很多课程教学与实验中涉及不到的东西，包括数据集的收集、模型的选择以及作为一个完整项目的代码实现等等多个方面，这也是我第一次使用GPU资源去进行。虽然由于时间等条件的限制，在模型选择上并没有进行深入的调研与充分的对比试验，只是基于自己已知的一些知识对于架构较为简单的自编码器模型与卷积神经网络进行了复现与设计，最终模型的分类精度还有一定的提升空间，但是这也为我后续的自主学习打下了一个良好的基础，希望未来我能在计算机视觉方面有更加深入的学习与探索，也感谢老师的耐心指导与悉心教学。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Nosa-Omoruyi M, Oghenekaro L U. AutoEncoder Convolutional Neural Network for Pneumonia Detection[J]. arXiv preprint arXiv:2409.02142, 2024.</p>
<p>[2] Ratiphaphongthon W, Panup W, Wangkeeree R. An improved technique for pneumonia infected patients image recognition based on combination algorithm of smooth generalized pinball SVM and variational autoencoders[J]. IEEE Access, 2022, 10: 107431-107445.</p>
<p>[3] Gayathri J L, Abraham B, Sujarani M S, et al. A computer-aided diagnosis system for the classification of COVID-19 and non-COVID-19 pneumonia on chest X-ray images by integrating CNN with sparse autoencoder and feed forward neural network[J]. Computers in biology and medicine, 2022, 141: 105134.</p>
<p>[4] García-Ordás M T, Benítez-Andrades J A, García-Rodríguez I, et al. Detecting respiratory pathologies using convolutional neural networks and variational autoencoders for unbalancing data[J]. Sensors, 2020,20(4): 1214.</p>
<p>[5] Xia Y. Enhanced Pneumonia Detection in Chest X-Rays Based on Integrated Denoising Autoencoders and Convolutional Neural Networks[J].</p>
<p>[6] El-Shafai W, El-Nabi S A, El-Rabaie E S M, et al. Efficient Deep-Learning-Based Autoencoder Denoising Approach for Medical Image Diagnosis[J]. Computers, Materials &amp; Continua, 2022, 70(3).</p>
<p>[7] Rana N, Marwaha H. Auto encoder-guided Feature Extraction for Pneumonia Identification from Chest X-ray Images[C]//E3S Web of Conferences. EDP Sciences, 2024, 556: 01011.</p>
<p>[8] Ankayarkanni B, Sangeetha P. An Autoencoder-BiLSTM framework for classifying multiple types of lung diseases from CXR images[J]. Multimedia Tools and Applications, 2024: 1-30.</p>
<p>[9] 孙敬,丁嘉伟,冯光辉.一种基于自编码器降维的神经卷积网络入侵检测模型[J/OL].电信科学,1-7[2025-01-05].</p>
<p>[10] 张淙越,杨晓玲.基于卷积神经网络的新冠肺炎CT图像识别系统[J].电脑与信息技术,2022,30(03):12-14+40.</p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-12-30T18:02:03.000Z" title="2024/12/31 02:02:03">2024-12-31</time>发表</span><span class="level-item"><time datetime="2025-03-02T17:27:56.470Z" title="2025/3/3 01:27:56">2025-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95II/">定量工程设计方法II</a></span><span class="level-item">2 小时读完 (大约13620个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/12/31/ecg/">心电信号采集与处理</a></p><div class="content"><div id="postchat_postcontent"><h2 id="1-实验需求分析"><a href="#1-实验需求分析" class="headerlink" title="1 实验需求分析"></a>1 实验需求分析</h2><h3 id="1-1-项目背景介绍"><a href="#1-1-项目背景介绍" class="headerlink" title="1.1 项目背景介绍"></a>1.1 项目背景介绍</h3><p>心电信号（Electrocardiogram, ECG）是反映心脏活动电生理变化的重要生物电信号，其特征包括心率、节律、波形等参数，能够直观反映心脏健康状况，在临床医学、健康监测和疾病预防中具有不可替代的作用。通过心电信号的测量与分析，可以检测心律失常、心肌缺血、心脏传导阻滞等异常，为心脏疾病的诊断和治疗提供关键支持；借助便携式和可穿戴设备，实时心电监测已成为健康管理的重要手段，为心血管疾病高危人群提供预警，有助于降低发病率和致死率。此外，心电信号还是生物医学研究的重要工具，为心血管药物开发、人工心脏研究等领域提供了基础数据。在当前人口老龄化加剧和心血管疾病高发的背景下，心电信号测量与分析技术显得尤为重要。本项目旨在开发高精度的心电信号采集系统，结合课程中介绍的数字信号处理等专业知识，为心脏健康提供更加便捷和智能的监测方案，推动精准医疗与个性化健康管理的发展。</p>
<h3 id="1-2-心电信号特征与设计需求"><a href="#1-2-心电信号特征与设计需求" class="headerlink" title="1.2 心电信号特征与设计需求"></a>1.2 心电信号特征与设计需求</h3><p>心脏内部产生的一系列非常协调的电刺激脉冲，使得心脏肌肉细胞有节奏的舒张和收缩，这些信号传递到人体表面的不同部位形成不同的电位差。通过仪器设备可以从体表检测到这些微弱的电位差信号，称之为心电信号。换言之，心电信号即为人体心脏细胞细胞膜产生的电势差。在医学上，医生往往需要通过心率与幅值等参数来初步判断患者的健康状况，因此实现高精度的心率与幅值测量是本项目中设计的心电信号采集与处理系统的核心功能。</p>
<p><img src="/images/ecg/media/image2.png" alt="图1.1：心电信号简介"></p>
<p>正常的心电信号频率范围为0.05Hz－100Hz，其能量集中在低频段，其中99％的能量集中在0Hz－35Hz。在其采集过程中容易受到各种干扰，主要分为三种：</p>
<ul>
<li><p>工频和工频的谐波频率干扰，工频频率在我国为50Hz；</p>
</li>
<li><p>肌颤噪声和采样电路参考电压引入的电源纹波等高频噪声，频率通常在100Hz以上；</p>
</li>
<li><p>呼吸基线漂移和采样引入的直流分量，频率一般分布在0-0.7Hz。</p>
</li>
</ul>
<p>以上的各种干扰会对心电信号采集结果产生较大的影响，使得采集到的心电信号中出现许多杂波与噪声，这是我们所不希望看到的。因此，为提高心电信号的测量精度，需要设计相应的滤波器对传感器采集到的信号进行滤波，从而减小信号中的噪声震荡，提高心率与幅值测量的准确程度。特别的，由于参考电压受环境温度变化会产生一定的温漂，以及人的呼吸活动和电极滑动也导致基线漂移。这些干扰的频率很低，通常在几Hz以内，但和心电信号的有效频谱非常接近，因此需要过渡带较窄的IIR直流陷波器来消除干扰。</p>
<p>基于心电信号的以上特性，对于该心电信号采集与处理系统，提出如下的技术指标需求：</p>
<ul>
<li><p>0频处的缓变直流衰减不低于30dB；</p>
</li>
<li><p>降噪滤波器以35Hz为3dB通带截止频率，过渡带不超过10Hz，阻带衰减不低于40dB；</p>
</li>
<li><p>心率估算误差不超过10%。</p>
</li>
</ul>
<h2 id="2-实现方案论证"><a href="#2-实现方案论证" class="headerlink" title="2 实现方案论证"></a>2 实现方案论证</h2><h3 id="2-1-系统框架设计"><a href="#2-1-系统框架设计" class="headerlink" title="2.1 系统框架设计"></a>2.1 系统框架设计</h3><p>本项目的核心目标是实现心电信号的采集与滤波以及心率测量，同时需要在屏幕上绘制时域波形与频谱图。具体而言，细分的功能如下：</p>
<ul>
<li><p>实现ADS1292获取心电信号原始数据，并通过串口传输至PC电脑；</p>
</li>
<li><p>实现PC电脑中通过MATLAB对原始数据进行时域和频域分析；</p>
</li>
<li><p>实现PC电脑中通过MATLAB对原始数据进行降噪和提取心率；</p>
</li>
<li><p>实现STM32单片机中对原始数据进行降噪和提取心率；</p>
</li>
<li><p>TFT屏幕中绘制心电信号曲线和显示心率数值。</p>
</li>
</ul>
<p>为实现以上功能，采用如下的系统设计流程：</p>
<ol>
<li><p>调试ADS1292R_PowerOnInit函数中的ADS1292芯片读取，通过读取芯片device_id验证硬件功能正常且连接正确；</p>
</li>
<li><p>在中断驱动下，读取ADS1292的原始数据，并存储在单片机的存储器中；</p>
</li>
<li><p>把原始数据传输到PC；</p>
</li>
<li><p>在PC中分析原始数据的时域和频域；</p>
</li>
<li><p>在PC中设计滤波器对原始数据进行处理，并提取心率等；</p>
</li>
<li><p>把PC中的滤波器移植到单片机中；</p>
</li>
<li><p>在单片机中把心电波形和心率等数据显示到TFT屏幕。</p>
</li>
</ol>
<p><img src="/images/ecg/media/image3.png" alt="图2.1：系统设计流程"></p>
<p>根据如上设计流程，结合目前提供的材料，设计了如下图所示的心电信号采集与分析系统：</p>
<p><img src="/images/ecg/media/image4.png" alt="图2.2：系统框架"></p>
<p>系统的工作流程如下：</p>
<ol>
<li><p>首先，STM32控制器向心电传感器发送采集指令，传感器随后采集来自人体或模拟信号源的心电信号，并将数据反馈至控制器；</p>
</li>
<li><p>接着，控制器将采集到的数据传输至PC端，供进一步分析处理；</p>
</li>
<li><p>然后，根据PC端的分析结果，控制器会调整参数并优化心电信号处理；</p>
</li>
<li><p>最终，处理后的结果将在TFT屏幕上实时显示，供用户查看。</p>
</li>
</ol>
<p>可以看到，该系统主要涉及到STM32主控芯片、ADS1292R传感器、TFT显示屏、心电信号模拟器以及PC端分析软件MATLAB等关键组件。接下来将对于本项目涉及的各硬件组件进行介绍。</p>
<h3 id="2-2-STM32主控芯片"><a href="#2-2-STM32主控芯片" class="headerlink" title="2.2 STM32主控芯片"></a>2.2 STM32主控芯片</h3><p>本项目选用的微控制器STM32F407ZG是系统的核心控制单元，负责协调各个模块的工作。其不仅负责信号的采集，还管理信号传输、滤波器应用、以及与TFT屏幕的显示操作。其强大的处理能力和灵活的控制方式使其成为整个系统的”大脑”。该控制器目前搭载在”正点原子”探索者STM32F407开发板V3上，负责完成系统的信号采集、处理与传输任务。</p>
<p><img src="/images/ecg/media/image5.jpeg" alt="图2.3：STM32F407探索者开发板V3实物图正面"></p>
<p>该单片机具备高性能的ARM Cortex-M4内核，主频高达168MHz，同时集成了丰富的外设接口，包括多个ADC通道、DMA（直接存储器访问）、定时器以及USART串口等，为心电信号的实时采集、处理与传输提供了强有力的硬件支持。它通过SPI协议与ADS1292传感器进行数据交换，采集来自人体或模拟信号源的心电信号，并进行初步处理。</p>
<h3 id="2-3-心电信号模拟器"><a href="#2-3-心电信号模拟器" class="headerlink" title="2.3 心电信号模拟器"></a>2.3 心电信号模拟器</h3><p>在实验的过程中，无法总是以人体作为心电信号源，因此在缺乏人体数据的情况下，本项目采用SKX-2000心电信号模拟仪作为测试时的模拟信号源。它能够生成不同类型的心电波形，广泛用于测试系统性能和验证心电信号采集、处理的稳定性。此设备对确保系统在实际使用前达到预期的性能标准至关重要。</p>
<p><img src="/images/ecg/media/image6.png" alt="图2.4：SKX-2000心电信号模拟仪"></p>
<p><img src="/images/ecg/media/image7.png" alt="图2.5：SKX-2000心电信号模拟仪使用说明书"><img src="/images/ecg/media/image8.png" alt="图2.5：SKX-2000心电信号模拟仪使用说明书"></p>
<p>在本项目中，主要使用到的是正常的心电波形与标准的心率信号，可以通过操作该模拟仪控制其产生心电信号的心率以及幅度。在连接方面，如图2.3所示，采用三导联接法，RA连接右手（红色），LA连接左手（黄色），LL连接左脚（绿色）；通过3.5耳机动态导联线，将模拟仪产生的心电信号输入ADS1292S传感器中以供进一步采集。</p>
<h3 id="2-3-信号采集传感器：ADS1292R"><a href="#2-3-信号采集传感器：ADS1292R" class="headerlink" title="2.3 信号采集传感器：ADS1292R"></a>2.3 信号采集传感器：ADS1292R</h3><p>ADS1292R作为一款多通道同步采样的24位模数转换器（ADC），被广泛应用于生物电势测量领域，其独特的设计集成了可编程增益放大器、内部基准源和板载振荡器，确保了心电信号的精准采集。在本系统中，ADS1292R作为信号采集模块的核心组件，负责从心电电极捕获原始心电信号。这些信号随后通过SPI接口传输至STM32微控制器，供后续处理和分析。</p>
<p><img src="/images/ecg/media/image9.jpeg" alt="图2.6：ADS1292R传感器实物图与电路原理图"><br><img src="/images/ecg/media/image10.png" alt="图2.6：ADS1292R传感器实物图与电路原理图">该模块共有12个输出引脚（传感器模块右侧)，各引脚接口功能说明如下：</p>
<ul>
<li><p>GND：接供电电源地；</p>
</li>
<li><p>CLK：提供给ADS1292R工作的外部时钟，由于本项目采用内部时钟，故该引脚无需连接；</p>
</li>
<li><p>GPIO1、GPIO2：本项目中未使用，无需连接</p>
</li>
<li><p>SPI_SCK：接入由STM32单片机提供的SPI时钟信号；</p>
</li>
<li><p>SPI_MISO：向STM32单片机发送SPI数据输入信号；</p>
</li>
<li><p>SPI_MOSI：接收STM32单片机发出的数据输出信号；</p>
</li>
<li><p>SPI_CS0：接入STM32单片机GPIO，为ADS1292R提供片选选中信号；</p>
</li>
<li><p>ADS_DRDY：向STM32单片机发送外部中断输入，告知单片机可以通过SPI接收采集信号；</p>
</li>
<li><p>ADS_START：接入STM32单片机GPIO，为ADS1292R提供开始采集信号；</p>
</li>
<li><p>ADS_PWDN：接入STM32单片机GPIO，为ADS1292R提供复位信号RESET；</p>
</li>
<li><p>+5V：接供电电源+5V（由STM32输出）。</p>
</li>
</ul>
<p>除此之外，由于选用的STM32单片机只允许接收0~3.3V的输出电压，故单片机通过SPI通信接收的信号电压必须限制在该范围内，因此需要将ADS1292R传感器模块中间的VDD与3.3V引脚通过跳线帽相连以实现电压转换（与图2.5中左图的连接方式相反）。</p>
<h3 id="2-4-SPI通信读取采集数据"><a href="#2-4-SPI通信读取采集数据" class="headerlink" title="2.4 SPI通信读取采集数据"></a>2.4 SPI通信读取采集数据</h3><p>在本系统中，传感器将数字化后的原始心电信号数据通过SPI接口传输到STM32微控制器。SPI通信具有高速度、全双工传输的优势，非常适合用于实时性要求较高的应用场景。SPI接口确保了心电信号数据的快速、稳定传输，保证了信号的实时处理和准确性。通过SPI，ADS1292R和STM32微控制器能够高效地交换数据，从而提升系统的整体性能和响应速度。</p>
<p>SPI通信采用主从结构，其中STM32微控制器作为主设备，ADS1292R作为从设备。具体来说，SPI通信包括四个主要信号线：时钟信号（SCK）、主输出从输入（MOSI）、主输入从输出（MISO）和片选信号（CS）。时钟信号由STM32微控制器提供，用于同步数据传输。数据通过MOSI线从ADS1292R传输到STM32微控制器，而传感器通过MISO线将必要的反馈信息传回STM32。</p>
<p><img src="/images/ecg/media/image11.png" alt="图2.7：SPI内部结构简图"></p>
<p>为了提高系统的响应速度和处理效率，在单片机端选择了基于中断驱动的数据采集机制。当ADS1292R传感器完成一组心电数据的采集后，通过中断信号通知STM32F407进行数据读取和处理。这种机制有效减少了CPU的空闲时间，提高了系统的整体效率。</p>
<p><img src="/images/ecg/media/image12.png" alt="图2.8：中断驱动SPI通信采集数据的系统框架简图"></p>
<p>在单片机程序工程中，通过调用驱动库文件中的ADS1292_Read_Data函数，可以实现单片机与ADS1292R的数据交互以进行实时数据监测，并通过函数ADS1292_Send_CMD将信号数据通过UART串口以115200的波特率传输至PC端并保存。在此过程中，原始信号数据被保存为.dat格式的文件，后续将通过MATLAB读取和显示这些信号数据，并针对这些数据进行滤波器等模块的设计，对信号进行进一步验证与调试。</p>
<p><img src="/images/ecg/media/image13.png" alt="图2.9：单片机实现读取原始信号数据的函数ADS1292_Read_Data"></p>
<p><img src="/images/ecg/media/image14.png" alt="图2.10：单片机实现串口输出原始信号数据的函数ADS1292_Send_CMD"></p>
<p><img src="/images/ecg/media/image15.png" alt="图2.11：PC端可视化软件中显示采集到的原始心电信号（解码后）"></p>
<h2 id="3-理论推导与MATLAB计算"><a href="#3-理论推导与MATLAB计算" class="headerlink" title="3 理论推导与MATLAB计算"></a>3 理论推导与MATLAB计算</h2><p>PC端分析软件（本项目中使用MATLAB）用于对采集到的原始心电信号进行深入分析。为验证滤波器对心电信号的作用和效果，可以先在MATLAB上设计算法对心电信号进行一系列处理，包括数据读取、绘制原始数据时域波形、分析原始数据的频谱、设计数字直流陷波器、设计FIR数字低通滤波器、分析并比较滤波前后数据的频谱以及估算心率。通过这些分析，系统能够设计出合适的滤波器以去除噪声并提取出心率等重要参数，为后续移植到单片机上提供理论验证。</p>
<h3 id="3-1-原始心电信号数据的读取与频谱分析"><a href="#3-1-原始心电信号数据的读取与频谱分析" class="headerlink" title="3.1 原始心电信号数据的读取与频谱分析"></a>3.1 原始心电信号数据的读取与频谱分析</h3><p>为了研究信号特征和评估处理效果，首先需要导入心电信号数据并进行基本分析。当心电信号传入单片机后，根据ADS1292R的数据手册，还需在单片机中对数据进行解码处理。在2.4节中，直接存入.dat文件的是未经过解码的原始数据，而图2.11展示的则是经过解码转换后的波形数据可视化结果（由单片机内部程序完成解码转换，将在4.2节中详细展开）。</p>
<p><img src="/images/ecg/media/image16.png" alt="图3.1：MATLAB从串口读取信号数据并写入.dat文件的程序代码"></p>
<p>本章中的MATLAB分析均基于未解码的.dat文件，因此要想获得真实的波形数据（电压值），需要先根据以下规则对数据进行解码（4.2中的解码基于同样的原理，后续不再赘述）：</p>
<p>由于原始数据格式是24bits的二进制补码（7FFFFF对应的模拟信号是2.4V。800000对应的模拟信号是-2.4V），若考虑保留高16bits，需要注意此时为补码，同时也要考虑到16bits相比于24bits相当于右移了8位。所以此时7FFF的数值对应模拟信号相当于2.4V，8000对应模拟信号-2.4V。</p>
<p><img src="/images/ecg/media/image17.png" alt="图3.2：原始信号电压与读取信号数据间的关系"></p>
<p>基于这样的规则，可以在MATLAB编写对应的接收数据代码，从文件中读取数据（注意把负数的二进制补码转换为原码），其中Off可以为0或1（因为MATLAB接收的起始数据可能是16bits的高8位或者低8位，用off作为偏移调整，这样组合的数据才不会出现错位）；同时通过plot函数绘制出原始心电信号的时域波形，并使用快速傅里叶变换（FFT）分析信号频谱，绘制出频谱图。</p>
<p><img src="/images/ecg/media/image18.png" alt="图3.3：原始心电信号数据解码读取、时域波形绘制与频谱分析绘制MATLAB代码"></p>
<p><img src="/images/ecg/media/image19.png" alt="图3.4：原始心电信号时域波形与频谱"><img src="/images/ecg/media/image20.png" alt="图3.4：原始心电信号时域波形与频谱"></p>
<p>从频谱图（上右图）中可以明显观察到信号中的低频基线漂移和工频干扰（与1.2节中的分析基本一致），这些成分需要通过滤波器加以去除。</p>
<h3 id="3-2-IIR数字直流陷波器设计与滤波效果"><a href="#3-2-IIR数字直流陷波器设计与滤波效果" class="headerlink" title="3.2 IIR数字直流陷波器设计与滤波效果"></a>3.2 IIR数字直流陷波器设计与滤波效果</h3><p>工程中使用高精度传感器采集动态信号，采集的原始数据会因为环境变化、量化字长和参考电压等因素，包含较强的缓变直流分量，如果不予以消除，会导致在降噪等处理中出现运算饱和溢出。由于在采集心电信号时，人的呼吸活动和电极滑动会导致基线漂移，而这些干扰的频率又与心电信号的有效频谱非常接近，因此需要设计窄带IIR直流陷波器来消除该干扰。</p>
<p>直流陷波器的传递函数Η(z)为：<br>$$<br>Η(z) = \frac{z - 1}{z - a}<br>$$<br>该数字系统的极点为z = a，零点为z=1，其中参数a决定了陷波器的过渡带宽和衰减性能，为接近1的正实数。因为零点对应的幅角ω = 0，所以数字系统在零频处的增益显著衰减（如图3.5所示），其衰减的程度与过渡带的宽度和极点a的数值有关：a越大衰减变小，同时过渡带变窄，反之则衰减增大和过渡带增宽。通过实验调整，选择a=0.992可在基线漂移和信号完整性之间取得平衡。</p>
<p><img src="/images/ecg/media/image21.png" alt="图3.5：a=0.992时直流陷波器H(z)的增益和相位特性"></p>
<p><img src="/images/ecg/media/image22.png" alt="图3.6：IIR数字直流陷波器设计及滤波后频谱分析绘制MATLAB代码及其运行结果"><br><img src="/images/ecg/media/image23.png" alt="图3.6：IIR数字直流陷波器设计及滤波后频谱分析绘制MATLAB代码及其运行结果"></p>
<p>可以看到，在加入了直流陷波器进行滤波后，0频处的基线漂移基本被消除，说明该滤波器的设计有效并起到了很好的效果。</p>
<h3 id="3-3-FIR数字低通滤波器设计与滤波效果"><a href="#3-3-FIR数字低通滤波器设计与滤波效果" class="headerlink" title="3.3 FIR数字低通滤波器设计与滤波效果"></a>3.3 FIR数字低通滤波器设计与滤波效果</h3><p>根据阻带衰减不低于40dB且过渡带不超过10Hz的要求，利用MATLAB中自带的filterDesigner滤波器设计工具对于FIR数字低通滤波器进行设计。在该滤波器中，采用固定窗口，通过对当前点及其前160个点的加权求和来计算输出（指定滤波器阶数为160）。</p>
<p>在固定窗口的选择上，由于不同窗函数的阻带最小衰减各不相同，过渡带应与对应窗函数的”精确过渡带宽”相等。以下是常用窗函数的对比表：</p>
<p>表3.1 不同窗函数的阻带最小衰减</p>
<table>
<thead>
<tr>
<th>窗函数</th>
<th>第一旁瓣衰减A/dB</th>
<th>近似过渡带宽Bw</th>
<th>精确过渡带宽</th>
<th>旁瓣峰值衰减/(dB * oct^(- 1))</th>
</tr>
</thead>
<tbody><tr>
<td>矩形窗</td>
<td>-13</td>
<td>4π/N</td>
<td>1.8π/N</td>
<td>21</td>
</tr>
<tr>
<td>汉宁窗</td>
<td>-31</td>
<td>8π/N</td>
<td>6.2π/N</td>
<td>44</td>
</tr>
<tr>
<td>海明窗</td>
<td>-41</td>
<td>8π/N</td>
<td>6.6π/N</td>
<td>53</td>
</tr>
<tr>
<td>布莱克曼窗</td>
<td>-57</td>
<td>12π/N</td>
<td>11π/N</td>
<td>74</td>
</tr>
<tr>
<td>凯泽窗(β = 7.865)</td>
<td>-57</td>
<td></td>
<td>10π/N</td>
<td>80</td>
</tr>
</tbody></table>
<p>在实际设计中，选择Chebyshev（切比雪夫）窗，其主要特点为：在给定窗口长度的情况下，能够提供最小的主瓣宽度。因此，通过选用Chebyshev窗，在频域上最小化主瓣的振幅波动，以实现滤波器的设计。</p>
<p>除此之外，设计时还指定采样频率为500Hz，阻带频率设计为35Hz，确定好参数后可在filterDesigner工具中导出为MATLAB函数：</p>
<p><img src="/images/ecg/media/image24.png" alt="图3.7：基于filterDesigner工具的FIR数字低通滤波器设计及其生成的MATLAB代码"><img src="/images/ecg/media/image25.png" alt="图3.7：基于filterDesigner工具的FIR数字低通滤波器设计及其生成的MATLAB代码"></p>
<p>在主程序中调用生成的滤波器函数构造一个FIR数字低通滤波器实例，并利用filter函数对于直流陷波后的波形数据进行FIR滤波并通过plot函数绘制滤波后的频谱，代码与结果如下所示：</p>
<p><img src="/images/ecg/media/image26.png" alt="图3.8：信号经FIR数字低通滤波后频谱分析绘制MATLAB代码及其运行结果"><img src="/images/ecg/media/image27.png" alt="图3.8：信号经FIR数字低通滤波后频谱分析绘制MATLAB代码及其运行结果"></p>
<p>可以看到，在加入了数字低通滤波器进行滤波后，50Hz处的工频干扰完全被消除，说明该滤波器的设计有效并起到了很好的效果。</p>
<h3 id="3-4-滤波结果综合分析"><a href="#3-4-滤波结果综合分析" class="headerlink" title="3.4 滤波结果综合分析"></a>3.4 滤波结果综合分析</h3><p>通过IIR和FIR滤波器的级联处理，最终获得了较为清晰的心电信号波形（如图3.9所示）。此过程有效去除了干扰，为后续心率计算和信号分析提供了可靠的基础。</p>
<p><img src="/images/ecg/media/image28.png" alt="图3.9 滤波后心电图结果"><img src="/images/ecg/media/image29.png" alt="图3.9 滤波后心电图结果"></p>
<p><img src="/images/ecg/media/image30.png" alt="图3.10 信号频谱对比图"><img src="/images/ecg/media/image31.png" alt="图3.10 信号频谱对比图"></p>
<p>为了更直观地展示信号处理过程的效果，对心电信号在各个处理阶段的频谱进行了对比分析。图3.10中显示了原始心电信号以及经过直流陷波器和FIR低通滤波器联合处理后的信号频谱图。</p>
<p>从原始心电信号频谱可以看出，信号中存在显著的工频干扰（约50Hz）和低频基线漂移（频率较低）。此外，信号还包含较多高频噪声，影响了心电信号的质量。经过直流陷波器处理后，低频基线漂移明显被抑制，低频成分显著减少但同时工频干扰和高频噪声依然存在，但其幅值未发生明显变化，表明直流陷波器主要对低频干扰起到作用；在应用FIR低通滤波器后，信号中50Hz附近的工频干扰被有效抑制，同时高频噪声也显著减弱。</p>
<p>最终处理后的频谱显示出清晰的心电信号主频成分（低于30Hz），为后续的R波检测与心率计算提供了可靠的基础。</p>
<h3 id="3-5-心率计算"><a href="#3-5-心率计算" class="headerlink" title="3.5 心率计算"></a>3.5 心率计算</h3><p>在对原始心电信号完成滤波处理后，可进一步估算心率这一关键生理参数。心率的计算基于心电信号中的R波峰值检测，通过分析相邻R波之间的R-R间期推算心率值。R波的检测是心率估算的关键环节。在此实验中，采用MATLAB函数findpeaks来检测心电信号中的峰值。为提高检测精度，将滤波后的信号进行缩放，并设置峰值检测的阈值为信号均值加一倍标准差。</p>
<p>检测到R波位置后，可通过计算相邻峰值位置之间的时间间隔（R-R间期）来估算心率。使用diff函数计算相邻R波的时间间隔并计算R-R间期的平均值，并根据如下公式计算出心率：</p>
<p>$$<br>心率 = \frac{60}{平均R - R间期}<br>$$<br><img src="/images/ecg/media/image32.png" alt="图3.11 MATLAB心率计算代码"></p>
<p>最终得出结果为60.29bpm，对比实际信号发生仪60bmp的心率，可以较为准确地估算心率，其结果符合误差小于10%的预期。</p>
<h2 id="4-STM32程序设计与参数选择"><a href="#4-STM32程序设计与参数选择" class="headerlink" title="4 STM32程序设计与参数选择"></a>4 STM32程序设计与参数选择</h2><p>项目代码已推送至Github远程仓库：<a target="_blank" rel="noopener" href="https://github.com/Asgard-Tim/ECG_Final_Project">Asgard-Tim/ECG_Final_Project</a></p>
<h3 id="4-1-单片机程序架构设计"><a href="#4-1-单片机程序架构设计" class="headerlink" title="4.1 单片机程序架构设计"></a>4.1 单片机程序架构设计</h3><p>为实现2.1节所提出的基本功能，除了要采集心电数据并对其进行滤波、显示时域波形外，还需要对滤波后的波形进行频谱分析并显示。为了更高效地完成这一过程，系统引入了快速傅里叶变换（FFT）算法，用于将时域信号转化为频域信号，便于分析信号的频谱特性。然而，由于FFT计算量较大，尤其是在较高采样率下，需要处理大量的点，因此为了加快运行速度，程序采用了FreeRTOS实时操作系统，分别对信号滤波和频谱分析进行任务划分和并行处理。</p>
<p><img src="/images/ecg/media/image33.png" alt="图4.1 单片机程序工程基本工作框架"></p>
<p>在系统的实现中，FreeRTOS将任务分为信号采集与滤波任务ECG和FFT计算任务。如上图所示，信号采集任务负责从ADS1292R中读取原始心电信号，并完成IIR和FIR滤波的处理，将滤波后的数据存储到循环缓冲区中，通过中断驱动的方式与传感器交互，确保数据的实时性和可靠性；而FFT计算任务则专注于对缓冲区中的数据进行频谱分析，每当缓冲区填满指定数量的数据点时，FFT计算任务将被启动，这虽然会导致实际运行时FFT频谱更新会产生一定的延时，但这样的设计将使得整个系统的工作更加稳定可控。</p>
<p>通过引入FreeRTOS，系统充分利用了单片机的多任务并行能力，使信号滤波和频谱分析的运行效率大幅提升，同时保证了心电信号处理的实时性。滤波和频谱分析的结合，不仅提高了信号的可用性，还为后续的心率计算和心电异常检测提供了更加丰富和可靠的数据支持。</p>
<h3 id="4-2-采集原始数据解码"><a href="#4-2-采集原始数据解码" class="headerlink" title="4.2 采集原始数据解码"></a>4.2 采集原始数据解码</h3><p>通过SPI接口，STM32微控制器不断与ADS1292R传感器进行交互，读取其输出的24位数字信号数据。基于3.1节提到的价码规则，将读取到的数据经过必要的解码和处理后，可将其转换为实际的电压值，并进一步用于实时显示与分析。其核心代码如下所示：</p>
<p><img src="/images/ecg/media/image34.png" alt="图4.2 ADS1292R原始数据解码核心代码"><img src="/images/ecg/media/image35.png" alt="图4.2 ADS1292R原始数据解码核心代码"></p>
<p>在具体实现中，通过将ADS1292R的24位原始数据解码为32位有符号整数，消除了符号位可能引起的误差。随后，将解码后的信号根据增益和参考电压转换为实际的电压值。这一过程中，左导联和右导联的连接状态也会被实时检测，以确保数据采集的可靠性。如果导联连接异常（如电极松动），系统会发出提示并暂停后续的采集。</p>
<h3 id="4-3-处理算法移植：滤波器"><a href="#4-3-处理算法移植：滤波器" class="headerlink" title="4.3 处理算法移植：滤波器"></a>4.3 处理算法移植：滤波器</h3><p>经过STM32接收心电信号后，系统根据PC端设计好的滤波器方案对原始信号进行双重滤波处理，先通过IIR滤波器消除直流分量，然后利用FIR滤波器进一步去除高频噪声，从而得到更为清晰的心电信号。经过IIR和FIR滤波后的信号显著改善，直流漂移、工频干扰以及高频噪声均被有效抑制，这一改进不仅提高了信号的可分析性，也为后续的特征提取与心率计算打下了坚实基础。</p>
<p>滤波后，处理得到的心电信号被传输至PC端，并通过可视化工具显示其改进的波形。如下图所示，信号的基线漂移已完全消除，高频噪声也显著减弱。滤波后的心电信号为后续的心率估算和其他心电特征分析提供了高质量的数据输入，从而提升了系统的整体性能和实用性。</p>
<p><img src="/images/ecg/media/image36.png" alt="图4.3：PC端可视化软件中显示采集到的滤波后心电信号（解码后）"></p>
<h4 id="4-3-1-IIR数字直流陷波器"><a href="#4-3-1-IIR数字直流陷波器" class="headerlink" title="4.3.1 IIR数字直流陷波器"></a>4.3.1 IIR数字直流陷波器</h4><p>在IIR滤波阶段，STM32程序参考了PC端的滤波器设计，实现了高效的实时滤波。IIR滤波器的核心算法通过递归关系计算当前输出值，其中参数a=0.992控制直流分量的衰减程度。算法以较少的存储空间完成了对信号直流漂移的有效抑制，使用上一输入与上一输出值的递归关系更新当前输出值，从而达到实时滤波的目的。</p>
<p><img src="/images/ecg/media/image37.png" alt="图4.4：IIR数字直流陷波器单片机C语言代码"></p>
<h4 id="4-3-2-FIR数字低通滤波器"><a href="#4-3-2-FIR数字低通滤波器" class="headerlink" title="4.3.2 FIR数字低通滤波器"></a>4.3.2 FIR数字低通滤波器</h4><p>经过IIR滤波后，信号中的直流分量被有效去除，但仍可能含有工频干扰和其他高频噪声。因此，信号会进一步通过FIR滤波器进行处理。FIR滤波器利用一个固定长度的滑动队列实现，其滤波系数矩阵B由MATLAB中的filterDesigner工具生成并导出到C代码中。该滤波运算采用定点方式，在初始化时需要将滤波器系数乘以66536（如图4.5中右图所示），再取整保存为16bits整数。该部分的核心算法是，通过遍历队列数据与滤波器系数进行逐项乘积累加，实现对信号的精准滤波。代码设计充分考虑了队列操作的效率，通过队列循环的方式减少内存消耗并保证实时性。</p>
<p><img src="/images/ecg/media/image38.png" alt="图4.5：filterDesigner导出系数矩阵B的部分结果及FIR滤波器参数初始化"><br><img src="/images/ecg/media/image39.png" alt="图4.5：filterDesigner导出系数矩阵B的部分结果及FIR滤波器参数初始化"></p>
<p><img src="/images/ecg/media/image40.png" alt="图4.6：FIR数字低通滤波器核心算法单片机C语言代码"></p>
<h3 id="4-4-处理算法移植：心率与幅值计算"><a href="#4-4-处理算法移植：心率与幅值计算" class="headerlink" title="4.4 处理算法移植：心率与幅值计算"></a>4.4 处理算法移植：心率与幅值计算</h3><p>系统的心跳检测功能基于心电信号的峰谷变化，通过heartbeat_check函数实现对R波峰值的实时检测。该函数采用简单高效的阈值法，以波峰和波谷之间的差值判断是否发生心跳事件。函数的核心逻辑包括记录当前波形的上升和下降趋势，以及动态调整波峰（up_value）和波谷（down_value）的值。</p>
<p>具体来说，当检测到波形从下降趋势转为上升趋势，且波峰与波谷的差值超过设定的阈值（经过调试设置为0.55较为合适），即判定为一次心跳事件。此时，波峰和波谷会重新初始化，为下一次心跳检测做好准备。如果当前波形变化幅度未达到阈值，则认为是噪声或非心跳波形，函数返回0。</p>
<p>在实际应用中，该函数与DWT模块配合使用，每次心跳事件发生时记录时间戳，通过计算相邻两次事件的时间间隔（R-R间期）估算心率。高精度的DWT计数器和简洁的心跳检测算法相结合，使得系统能够在保证实时性的同时，准确识别心跳并计算心率。</p>
<p><img src="/images/ecg/media/image41.png" alt="图4.7：单次心跳检测函数heartbeat_check代码"></p>
<p><img src="/images/ecg/media/image42.png" alt="图4.8：心率计算函数calc_heartbeat_rate代码（基于单次心跳的检测结果）"></p>
<p>为衡量心率信号的幅值范围，编写函数 Cal_PeakToPeak 以计算一组浮点数数据的峰峰值，即数据中的最大值与最小值之间的差值，用以反映数据的动态范围或振幅。函数通过接收一个浮点数数组 samples 和数组中的元素个数 sample_count 作为输入，首先将数组的第一个元素初始化为当前的最大值和最小值，然后从第二个元素开始逐一遍历整个数组。在遍历过程中，函数逐步更新最大值 max 和最小值 min，确保能够捕获数据中的真实极值。遍历完成后，函数通过计算 max - min 得到峰峰值，并将结果作为返回值。整个过程采用单次遍历的方法，计算效率较高，适合处理较大规模的采样数据。</p>
<p><img src="/images/ecg/media/image43.png" alt="图4.9：幅值检测函数Cal_PeakToPeak代码"></p>
<h3 id="4-5-TFT屏幕绘制采集波形"><a href="#4-5-TFT屏幕绘制采集波形" class="headerlink" title="4.5 TFT屏幕绘制采集波形"></a>4.5 TFT屏幕绘制采集波形</h3><p>TFT屏幕是系统的重要输出模块，负责实时显示处理后的心电波形和心率数据。通过高分辨率和快速刷新率，TFT屏幕能够清晰呈现心电信号的变化，供用户随时监控自己的心脏健康状况。它不仅显示心电波形，还提供当前的心率和可能的异常信号提示，帮助用户及时发现问题。</p>
<p><img src="/images/ecg/media/image44.png" alt="图4.10 2.8寸TFT LCD电阻触摸屏模块320\*240实物图"></p>
<p>对于已经滤波后的心电信号，在移植并调用原有LCD驱动库的基础上，编写了drawCurve函数实现实时的波形显示。该函数根据输入的心电信号数值，将其映射到屏幕的像素坐标，并绘制出连续的曲线。</p>
<p><img src="/images/ecg/media/image45.png" alt="图4.11：TFT屏幕波形绘制函数drawCurve代码"></p>
<p>可以看到，对于滤波后的心电信号值，除了基本的指定区域绘制波形外，为避免波形超出屏幕边界，还对计算得到的y坐标进行上下限约束，使其始终位于屏幕的有效显示区域内：如果y坐标超过屏幕范围，则自动截断至边界位置；当x坐标超出屏幕宽度时，程序清空屏幕并从起始位置重新开始绘制新的波形。通过这种循环显示方式，确保波形在屏幕上以滚动形式连续更新，为实时心电信号的监测提供直观的显示效果。</p>
<h3 id="4-6-频谱分析及其TFT屏幕绘制"><a href="#4-6-频谱分析及其TFT屏幕绘制" class="headerlink" title="4.6 频谱分析及其TFT屏幕绘制"></a>4.6 频谱分析及其TFT屏幕绘制</h3><p>在频谱FFT计算的具体实现中，程序使用CMSIS-DSP库提供的高效FFT算法，首先将心电信号数据打包为复数输入，其中实部为滤波后的心电数据，虚部置为零。随后调用arm_cfft_radix4_f32函数完成快速傅里叶变换，并通过arm_cmplx_mag_f32函数计算复数频谱的幅值。计算结果存储在FFT输出缓冲区中，用于后续的频谱绘制。</p>
<p><img src="/images/ecg/media/image46.png" alt="图4.12：频谱计算（FFT）函数FFT_Calculate代码"></p>
<p>对于频域波形，系统通过FFT算法计算心电信号的频率分量，并将其可视化为频谱图。频谱图的x轴代表频率，y轴代表频率分量的幅值，能够直观反映心电信号的频率特性。频域波形的可视化主要依赖Draw_Spectrum函数：</p>
<p><img src="/images/ecg/media/image47.png" alt="图4.13：频谱绘制函数Draw_Spectrum代码"></p>
<p>由于屏幕高度有限，为避免绘图时坐标溢出，函数将FFT输出的幅值限制在合理范围内（0到150，其余位置留给时域波形）。当幅值超过上限或低于下限时，进行截断处理。每个频率分量对应一条垂直线，从屏幕底部开始绘制到计算得到的y坐标。</p>
<h2 id="5-程序测试方法"><a href="#5-程序测试方法" class="headerlink" title="5 程序测试方法"></a>5 程序测试方法</h2><h3 id="5-1-ADS1292R驱动移植及引脚配置"><a href="#5-1-ADS1292R驱动移植及引脚配置" class="headerlink" title="5.1 ADS1292R驱动移植及引脚配置"></a>5.1 ADS1292R驱动移植及引脚配置</h3><p>首先，在通过STM32CubeMX创建工程时，需要配置单片机的时钟速率，SPI接口，中断以及UART串口通信等。为实现与ADS1292R传感器的数据传输，选用SPI1并对引脚进行如下配置：</p>
<p><img src="/images/ecg/media/image48.png" alt="图5.1：SPI1引脚与参数配置"></p>
<p>其中与ADS1292R传感器通信的SPI接口配置为主模式，时钟极性为CPOL=LOW，时钟相位为CPHA=2EDGE，数据帧格式为8位，通信速率依据传感器要求设置在8MHz以下，此处设置为656.25Kbit/s。</p>
<p>此外，还需要根据ADS1292R库文件中的说明，对UART通信进行设置，其中波特率设置为115200，8位数据位，1位停止位，无校验。</p>
<p><img src="/images/ecg/media/image49.png" alt="图5.2：UART引脚与参数配置"></p>
<p>完成引脚配置后就可以进行初始代码生成。在生成的初始代码工程中，引入ADS1292R的相关库文件（ADS1292R.c与ADS1292R.h），根据对应的配置代码将STM32F407开发板与ADS1292R传感器模块进行连线：</p>
<p><img src="/images/ecg/media/image50.png" alt="图5.3：ADS1292R.h与spi.c代码文件中关于连线的相关说明"><img src="/images/ecg/media/image51.png" alt="图5.3：ADS1292R.h与spi.c代码文件中关于连线的相关说明"></p>
<p><img src="/images/ecg/media/image52.jpeg" alt="图5.4：连线实物图"><br><img src="/images/ecg/media/image53.jpeg" alt="图5.4：连线实物图"></p>
<p>连线完成后，要通过SPI接口实现与ADS1292R的数据交互，还需要在主程序中完成相应的初始化，即调用ADS1292R驱动库中的相关函数，由单片机向ADS1292R发送相应的命令以启动数据采集，并配置工作模式、采样速率、增益等参数。根据ADS1292R数据手册及项目要求，以下是对ADS1292R的主要配置过程：</p>
<p><img src="/images/ecg/media/image54.png" alt="图5.5：函数ADS1292_PowerOnInit中对于ADS1292R的基本配置代码"></p>
<p>首先，将ADS1292R的CONFIG2寄存器配置为0xA3，以启用内部参考电压。内部参考电压的稳定性对于后续心电信号的准确采集至关重要，因此在配置完成后需通过DWT_Delay_ms(10)添加延时，确保内部参考电压稳定。随后，将CONFIG1寄存器设置为0x02，配置心电采集的采样速率为500SPS（Samples Per Second），这一速率能够兼顾信号的时域分辨率和数据量。</p>
<p>接下来，对通道1和通道2进行配置。其中，通道1的CH1SET寄存器设置为0x00，表示通道1工作于正常采集模式，且未启用测试信号输入。通道2的CH2SET寄存器配置为0x05，用于指定通道2采集来自内部测试信号的方波，方便在调试阶段验证系统的采集和传输功能。</p>
<p>此外，为了进一步优化信号的质量，对右腿驱动（RLD）电极进行了配置，通过将RLD_SENS寄存器设置为0x2C，使右腿驱动电极同时连接到通道1和通道2，增强了共模信号的抑制能力。在呼吸阻抗测量相关功能中，将RESP1和RESP2寄存器分别配置为0x02和0x03，根据手册要求开启适当的工作模式。</p>
<p>通过上述配置，ADS1292R可以稳定运行于双通道心电采集模式，通道1用于实时采集患者的心电信号，通道2可用于采集ADS1292R传感器的测试信号以验证该传感器模块是否被正常驱动。</p>
<h3 id="5-2-ADS1292R驱动移植验证：读取传感器设备ID"><a href="#5-2-ADS1292R驱动移植验证：读取传感器设备ID" class="headerlink" title="5.2 ADS1292R驱动移植验证：读取传感器设备ID"></a>5.2 ADS1292R驱动移植验证：读取传感器设备ID</h3><p>事实上，在ADS1292_PowerOnInit函数中，图5.5所示初始化代码之前还有一段代码：</p>
<p><img src="/images/ecg/media/image55.png" alt="图5.6：ADS1292_PowerOnInit初始化函数部分代码"></p>
<p>可以看到，要实现5.1节中对于ADS1292R传感器模块的正确驱动，就必须要顺利运行该段代码，其中调用了ADS1292_ReadDeviceID这一函数并设置了判断条件，若读取到的设备ID不为83（ADS1292）或115（ADS1292R）则会一直循环读取ID而不进行后续的初始化，以确保读取的心电信号不会出现无效数据且采集数据符合预期格式。由于本次项目使用的传感器芯片为ADS1292R，故成功读取到并在串口助手中打印的device_id为115，这也证明驱动库文件的移植是正确的且能正常驱动该传感器模块。</p>
<h3 id="5-3-ADS1292R驱动移植验证：测试信号采集及其TFT屏幕绘制"><a href="#5-3-ADS1292R驱动移植验证：测试信号采集及其TFT屏幕绘制" class="headerlink" title="5.3 ADS1292R驱动移植验证：测试信号采集及其TFT屏幕绘制"></a>5.3 ADS1292R驱动移植验证：测试信号采集及其TFT屏幕绘制</h3><p>在ADS1292R的芯片数据手册中，给出了其内置测试信号的相关参数：</p>
<p><img src="/images/ecg/media/image56.png" alt="图5.7：ADS1292R芯片手册测试信号部分"></p>
<p>可以看到，当PGA增益倍数设置为1时，芯片将输出测试方波信号，通过MATLAB读取并解码原始数据，得到（含直流）范围在-20到8；而去除直流后，该方波动态范围为-14到14。由于参考电压为2.4V（16bits），此时14/32768*2400mv<br>约等于1mv，说明此时方波动态范围转换为电压是正负1mv，和数据手册说明一致。方波测试信号的成功读取也进一步验证了ADS1292R驱动库移植的正确性且能正常驱动该传感器模块。</p>
<p><img src="/images/ecg/media/image57.png" alt="图5.8：MATLAB读取测试方波结果"></p>
<p>图5.8：MATLAB读取测试方波结果</p>
<h2 id="6-实验数据记录与分析"><a href="#6-实验数据记录与分析" class="headerlink" title="6 实验数据记录与分析"></a>6 实验数据记录与分析</h2><p>演示视频链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HWCkYzETe/">https://www.bilibili.com/video/BV1HWCkYzETe/</a></p>
<h3 id="6-1-测试信号采集"><a href="#6-1-测试信号采集" class="headerlink" title="6.1 测试信号采集"></a>6.1 测试信号采集</h3><p>在测试ADS1292的内部方波信号时，设置PGA增益为1，测试结果显示方波波形良好，基本无误差。系统能够准确读取方波信号的峰峰值和幅度值，其效果如图所示：</p>
<p><img src="/images/ecg/media/image58.jpeg" alt="图6.1：采集测试信号在LCD屏幕上的显示效果（测量幅度值为155）"></p>
<p>此外，系统新增了按键功能，按压KEY_0即可实现在显示测试信号波形与显示心电信号波形间切换。</p>
<h3 id="6-2-模拟器心电信号采集"><a href="#6-2-模拟器心电信号采集" class="headerlink" title="6.2 模拟器心电信号采集"></a>6.2 模拟器心电信号采集</h3><p>在实际运行中，drawCurve函数结合系统滤波模块的输出数据和心跳检测结果，将心电信号时域与频域的动态变化以实时曲线的形式绘制在屏幕上。同时，在屏幕上显示心率、波幅等关键参数，进一步增强了系统的直观性和信息量。其效果如下图所示：</p>
<p><img src="/images/ecg/media/image59.jpeg" alt="图6.2：BPM为60的心电信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p>经过测试，测算出的心率值与心电模拟仪中给出的心率值误差不超过3 BPM（每分钟心跳数），满足系统设计需求；但此时滤波器的滤波效果有点过度，也可能是显示的波形幅度调整的不好，导致最终显示的波形丢失了过多的有用信息。</p>
<h3 id="6-3-模拟器心率信号采集"><a href="#6-3-模拟器心率信号采集" class="headerlink" title="6.3 模拟器心率信号采集"></a>6.3 模拟器心率信号采集</h3><p>将模拟器调至2档（心率档），产生的心率信号默认为75BPM，此时时域与频域波形的显示效果如下：</p>
<p><img src="/images/ecg/media/image60.jpeg" alt="图6.3：BPM为75的心率信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p>可以看到，此时测得的心率基本准确，与心电模拟仪中给出的心率值误差不超过3 BPM，满足系统设计需求，且频谱图也有较明显的尖峰且噪声较少；此时滤波器的滤波效果虽然也有点过度了，但效果明显由于6.2节中对于心电信号的测量，有明显的波峰。</p>
<p>心跳检测功能的设计不仅能够适应动态变化的心电信号，还通过灵活的阈值调整提高了对不同信号幅度的适应性。将模拟器调至8档，以调整产生心率信号的幅值（心率BPM仍为75），采集与显示效果如下：</p>
<p><img src="/images/ecg/media/image61.jpeg" alt="图6.4：幅值为1mV的心率信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p><img src="/images/ecg/media/image62.jpeg" alt="图6.5：幅值为2mV的心率信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p><img src="/images/ecg/media/image63.jpeg" alt="图6.6：幅值为3mV的心率信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p>可以看到，随着心率信号幅值的成倍变化，测量出的波形幅值也在成倍变化，且频谱较为干净，这说明该心电信号采集系统对于不同的信号幅度具有较高的灵敏性，但未对测量的幅值数值进行对应电压的换算导致结果并不直观；同时由于测量心率程序中对于检测跳变幅度的阈值设置较小，导致此时当幅值明显增大时，震荡信号的跳变幅度也随之增加，导致心率测量出现一定程度的偏差。</p>
<h3 id="6-4-人体心电信号采集与测量"><a href="#6-4-人体心电信号采集与测量" class="headerlink" title="6.4 人体心电信号采集与测量"></a>6.4 人体心电信号采集与测量</h3><p>未接入人体心电信号时，采集到信号的时域波形与频谱如下：</p>
<p><img src="/images/ecg/media/image64.jpeg" alt="图6.7：未接入任何心率信号时LCD屏幕上显示的时域与频域波形（白板）"></p>
<p>对于人体心电信号检测，由于心电电极对接触状态的敏感性，最佳效果仅在涂抹酒精并佩戴三分钟内获得，因此系统仅能在心电电极贴附于人体的短时间内实现精确检测</p>
<p>在实际测试时，邀请室友将电极片分别贴于手腕和脚部，并分别与数据线连接，此时系统采集到的心电波形如下所示（详细测试过程在演示视频中）：</p>
<p><img src="/images/ecg/media/image65.jpeg" alt="图6.8：人体心电信号测试过程掠影"><br><img src="/images/ecg/media/image66.jpeg" alt="图6.8：人体心电信号测试过程掠影"></p>
<p><img src="/images/ecg/media/image67.png" alt="图6.9：采集到的人体心电信号时域与频域波形显示结果"></p>
<p>从图中可以看出，检测人体心电信号时，波形与心电信号模拟仪的输出相比仅存在轻微差别，整体表现良好，但仍然存在滤波过度的问题。</p>
<p>除了将电极贴于手腕和脚部进行测试外，系统还测试了将电极贴在左右锁骨中线第一肋间和胸骨左缘第四肋间的位置。测试结果显示，这些位置的信号稳定性优于手脚部位，并且能够维持更长时间的良好效果。</p>
<h2 id="7-实验结果总结和心得体会"><a href="#7-实验结果总结和心得体会" class="headerlink" title="7 实验结果总结和心得体会"></a>7 实验结果总结和心得体会</h2><h3 id="7-1-实验结果"><a href="#7-1-实验结果" class="headerlink" title="7.1 实验结果"></a>7.1 实验结果</h3><p>在本项目中，基于 STM32F407ZG 主控芯片和 ADS1292R 传感器模块，成功实现了人体心电信号的采集与分析功能。针对心电信号易受工频干扰和低频基线漂移影响的问题，设计并实现了 IIR 数字直流陷波器 和 FIR 数字低通滤波器，有效消除了干扰并获得了较为清晰的心电波形。</p>
<p>在开发过程中，利用心电信号模拟仪对单片机程序进行了调试，使系统能够稳定采集和显示心电波形。尽管滤波器在MATLAB仿真中效果良好，但移植到单片机工程中后，出现了滤波过度的问题。初步分析认为，这可能与信号采样频率、显示波形的幅度比例调节以及滤波算法的具体实现有关，仍需进一步优化。然而，系统总体性能令人满意，其采集效果、频域分析结果、心电峰峰值及心率测算结果均较为准确。</p>
<p>此外，系统还实现了对 ADS1292R模块自带测试方波信号的读取、显示以及峰峰值测量功能，基本满足了所有的设计需求。最终也成功采集并显示了实际人体心电信号的时域波形与频谱。</p>
<h3 id="7-2-心得体会"><a href="#7-2-心得体会" class="headerlink" title="7.2 心得体会"></a>7.2 心得体会</h3><p>通过本次项目的实践，我对数字信号的采集与处理以及滤波器的设计与实现有了更加深刻的理解。这不仅加深了我对数字信号处理理论知识的掌握，还让我在理论与实践的结合中得以进一步巩固相关技能。在单片机的编程实践与调试过程中，我对STM32尤其是F4系列开发板的硬件和软件开发有了更深入的认识，这大大提升了我的开发效率和调试能力。</p>
<p>本项目也是我首次尝试使用 FreeRTOS操作系统搭建整个工程框架。在此过程中，我学习并掌握了实时操作系统的基本原理和任务调度机制，初步理解了如何优化系统资源管理，成功地将操作系统的使用融入到嵌入式项目开发中。这一尝试不仅丰富了我的开发经验，也让我更好地认识到实时操作系统在复杂工程中的价值。</p>
<p>尽管最终心电信号的显示结果并未完全达到预期，但我从问题中发现了自身在信号采集频率、滤波算法实现以及系统显示优化方面的不足，并明确了未来改进的方向。整个项目开发的过程充满了挑战，同时也伴随着大量的收获。我深刻体会到硬件开发与数字信号处理是一个不断探索和优化的过程，而这次项目实践无疑为我在这些领域的技能提升打下了坚实基础。</p>
<p>此外，本次项目还培养了我独立分析和解决问题的能力。从模块功能的实现到整体工程的构建，我逐步熟悉了完整的开发流程，对系统的设计、调试和优化有了更加系统化的认识。我相信，这些经验和能力将在今后的学习和工作中发挥重要作用，为更高层次的开发任务奠定基础。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 朱冰莲,方敏编著.数字信号处理[M].电子工业出版社,2014:276.</p>
<p>[2] 程佩青编著.数字信号处理教程[M].清华大学出版社,2015:524.</p>
<p>[3] 任勇,曾浩编著.单片机原理及应用[M].清华大学出版社,2023.</p>
<p>[4] 德州仪器. ADS1292 数据手册</p>
<p>[5] 任勇. CQU_S12XDEV开发板原理图 微电子与通信工程学院</p>
<p>[6] 任勇. ADS1292-心电信号采集原理图及接口说明-RY</p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-12-21T18:15:03.000Z" title="2024/12/22 02:15:03">2024-12-22</time>发表</span><span class="level-item"><time datetime="2025-03-02T17:56:40.547Z" title="2025/3/3 01:56:40">2025-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/">自动控制原理</a></span><span class="level-item">3 小时读完 (大约30100个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/12/22/control/">基于直流电源调控的自动调光控制设计</a></p><div class="content"><div id="postchat_postcontent"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本项目围绕直流电源调控的自动调光控制系统展开研究与设计，系统性地探讨了Buck变换器的基本原理、建模方法、性能分析及其实验验证过程。在硬件设计方面，基于STM32处理器，选择了高性能的元器件并通过合理的电路拓扑实现高效的能量转换；在软件控制算法方面，采用PID闭环控制，并结合自动控制原理中的经典控制理论，利用PSIM与MWorks等仿真与科学计算工具，对控制系统的时域响应、频域特性和稳定性进行了详尽分析，进而通过参数优化与校正环节设计显著提升了系统的响应速度和稳态性能，同时也验证了闭环控制系统在动态性能、抗干扰能力和输出精度方面的显著优势。此外，通过实验测量与仿真结果对比，探讨了电路寄生参数对系统性能的影响，为后续优化提供了理论依据。在基于光敏电阻的自动调光功能模块中，结合蓝牙通信接口实现了系统的智能化控制，同时对于自动调光系统进行外观设计，赋予产品更多的人文关怀与实用价值；在光伏板最大功率点跟踪（MPPT）功能模块中，根据MPPT的原理与基本思想设计了相应的控制算法，并在实验中成功控制光伏板输出功率，使其约等于负载消耗功率，完成了不同光照强度下最大功率点的跟踪。最后，对于该自动控制系统的设计成果及其在实际应用中的可行性与局限性进行总结，并对未来可能的优化方向和工程实现前景提出了展望。</p>
<p><strong>关键词：</strong>Buck变换器；PID闭环控制；自动调光；光伏MPPT</p>
<h2 id="1-课程涉及理论基础和STM32简介"><a href="#1-课程涉及理论基础和STM32简介" class="headerlink" title="1 课程涉及理论基础和STM32简介"></a>1 课程涉及理论基础和STM32简介</h2><h3 id="1-1-自动控制原理简介"><a href="#1-1-自动控制原理简介" class="headerlink" title="1.1 自动控制原理简介"></a>1.1 自动控制原理简介</h3><p>在科学技术飞速发展的今天，自动控制技术和理论已经成为现代社会不可缺少的组成部分。自动控制技术的应用不仅使生产过程实现自动化，从而提高了劳动生产率和产品质量，降低了生产成本，提高了经济效益，改善了劳动条件，使人们从繁重的体力劳动和单调重复的脑力劳动中解放出来；而且在人类征服大自然、探索新能源、发展空间技术和创造人类社会文明等方面都具有十分重要的意义。</p>
<p>自动控制理论是研究关于自动控制系统组成、分析和综合的一般性理论，是研究自动控制共同规律的技术科学。自动控制是在人不直接参与的情况下，利用外加的自动控制设备或装置（控制装置或控制器），使机器、设备或生产过程（统称为被控对象）的某个工作状态或参数（被控量）自动地按照预定的规律运行，使机器的动作、设备的运转、生产过程的状态能够自动地在一定的精度范围内按照给定的规律变化。学习和研究自动控制理论是为了探索自动控制系统中变量的运动规律和改变这种运动规律的可能性和途径，为建立高性能的自动控制系统提供必要的理论依据。</p>
<h3 id="1-2-本项目所涉及的经典控制理论内容"><a href="#1-2-本项目所涉及的经典控制理论内容" class="headerlink" title="1.2 本项目所涉及的经典控制理论内容"></a>1.2 本项目所涉及的经典控制理论内容</h3><p><img src="/images/control/media/image2.png" alt="图1.1：项目涉及的经典控制理论框图"></p>
<p>本项目从经典控制理论的基本原理与概念出发，以Buck变换器这一单输入-单输出的线性系统作为研究对象，利用微分方程、Laplace变换与传递函数等数学工具建立系统的数学模型，并基于时域分析、频域分析以及根轨迹法等多种分析方法对于系统的稳定性与响应特性进行详细分析，从而针对特定的性能指标进行对应的校正设计，通过引入PID控制器并调控其参数以改变系统的频率特性从而满足给定的各项性能指标，使得整个闭环控制系统能够兼具稳定性、快速性与准确性。</p>
<h3 id="1-3-STM32处理器介绍"><a href="#1-3-STM32处理器介绍" class="headerlink" title="1.3 STM32处理器介绍"></a>1.3 STM32处理器介绍</h3><p>控制核心是控制系统中的重要组成部分，用于计算、解析各种数据，并执行相应的控制算法。芯片选型的设计直接决定了控制板的性能和功能。STM32是由意法半导体公司（ST）推出的基于Arm Cortex-M处理器内核的32位微控制器，专为要求高性能、低成本、低功耗的嵌入式应用设计，集实时功能、数字信号处理、低功耗/低电压操作、连接性等特性于一身，同时还保持了集成度高和易于开发的特点，基于行业标准内核，提供了大量工具和软件选项以支持工程开发，非常适用于小型项目或端到端平台。</p>
<p>本项目选用的处理器STM32F103C8T6作为中等容量高性能系列MCU，集成了工作频率为72MHz的高性能Arm Cortex-M3 32位RISC内核、高速嵌入式存储器（高达128KB的Flash存储器和20KB的SRAM存储器），以及大量连接至2条APB总线的增强型I/O与外设，具有36引脚至100引脚等6种不同的封装类型。所有器件均提供2个12位ADC、3个16位通用定时器、2个PWM定时器以及标准和高级通信接口：多达2个I2C和SPI、3个USART、1个USB和1个CAN。器件的工作电压为2.0V至3.6V。该处理器的工作温度范围为-40℃到+85℃，可扩展至-40℃到+105摄氏度。这些特性使得该处理器成为各种应用的理想之选，也能很好满足本项目对于控制器的性能需求。</p>
<p><img src="/images/control/media/image3.png" alt="图1.2：本项目选用的处理器STM32F103C8T6"></p>
<h3 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h3><p>本章主要介绍了本课程相关的自动控制理论基础，针对本项目涉及到的经典控制理论框架进行了简要概述，同时对于本项目所选用的控制核心——STM32处理器进行简单介绍，重点分析了我们采用的STM32F103C8T6处理器的性能特性并给出选型原因。这为本课程项目提供了整体框架，并从理论上对后续项目的具体实施给出了方向性的指引。</p>
<h2 id="2-直流Buck变换器设计与调试"><a href="#2-直流Buck变换器设计与调试" class="headerlink" title="2 直流Buck变换器设计与调试"></a>2 直流Buck变换器设计与调试</h2><h3 id="2-1-Buck变换器拓扑原理分析"><a href="#2-1-Buck变换器拓扑原理分析" class="headerlink" title="2.1 Buck变换器拓扑原理分析"></a>2.1 Buck变换器拓扑原理分析</h3><p>Buck（降压式）变换器是一种输出电压≤输入电压的非隔离直流DC-DC变换器，其中输入电流为脉冲式的，而输出电流为连续的低纹波直流电压。Buck变换器实现的稳态输入输出关系为：<br>$$<br>U_{0} = DU_{in}<br>$$<br>Buck变换器的主电路由开关管Q，二极管D，输出滤波电感L和输出滤波电容C构成。</p>
<p><img src="/images/control/media/image4.png" alt="图2.1：Buck开关功率变换器基本电路"></p>
<p>可以看到，在能量缓冲变换电路中，主要由如下三个部分组成：</p>
<ol>
<li><p>电感L与电容C实质上构成了一个二阶低通滤波器，通过滤除开关频率交流分量而仅保留其直流分量，得到平直的输出电压U0；</p>
</li>
<li><p>脉冲宽度调制（Pulse Width Modulation，PWM）产生方波电压控制开关管Q的导通；</p>
</li>
<li><p>二极管D为电感电流提供续流回路。</p>
</li>
</ol>
<p>Buck变换器主电路整体的工作逻辑如下：</p>
<ol>
<li>当开关管Q驱动为高电平时，开关管导通，储能电感L被充磁，流经电感的电流线性增加，同时给电容C充电，给负载R提供能量；</li>
</ol>
<p><img src="/images/control/media/image5.png" alt="图2.2：开关管导通时电流环路"></p>
<ol start="2">
<li>当开关管Q驱动为低电平时，开关管关断，储能电感L通过续流二极管D放电，电感电流线性减少，输出电压靠输出滤波电容C放电以及减小的电感电流维持。</li>
</ol>
<p><img src="/images/control/media/image6.png" alt="图2.3：开关管关断时电流环路"></p>
<p>事实上，对于该电能变换器，可以通过更改个别元器件的种类、接入方式与顺序，实现搭建具有不同功能的电能变换电路，即Buck变换器的拓扑原理。下面列举几种常见的拓扑电路：</p>
<ol>
<li>升压变换器：</li>
</ol>
<p><img src="/images/control/media/image7.png" alt="图2.4：Buck变换器拓扑：降压--->升压"></p>
<ol start="2">
<li>降压同步整流变换：采用互补工作模式，可减小损耗</li>
</ol>
<p><img src="/images/control/media/image8.png" alt="图2.5：Buck变换器拓扑：同步整流"></p>
<ol start="3">
<li>H桥DC-AC逆变器：开关管部分串联构成双极性交流电压源</li>
</ol>
<p><img src="/images/control/media/image9.png" alt="图2.6：Buck变换器拓扑：DC-DC --->DC-AC"></p>
<ol start="4">
<li>闭环PWM控制：可以在原有Buck电路基础上增加闭环环路，通过PWM调配开关管Q的导通与否，从而实现对于输出电压的控制，使系统能够更加”稳”、”快”、”准”地得到期望的输出。目前的控制器选择主流为PID控制器，根据不同的指标又可将闭环控制系统分为不同类别：若根据控制对象分类，则可分为电压控制与电流控制；若根据接收调控信息的时间先后分类，又可分为反馈控制与前馈控制；根据其他的分类标准，还可分为线性/非线性控制、平均/纹波控制、模拟/数字控制……在此不一一列举。</li>
</ol>
<h3 id="2-2-Buck变换器元器件参数选择"><a href="#2-2-Buck变换器元器件参数选择" class="headerlink" title="2.2 Buck变换器元器件参数选择"></a>2.2 Buck变换器元器件参数选择</h3><p>在Buck变换主电路中，对电路参数进行如下设定：</p>
<ul>
<li><p>输入电压<br>$$<br>U_{in} = 15V<br>$$</p>
</li>
<li><p>输出电压<br>$$<br>U_{o} = 8V<br>$$</p>
</li>
<li><p>占空比<br>$$<br>d = 50%<br>$$</p>
</li>
<li><p>电源转换电压：12V、15V、5V、5V（隔离）</p>
</li>
<li><p>电感<br>$$<br>L = 100\mu F<br>$$</p>
</li>
<li><p>电容<br>$$<br>C = 660\mu F<br>$$</p>
</li>
<li><p>工作频率<br>$$<br>f = 25kHz<br>$$</p>
</li>
</ul>
<p>首先，为满足电源转换与单片机供电的需求，需要在电源直接引入Buck电路前先接入电源模块，涉及到的元器件及相关参数如下：</p>
<ol>
<li>URB2412YMD-10WR3电源模块：降压模块，将电源提供的输入电压（最大35V，本实验中为15V）转换为12V输出，提供0.83A的电流；</li>
</ol>
<p><img src="/images/control/media/image10.png" alt="图2.7：URB2412YMD-10WR3电源模块原理图与实物图"><img src="/images/control/media/image11.png" alt="图2.7：URB2412YMD-10WR3电源模块原理图与实物图"></p>
<ol start="2">
<li>CW7805线性稳压器：将12V输入电压转换为稳定的5V输出电压，并将输出电流转换成1A，分输入、输出与接地三端，主要用于使线性的输出电压稳定；</li>
</ol>
<p><img src="/images/control/media/image12.png" alt="图2.8：CW7805线性稳压器原理图与实物图"><img src="/images/control/media/image13.png" alt="图2.8：CW7805线性稳压器原理图与实物图"></p>
<ol start="3">
<li>A1215S-2WR3电源模块：升压模块，将12V输入转换为±15V，适合供给双电源运放电路，本实验中主要用于为采样电路（滤波器）供电；</li>
</ol>
<p><img src="/images/control/media/image14.png" alt="图2.9：A1215S-2WR3电源模块原理图与实物图"><img src="/images/control/media/image15.png" alt="图2.9：A1215S-2WR3电源模块原理图与实物图"></p>
<ol start="4">
<li>IB1205S-2W电源模块：降压模块，将12V输入转换为5V，通常用于低功耗电路的供电，本实验中主要用于光耦（与驱动）电路的供电。</li>
</ol>
<p><img src="/images/control/media/image16.png" alt="图2.10：IB1205S-2W电源模块原理图与实物图"><img src="/images/control/media/image17.jpeg" alt="图2.10：IB1205S-2W电源模块原理图与实物图">其次，在Buck变换主电路中，为满足设定元件参数，选取如下元器件：</p>
<ol>
<li>贴片MOS管NCE0130KA：VDS=100V，VGS=10V</li>
</ol>
<p><img src="/images/control/media/image18.png" alt="图2.11： 贴片MOS管NCE0130KA实物图"></p>
<ol start="2">
<li>贴片电感：色环直插型，100uH</li>
</ol>
<p><img src="/images/control/media/image19.png" alt="图2.12：贴片电感实物图"></p>
<ol start="3">
<li>贴片铝电解电容：330uF，±20%，耐压50V，两个并联达到设定660uF</li>
</ol>
<p><img src="/images/control/media/image20.png" alt="图2.13：贴片铝电解电容实物图"></p>
<ol start="4">
<li>电流传感器CC6920SO-5A：初级电流测量范围-5A~5A，供电电压5V</li>
</ol>
<p><img src="/images/control/media/image21.png" alt="图2.14：电流传感器CC6920SO-5A实物图"></p>
<ol start="5">
<li>电压传感器LV25-NP：初级电流测量范围10-500V，供电电压±15V</li>
</ol>
<p><img src="/images/control/media/image22.jpeg" alt="图2.15：电压传感器LV25-NP实物图"></p>
<p>其中，电容与电感均采用贴片形式的原因主要有以下几点：</p>
<p>【1】 体积小且便于贴装，适合电路的高集成度需求；</p>
<p>【2】 贴片元件引线较短，寄生电感和电容较小，可提高电路的高频性能；</p>
<p>【3】 贴片元件的散热性能通常较好，有助于提高电路的可靠性；</p>
<p>【4】 贴片元件可以有效减小电磁干扰，提高电路的稳定性。</p>
<p>除此之外，由于本实验采用的主控STM32输出能力有限，无法直接驱动管子开关，因此还需要采用光耦和驱动电路为管子提供驱动信号，涉及到的元器件及相关参数如下：</p>
<ol>
<li>IR21844S驱动：栅极驱动供电范围10-20V</li>
</ol>
<p><img src="/images/control/media/image23.jpeg" alt="图2.16：IR21844S驱动实物图"></p>
<ol start="2">
<li>光耦-逻辑输出6N135：5V供电，光耦隔离</li>
</ol>
<p><img src="/images/control/media/image24.jpeg" alt="图2.17：光耦-逻辑输出6N135实物图"></p>
<ol start="3">
<li>运算放大器AD823ARZ：最大输入偏置电流25pA，低失真−108dBc</li>
</ol>
<p><img src="/images/control/media/image25.jpeg" alt="图2.18：运算放大器AD823ARZ实物图"></p>
<h3 id="2-3-Buck变换器实物设计与调试"><a href="#2-3-Buck变换器实物设计与调试" class="headerlink" title="2.3 Buck变换器实物设计与调试"></a>2.3 Buck变换器实物设计与调试</h3><p>在Buck变换主电路设计时，选择不对Buck变换器的电路部分进行拓扑，而在闭环PWM控制电路中采用平均电压模式进行控制。本项目采用的实验电路板主要包括Buck电路基本器件、开关管驱动、辅助电源以及采样电路（信号调理电路），实验时将元器件焊接至电路板上并分别调试各模块功能。</p>
<p><img src="/images/control/media/image26.jpeg" alt="图2.19：组员焊接电路板过程"><img src="/images/control/media/image27.jpeg" alt="图2.19：组员焊接电路板过程"></p>
<p><img src="/images/control/media/image28.png" alt="图2.20：焊接后Buck变换器整体电路实物图"><img src="/images/control/media/image29.png" alt="图2.20：焊接后Buck变换器整体电路实物图"></p>
<h4 id="2-3-1-主电路设计与调试"><a href="#2-3-1-主电路设计与调试" class="headerlink" title="2.3.1 主电路设计与调试"></a>2.3.1 主电路设计与调试</h4><p><img src="/images/control/media/image30.png" alt="图2.21：Buck变换器主电路原理图"></p>
<p>该电路是一个典型的降压型 DC-DC 转换器，其工作原理是通过开关管 Q3 的高速开关动作，将输入电压V_IN转换为期望的输出电压V_OUT。当开关管Q3导通时，输入电压通过 L2、L3和负载形成电流回路，电感存储能量，同时为负载供电；当 Q3关断时，续流二极管 D4 提供电流通路，电感释放能量维持负载电流的连续性。控制器 U6根据反馈电压（通过分压电阻 R8 反馈的V_OUT）与参考电压之间的误差，实时调节 Q3的导通时间（占空比），从而实现输出电压的稳定调节。两级电感 L2 和 L3以及滤波电容 C9、C15进一步平滑输出电流和电压，减少高频纹波，确保输出电压的稳定性和低噪声特性。</p>
<p>经过调试，Buck降压模块主电路可正常实现功能，在参考输入方波幅值为8V、占空比为50%的情况下能够输出占空比为50%、幅值在8V左右（实际约为8.5V）的方波。</p>
<p><img src="/images/control/media/image31.png" alt="图2.22：Buck变换器主电路调试过程与调试结果"><img src="/images/control/media/image32.png" alt="图2.22：Buck变换器主电路调试过程与调试结果"><img src="/images/control/media/image33.png" alt="图2.22：Buck变换器主电路调试过程与调试结果"><img src="/images/control/media/image34.png" alt="图2.22：Buck变换器主电路调试过程与调试结果"></p>
<h4 id="2-3-2-控制电路供电设计与调试"><a href="#2-3-2-控制电路供电设计与调试" class="headerlink" title="2.3.2 控制电路供电设计与调试"></a>2.3.2 控制电路供电设计与调试</h4><p><img src="/images/control/media/image35.png" alt="图2.23：STM32主控芯片供电电路及预留引脚接口"></p>
<p>如图所示为STM32主控芯片供电电路（电源模块）以及单片机内部所使用的接口引脚图，同时将大部分未使用的引脚通过排针引出以供后续拓展功能开发。</p>
<p>在STM32主控芯片供电电路中，包含两个级联的线性稳压器，用于将高电压逐级稳压到所需的5V 和 3.3V。上半部分采用 CJ7805稳压器，将输入电压V_IN转换为稳定的5V输出，通过输入电容C2和C1滤波降低输入纹波，稳压器通过内部反馈电路调节输入电压，使输出稳定在5V，同时通过输出电容C3滤除高频噪声，进一步平滑输出电压。下半部分采用<br>AMS1117-3.3 稳压器，将上一级提供的 5V 电压进一步稳压为3.3V，通过输入滤波电容 C5和 C6减少输入噪声，并通过输出滤波电容C4提高输出电压的稳定性。整个电路通过分级稳压设计，既提高了稳压效率，又能为负载提供低噪声、高稳定性的5V和3.3V电压，适用于嵌入式系统和低功耗数字电路的电源需求。</p>
<p>调试流程：取下单片机核心板—&gt;接入负载100欧姆—&gt;单片机输出PWM—&gt;观测PA8端口波形—&gt;观测驱动芯片输出端口波形—&gt;上主电24V—&gt;检测辅助电源输出电压—&gt;检测输出电压—&gt;根据占空比计算输出电压是否正常—&gt;完成</p>
<p>经调试，该部分模块可正常工作，为STM32主控芯片提供稳定的5V电压：</p>
<p><img src="/images/control/media/image36.jpeg" alt="图2.24：控制模块供电电路调试输出结果"><img src="/images/control/media/image37.jpeg" alt="图2.24：控制模块供电电路调试输出结果"></p>
<h4 id="2-3-3-驱动电路设计与调试"><a href="#2-3-3-驱动电路设计与调试" class="headerlink" title="2.3.3 驱动电路设计与调试"></a>2.3.3 驱动电路设计与调试</h4><p><img src="/images/control/media/image38.png" alt="图2.25：光耦隔离（上）与驱动电路（下）原理图"></p>
<p>如图所示，驱动电路为已有的STM32输出提供了合适的电压和电流驱动功率器件，而如果直接使用STM32输出驱动，可能会超出其输出能力或不能实现良好的电气隔离，导致驱动失败或损坏器件，输出信号不稳定。使用光耦和驱动电路则可以更好地实现电气隔离，从而防止高压或大电流对控制电路的干扰或损坏，保护STM32免受高电压或大电流的影响，提高系统工作可靠性。</p>
<p>调试时，先切断仿真器供电，将单片机供电切换为主电路辅助电源供电；单片机烧录输出电压控制程序后，接入后端负载，再上主电，观测输出电压。经调试，驱动电路可正常工作。</p>
<p><img src="/images/control/media/image39.png" alt="图2.26：驱动电路调试后输出结果"><img src="/images/control/media/image40.png" alt="图2.26：驱动电路调试后输出结果"></p>
<h4 id="2-3-4-电压和电流采样调理滤波设计与调试"><a href="#2-3-4-电压和电流采样调理滤波设计与调试" class="headerlink" title="2.3.4 电压和电流采样调理滤波设计与调试"></a>2.3.4 电压和电流采样调理滤波设计与调试</h4><p><img src="/images/control/media/image41.png" alt="图2.27：电感电流（上）与输出电压（下）采样调理滤波电路原理图"></p>
<p>该电路是一个基于运算放大器的电压比较和分压检测电路，主要功能是将输入电压V_OUT通过电阻分压后与基准电压比较，并输出相应的信号V_S。该电路可用于电压监测或过压保护等场景，通过调整R1 和 R2 的比例，可以设置分压电压，从而灵活设定输入电压的触发阈值。</p>
<p>具体工作原理如下：输入电压$V_{OUT}$经由电阻R1和R2分压后，产生一个分压电压，该电压送入运算放大器U5的反相输入端（引脚2）。运算放大器的非反相输入端（引脚 3）通过稳压二极管 D2提供一个固定的基准电压（3.3V）。当分压后的电压低于基准电压时，运算放大器输出高电平；当分压电压高于基准电压时，运算放大器输出低电平。电容C7和C16用于滤除输入和输出的高频噪声，保证比较过程的稳定性。</p>
<p>调试时，使用仿真器给单片机供电，以调试PWM波形输出是否正常；烧录开环测试程序之后，使用示波器或者上位机观测电路板PA8端口是否正常输出PWM波形。经调试，可对输入信号正确采样并输出对应波形，说明采样模块正常工作：</p>
<p><img src="/images/control/media/image42.jpeg" alt="图2.28：采样模块调试后输出结果"><img src="/images/control/media/image43.jpeg" alt="图2.28：采样模块调试后输出结果"></p>
<h3 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h3><p>本章主要介绍了直流Buck变换器的基本工作原理及其拓扑变换，并根据选定的主控芯片STM32F103C8T6以及设定的电路参数进行了基本元器件的选型与电路原理图及PCB电路板的设计，确定电路主要包括Buck降压变换主电路、控制电路供电辅助电源模块、驱动电路以及采样电路（信号调理电路）四个模块；在焊接时对各个模块依次进行焊接与调试，保证各模块均可以正常工作，以便于后续闭环控制实现时STM32主控控制模块与代码的设计与测试。</p>
<h2 id="3-直流Buck变换器建模"><a href="#3-直流Buck变换器建模" class="headerlink" title="3 直流Buck变换器建模"></a>3 直流Buck变换器建模</h2><h3 id="3-1-Buck变换器闭环控制原理分析"><a href="#3-1-Buck变换器闭环控制原理分析" class="headerlink" title="3.1 Buck变换器闭环控制原理分析"></a>3.1 Buck变换器闭环控制原理分析</h3><p>Buck变换器闭环控制系统主要由以下几个部分组成：</p>
<ol>
<li><p>误差放大器：将参考电压V_ref与实际输出电压V_OUT比较，生成误差信号；</p>
</li>
<li><p>补偿网络：对误差信号进行处理（例如，PI或PID控制），以提高系统稳定性和动态性能；</p>
</li>
<li><p>PWM调制器：将补偿后的控制信号转换为开关元件的占空比D;</p>
</li>
<li><p>采样电路：对输出电压 V_OUT进行实时采样。</p>
</li>
</ol>
<p><img src="/images/control/media/image44.png" alt="图3.1：Buck变换器闭环控制电路简图"></p>
<p>整个闭环控制系统的工作过程如下：</p>
<ol>
<li><p>输出电压采样：通过分压电路对输出电压V_OUT进行采样，得到反馈电压V_fb;</p>
</li>
<li><p>误差检测：误差放大器将参考电压V_ref与反馈电压V_fb比较，产生误差信号<br>$$<br>e(t) = V_{ref} - V_{fb}<br>$$</p>
</li>
<li><p>误差调节：误差信号经过补偿网络调节，生成调节信号V_ctrl，此信号决定PWM占空比；</p>
</li>
<li><p>PWM调制：调制器根据调节信号V_ctrl生成控制信号D，驱动开关元件；</p>
</li>
<li><p>电感电流调节：开关元件的导通时间决定电感电流的充电时间，从而控制输出电压。</p>
</li>
</ol>
<p><img src="/images/control/media/image45.png" alt="图3.2：Buck变换器闭环控制系统框图"></p>
<p>从系统传递函数的角度考虑，根据系统框图与元件特性，可计算其开环传递函数与特征方程：</p>
<p>（1）G_c(s)为PI环节， PI调节器为：<br>$$<br>\left{ \begin{aligned}<br> &amp; \dot{x} = K_{I}v \<br> &amp; y = K_{p}v + x<br>\end{aligned} \right.<br>$$<br>可得PI环节传递函数G_c(s)：</p>
<p>$$<br>G_{c}(s) = K_{p} + K_{I}\frac{1}{s} = \frac{K_{p}(\tau s + 1)}{\tau s}，\tau = \frac{K_{p}}{K_{I}}<br>$$<br>（2）PWM脉宽调制环节：由大信号关系<br>$$<br>v_{con}(dT) = v_{ramp}(dT) = V_{M}\frac{dT}{T} = dV_{M}<br>$$<br>做微分可得小信号的线性关系<br>$$<br>\mathrm{\Delta}v_{con} = \mathrm{\Delta}dV_{M}<br>$$<br>从而实现传递函数的线性化：</p>
<p>$$<br>G_{pwm} = \frac{\mathrm{\Delta}d}{\mathrm{\Delta}v_{con}} = 1/V_{M}<br>$$<br>（3）PWM脉宽控制开关电路：由大信号关系<br>$$<br>v_{D} = dv_{g}<br>$$<br>做全微分可得小信号线性关系<br>$$<br>\mathrm{\Delta}v_{D} = \mathrm{\Delta}dV_{g} + \mathrm{\Delta}v_{g}D<br>$$<br>零初始条件下，对应的工作点为<br>$$<br>V_{g} = V_{in}，\mathrm{\Delta}v_{g} = 0<br>$$<br>于是有传递函数：<br>$$<br>G_{vg} = \frac{\mathrm{\Delta}v_{D}}{\mathrm{\Delta}d} = V_{g}<br>$$<br>（4）RLC并联二阶输出滤波器：由电路图与元件特性可得各元件间电流电压关系：</p>
<p>$$<br>\left{ \begin{array}{r}<br>u_{0} = Ri_{2} \<br>u_{L} = L\frac{di}{dt} \<br>i_{1} = C\frac{du_{0}}{dt} \<br>i = i_{1} + i_{2} \<br>u_{D} = u_{L} + u_{0}<br>\end{array} \right.<br>$$<br>从而可得该滤波器对应的微分方程：<br>$$<br>u_{D} = LC{u_{0}}^{‘’} + \frac{L}{R}{u_{0}}^{‘} + u_{0}<br>$$<br>对两边同时进行拉普拉斯变换，化简整理后可得二阶滤波器的传递函数G_vd(s)：</p>
<p>$$<br>G_{vd}(s) = \frac{U_{0}(s)}{U_{D}(s)}V_{in} = \frac{\frac{1}{LC}}{s^{2} + \frac{1}{RC}s + \frac{1}{LC}}V_{in}<br>$$<br>又因输出信号v_0直接接入PI控制器，故<br>$$<br>H(s) = 1<br>$$<br>综上所述：有开环传递函数：</p>
<p>$$<br>T(s) = G_{c}(s)G_{pwm}G_{\text{vd}}H(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{\frac{1}{LC}}{s^{2} + \frac{1}{RC}s + \frac{1}{LC}}V_{in} = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1}<br>$$<br>进而可以得到系统的特征方程<br>$$<br>T(s) + 1 = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{g}}{LCs^{2} + \frac{L}{R}s + 1} + 1 = 0<br>$$<br>化简后可得：<br>$$<br>\Delta(s) = V_{g}K_{p}(\tau s + 1) + \tau sV_{M}\left( LCs^{2} + \frac{L}{R}s + 1 \right) = \tau V_{M}LCs^{3} + \tau V_{M}\frac{L}{R}s^{2} + (V_{g}K_{p} + V_{M})\tau s + V_{g}K_{p} = 0<br>$$</p>
<h3 id="3-2-Buck变换器PSIM仿真（开环-闭环）"><a href="#3-2-Buck变换器PSIM仿真（开环-闭环）" class="headerlink" title="3.2 Buck变换器PSIM仿真（开环+闭环）"></a>3.2 Buck变换器PSIM仿真（开环+闭环）</h3><p>利用PSIM软件进行电路仿真，根据实际电路结构搭建仿真电路图，并将电路各元件实际参数代入（PI控制器参数：K_p = 0.1，tao = 0.004）：</p>
<p><img src="/images/control/media/image46.png" alt="图3.3：Buck变换器开环控制PSIM仿真电路图"></p>
<p><img src="/images/control/media/image47.png" alt="图3.4：Buck变换器闭环控制PSIM仿真电路图"></p>
<p>运行仿真程序，可得到输出电压的仿真结果：</p>
<p><img src="/images/control/media/image48.png" alt="图3.5：Buck变换器开环控制PSIM仿真结果------输出电压"></p>
<p><img src="/images/control/media/image49.png" alt="图3.6：Buck变换器闭环控制PSIM仿真结果------输出电压"></p>
<p>对比开环与闭环控制系统的输出电压仿真结果可以发现，尽管两个系统都能在短时间内达到稳定的输出电压，但显然闭环控制系统到达稳态的速度更快且震荡更小，稳定后的电压也更接近参考电压8V（约为7.95V）。这说明闭环控制系统具有更快的响应速度与更好的稳定性和准确性。</p>
<h3 id="3-3-输出电压纹波计算（仿真-实验）"><a href="#3-3-输出电压纹波计算（仿真-实验）" class="headerlink" title="3.3 输出电压纹波计算（仿真+实验）"></a>3.3 输出电压纹波计算（仿真+实验）</h3><p><img src="/images/control/media/image50.jpeg" alt="图3.7：Buck变换器开环控制实验输出电压纹波波形"><img src="/images/control/media/image51.jpeg" alt="图3.7：Buck变换器开环控制实验输出电压纹波波形"></p>
<p>首先进行Buck变换器的开环控制实验，并通过示波器观察其输出电压的纹波波形。可以看到，输出波形峰值<br>$$<br>V_{omax} = 88mV<br>$$<br>谷值<br>$$<br>V_{omin} = - 76mV<br>$$<br>则波形的震荡幅度为<br>$$<br>\Delta V_{o} = V_{omax} - V_{omin} = 164mV<br>$$<br>随后利用PSIM软件进行电路仿真，根据实际电路结构搭建仿真电路图，并将电路各元件实际参数代入：</p>
<p><img src="/images/control/media/image52.png" alt="图3.8：Buck变换器开环控制PSIM仿真电路图"></p>
<p>可得到输出电压纹波的仿真结果：</p>
<p><img src="/images/control/media/image53.png" alt="图3.9：Buck变换器开环控制PSIM仿真结果------输出电压纹波"></p>
<p>可以看到，输出电压信号的震荡波形与实际电路示波器显示的纹波形状一致且震荡幅度大致相同。</p>
<h3 id="3-4-电容寄生电阻计算（仿真-实验）"><a href="#3-4-电容寄生电阻计算（仿真-实验）" class="headerlink" title="3.4 电容寄生电阻计算（仿真+实验）"></a>3.4 电容寄生电阻计算（仿真+实验）</h3><p>在Buck变换器开环控制实验中，通过万用表测量得到输入电压V_i= 15.304V，输出电压均值V_o = 7.537V：</p>
<p><img src="/images/control/media/image54.jpeg" alt="图3.10：Buck变换器开环控制实验输入、输出电压测量结果"><img src="/images/control/media/image55.jpeg" alt="图3.10：Buck变换器开环控制实验输入、输出电压测量结果"></p>
<p>除了给定的元件参数之外，为对直流Buck变换器进行精确建模，考虑到电容的寄生参数可能对系统有较大影响，故特别计算其寄生电阻阻值ESR：</p>
<p><img src="/images/control/media/image56.png" alt="图3.11：寄生电阻阻值计算理论依据"></p>
<p>结合<br>$$<br>U_{esr} = \Delta I_{L}*ESR<br>$$<br>一式，考虑到电流因流过电容的寄生电阻而产生的压降U_esr应不大于（实际一般处理为等于）波形的震荡幅度，即：<br>$$<br>U_{esr} \leq \Delta V_{o}<br>$$<br>可以得到在同步Buck电路中（V_d = 0）电容寄生电阻阻值ESR的计算公式：</p>
<p>$$<br>ESR \leq \frac{\Delta V_{o}fLV_{i}}{V_{o}\left( V_{i} - V_{o} \right)}<br>$$<br>结合Buck变换器开环控制实验结果，代入参数<br>$$<br>\Delta V_{o} = 164mV，L = 100\mu F，f = 25kHz，V_{i} = 15.304V，V_{o} = 7.537V<br>$$<br>可以计算得出该电路中实际的电容寄生电阻阻值<br>$$<br>ESR \approx 107.185m\Omega<br>$$<br>这里计算的是接入单个电容的寄生电阻阻值，在实际电路中使用了两个330μF的电容等效替代原设计电路中的660μF电容，为使仿真尽可能接近实际，采取了与实际电路相同的结构，因此需要把寄生电阻同样进行等效，根据电阻并联的等效电阻计算可以得到两个330μF电容的寄生电阻值均为<br>$$<br>2ESR \approx 214.371m\Omega<br>$$<br>利用PSIM软件进行电路仿真，根据实际电路结构搭建仿真电路图，并将计算出的寄生电阻结果代入仿真电路中：</p>
<p><img src="/images/control/media/image57.png" alt="图3.12：引入寄生电阻后的Buck变换器开环控制PSIM仿真电路图"></p>
<p>得到的输出电压仿真结果如下图所示：</p>
<p><img src="/images/control/media/image48.png" alt="图3.13：引入寄生电阻后的Buck变换器开环控制PSIM仿真结果------输出电压"></p>
<p><img src="/images/control/media/image53.png" alt="图3.14：引入寄生电阻后的Buck变换器开环控制PSIM仿真结果------输出电压纹波"></p>
<p>可以看到，仿真结果中输出电压的均值约为7.65V，与实际的测量结果<br>$$<br>V_{o} = 7.537V<br>$$<br>较为接近；同时输出电压信号的震荡波形也与实际电路示波器显示的纹波形状一致且震荡幅度大致相同。这也印证了寄生电阻的计算以及电路建模与仿真的正确性。</p>
<h3 id="3-5-本章小结"><a href="#3-5-本章小结" class="headerlink" title="3.5 本章小结"></a>3.5 本章小结</h3><p>本章主要介绍了直流Buck控制器及其闭环控制系统的建模过程，通过分析Buck电路中的元件特性及闭环控制的各个环节，实现控制系统的数学建模，得到系统的开环传递函数与特征方程；同时结合Buck控制器开环控制实验的实际测量结果，关注到电容寄生电阻对于系统输出的重要影响，并通过输出电压纹波的相关特性对其进行计算，搭建PSIM电路仿真模型观察修正前后的仿真结果，发现引入寄生电阻后的仿真结果与实际实验波形输出基本一致从而说明考虑寄生电阻的必要性。除此之外，还分别搭建了Buck变换器的开环与闭环控制系统PSIM仿真电路并对比输出电压仿真结果，可以发现闭环控制系统具有更好的动态响应性能，其稳定性、快速性与准确性均优于开环控制系统。</p>
<h2 id="4-直流Buck变换器控制性能分析"><a href="#4-直流Buck变换器控制性能分析" class="headerlink" title="4 直流Buck变换器控制性能分析"></a>4 直流Buck变换器控制性能分析</h2><h3 id="4-1-直流Buck变换器劳斯稳定判据分析"><a href="#4-1-直流Buck变换器劳斯稳定判据分析" class="headerlink" title="4.1 直流Buck变换器劳斯稳定判据分析"></a>4.1 直流Buck变换器劳斯稳定判据分析</h3><p>基于3.1节得到的开环传递函数与系统特征方程，可利用劳斯判据给出系统稳定的PI控制器比例系数K_p临界条件：</p>
<p>根据系统特征方程可给出如下劳斯表：</p>
<p><img src="/images/control/media/01.png" alt="劳斯表"></p>
<p>根据劳斯判据，要使得系统稳定，需同时满足如下条件：</p>
<p>$$<br>\left{ \begin{array}{r}<br>\ \tau V_{M}LC &gt; 0 \<br>\tau V_{M}\frac{L}{R} &gt; 0 \<br>\left( V_{in}K_{p} + V_{M} \right)\tau - V_{in}K_{p}RC &gt; 0 \<br>{\ \ V}<em>{in}K</em>{p} &gt; 0<br>\end{array} \right.\<br>$$<br>这是关于PI控制器比例系数K_p的不等式组，可解得其边界条件为：</p>
<p>$$<br>0 &lt; K_{p} &lt; \frac{V_{M}\tau}{V_{in}(RC - \tau)}<br>$$<br>若选定控制环路的时间常数<br>$$<br>\tau = 0.004$<br>$$<br>三角载波幅值<br>$$<br>V_{M} = 0.5V<br>$$<br>则可代入数值解得：比例系数K_p的稳定边界为<br>$$<br>\frac{V_{M}\tau}{V_{in}(RC - \tau)} \approx 0.0513<br>$$<br>而在实际情况下，需要考虑电容的寄生电阻<br>$$<br>ESR \approx 107.185m\Omega<br>$$<br>这意味着需要对3.1节建立的数学模型进行修正。显然电路结构中除二阶滤波器外的其他环节没有发生改变，针对考虑电容寄生电阻ESR的RLC并联二阶输出滤波器，由电路图与元件特性可得各元件间电流电压关系：</p>
<p>$$<br>\left{ \begin{array}{r}<br>u_{0} = Ri_{2} \<br>u_{L} = L\frac{di}{dt} \<br>i_{1} = C\frac{du_{C}}{dt} \<br>i = i_{1} + i_{2} \<br>u_{0} = u_{C} + ESRi_{1} \<br>u_{D} = u_{L} + u_{0}<br>\end{array} \right.\<br>$$<br>从而可得该滤波器对应的微分方程，对两边同时进行拉普拉斯变换，化简整理后可得二阶滤波器的传递函数G_vd(s)：</p>
<p>$$<br>G_{vd}(s) = \frac{U_{0}(s)}{U_{D}(s)}V_{in} = \frac{\frac{1}{LC} + \frac{ESR}{L}s}{(1 + \frac{ESR}{R})s^{2} + (\frac{1}{RC} + \frac{ESR}{L})s + \frac{1}{LC}}V_{in}<br>$$<br>其他环节保持不变，于是有开环传递函数：<br>$$<br>T(s) = G_{c}(s)G_{pwm}G_{\text{vd}}H(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{\frac{1}{LC} + \frac{ESR}{L}s}{\left( 1 + \frac{ESR}{R} \right)s^{2} + \left( \frac{1}{RC} + \frac{ESR}{L} \right)s + \frac{1}{LC}}V_{in} \approx \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{1 + C \bullet ESRs}{LCs^{2} + \frac{L}{R}s + 1}V_{in}<br>$$<br>因此近似后系统的特征方程<br>$$<br>T(s) + 1 = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{(1 + C \bullet ESRs)V_{in}}{LCs^{2} + \frac{L}{R}s + 1} + 1 = 0<br>$$<br>化简后可得：</p>
<p>$$<br>\Delta(s) = {(1 + C \bullet ESRs)V}<em>{in}K</em>{p}(\tau s + 1) + \tau sV_{M}\left( LCs^{2} + \frac{L}{R}s + 1 \right) = V_{M}LC\tau s^{3} + (V_{M}\frac{L}{R} + C \bullet ESR \bullet V_{in}K_{p})\tau s^{2} + (V_{in}K_{p}\tau + V_{M}\tau + C \bullet ESR \bullet V_{in}K_{p})s + V_{in}K_{p} = 0<br>$$<br>接下来利用劳斯判据给出系统稳定的PI控制器比例系数K_p临界条件：</p>
<p>根据系统特征方程可给出如下劳斯表：</p>
<p><img src="/images/control/media/03.png" alt="劳斯表"></p>
<p>根据劳斯判据，要使得系统稳定，需同时满足如下条件：</p>
<p>$$<br>\left{ \begin{array}{r}<br>\ \tau V_{M}LC &gt; 0 \<br>\tau V_{M}\frac{L}{R} &gt; 0 \<br>V_{in}K_{p}\tau + V_{M}\tau + C \bullet ESR \bullet V_{in}K_{p} - \frac{V_{M}LCV_{in}K_{p}}{V_{M}\frac{L}{R} + C \bullet ESR \bullet V_{in}K_{p}} &gt; 0 \<br>{\ \ V}<em>{in}K</em>{p} &gt; 0<br>\end{array} \right.\<br>$$<br>这是关于PI控制器比例系数K_p的不等式组，其中第1、2、4个不等式均指向K_p &gt; 0，而第三个不等式是一个关于K_p的一元二次不等式，代入电路元件参数可解得<br>$$<br>K_{p} &lt; - 0.0232或K_{p} &gt; - 0.0067<br>$$<br>因此可得到K_p的稳定边界为：<br>$$<br>K_{p} &gt; 0<br>$$<br>即该情况下系统始终稳定。</p>
<h3 id="4-2-直流Buck变换器系统根轨迹分析（手绘-MWorks绘制）"><a href="#4-2-直流Buck变换器系统根轨迹分析（手绘-MWorks绘制）" class="headerlink" title="4.2 直流Buck变换器系统根轨迹分析（手绘+MWorks绘制）"></a>4.2 直流Buck变换器系统根轨迹分析（手绘+MWorks绘制）</h3><p>基于3.1节得到的开环传递函数，代入数值可得：</p>
<p>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1} = \frac{30K_{p}(s + 250)}{s(6.6*10^{- 8}s^{2} + 10^{- 5}s + 1)}<br>$$<br>根据该开环传递函数可知，该系统：</p>
<p>具有1个零点：<br>$$<br>z_{1} = 250<br>$$<br>具有3个极点：<br>$$<br>p_{0} = 0，p_{1} + p_{2} = \frac{5}{33}*10^{3} \approx 151.5，p_{1} = \frac{5}{66}*10^{3} + a_i，p_{1} + p_{2} = \frac{5}{66}*10^{3} - a_i<br>$$<br>故有3条根轨迹，1条止于开环零点，2条止于无穷远；</p>
<p>根轨迹的渐近线与实轴的夹角<br>$$<br>\varphi_{a} = \pm \frac{2k + 1}{2}\pi(k = 0,1,2\ldots) = \pm 90{^\circ}、180{^\circ}<br>$$<br>渐近线与实轴交点的坐标值<br>$$</p>
<ul>
<li>\delta_{a} = \frac{\sum_{}^{}\left( - p_{i} \right) - \sum_{}^{}\left( - z_{i} \right)}{2} = \frac{- \frac{5}{33}*10^{3} + 250}{2} \approx 49.24<br>$$</li>
</ul>
<p>基于以上结果，可手绘根轨迹草图如下：</p>
<p><img src="/images/control/media/image58.png" alt="图4.1：不考虑寄生电阻------手绘根轨迹草图"></p>
<p>编写如下MWorks代码：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">G=(s+<span class="number">250</span>)/(s*(<span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">8</span>)*s*s+<span class="number">10</span>^(-<span class="number">5</span>)*s+<span class="number">1</span>));</span><br><span class="line">rlocus(G);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码，得到MWorks绘制的根轨迹图如下：</p>
<p><img src="/images/control/media/image59.png" alt="图4.2：不考虑寄生电阻------MWorks绘制根轨迹图"></p>
<p>根轨迹本质上反映的随着比例系数K_p的变化，特征方程根的变化情况；当两个共轭根恰好位于虚轴上时，此时对应的比例系数K_p（可将此时特征根带回特征方程求出）即为其稳定的边界值（大于该值不稳定，小于该值稳定）。</p>
<p>编写如下MWorks程序，寻找根轨迹与虚轴的交点并带回特征方程，求出比例系数K_p稳定边界值：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">% 找寻与虚轴交点</span><br><span class="line">k = linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>); % 增加点数，<span class="number">1000</span>个点</span><br><span class="line">[r, k]=rlocus(G,k);</span><br><span class="line">real_part = real(r);</span><br><span class="line">imag_part = imag(r);</span><br><span class="line">% 查找实部接近零的索引</span><br><span class="line">tolerance = <span class="number">1e-1</span>; % 设定阈值</span><br><span class="line">idx = find(abs(real_part) &lt; tolerance); % 找到所有交点的索引</span><br><span class="line">intersections = r(idx); % 交点的复数值</span><br><span class="line">% 求解临界kp</span><br><span class="line">s = intersections(<span class="number">2</span>);</span><br><span class="line">% 系统参数</span><br><span class="line">tao = <span class="number">0.004</span>;</span><br><span class="line">vm = <span class="number">0.5</span>;</span><br><span class="line">l = <span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">c = <span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">vin = <span class="number">15</span>;</span><br><span class="line">r = <span class="number">10</span>;</span><br><span class="line">syms kp; % 定义符号变量</span><br><span class="line">eq = tao*vm*l*c*s*s*s + tao*vm*l*s*s/r + vin*kp*tao*s + vm*tao*s + vin*kp == <span class="number">0</span>;</span><br><span class="line">solutions = solve(eq, kp); % 求解</span><br><span class="line">real_solutions = real(solutions); % 取实部</span><br><span class="line">decimal_solutions = double(real_solutions); % 转换为小数</span><br><span class="line">disp(decimal_solutions); % 显示结果</span><br></pre></td></tr></tbody></table></figure>

<p>运行上述MWorks代码，得到的比例系数K_p稳定边界值结果为：0.0514，这与先前依据劳斯判据得到的结果<br>$$<br>\frac{V_{M}\tau}{V_{in}(RC - \tau)} \approx 0.0513<br>$$<br>大致一致。</p>
<p>而在实际情况下，需要考虑电容的寄生电阻；基于4.1节修正后的开环传递函数，代入数值可得：</p>
<p>$$<br>T(s) \approx \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{1 + C \bullet ESRs}{LCs^{2} + \frac{L}{R}s + 1}V_{in} \approx \frac{30K_{p}(s + 250)(1 + 7.07<em>10^{- 5}s)}{s(6.6</em>10^{- 8}s^{2} + 10^{- 5}s + 1)}<br>$$<br>根据该开环传递函数可知，该系统：</p>
<p>具有2个零点：<br>$$<br>z_{1} = 250，z_{2} \approx 1.41*10^{5}<br>$$<br>具有3个极点：<br>$$<br>p_{0} = 0，p_{1} + p_{2} = \frac{5}{33}*10^{3} \approx 151.5，p_{1} = \frac{5}{66}*10^{3} + bi，p_{1} + p_{2} = \frac{5}{66}*10^{3} - bi<br>$$<br>故有3条根轨迹，2条止于开环零点，2条止于无穷远；</p>
<p>根轨迹的渐近线与实轴的夹角<br>$$<br>\varphi_{a} = \pm (2k + 1)\pi(k = 0,1,2\ldots) = 180{^\circ}<br>$$<br>基于以上结果，可手绘根轨迹草图如下：</p>
<p><img src="/images/control/media/image60.png" alt="图4.3：考虑寄生电阻------手绘根轨迹草图"></p>
<p>编写MWorks代码如下：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">c = <span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">esr = <span class="number">0.107185</span>;</span><br><span class="line">G=(s+<span class="number">250</span>)*(<span class="number">1</span>+c*esr*s)/(s*(<span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">8</span>)*s*s+<span class="number">10</span>^(-<span class="number">5</span>)*s+<span class="number">1</span>));</span><br><span class="line">rlocus(G);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码，得到MWorks绘制的根轨迹图如下：</p>
<p><img src="/images/control/media/image61.png" alt="图4.4：考虑寄生电阻------MWorks绘制根轨迹图"></p>
<p>可以看到，在考虑电容寄生电阻的情况下，根轨迹完全位于虚轴左侧，这意味着无论比例系数K_p（&gt;0）如何变化，系统特征方程的根均位于虚轴左侧，即此情况下系统始终稳定，这与先前依据劳斯判据得到的结果也是一致的。这样的结果也充分说明，寄生电阻的加入使得系统的稳定性提高。</p>
<h3 id="4-3-直流Buck变换器奈奎斯特稳定判据分析"><a href="#4-3-直流Buck变换器奈奎斯特稳定判据分析" class="headerlink" title="4.3 直流Buck变换器奈奎斯特稳定判据分析"></a>4.3 直流Buck变换器奈奎斯特稳定判据分析</h3><p>在不考虑寄生电阻的情况下，基于3.1节得到的开环传递函数，取负载电阻R = 2欧姆，代入PI控制器参数：<br>$$<br>K_{p} = 0.05、\tau = 1\text{/}5000<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 3V<br>$$<br>可得：</p>
<p>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1} = \frac{0.05 \times \left( \frac{1}{5000}s + 1 \right)}{\frac{1}{5000}s} \cdot \frac{1}{3} \cdot \frac{15 \times 10^{8}}{6.6s^{2} + 5000s + 10^{8}} = \frac{2.5 \times 10^{7}(s + 5000)}{s(6.6s^{2} + 5000s + 10^{8})}<br>$$<br>根据该开环传递函数，编写MWorks代码如下：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">H = tf([<span class="number">2.5</span>*<span class="number">10</span>^<span class="number">7</span> <span class="number">2.5</span>*<span class="number">10</span>^<span class="number">7</span>*<span class="number">5000</span>],[<span class="number">6.6</span> <span class="number">5000</span> <span class="number">10</span>^<span class="number">8</span> <span class="number">0</span>]);</span><br><span class="line">nyquist(H);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码，得到MWorks绘制的奈氏图如下：</p>
<p><img src="/images/control/media/image62.png" alt="图4.5：不考虑寄生电阻------MWorks绘制奈氏图"><img src="/images/control/media/image63.png" alt="图4.5：不考虑寄生电阻------MWorks绘制奈氏图"></p>
<p>观察奈氏图图像可得：正穿越次数N+=1，负穿越次数N- =1</p>
<p>又由系统开环传递函数可知：系统开环右极点数P=0</p>
<p>故由奈奎斯特稳定判据可知：该闭环系统稳定。</p>
<p><img src="/images/control/media/image64.png" alt="图4.6：奈奎斯特稳定判据"></p>
<h3 id="4-4-直流Buck变换器系统波特图分析（MWorks绘制）"><a href="#4-4-直流Buck变换器系统波特图分析（MWorks绘制）" class="headerlink" title="4.4 直流Buck变换器系统波特图分析（MWorks绘制）"></a>4.4 直流Buck变换器系统波特图分析（MWorks绘制）</h3><p>与4.3节使用相同参数，即开环传递函数可写为：</p>
<p>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1} = \frac{2.5 \times 10^{7}(s + 5000)}{s(6.6s^{2} + 5000s + 10^{8})}<br>$$<br>根据该开环传递函数，编写如下MWorks代码绘制波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">G=<span class="number">2.5</span>*<span class="number">10</span>^<span class="number">7</span>*(s+<span class="number">5000</span>)/(s*(<span class="number">6.6</span>*s^<span class="number">2</span>+<span class="number">5000</span>*s+<span class="number">10</span>^<span class="number">8</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码，得到MWorks绘制的波特图如下：</p>
<p><img src="/images/control/media/image65.png" alt="图4.7：不考虑寄生电阻------MWorks绘制波特图"></p>
<p>从图中可读出：剪切频率<br>$$<br>\omega_{c}≈1.49*10^{3}rad/s<br>$$<br>相位裕度<br>$$<br>γ≈102{^\circ}<br>$$<br>根据对数频率特性稳定判据可知：当相位裕度γ与增益裕度Lg同时大于零时，闭环系统稳定；而对于最小相位系统，相位裕度γ&gt;0与增益裕度Lg&gt;0是同时发生或同时不发生的，因此只需通过相位裕度γ即可判定闭环系统稳定情况。显然此时相位裕度大于零，表明闭环系统稳定，且稳定性较好（相位裕度较大）。</p>
<h3 id="4-5-直流Buck变换器闭环负载稳定边界计算及仿真验证"><a href="#4-5-直流Buck变换器闭环负载稳定边界计算及仿真验证" class="headerlink" title="4.5 直流Buck变换器闭环负载稳定边界计算及仿真验证"></a>4.5 直流Buck变换器闭环负载稳定边界计算及仿真验证</h3><p>基于2.2节中的电路元件参数以及输入电压恒为15V的客观事实，在给定PI控制器参数:<br>$$<br>K_{p} = 0.1、\tau = 0.004<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 0.5V<br>$$<br>的情况下，若不考虑电容寄生电阻，根据4.1节劳斯判据化简后的结果：<br>$$<br>RCV_{g}K_{p} \leq (\tau V_{M} + V_{g}K_{p}\tau)<br>$$<br>可推得系统处于稳定状态的电阻值范围应为：<br>$$<br>R \leq \frac{\tau}{C}\left( \frac{V_{M}}{V_{g}K_{p}} + 1 \right) \approx 8.08\Omega<br>$$<br>即直流Buck变换器闭环系统的负载电阻稳定边界约为8.1Ω。</p>
<p>为进一步通过仿真验证计算结果，建立PSIM仿真电路图如下：</p>
<p><img src="/images/control/media/image66.png" alt="图4.8：直流Buck变换器闭环控制负载电阻稳定边界PSIM仿真验证电路图"></p>
<ol>
<li>取负载电阻值R = 5Ω（小于临界值）时：</li>
</ol>
<p><img src="/images/control/media/image67.png" alt="图4.9：负载电阻值R=5Ω时输出电压PSIM仿真结果"></p>
<p><img src="/images/control/media/image68.png" alt="图4.10：负载电阻值R=5Ω时输出电压纹波PSIM仿真结果"></p>
<ol start="2">
<li>取负载电阻值R = 8.1欧姆（约等于临界值）时：</li>
</ol>
<p><img src="/images/control/media/image69.png" alt="图4.11：负载电阻值R=8.1Ω时输出电压PSIM仿真结果"></p>
<p><img src="/images/control/media/image70.png" alt="图4.12：负载电阻值R=8.1Ω时输出电压纹波PSIM仿真结果">取负载电阻值R=10Ω（大于临界值）时：</p>
<p><img src="/images/control/media/image71.png" alt="图4.13：负载电阻值R=10Ω时输出电压PSIM仿真结果"></p>
<p><img src="/images/control/media/image72.png" alt="图4.14：负载电阻值R=10Ω时输出电压纹波PSIM仿真结果"></p>
<p>通过对比三组仿真结果可以发现：取不同的负载电阻值并不会影响系统的响应速度与响应瞬时超调量，而是影响输出电压趋于稳定后的纹波波形：</p>
<ol>
<li><p>当负载电阻值小于临界值时，稳定后的输出电压会有较大的震荡（负载越小，震荡幅度越大），但该震荡上没有纹波，系统处于稳定状态；</p>
</li>
<li><p>当负载电阻接近临界值（实际临界值略小于8.1Ω）时，稳定后输出电压的震荡幅度减小，但开始出现纹波，系统处于临界稳定状态；</p>
</li>
<li><p>当负载电阻大于临界值时，稳定后输出电压的震荡幅度进一步减小，但纹波幅度有所增大，系统处于不稳定状态。</p>
</li>
</ol>
<h3 id="4-6-考虑寄生参数直流Buck变换器波特图分析（MWorks绘制）"><a href="#4-6-考虑寄生参数直流Buck变换器波特图分析（MWorks绘制）" class="headerlink" title="4.6 考虑寄生参数直流Buck变换器波特图分析（MWorks绘制）"></a>4.6 考虑寄生参数直流Buck变换器波特图分析（MWorks绘制）</h3><p>在实际情况下，为实现对直流Buck变换器闭环控制系统更加精准的建模，需要考虑电容的寄生电阻，基于4.1节修正后的开环传递函数（取未近似结果）：</p>
<p>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{\frac{1}{LC} + \frac{ESR}{L}s}{\left( 1 + \frac{ESR}{R} \right)s^{2} + \left( \frac{1}{RC} + \frac{ESR}{L} \right)s + \frac{1}{LC}}V_{in}<br>$$<br>取PI控制器参数:<br>$$<br>K_{p} = 1、\tau = 0.01<br>$$<br>三角载波幅值<br>$$<br>V_{M} = 2V<br>$$<br>负载电阻<br>$$<br>R = 2\Omega<br>$$<br>代入电路各元件参数与3.4节测算得到的寄生电阻<br>$$<br>ESR \approx 107.185m\Omega<br>$$<br>编写如下MWorks程序绘制波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">vm=<span class="number">2</span>;</span><br><span class="line">r=<span class="number">2</span>;</span><br><span class="line">esr=<span class="number">0.107185</span>;</span><br><span class="line">c=<span class="number">6.6</span>\*<span class="number">10</span>\^(-<span class="number">4</span>);</span><br><span class="line">l=<span class="number">10</span>\^(-<span class="number">4</span>);</span><br><span class="line">vg=<span class="number">15</span>;</span><br><span class="line">kp=<span class="number">1</span>;</span><br><span class="line">tao=<span class="number">0.01</span>;</span><br><span class="line">G=kp\*(tao\*s+<span class="number">1</span>)\*(esr\*c\*s+<span class="number">1</span>)\*vg/(tao\*s\*vm\*(l\*c\*(<span class="number">1</span>+esr/r)\*s\*s+(l/r+esr\*c)\*s+<span class="number">1</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码后绘制出的波特图如下：</p>
<p><img src="/images/control/media/image73.png" alt="图4.15：考虑寄生电阻------MWorks绘制波特图"></p>
<p>从图中可读出：剪切频率<br>$$<br>\omega_{c}≈1.29*10^{4}rad/s<br>$$<br>相位裕度<br>$$<br>γ≈50{^\circ}<br>$$<br>根据对数频率特性稳定判据可知，此时相位裕度γ&gt;0，表明闭环系统稳定。</p>
<h3 id="4-7-PSIM仿真扫频波特图"><a href="#4-7-PSIM仿真扫频波特图" class="headerlink" title="4.7 PSIM仿真扫频波特图"></a>4.7 PSIM仿真扫频波特图</h3><p>取与4.6节相同的参数，利用PSIM搭建扫频电路进行仿真得到波特图：</p>
<p><img src="/images/control/media/image74.png" alt="图4.16：考虑寄生电阻------PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image75.png" alt="图4.17：考虑寄生电阻------PSIM扫频仿真结果"></p>
<p>从图中可读出：剪切频率<br>$$<br>\omega_{c} \approx 1997Hz \approx 1.25*10^{4}rad/s<br>$$<br>相位裕度<br>$$<br>γ≈50{^\circ}<br>$$<br>扫频仿真结果与MWorks根据系统开环传递函数绘制的波特图基本一致。</p>
<p>若在仿真电路图中加入锁存器与零阶保持器：</p>
<p><img src="/images/control/media/image76.png" alt="图4.18：考虑寄生电阻------加入锁存器与零阶保持器后PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image77.png" alt="图4.19：考虑寄生电阻------加入锁存器与零阶保持器后PSIM扫频仿真结果"></p>
<p>图4.19：考虑寄生电阻——加入锁存器与零阶保持器后PSIM扫频仿真结果</p>
<p>从图中可读出：剪切频率<br>$$<br>\omega_{c}≈1997Hz<br>$$<br>相位裕度<br>$$<br>γ≈18{^\circ}<br>$$<br>可以发现，在仿真中加入锁存器与零阶保持器后，剪切频率基本未发生改变，图线也大致与MWorks通过传递函数得到的波特图相同，但相位裕度有所降低，系统仍然保持稳定。</p>
<h3 id="4-8-本章小结"><a href="#4-8-本章小结" class="headerlink" title="4.8 本章小结"></a>4.8 本章小结</h3><p>本章主要对于直流Buck变换器闭环控制系统的控制性能进行了详细的分析，特别是针对系统的稳定性问题，从系统的开环传递函数入手，对于考虑电容寄生电阻与否的两种不同情况，在时域上利用劳斯稳定判据与根轨迹法，讨论在负载电阻R与PI控制器时间常数τ给定的情况下，PI控制器比例系数K_p的稳定边界；在频域上依据奈奎斯特稳定判据（基于奈奎斯特图）与对数频率特性稳定判据（基于波特图，由MWorks绘制与PSIM扫频仿真得到，两者结果高度吻合），通过系统相位裕度γ判断闭环系统稳定性，同时在PI控制器参数给定的情况下讨论负载电阻R的稳定边界，并搭建PSIM仿真电路对不同负载电阻下闭环系统的稳定性进行验证，仿真结果与理论推导结论基本一致。</p>
<h2 id="5-直流Buck变换器闭环控制实验"><a href="#5-直流Buck变换器闭环控制实验" class="headerlink" title="5 直流Buck变换器闭环控制实验"></a>5 直流Buck变换器闭环控制实验</h2><h3 id="5-1-KEIL5软件环境安装及创建"><a href="#5-1-KEIL5软件环境安装及创建" class="headerlink" title="5.1 KEIL5软件环境安装及创建"></a>5.1 KEIL5软件环境安装及创建</h3><p>Keil 5是一款集成开发环境（IDE），它以其强大的功能和丰富的特性，在嵌入式系统开发领域占据了重要的地位。在本项目中，需要借助该IDE编写主控代码并烧录至STM32芯片中，使其能够在闭环控制系统中正常发挥控制作用。</p>
<p>下载助教在课程群内上传的安装程序压缩包并解压，文件夹内包含如下文件：</p>
<p><img src="/images/control/media/image78.png" alt="图5.1：Keil5 MDK安装程序压缩包解压结果"></p>
<p>双击安装程序”MDK524a.EXE”，一路点击”NEXT&gt;&gt;“（注意勾选同意许可证条款与指定软件安装位置）即可完成Keil5软件安装；软件安装完成后会自动运行，关闭后需要重新以管理员身份运行Keil5（右键-&gt;以管理员身份运行），随后进入keygen_new2032文件夹，双击运行破解程序”keygen_new2032.exe”，输入Keil5软件内”File-&gt;Licence Management…”里的CID并选择ARM，点击”Generate”并将生成的序列号复制到Keil5软件内”File-&gt;Licence Management…”下方的LIC一栏，点击”ADD LIC”即可完成破解。</p>
<p><img src="/images/control/media/image79.png" alt="图5.2：Keil5 MDK软件破解流程"><img src="/images/control/media/image80.png" alt="图5.2：Keil5 MDK软件破解流程"></p>
<p><img src="/images/control/media/image81.png" alt="图5.2：Keil5 MDK软件破解流程"><img src="/images/control/media/image82.png" alt="图5.2：Keil5 MDK软件破解流程"></p>
<p>除此之外，针对本项目选用的STM32F103C8T6芯片，还需要安装相关芯片库：双击”支持包”文件夹中的”Keil.STM32F1xx_DFP.2.2.0.pack”文件并点击”NEXT&gt;&gt;“即可完成安装。</p>
<p>完成软件环境的安装后，需要进入Keil5软件，点击上侧菜单栏中”Project-&gt;New μVision Project”新建工程，随后会进入到芯片设备的选择环节，选择芯片”STM32F103C8”并点击”OK”，在弹出的Manage Run-Time Environment对话框中再次点击”OK”即可完成工程创建。</p>
<p><img src="/images/control/media/image83.png" alt="图5.3：Keil5中STM32工程创建流程"><img src="/images/control/media/image84.png" alt="图5.3：Keil5中STM32工程创建流程"><img src="/images/control/media/image85.png" alt="图5.3：Keil5中STM32工程创建流程"><img src="/images/control/media/image86.png" alt="图5.3：Keil5中STM32工程创建流程"></p>
<p>当然事实上这样建立的工程仍然无法正常使用，还需要引入一系列启动文件与库函数文件等，具体流程在此不详细赘述，可以参考博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74800695/article/details/132817145">如何在keil中建立一个STM32F10x完整工程</a>。至此Keil5的软件环境安装及工程创建过程已经全部完成，再额外导入一些系统辅助函数文件（如”Delay.c”等），即可在”main.c”文件中进行闭环控制程序的编写了。</p>
<h3 id="5-2-ADC采样及PWM生成原理"><a href="#5-2-ADC采样及PWM生成原理" class="headerlink" title="5.2 ADC采样及PWM生成原理"></a>5.2 ADC采样及PWM生成原理</h3><p>ADC（Analog-to-Digital Converter），即模拟到数字转换器，主要用于将连续传输的模拟信号转换为数字信号，便于数字系统（如中央处理器CPU、微控制器MCU等）对传输信息进行快速处理和分析。</p>
<p><img src="/images/control/media/image87.png" alt="图5.4：STM32F103C8T6芯片参考手册中ADC相关模块"></p>
<p>采样是指ADC在一定时间间隔内对连续变化的模拟信号进行取样，得到一系列离散的样本点，实现在有限采样率条件下，无失真还原信号波形信息。采样率决定了每秒采集的样本量，通常单位为Hz；其必须满足奈奎斯特采样定理（大于信号最高频率的两倍），否则会产生混叠。</p>
<p>由于数字信号本身不具有实际意义，仅仅表示一个相对大小，故任何一个模数转换器都需要一个参考模拟量作为转换的标准，比较常见的参考标准为最大的可转换信号大小，而输出的数字量则表示输入信号相对于参考信号的大小。在STM32单片机中，ADC为12位，即单片机读取的ADC值应在0~4095范围内，这样的ADC值与0~3.3V的输入电压值之间存在线性对应关系（若输入电压范围超出0~3.3V，则需要在输入ADC引脚前加入电阻分压和放大器等外围电路，在2.3.4小节中有详细介绍该部分采样电路）。</p>
<p>PWM（Pulse Width Modulation），即脉冲宽度调制，是一种通过调节脉冲信号的宽度（即占空比，高电平持续时间占整个周期的比例）来控制输出信号平均值的方法。在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量。简单而言，PWM可以视为一种DA（数字-&gt;模拟）转换，通过产生PWM波形这一数字信号等效地实现了模拟信号的输出。</p>
<p><img src="/images/control/media/image88.jpeg" alt="图5.5：PWM信号示意图"></p>
<p>PWM实现的原理是：通过锯齿波/三角波(载波)所需要合成的波形（调制波）进行比较，然后确定PWM所需要输出的极性，锯齿波从比较器的反相端端输入，当大于参考电压时输出与锯齿波相反的极性，而当锯齿波从比较器同相端输入，当大于参考电压时输出与锯齿波相同极性。</p>
<p><img src="/images/control/media/image89.png" alt="图5.6：PWM实现流程：黄色线------计算器溢出频率（ARR），即PWM更新频率；红色线------捕获比较寄存器（CRR）的值；蓝色线------计数器（CNT）的值"></p>
<p>在Keil工程中，基于以上PWM生成原理编写函数文件”PWM.c”，其中包含了生成PWM波形所需的全部函数。实际运行时，PWM波形是通过定时器的计数和输出比较模块的配合生成的，其具体过程如下：</p>
<p>（1）计数器计数：TIM2定时器按照内部时钟驱动，从0计数到ARR（2999），然后重新清零，重复循环。</p>
<p>（2）比较与输出：定时器每次计数到CCR（1500）时，切换PWM输出的电平状态：从计数开始到计数器值为CCR时，输出高电平；从计数器值为CCR到ARR，输出低电平。</p>
<p>（3）占空比：由CCR与ARR的比值决定。程序中初始设定CCR=1500，ARR=2999，故可计算得出占空比为<br>$$<br>\frac{CCR}{ARR + 1} = 50%<br>$$<br>同时在主程序的控制过程中还可通过函数PWM_SetCompare1动态设置CCR值，从而实时改变占空比，进而影响输出的等效电压值。</p>
<h3 id="5-3-基本PI控制理论及程序"><a href="#5-3-基本PI控制理论及程序" class="headerlink" title="5.3 基本PI控制理论及程序"></a>5.3 基本PI控制理论及程序</h3><p>PI控制器是比例-积分控制器的一种，其核心是通过调节控制变量（输出电压），使系统输出接近目标值，是在控制工程中技术成熟、理论完善、应用最为广泛的一种控制策略。</p>
<p>对于PI控制器而言，其控制量的计算公式为：<br>$$<br>u(t) = K_{P} \cdot \mathbb{e}(t) + K_{I}\int\mathbb{e}(t)\mathbb{d}t<br>$$<br>其中：</p>
<p>（1）e(t)：当前时刻系统输出电压与参考电压之间的误差值；</p>
<p>（2）K_P：比例增益系数，用于快速响应；</p>
<p>（3）K_I：积分增益系数，用于消除稳态误差；</p>
<p>（4）u(t)：待控制变量——系统输出电压。</p>
<p>写成微分方程形式则为：<br>$$<br>\left{ \begin{aligned}<br> &amp; \dot{x} = K_{I}v \<br> &amp; y = K_{p}v + x<br>\end{aligned} \right.<br>$$<br>根据传递函数定义，其传递函数可表示为：</p>
<p>$$<br>G_{c}(s) = K_{p} + K_{I}\frac{1}{s} = \frac{K_{p}(\tau s + 1)}{\tau s}<br>$$<br>其中积分时间常数<br>$$<br>\tau = \frac{K_{p}}{K_{I}}<br>$$<br>PI控制器具有以下特点：</p>
<ol>
<li><p>从时域上看，只要存在偏差，积分就会不停对偏差积累，因此稳态时误差一定为零；</p>
</li>
<li><p>比例与积分动作都是对过去控制误差进行操作，不对未来控制误差进行预测，限制了控制性能；</p>
</li>
<li><p>PI调节将比例调节的快速反应与积分调节消除静差的特点结合，主要用于改善控制系统的稳态性能。</p>
</li>
</ol>
<p><img src="/images/control/media/image90.png" alt="图5.7：具有PI控制器的控制系统控制框图"></p>
<p>在Keil工程中的主函数文件”main.c”中，其main函数在进行了PWM、ADC与串口等必要的初始化后，在while循环中反复运行update_voltage_reference与control_buck两个函数，其中前者主要是进行参考电压的动态更新，而后者中则包含了PI控制的主要逻辑，部分核心代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error = voltage_ref \* <span class="number">2500</span> \* <span class="number">1000</span> / <span class="number">1050</span> / <span class="number">20000</span> - voltage_fb;</span><br><span class="line">integral += error;</span><br><span class="line">control_signal = KP \* error + KI \* integral;</span><br><span class="line">last_error = error;</span><br></pre></td></tr></tbody></table></figure>

<p>该段代码主要按照如下流程实现PI控制：</p>
<ol>
<li>误差计算：error<br>$$<br>e(t) = V_{ref} - V_{fb}<br>$$</li>
</ol>
<blockquote>
<p>其中V_ref（voltage_ref）为函数update_voltage_reference中设定的目标电压，而V_fb（voltage_fb）为系统输出并反馈至控制器的实际电压。</p>
</blockquote>
<ol start="2">
<li><p>积分计算：<br>$$<br>integral = \int\mathbb{e}(t)\mathbb{d}t<br>$$<br>为累加误差，用于消除系统的稳态误差（输出电压voltage_fb与参考电压voltage_ref的差值error）。</p>
</li>
<li><p>PI控制量：control_signal<br>$$<br>u(t) = K_{P} \cdot \mathbb{e}(t) + K_{I}\int\mathbb{e}(t)\mathbb{d}t<br>$$<br>为最终控制信号，用于调节PWM占空比。</p>
</li>
</ol>
<p>除此之外，为防止占空比超出合理范围，还对控制信号control_signal进行约束：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (control_signal \&gt; <span class="number">0.8</span>)</span><br><span class="line">	control_signal = <span class="number">0.8</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (control_signal \&lt; <span class="number">0.2</span>)</span><br><span class="line">	control_signal = <span class="number">0.2</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>除了PI控制的核心逻辑外，在主控函数control_buck中还实现了其他功能：</p>
<ol>
<li>模拟信号采集得到系统输出并反馈至控制器的实际电压V_fb（voltage_fb）：</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">voltage_fb = (<span class="type">float</span>)AD_GetValue()\*<span class="number">3.3</span>/<span class="number">4096</span>;</span><br><span class="line">trueVoltage = voltage_fb \* <span class="number">1050</span> \* <span class="number">20000</span> / <span class="number">2500</span> / <span class="number">1000</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>根据PI控制结果，实时更新PWM占空比：</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duty_cycle = control_signal \* PWM_PERIOD;</span><br><span class="line">i = (<span class="type">int</span>)duty_cycle;</span><br><span class="line">PWM_SetCompare1(i);</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>通过串口发送调试信息，用于监控采样值和控制效果：</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serial_Printf(\<span class="string">"%d,%.2f\\r\\n\", sample_index, trueVoltage);</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-4-闭环PI稳压调控输出（8V、10V）"><a href="#5-4-闭环PI稳压调控输出（8V、10V）" class="headerlink" title="5.4 闭环PI稳压调控输出（8V、10V）"></a>5.4 闭环PI稳压调控输出（8V、10V）</h3><p>5.3节中对于主控函数control_buck进行了详细的解析，整个闭环PI调控过程都由此函数完成，在此不重复赘述；而对于函数update_voltage_reference而言，该函数实现了电压的切换：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_voltage_reference</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    time_counter += <span class="number">40</span>; <span class="comment">// 每次调用增加计时器值</span></span><br><span class="line">    <span class="keyword">if</span> (time_counter \&gt;= <span class="number">10000</span>) <span class="comment">// 达到10秒{</span></span><br><span class="line">        time_counter = <span class="number">0</span>; <span class="comment">// 重置计时器</span></span><br><span class="line">        <span class="keyword">if</span> (voltage_state == <span class="number">0</span>){</span><br><span class="line">            voltage_ref = <span class="number">10.0</span>; <span class="comment">// 切换到10V</span></span><br><span class="line">            voltage_state = <span class="number">1</span>; <span class="comment">// 更新状态</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            voltage_ref = <span class="number">8.0</span>; <span class="comment">// 切换到8V</span></span><br><span class="line">            voltage_state = <span class="number">0</span>; <span class="comment">// 更新状态</span></span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，该函数每隔10秒就对于目标电压voltage_ref进行一次切换，由10V切换为8V，再由8V切换回10V，循环往复。该函数主要用于模拟动态负载或参考值变化的情景，以测试控制器再目标电压变化时的响应性能。</p>
<p>事实上，在main函数中，在进行各项初始化（PWM、ADC、串口等）后，while循环中只有参考电压切换函数update_voltage_reference与PI主控函数control_buck反复作用，也正是这两个函数使得该直流Buck变换器闭环控制PI系统能够交替稳压输出8V或10V的电压。</p>
<h3 id="5-5-闭环参考电压8V-10V连续跳变实验与分析（仿真-实验）"><a href="#5-5-闭环参考电压8V-10V连续跳变实验与分析（仿真-实验）" class="headerlink" title="5.5 闭环参考电压8V-10V连续跳变实验与分析（仿真+实验）"></a>5.5 闭环参考电压8V-10V连续跳变实验与分析（仿真+实验）</h3><p>在直流Buck变换器闭环PI控制系统参考电压8V-10V连续跳变实验时，重点对于输出电压分别为8V与10V的两种情况下单片机的PWM输出波形进行测试，通过观察其占空比反映其输出电压情况：</p>
<ol>
<li><p>先使用仿真器给单片机供电，以调试PWM波形输出是否正常；</p>
</li>
<li><p>将上述闭环控制程序放入Keil工程中，成功编译后烧录至单片机内，将单片机（最小系统板）插入电路板上预留的引脚接口处并上电测试，使用示波器或者上位机观测电路板PA8端口输出PWM波形的占空比。</p>
</li>
</ol>
<p><img src="/images/control/media/image91.jpeg" alt="图5.8：参考电压设置为10V时的PWM波形"></p>
<p><img src="/images/control/media/image92.jpeg" alt="图5.9：参考电压设置为8V时的PWM波形"></p>
<p>可以看到，在参考电压设置为8V时，单片机输出的PWM占空比明显小于参考电压为10V时的结果。</p>
<p>为进一步观察参考电压连续跳变时的动态响应过程，进行了对应的PSIM电路仿真（仿真参数：kp=0.12，τ_i=1/5000，R=2Ω），其中跳变效果通过在直流参考电压后接入一个周期方波信号实现，跳变周期为0.1s：</p>
<p><img src="/images/control/media/image93.png" alt="图5.10：参考电压8V-10V连续跳变PSIM仿真电路图"></p>
<p><img src="/images/control/media/image94.png" alt="图5.11：参考电压8V-10V连续跳变PSIM仿真动态响应结果"></p>
<p>可以看到，跳变瞬间系统的动态响应较快（约为0.01s）且输出电压稳定后震荡幅度较小，说明该参数下系统具有较好的动态响应性能。</p>
<h3 id="5-6-本章小结"><a href="#5-6-本章小结" class="headerlink" title="5.6 本章小结"></a>5.6 本章小结</h3><p>本章主要介绍了对于直流Buck变换器PI闭环控制的整体实验流程，从STM32单片机编程环境的搭建，到根据PWM生成原理编写PWM的初始化函数及占空比实时调控函数，再到根据PI控制的基础理论编写对应的主控代码，在参考电压连续跳变（8V-10V）的情况下调控闭环PI的稳压输出，最后将代码烧录进行实际实验，测试单片机的PWM输出调控情况，并通过仿真观察参考电压连续跳变时的动态响应情况。通过该闭环控制实验，充分证明了PI闭环控制系统对于直流Buck变换器具有良好的控制效果。</p>
<h2 id="6-复合PI控制直流Buck变换器"><a href="#6-复合PI控制直流Buck变换器" class="headerlink" title="6 复合PI控制直流Buck变换器"></a>6 复合PI控制直流Buck变换器</h2><h3 id="6-1-PI-超前校正（复合PI）分析设计"><a href="#6-1-PI-超前校正（复合PI）分析设计" class="headerlink" title="6.1 PI+超前校正（复合PI）分析设计"></a>6.1 PI+超前校正（复合PI）分析设计</h3><p>为提高PI闭环控制系统暂态响应速度，可以在原有的控制系统中加入一些其参数可以根据需要而改变的控制器，即对于系统进行校正，从而使整个系统的频率特性发生变化。本项目中针对直流Buck变换器的PI闭环控制系统，采用PI+串联超前校正的复合PI控制器，以进一步提升系统性能指标。</p>
<p><img src="/images/control/media/image95.png" alt="图6.1：串联超前校正环节示意图"></p>
<p>串联超前校正的核心思想是，将补偿中心ω_ m设计为期望剪切频率ω_ c处，从而提升剪切频率(补偿中心)所对应相位，并利用补偿处增益放大(+20)来改善剪切频率处斜率。具体的设计流程如下：</p>
<ol>
<li><p>根据静态性能指标，确定开环增益K</p>
</li>
<li><p>为确定校正环节的设计方向，根据所确定的开环增益，画出系统固有部分G_s(s)的波特图，并计算其剪切频率ω_ c1与相位裕度γ_ 0；</p>
</li>
<li><p>根据要求的相位裕度γ，确定<br>$$<br>\varphi_{m} = \mathrm{\Delta}\varphi = \gamma - \gamma_{0} + \varepsilon，\varepsilon =5° - 25°<br>$$<br>若<br>$$<br>\varphi_{m} &lt; 60{^\circ}<br>$$<br>说明可采用串联超前校正，即<br>$$<br>\varepsilon \approx \varphi（\omega_{c1}）-<br>\varphi（\omega_{c2}），\omega_{c1}为原穿越频率，\omega_{c2}为校正后穿越频率<br>$$</p>
</li>
<li><p>由φ_m确定α：<br>$$<br>$\alpha = \frac{1 + \sin\varphi_{m}}{1 - \sin\varphi_{m}} &gt; 1<br>$$</p>
</li>
<li><p>令校正后剪切频率<br>$$<br>\omega_{c2} = \omega_{m} = \frac{1}{T\sqrt{\alpha}}<br>$$</p>
</li>
<li><p>画出校正后系统的波特图，并验算相位裕度是否满足要求：若满足要求，则需要在原有PI控制器前增加环节<br>$$<br>G_{c}(s) = \frac{\alpha Ts + 1}{Ts + 1}<br>$$<br>若不满足要求，需增大ε的值，从第（3）步重新开始计算。</p>
</li>
</ol>
<p><img src="/images/control/media/image96.png" alt="图6.2：超前校正环节一般设计流程"></p>
<p>对于比例积分PI控制器，一般采用如下的超前校正方式：</p>
<p><img src="/images/control/media/image97.png" alt="图6.3：PI控制器超前校正电路原理图"></p>
<p>图6.3：PI控制器超前校正电路原理图</p>
<p>针对直流Buck变换器的PI闭环控制系统，给定PI控制器参数:<br>$$<br>K_{p} = 0.8、\tau = 1/5000<br>$$<br>负载电阻<br>$$<br>R = 2\Omega<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 1V<br>$$<br>根据3.1节给出的系统开环传递函数（不考虑电容寄生电阻）：<br>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1}<br>$$<br>在MWorks中编写如下代码绘制校正前的波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">vm=<span class="number">1</span>;</span><br><span class="line">r=<span class="number">2</span>;</span><br><span class="line">c=<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">l=<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">vg=<span class="number">20</span>;</span><br><span class="line">kp=<span class="number">0.8</span>;</span><br><span class="line">tao=<span class="number">1</span>/<span class="number">5000</span>;</span><br><span class="line">G=kp*(tao*s+<span class="number">1</span>)*vg/(tao*s*vm*(l*c*s*s+(l/r)*s+<span class="number">1</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p>绘制出校正前的波特图：</p>
<p><img src="/images/control/media/image98.png" alt="图6.4：校正前MWorks绘制波特图"></p>
<p>从图中可读出：校正前系统的剪切频率<br>$$<br>\omega_{c1}≈4.20*10^{4}rad/s<br>$$<br>相位裕度<br>$$<br>\gamma_{0}≈0{^\circ}<br>$$<br>此时系统处于临界稳定状态。</p>
<p>为使得校正后的相位裕度<br>$$<br>\gamma &gt; 30{^\circ}<br>$$<br>可确定需增加的相位裕度<br>$$<br>\varphi_{m} = \mathrm{\Delta}\varphi = \gamma - \gamma_{0} + \varepsilon = 30{^\circ} - 0{^\circ} + 15.5{^\circ} = 45.5{^\circ} &lt; 60{^\circ}<br>$$<br>满足超前校正要求，进而可以确定</p>
<p>$$<br>\alpha = \frac{1 + \sin\varphi_{m}}{1 - \sin\varphi_{m}} \approx 6<br>$$<br>又因为系统周期<br>$$<br>T = \frac{1}{70000}s<br>$$<br>从而可以确定增加的超前校正环节的开环传递函数为：</p>
<p>$$<br>H(s) = \frac{\frac{6}{70000}s + 1}{\frac{1}{70000}s + 1}<br>$$<br>这意味着校正后整个闭环控制系统的传递函数变为<br>$$<br>T^{‘}(s) = T(s)H(s)<br>$$<br>可在上述MWorks代码的基础上增加下列代码以实现对于校正后闭环控制系统波特图的绘制：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">H=(<span class="number">6</span>*s/<span class="number">70000</span>+<span class="number">1</span>)/(s/<span class="number">70000</span>+<span class="number">1</span>);</span><br><span class="line">G1=G*H;</span><br><span class="line">bode(G1);</span><br></pre></td></tr></tbody></table></figure>

<p>绘制出校正后的波特图：</p>
<p><img src="/images/control/media/image99.png" alt="图6.5：校正后MWorks绘制波特图"></p>
<p>从图中可读出：校正后系统的剪切频率<br>$$<br>\omega_{c2}≈8.71*10^{4}rad/s<br>$$<br>相位裕度<br>$$<br>\gamma≈31{^\circ} &gt; 30{^\circ}<br>$$<br>相位裕度较校正前有明显提升且满足系统对品质指标的要求，校正正确。</p>
<h3 id="6-2-复合PI控制PSIM仿真（校正前后参考电压变化时输出电压分析）"><a href="#6-2-复合PI控制PSIM仿真（校正前后参考电压变化时输出电压分析）" class="headerlink" title="6.2 复合PI控制PSIM仿真（校正前后参考电压变化时输出电压分析）"></a>6.2 复合PI控制PSIM仿真（校正前后参考电压变化时输出电压分析）</h3><p>首先通过PSIM扫频仿真对先前波特图的MWorks绘制结果进行验证：</p>
<p><img src="/images/control/media/image100.png" alt="图6.6：超前校正控制PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image101.png" alt="图6.7：校正前PSIM扫频仿真结果"></p>
<p><img src="/images/control/media/image102.png" alt="图6.8：校正后PSIM扫频仿真结果"></p>
<p>从图中可读出：校正前系统的剪切频率<br>$$<br>\omega_{c1}≈6554Hz<br>$$<br>相位裕度<br>$$<br>\gamma_{0}≈0{^\circ}<br>$$<br>校正后系统的剪切频率<br>$$<br>\omega_{c2}≈14126Hz<br>$$<br>相位裕度<br>$$<br>\gamma≈35{^\circ}<br>$$<br>与MWorks绘制的波特图结果基本一致。</p>
<p>为反映超前校正的引入对于系统暂态响应速度的提升效果，搭建PSIM仿真电路，分析校正前后参考电压跳变瞬间的输出电压响应情况：</p>
<p><img src="/images/control/media/image103.png" alt="图6.9：超前校正控制参考跳变PSIM仿真电路图"></p>
<p><img src="/images/control/media/image104.jpeg" alt="图6.10：校正前系统暂态响应PSIM仿真结果"></p>
<p><img src="/images/control/media/image105.jpeg" alt="图6.11：校正后系统暂态响应PSIM仿真结果"></p>
<p>对比校正前后参考电压跳变瞬间的输出电压暂态响应PSIM仿真结果，可以发现：校正前系统暂态响应时间约为0.034s，而加入超前校正环节后系统暂态响应时间为0.0006s，较校正前有显著缩短，说明超前校正的引入有效提升了系统的动态响应特性（快速性）。</p>
<h3 id="6-3-PI-微分环节D（PID）分析设计"><a href="#6-3-PI-微分环节D（PID）分析设计" class="headerlink" title="6.3 PI+微分环节D（PID）分析设计"></a>6.3 PI+微分环节D（PID）分析设计</h3><p>除增加串联超前校正环节设计外，还可以通过在原有PI控制器基础上加入微分环节D实现PID闭环控制来提升系统的稳定性与暂态响应速度。事实上，在PID控制器的三个环节中，比例环节P主要负责动态性能的提升，积分环节I主要负责稳态精度的提升，而引入微分环节D则可进一步改善系统的稳定裕度以提升系统稳定性。</p>
<p><img src="/images/control/media/image106.png" alt="图6.12：PID控制器电路原理图"></p>
<p>与PI控制器类似，通过对PID控制器的微分方程组进行拉普拉斯变换，可以得到其传递函数为：<br>$$<br>G_{c}(s) = \frac{K_{p}(\tau_{i}s + 1)}{\tau_{i}s} + \tau_{d}s<br>$$<br>其中τ_ i为积分时间常数，而τ_ d为微分时间常数。</p>
<p>接下来将通过MWorks绘制波特图，配合PSIM的扫频仿真结果，从相位裕度的角度来反映微分环节D的引入对于系统稳定性的提升：</p>
<p>对于PI控制器，给定控制器参数:<br>$$<br>K_{p} = 0.12、\tau = 1/5000<br>$$<br>负载电阻<br>$$<br>R = 2\Omega<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 1V<br>$$<br>根据3.1节给出的系统开环传递函数（不考虑电容寄生电阻）：<br>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1}$<br>$$<br>在MWorks中编写如下代码绘制波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">vm=<span class="number">1</span>;</span><br><span class="line">r=<span class="number">2</span>;</span><br><span class="line">esr=<span class="number">0.107185</span>;</span><br><span class="line">c=<span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">l=<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">vg=<span class="number">15</span>;</span><br><span class="line">kp=<span class="number">0.12</span>;</span><br><span class="line">tao=<span class="number">1</span>/<span class="number">5000</span>;</span><br><span class="line">G=kp*(tao*s+<span class="number">1</span>)\*(esr*c*s+<span class="number">1</span>)*vg/(tao*s*vm*(l*c*(<span class="number">1</span>+esr/r)*s*s+(l/r+esr*c)*s+<span class="number">1</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/control/media/image107.png" alt="图6.13：PI控制器MWorks绘制波特图"></p>
<p>同时在PSIM中搭建扫频仿真电路，通过扫频仿真结果验证MWorks绘制波特图的正确性：</p>
<p><img src="/images/control/media/image108.png" alt="图6.14：PI控制器PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image109.png" alt="图6.15：PI控制器PSIM扫频仿真结果"></p>
<p>从图中可读出：PI闭环控制系统剪切频率<br>$$<br>\omega_{c}≈6.78*10^{3}rad/s \approx 1105Hz<br>$$<br>相位裕度<br>$$<br>\gamma$≈$10{^\circ}<br>$$<br>且MWorks绘制波特图与PSIM扫频仿真结果基本一致。</p>
<p>对于加入微分环节D后的PID控制器，给定控制器参数:<br>$$<br>K_{p} = 0.12、\tau_{i} = 1/5000、\tau_{d} = 0.00001<br>$$<br>负载电阻<br>$$<br>R = 2\Omega<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 1V<br>$$<br>根据3.1节给出的系统开环传递函数（不考虑电容寄生电阻）并将其中PI控制器的传递函数替换为PID控制器的传递函数，可得到PID闭环控制系统的开环传递函数：<br>$$<br>T(s) = (\frac{K_{p}(\tau_{i}s + 1)}{\tau_{i}s} + \tau_{d}s)\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1}<br>$$<br>在MWorks中编写如下代码绘制波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">vm=<span class="number">1</span>;</span><br><span class="line">r=<span class="number">2</span>;</span><br><span class="line">esr=<span class="number">0.107185</span>;</span><br><span class="line">c=<span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">l=<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">vg=<span class="number">15</span>;</span><br><span class="line">kp=<span class="number">0.12</span>;</span><br><span class="line">tao=<span class="number">1</span>/<span class="number">5000</span>;</span><br><span class="line">taod=<span class="number">0.00001</span>;</span><br><span class="line">G=(kp*(tao*s+<span class="number">1</span>)+taod*tao*s*s)*(esr*c*s+<span class="number">1</span>)*vg/(tao*s*vm*(l*c*(<span class="number">1</span>+esr/r)*s*s+(l/r+esr*c)*s+<span class="number">1</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/control/media/image110.png" alt="图6.16：PID控制器MWorks绘制波特图"></p>
<p>同时在PSIM中搭建扫频仿真电路，通过扫频仿真结果验证MWorks绘制波特图的正确性：</p>
<p><img src="/images/control/media/image111.png" alt="图6.17：PID控制器PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image112.png" alt="图6.18：PID控制器PSIM扫频仿真结果"></p>
<p>从图中可读出：PID闭环控制系统剪切频率<br>$$<br>\omega_{c}≈6.78*10^{3}rad/s \approx 1026Hz<br>$$<br>相位裕度<br>$$<br>\gamma≈36{^\circ}<br>$$<br>且MWorks绘制波特图与PSIM扫频仿真结果基本一致。</p>
<p>通过对比PI和PID控制下的波特图与扫频结果可以发现，相比于PI控制器，PID控制下的直流Buck变换器闭环系统具有更高的相位裕度，这意味着在加入微分环节D之后，系统具有更好的稳定性。</p>
<h3 id="6-4-PID控制PSIM仿真（校正前后R变化时输出电压分析）"><a href="#6-4-PID控制PSIM仿真（校正前后R变化时输出电压分析）" class="headerlink" title="6.4 PID控制PSIM仿真（校正前后R变化时输出电压分析）"></a>6.4 PID控制PSIM仿真（校正前后R变化时输出电压分析）</h3><p>为反映微分环节D的引入对于系统稳定性与响应速度的提升效果，搭建PSIM仿真电路，分析PI与PID控制器在负载电阻R不同时输出电压响应情况：</p>
<p><img src="/images/control/media/image113.png" alt="图6.19：PI控制器动态响应PSIM仿真电路图"></p>
<p><img src="/images/control/media/image114.png" alt="图6.20：PI控制器负载电阻R=2Ω时动态响应PSIM仿真结果"></p>
<p><img src="/images/control/media/image115.png" alt="图6.21：PI控制器负载电阻R=5Ω时动态响应PSIM仿真结果"></p>
<p><img src="/images/control/media/image116.png" alt="图6.22：PID控制器动态响应PSIM仿真电路图"></p>
<p><img src="/images/control/media/image117.png" alt="图6.23：PID控制器负载电阻R=2Ω时动态响应PSIM仿真结果"></p>
<p><img src="/images/control/media/image118.png" alt="图6.24：PID控制器负载电阻R=5Ω时动态响应PSIM仿真结果"></p>
<p>对比PI与PID控制器在负载电阻R不同时的输出电压暂态响应PSIM仿真结果，可以发现：当负载电阻R=2Ω时，在原有的PI控制器闭环控制下，系统的暂态响应时间约为0.008s，而加入微分环节D后，系统在PID控制器的闭环控制下暂态响应时间为0.004s，这意味着在加入微分环节D后，系统的动态响应特性得到一定提升（响应时间缩短50%）；除此之外，在相同的控制器作用下，随着负载电阻阻值由2Ω增大到5Ω，系统的输出电压在稳定后的振荡幅度明显减，但此时暂态响应时间也明显增加（增加近两倍）。</p>
<h3 id="6-5-本章小结"><a href="#6-5-本章小结" class="headerlink" title="6.5 本章小结"></a>6.5 本章小结</h3><p>本章主要介绍了基于PI控制器的校正设计，对于直流Buck变换器的闭环控制而言，分别采用在原有控制系统上增加超前校正环节与微分环节D的两种校正方式实现复合PI控制，通过MWorks绘制波特图与PSIM扫频仿真，反映校正环节的引入对于相位裕度即系统稳定性的提升效果，并结合PSIM电路仿真的输出电压结果，观察校正环节的引入对于系统暂态响应速度即动态响应特性的提升效果。仿真实验结果表明，对于PI控制器的校正设计（超前校正/引入微分环节形成PID控制）在提升系统稳定性与动态响应快速性方面取得了良好的效果。</p>
<h2 id="7-基于直流电源调控的自动调光控制设计"><a href="#7-基于直流电源调控的自动调光控制设计" class="headerlink" title="7 基于直流电源调控的自动调光控制设计"></a>7 基于直流电源调控的自动调光控制设计</h2><p>该系统的主要功能是将灯的电压通过直流Buck变换器完成闭环PID控制，将输出电压控制在0-15V范围内。系统主要包含电量控制与亮度控制两个部分，其中电量控制由STM32数字控制器通过电压控制信号调节Buck变换器输出电压；亮度控制则通过光敏传感器感知外界光强，并将反馈信号传递给STM32，实现对LED灯源亮度的动态调整，从而形成电压与亮度的双闭环调节系统。</p>
<p><img src="/images/control/media/image119.png" alt="图7.1：基于直流电源调控的自动调光系统整体架构"></p>
<p>基于该架构，系统设计的基本流程如下：</p>
<ol>
<li><p>搭建Buck电路控制系统，用于调控LED灯源；</p>
</li>
<li><p>使用开发工具Keil5编写STM32控制程序，实现PWM信号生成和调节；</p>
</li>
<li><p>将光敏传感器的输出连接到STM32的ADC（模数转换器）端口；</p>
</li>
<li><p>设计闭环控制系统并编写主控程序，实现根据光照强度自动调节PWM占空比，从而控制LED灯光的亮度；</p>
</li>
<li><p>调试系统，过程中实时监测电路工作状态，确保电路安全稳定运行且光照强度变化时LED灯亮度能够迅速进行响应调整；</p>
</li>
<li><p>对系统功能进行测试与优化，验证系统的响应速度和调光精度。</p>
</li>
</ol>
<p><img src="/images/control/media/image120.png" alt="图7.2：基于直流电源调控的自动调光系统设计流程"></p>
<p>除此之外，在系统基本功能的设计实现基础上，还进行了基于无线通信的远程控制这一拓展功能设计，将调光系统与蓝牙无线通信模块结合，实现通过手机应用对LED灯进行调光控制，增加系统的便携性和灵活性。</p>
<p>接下来将分模块具体阐述自动调光控制系统各功能设计的详细过程。</p>
<h3 id="7-1-默认电压值设置"><a href="#7-1-默认电压值设置" class="headerlink" title="7.1 默认电压值设置"></a>7.1 默认电压值设置</h3><p>在系统上电之后，输出电压默认设置为9V。之所以选择9V作为默认值，是因为这一电压能够在不消耗过多能量的情况下提供足够的亮度，同时避免由于过高或过低电压对系统性能的影响。</p>
<p>具体来说，9V的默认值具有以下几个优点：</p>
<p>（1）能耗平衡：相较于较低电压（5V），9V能够提供更高的亮度输出，同时不会像满电压（15V）那样带来显著的能量消耗，适合作为常规环境下的起始亮度。</p>
<p>（2）避免电压冲击：在系统刚启动时，设定较高的默认电压可能会导致电流冲击，影响电源和负载的寿命。9V作为中间值，有效降低了这种风险。</p>
<p>（3）用户体验优化：默认电压为9V时，灯光亮度适中，避免了开机过亮或过暗对用户造成的不适，同时为后续手动或自动调节提供了便利。</p>
<p>（4）环境适应性：在普通家庭或办公室环境下，9V的亮度通常能满足基本照明需求，而无需立即调整，增强了系统的即用性。</p>
<p>此外，9V的默认值通过主程序固化设置，确保每次系统启动时都能快速恢复到该默认电压值。这一设置不仅提高了系统的稳定性，还为后续用户操作提供了可靠的初始状态。设计中对默认电压的选择经过多次实验验证，综合考虑了实际照明需求和电源性能，最终确定了这一合理数值。</p>
<h3 id="7-2-蓝牙接口通信控制"><a href="#7-2-蓝牙接口通信控制" class="headerlink" title="7.2 蓝牙接口通信控制"></a>7.2 蓝牙接口通信控制</h3><p>在本系统中，蓝牙模块被用作与手机或其他移动设备的通信桥梁，用户可通过蓝牙实现对灯光的远程控制，增强系统的操作便利性和用户体验。蓝牙模块选用低功耗蓝牙（Bluetooth Low Energy, BLE）技术，保证了通信的可靠性和功耗优化。具体而言，蓝牙通信具有以下优点：</p>
<ul>
<li><p>便捷性：用户可通过手机远程调节灯光，无需物理接触，尤其适合家庭场景。</p>
</li>
<li><p>可扩展性：蓝牙接口支持更多功能指令的扩展，如灯光模式切换等。</p>
</li>
<li><p>低成本实现：蓝牙模块硬件成本低，结合STM32可轻松实现稳定通信。</p>
</li>
</ul>
<p>以下是蓝牙接口通信功能的详细设计：</p>
<ol>
<li>硬件接口设计</li>
</ol>
<ul>
<li><p>蓝牙模块选型：选用HC-05蓝牙模块，该模块具有支持串行通信（UART）功能，能与STM32单片机直接连接；模块通过UART接口与STM32的USART1通道连接，波特率设置为9600bps以平衡数据传输速率与稳定性。</p>
</li>
<li><p>引脚连接：蓝牙模块的TX和RX引脚分别连接STM32的RX和TX引脚，模块的VCC和GND引脚分别接单片机供电端和地线，保证模块稳定供电。</p>
</li>
</ul>
<ol start="2">
<li>软件功能设计</li>
</ol>
<p>蓝牙通信通过STM32主程序实现对蓝牙模块接收指令的解析和响应。指令的解析流程大致是这样的：主程序中设定一个蓝牙接收缓冲区，用于存储用户发送的指令；当蓝牙模块接收到数据时，触发中断，将数据写入缓冲区；程序定时轮询缓冲区，并根据指令类型解析执行以下指令以实现功能，包括灯的开关、亮度百分比调整，以及环境光自动调节的触发：</p>
<ul>
<li>“on”/“off”指令：通过电压直接跳转的方式实现即时开关</li>
</ul>
<blockquote>
<p>“on”：将输出电压设定为最大值15V，点亮灯光；</p>
<p>“off”：将输出电压设定为最小值0V，关闭灯光。</p>
</blockquote>
<ul>
<li><p>亮度调整指令：接收一个0-100的整数，表示灯光亮度为15V的百分比。程序计算目标电压时依据公式：<br>$$<br>V_{target} = \frac{百分比指令}{100} \times 15<br>$$<br>调用PWM控制函数调整Buck变换器的输出电压至目标值，实现实时亮度调节。</p>
</li>
<li><p>“LL”指令：触发光敏传感器，启动环境光度自动调节模式（详见7.3节）。</p>
</li>
</ul>
<ol start="3">
<li>通信协议设计</li>
</ol>
<p>蓝牙通信基于简单的ASCII协议，用户可通过手机APP或终端工具发送指令。每条指令均以换行符\n结尾，便于解析。以下是通信协议的具体格式：</p>
<ul>
<li><p>“on\n”：开启灯光。</p>
</li>
<li><p>“off\n”：关闭灯光。</p>
</li>
<li><p>“50\n”：将亮度设置为50%。</p>
</li>
<li><p>“LL\n”：启动环境光度自动调节模式。</p>
</li>
</ul>
<p>通过蓝牙接口通信，系统不仅支持手动调节灯光，还为后续的智能化功能扩展奠定了基础。</p>
<h3 id="7-3-基于光敏传感器的调光功能"><a href="#7-3-基于光敏传感器的调光功能" class="headerlink" title="7.3 基于光敏传感器的调光功能"></a>7.3 基于光敏传感器的调光功能</h3><p>本系统采用光敏传感器对环境光强进行实时检测，并基于检测值动态调整灯光的亮度，提供适应不同场景的自动调光功能。通过光敏传感器实现调光，既可以减少用户手动调整灯光的频率，还可以自动优化输出电压，适用多种场景需求。通过闭环控制机制，确保灯光的输出电压与环境光强度的变化相匹配，为用户提供更舒适、高效的照明体验。以下为光敏传感器调光功能的详细设计与实现过程：</p>
<ol>
<li>硬件接口设计</li>
</ol>
<ul>
<li><p>光敏传感器选型：选用光敏电阻模块，输出光强的模拟信号值。传感器将环境光强信号转换为电压信号，供STM32单片机的ADC模块读取。</p>
</li>
<li><p>传感器连接方式：光敏传感器的模拟输出端（AO口）连接到STM32单片机的PA5引脚，PA5被配置为ADC输入通道。供电引脚（VCC）连接单片机的3.3V供电，地线（GND）连接系统地，保证传感器的稳定工作。</p>
</li>
</ul>
<ol start="2">
<li>软件功能设计</li>
</ol>
<ul>
<li><p>数据采集与转换：STM32通过ADC模块以一定采样频率读取光敏传感器的模拟信号，模拟值范围为0到4095，对应电压范围为0到3.3V；可通过公式<br>$$<br>V_{target} = \frac{ADC值}{4095} \times 15<br>$$<br>将光强模拟值映射为输出电压目标值，该线性映射关系保证了灯光亮度的平滑过渡，避免突然变化对用户产生视觉不适。</p>
</li>
<li><p>调光逻辑与策略：当ADC值低于预设阈值（如1024）时，认为环境光较暗，此时系统逐步增加输出电压，以提高灯光亮度补偿环境光；当ADC值高于预设阈值（如3072）时，认为环境光较亮，此时系统逐步降低输出电压，以避免浪费电能或造成视觉不适；当光强处于中等范围时（ADC值1024到3072），输出电压以线性比例动态调节，保持环境与灯光亮度的适应性平衡。</p>
</li>
<li><p>PID闭环控制：根据光敏电阻值计算目标电压，并作为参考值输入PID控制器；PID控制器实时计算实际输出电压与目标电压之间的误差，并调整PWM信号占空比控制Buck变换器，确保输出电压快速稳定地收敛到目标值。</p>
</li>
<li><p>状态反馈与异常处理：当光敏传感器信号异常（如ADC值恒定不变或超出有效范围）时，系统进入保护模式，将输出电压设定为安全值9V，并通过蓝牙模块通知用户；传感器数据每次读取后均存储在缓冲区中，并定期更新，避免因单次采样噪声造成调光不稳定。</p>
</li>
</ul>
<p>为进一步验证调光功能的灵敏度，需要测试光敏传感器在不同光强条件下的响应时间和精度，确保其采集的光强信号与实际环境光强相符。经过调试，光敏电阻灵敏度较高，但光敏电阻的朝向会对空间中同一点的光敏传感有不同的值。解决方式为固定光敏电阻朝向位置，使其主要接收来自上方的环境光。除此之外，还需要验证在自动调光模式下，灯光亮度调整是否与环境光变化相匹配。经过我们的实验，该灯泡在8V电压以下不会发光，且为了保护电路和用户，我们将最高输出电压15V通过程序限制在12V，于是我们将光亮百分比线性映射公式修改为：<br>$$<br>V_{target} = \frac{百分比指令}{100} \times 4 + 8<br>$$<br>从而使得亮度百分比更符合实际；由于百分比电压现在被限制在8-12V，光敏需要更多的外边界，从原先0-15V电压的计算，改为5-15V电压的线性映射，光敏电阻映射公式也需要对应修改为：<br>$$<br>V_{target} = \frac{ADC值}{4095} \times 10 + 5<br>$$<br>此时由于光敏电阻在一般的环境光下位于1024-3072而并不会趋于极端值，且程序有保护设计，故一定可以限制输出电压在8-12V范围内。</p>
<p>为进一步优化用户的使用体验，还开展了用户测试实验为产品优化提供参考。实验记录了光敏传感器自动调光时用户的视觉体验，并通过调整PID参数和映射公式提高舒适性。通过光敏传感器的引入，本系统实现了基于环境光强的自动调光功能，显著提升了灯光控制的智能化水平与用户体验。</p>
<h3 id="7-4-闭环PID控制原理"><a href="#7-4-闭环PID控制原理" class="headerlink" title="7.4 闭环PID控制原理"></a>7.4 闭环PID控制原理</h3><p>闭环PID控制是本系统的核心功能之一，负责根据目标输出电压值和实际输出电压值的误差，动态调节PWM信号，从而控制Buck变换器的输出电压，实现稳定、精准的调光效果。通过PID控制算法，可以使Buck变换器的输出电压始终接近目标值，无论输入电压波动、负载变化，还是环境光强条件改变，都能够保持系统的高稳定性和快速响应性。</p>
<p>PID控制算法主要由三部分组成：比例（P）、积分（I）、微分（D），可通过公式<br>$$<br>u(t) = K_{p}e(t) + K_{i}\int_{0}^{t}{e(\tau)d\tau} + K_{d}\frac{de(t)}{dt}<br>$$<br>计算其控制输出，其中u(t)为控制信号（用于调节PWM占空比）；e(t)为当前误差值，定义为目标值与实际值之差，即<br>$$<br>e(t) = V_{target} - V_{actual}<br>$$<br>K_p,K_i,K_d分别为比例、积分、微分的调节系数，分别控制系统的响应速度、稳态误差消除能力和动态性能。</p>
<p>通过调节K_p,K_i,K_d三个参数，可以调整控制器的性能，从而实现系统响应特性的优化，提升系统控制效果。具体而言，三个参数对于响应输出的影响如下：</p>
<ul>
<li><p>比例（P）参数K_p：比例项主要控制误差对输出的直接影响，增大K_p会使系统响应更迅速，但过大可能引起震荡。本系统初始设置<br>$$<br>K_{p} = 0.1<br>$$<br>通过实验验证实现了较平滑的响应。</p>
</li>
<li><p>积分（I）参数K_i：积分项通过累积误差消除稳态误差，确保输出精度。由于积分过大会导致超调或积分饱和，本系统设置<br>$$<br>K_{i} = 0.01<br>$$</p>
</li>
<li><p>微分（D）参数K_d：微分项对误差变化率进行调节，用于改善动态性能并抑制震荡。为避免过分灵敏的微分效应引入噪声，D参数设置为较小值<br>$$<br>K_{d} = 0.01<br>$$</p>
</li>
</ul>
<p>在本项目的自动调光系统中，PID控制器的控制流程主要分为如下几个步骤：</p>
<ol>
<li><p>误差计算：STM32单片机实时采集目标电压值 V_target 和实际输出电压值 V_actual，计算误差：<br>$$<br>e(t) = V_{target} - V_{actual}<br>$$</p>
</li>
<li><p>控制信号计算：根据误差值，通过PID公式计算控制信号u(t)，调整PWM信号的占空比：<br>$$<br>u(t) = K_{p}e(t) + K_{i}\sum_{k = 0}^{t}{e(k)\mathrm{\Delta}t} + K_{d}\frac{e(t) - e(t - 1)}{\mathrm{\Delta}t}<br>$$<br>其中Δt为控制周期；∑e(k)Δt为误差累积值；(e(t)-e(t-1))/Δt为误差变化率。</p>
</li>
<li><p>PWM调节：将计算得到的u(t)映射为PWM信号的占空比，直接控制Buck变换器的输出电压。占空比范围为10%至80%，对应输出电压范围为0V至15V。</p>
</li>
<li><p>反馈调整：系统持续监测实际输出电压，更新误差值并重复上述步骤，形成闭环控制。</p>
</li>
</ol>
<p>在基于STM32单片机编写程序具体实现PID控制器算法时，还需要特别注意以下两点：</p>
<ul>
<li><p>采样频率：ADC采样频率需要设置为与main函数主循环频率同步，以保证控制系统对输入误差的快速响应。同时PID计算周期也应同步于ADC采样，以避免数据滞后影响调节效果。</p>
</li>
<li><p>保护机制：若误差值持续过大（如超出安全范围），系统触发保护模式，因此实际实现时将PWM占空比最小设为10%，最大设为80%。</p>
</li>
</ul>
<p>在实际调试验证时，主要对于控制系统的动态性能与抗干扰能力进行了测试与优化，以进一步提升自动调光功能的灵敏性与稳定性，从而优化用户体验：</p>
<ul>
<li><p>动态性能测试：在快速切换目标电压值时，观察系统的响应时间和稳定性，确保输出电压能够迅速收敛到目标值。在负载变化的情况下，验证系统能否保持输出电压的稳定。</p>
</li>
<li><p>抗干扰能力测试：模拟输入电压波动和环境光强突变，测试系统的鲁棒性和PID调节效果。</p>
</li>
</ul>
<p>最终经过多次调试与不断优化，该闭环PID控制系统实现了以下目标：</p>
<ul>
<li><p>高精度输出：在误差范围内快速稳定输出目标电压。</p>
</li>
<li><p>快速响应：对目标值或负载变化的响应时间快，满足实际调光需求。</p>
</li>
<li><p>稳定性强：在输入波动、负载变化和环境干扰下，系统保持良好的稳定性。</p>
</li>
</ul>
<h3 id="7-5-外观设计制作"><a href="#7-5-外观设计制作" class="headerlink" title="7.5 外观设计制作"></a>7.5 外观设计制作</h3><p>为了使本系统不仅具有实用性，还能满足美观性和设计感的需求，我们对外观部分进行了重新设计和制作。本节详细介绍了外观设计的灵感来源、制作过程以及技术实现中的注意事项。</p>
<p>本系统的外观设计灵感来源于游戏《无畏契约》（Valorant）中的角色”尚博勒”（Chamber）的道具”摄像头”。这一设计概念契合科技感与现代感的视觉效果，适合科技爱好者的审美需求，同时其独特的造型也为灯具的装饰性增色。我们力求将其视觉元素融入本项目，打造一款既具功能性又有极高辨识度的灯具设备。同时在外壳设计时也结合了灯泡的散热需求，保证了灯具长时间工作时的安全性和稳定性。设计中注重可拆卸性，用户可以方便地调整灯泡朝向和光照亮度。</p>
<p><img src="/images/control/media/image121.jpeg" alt="图7.3：产品外观设计原型"></p>
<p>详细的制作过程如下：</p>
<ol>
<li>原型拆解</li>
</ol>
<p>我们首先将旧灯具的灯罩部分锯下来，仅保留其内部核心组件，包括灯泡、散热装置、电路板和连接线。为确保灯具正常运行，对保留的灯泡和电路板进行功能检测，确认其性能稳定，并清理了原型中多余的固定结构，为后续的外壳重新设计预留空间。</p>
<p><img src="/images/control/media/image122.jpeg" alt="图7.4：灯具原型拆解部分过程"><img src="/images/control/media/image123.jpeg" alt="图7.4：灯具原型拆解部分过程"></p>
<ol start="2">
<li>3D建模与设计</li>
</ol>
<p>使用Fusion 360软件，根据”尚博勒摄像头”的设计特点，建模了一个以球体和多面体造型的外壳结构。模拟摄像头的结构，在灯具上设计了圆形凹陷部分，提升灯具的科技感。外壳设计了散热格栅，与灯具散热需求相结合；外壳底部设计了支撑脚架，便于放置和移动。摄像头部分设计轨道凹槽，可旋转控制摄像头方向。</p>
<p><img src="/images/control/media/image124.png" alt="图7.5：产品外形3D建模效果图"></p>
<ol start="3">
<li>材料选择与加工</li>
</ol>
<p>外壳部分采用轻质耐用的 PLA 材料，利用3D打印技术制作。打印分为两个部分：上半部分为灯具主壳，下半部分为安装支架，组装后固定。3D打印完成后，外壳表面进行手工打磨并喷涂金色亚光涂料，灯罩边缘则涂上金属漆，营造高科技感。</p>
<ol start="4">
<li>组件安装与调试</li>
</ol>
<p>将灯泡、电路板、散热器嵌入3D打印外壳中，通过卡扣、限位固定，确保结构稳固。为避免外壳对散热产生影响，在装配后对设备进行长时间运行测试，确保温度稳定在安全范围内。重新调整灯光的投射方向和亮度，使其与设计的外壳结构匹配，确保在不同环境下具备良好的照明效果。</p>
<p><img src="/images/control/media/image125.jpeg" alt="图7.6：最终产品样机实物图"></p>
<p>为进一步提升用户体验，后续将持续对产品进行深度优化，包括添加更多灯光模式（如动态光效或多色渐变）以进一步增强装饰性和互动性，或引入语音控制功能并将其与蓝牙通信相结合以提升智能化体验。</p>
<h3 id="7-6-本章小结"><a href="#7-6-本章小结" class="headerlink" title="7.6 本章小结"></a>7.6 本章小结</h3><p>本章介绍了基于直流电源调控的自动调光控制设计，通过蓝牙模块完成手动输出电压控制，通过光敏传感器进行环境光度自动调节，最终通过Buck变换器闭环PID控制完成灯的电压和光亮度稳定。</p>
<h2 id="8-基于直流电源调控的光伏MPPT控制设计"><a href="#8-基于直流电源调控的光伏MPPT控制设计" class="headerlink" title="8 基于直流电源调控的光伏MPPT控制设计"></a>8 基于直流电源调控的光伏MPPT控制设计</h2><h3 id="8-1-设计背景与系统架构"><a href="#8-1-设计背景与系统架构" class="headerlink" title="8.1 设计背景与系统架构"></a>8.1 设计背景与系统架构</h3><p>光伏发电是当前清洁能源的主流之一，最大功率点跟踪（Maximum Power Point Tracking, MPPT）是光伏系统中提高效率的关键技术。由于光伏板的输出功率受到光照强度影响，不同的光照强度下最大功率点对应的输出电压不同，需要不断通过改变输出电压来寻找最大功率点（MPP）。因此，希望通过搭建一个基于直流电源调控的光伏MPPT控制系统，结合STM32单片机和Buck变换器实现光伏阵列的最大功率点跟踪，从而使得系统维持在最大功率工作，减少不必要的能量损失，有效储存其他能量转化成的电能。</p>
<p><img src="/images/control/media/image126.jpeg" alt="图8.1：光伏发电板"></p>
<p>在该系统中，外界光照被太阳能电池板转化为电能，经功率变换电路处理后向负载供电。STM32微控制器实时采集电池板电压、电流等参数，运行MPPT算法，生成控制信号优化功率变换电路的工作状态，确保太阳能电池板始终在最大功率点运行，提高能源利用效率。</p>
<p><img src="/images/control/media/image127.png" alt="图8.2：基于直流电源调控的光伏MPPT控制系统整体架构"></p>
<h3 id="8-2-实验原理"><a href="#8-2-实验原理" class="headerlink" title="8.2 实验原理"></a>8.2 实验原理</h3><p>光伏板的输出功率会受到环境条件（如光照、温度）影响，这一点无法改变，但是输出功率同时也受到工作电流、电压的因素影响，因此可以通过调节负载电压，使光伏系统的功率维持在最大值，即工作在最大功率点（实现输入侧阻抗匹配）。在本课程使用的Buck变换器中，可以根据STM32输出PWM波的占空比来控制输出的电压，同时由于电路中在不断采集输出电压，从而可以通过设计相应的控制算法算法实现对于输出电压的精确闭环控制。</p>
<p>为了找到最大功率点，可采用扰动观察法（Perturb and Observe, P&amp;O）算法。通过降低与增加占空比来调节输出电压，由于电阻一定，可以通过计算算出变化后的功率，同时将其与变化前的功率进行比较，若功率增大，则沿当前方向继续调整占空比；否则反向调整。在每次调整占空比后，计算功率并记录趋势，从而找到最大功率点。在本项目中，采用改进的扰动观察法，通过记录功率变化并自动调整占空比，从而快速收敛到最大功率点。</p>
<p><img src="/images/control/media/image128.png" alt="图8.3：不同光照强度对光伏板的P -V曲线"></p>
<h3 id="8-3-代码逻辑"><a href="#8-3-代码逻辑" class="headerlink" title="8.3 代码逻辑"></a>8.3 代码逻辑</h3><p>在Keil5中编写的STM32主控代码主要分为如下4个主要的功能模块：</p>
<ol>
<li>系统初始化：初始化系统时钟与ADC、PWM模块，为数据采集及控制做好准备。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SystemInit(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">PWM_Init(); <span class="comment">// 初始化PWM模块</span></span><br><span class="line">AD_Init(); <span class="comment">// 初始化ADC模块</span></span><br><span class="line">_enable_irq(); <span class="comment">// 开启全局中断</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>PWM控制模块：通过实时调控PWM输出占空比实现Buck变换器输出电压的改变，从而影响光伏阵列的工作点。值得注意的是，需要调整PWM输出频率与Buck变换器相适应，同时确保输出占空比范围在0~1范围内。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; <span class="comment">// 配置为PWM模式1</span></span><br><span class="line">TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">// 设置初始占空比为0</span></span><br><span class="line">TIM_SetCompare1(TIM2, (<span class="type">uint16_t</span>)(dutyCycle * PWM_PERIOD)); <span class="comment">// 调整PWM占空比</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>ADC采样模块：将光伏阵列输出的电压信号通过ADC采样转换为数字信号并读取，再通过与电阻的计算得出电流值，以用于功率计算。值得注意的是，ADC通道需与光伏阵列信号对应，同时为确保采样精度还需事先对ADC模块进行校准。</li>
</ol>
<p><img src="/images/control/media/image129.png" alt="图8.4：ADC采样模块相关函数代码"></p>
<ol start="4">
<li>MPPT算法实现：根据扰动观察法原理，通过电流与电压相乘得到当前输出功率，与上个点的功率相比较，若大于上个点的功率，则继续增大占空比，增加输出电压，从而增加输出功率，若小于，则减小占空比，并在每次调整占空比后再次计算输出功率。循环往复进行上述流程，同时记录功率变化趋势及对应占空比，以寻找最大功率点。值得注意的是，程序中设置的步长STEP_SIZE值应适中，过大会导致振荡，而过小则会影响跟踪的速度，同时还应避免控制过程中PWM波形的占空比超出0~1范围。</li>
</ol>
<p><img src="/images/control/media/image130.png" alt="图8.5：MPPT算法实现相关函数代码"></p>
<p>在主循环main函数中编写总控代码对上述代码逻辑进行整合，每次循环都会测量电压与电流从而得到功率，再通过进行扰动观察法寻找最大功率点。</p>
<p><img src="/images/control/media/image131.png" alt="图8.6：main函数总控代码"></p>
<h3 id="8-4-实验现象"><a href="#8-4-实验现象" class="headerlink" title="8.4 实验现象"></a>8.4 实验现象</h3><p>实验时，将Buck变换器、STM32开发板与光伏阵列进行连接，并确保采样与控制电路正常工作。将代码烧录到STM32开发板，并通过调整光照强度，观察功率点变化及最大功率点跟踪效果。接下来需要进行逐步调试：</p>
<ol>
<li>使用示波器观察PWM信号及Buck变换器输出电压，验证占空比调节是否正常，并使用万用表验证电压、电流采样值是否准确；</li>
</ol>
<p><img src="/images/control/media/image132.png" alt="图8.7：PWM输出占空比调试结果"></p>
<p><img src="/images/control/media/image133.png" alt="图8.8：Buck变换器输出电压调试结果"></p>
<p>可以看到，此时PWM输出占空比为50%，占空比调节正常；光伏板输出电压为5.1V，电流为0.025A，输入功率约为0.1275W。</p>
<ol start="2">
<li>通过调整光照强度，观察功率点变化及最大功率点跟踪效果。</li>
</ol>
<p><img src="/images/control/media/image134.png" alt="图8.9：负载电压图"></p>
<p><img src="/images/control/media/image135.png" alt="图8.10：负载消耗功率图"></p>
<p>可以看到，此时所接负载为200Ω，输出电压为4.5V，输出功率约为0.12W。考虑功率损耗，光伏板输出功率约等于负载消耗功率，完成了对该光照强度下最大功率点（MPP）的准确寻找。</p>
<p>随后又对于该控制系统的动态跟踪性能进行进一步的测试，可以观察到，当外界环境的光照强度改变时，控制系统能快速做出响应并使光伏板输出功率达到最大（约为负载消耗功率），说明控制系统对于最大功率点的实时跟踪性能良好。</p>
<h3 id="8-5-本章小结"><a href="#8-5-本章小结" class="headerlink" title="8.5 本章小结"></a>8.5 本章小结</h3><p>本章主要介绍了基于直流电源调控的光伏板最大功率点追踪（MPPT）控制系统的设计，设计时主要采用递归算法，每次通过扰动当前功将率与变换前功率作比较，若大，则继续增加占空比，若小，则减少占空比，以此类推，不断循环，从而找到最大功率点。每次变化占空比的步长与延时时间影响找到最大功率点的效率，需要调试找到最佳的相应效率。同时，在步长固定的情况下，通过自适应步长控制算法也可以更有效率的寻找最大功率。通过动态追踪，显著提高了光伏发电效率。</p>
<h2 id="9-总结与展望"><a href="#9-总结与展望" class="headerlink" title="9 总结与展望"></a>9 总结与展望</h2><h3 id="9-1-课程小结"><a href="#9-1-课程小结" class="headerlink" title="9.1 课程小结"></a>9.1 课程小结</h3><p>《自动控制原理》课程作为一门项目制课程，重点围绕经典控制相关理论知识及应用实践，有效地将理论教学与设计实践结合起来。通过课程的理论学习与项目实践，我们在实践操作中对于经典控制理论的知识有了更加深刻的理解，建立了”控制”工程观与系统性分析思维，也锻炼了自己将理论应用于工程实践的能力，以及对于控制工程问题的分析与解决能力。</p>
<p>该项目制课程主要分为两个项目板块：</p>
<p>控制基础实践项目为”直流电源控制分析与系统设计”，以直流电源这一经典工程案例串联起经典控制理论知识各版块，涵盖控制系统建模（微分方程与传递函数）、时域分析、根轨迹分析、频域分析，频域校正与PID控制等，从理论分析、仿真、实验三维度强化同一理论知识点的学习，完成直流电源控制系统的分析设计以及调试。这一部分项目在理论课程学习的同时穿插完成，主要涉及到经典控制理论的学习，并将其应用到实际的Buck变换器PI闭环控制系统中、结合实际电路参数完成的PSIM电路仿真与相应的MWorks分析计算。</p>
<p>综合应用实践项目为”基于电源的综合应用系统”，以直流电源驱动系统应用为综合实践项目，运用传感、闭环控制、先进控制等硬件与算法，完成基于直流电源控制的LED自动调光与光伏最大功率跟踪（MPPT）等项目实践。这一部分项目主要以实验方式开展，最终本小组顺利完成实验与设计内容并进行课程项目汇报。</p>
<p><img src="/images/control/media/image136.jpeg" alt="图9.1：小组答辩风采展示"></p>
<p>回顾这门课程一路走来，从课程引入与理论教学，到实际实验调试与项目设计，再到最终的项目测试与汇报，我们在理论与实践的结合中扎实掌握了经典控制理论的相关知识，并锻炼了自己的电路设计分析与实践能力。我们能取得如此的进步与成就离不开两位老师与四位助教的辛勤付出，在此再次向各位老师与助教们送上最真诚的感谢，也衷心祝愿这门课程在未来能建设得越来越好。</p>
<p><img src="/images/control/media/image137.png" alt="图9.2：课程汇报班级合影留念"></p>
<h3 id="9-2-课程收获及建议"><a href="#9-2-课程收获及建议" class="headerlink" title="9.2 课程收获及建议"></a>9.2 课程收获及建议</h3><p>通过《自动控制原理》这门课程的学习，我了解到了许多经典控制理论的相关知识：从系统的数学建模入手，微分方程与传递函数是描述一个控制系统性能的基本工具；为调整系统参数以提高控制系统的稳定性，可从时域与频域两个角度分别进行分析，时域上可以使用劳斯判据进行系统稳定性的判定并根据根轨迹找到系统的临界稳定状态，频域上可以使用奈奎斯特稳定判据或依据Bode图对系统稳定性进行分析；基于频率特性，还可以从频域校正环节的设计层面调节系统的动态响应特性。理论学习之余，课程紧密穿插了相应的仿真与电路调试实验，理论与实践的结合使得我对于这些枯燥的理论知识有了更加生动而深刻的理解。</p>
<p>在课程项目中，我主要负责对于闭环控制系统的理论分析、仿真验证与参数调试，以及课程项目报告绝大部分的撰写。令我印象最深刻的是，在理论部分对系统进行频率特性分析时，使用MWorks根据系统开环传递函数绘制Bode图，得到了穿越频率与相位裕度；而在根据实际电路结构在PSIM中搭建了相应的扫频电路之后，当看到运行扫频仿真得到的结果与MWorks绘制的Bode图几乎完全一致时，我深刻体会到了理论的有效性，这代表理论的分析确实可以真实地指导实际控制系统的设计，在后续项目设计与调试时也充分利用了这一点，有效提高了设计与调试的效率。最终我们也顺利完成了基于直流电源调控的自动调光与MPPT控制系统的设计与实现，并将自动调光系统实例化为一个具有实际应用意义的产品。相信在这门课程中学到的知识与技能能够为我们未来的硬件产品开发中起到重要的作用。</p>
<p>最后感谢两位老师耐心的教学与指导以及四位助教的辛苦付出，特别是几位助教，耐心地回答我们的问题、批改我们的作业并协助我们进行硬件实物的调试，为我们的项目实践提供了丰富的参考资料，帮助我们快速上手项目。在此提出一点小小的建议，这次项目中在电路焊接方面浪费了许多时间，希望未来的课程项目设计能够在各个实现细节上更加完善，在设计与测试时考虑的更加全面；同时希望在理论课程中穿插的各种仿真作业能够与实际的控制系统结合的更加紧密，完善一些逻辑不严谨的地方（如提供的报告框架中，是否考虑电容寄生电阻这点体现的略显混乱）。但总的来说，这门课程确实是已有项目制课程中的精品，也希望能够在未来建设得越来越好。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 胡寿松主编.自动控制原理[M].科学出版社,2019:a670.</p>
<p>[2] 卢京潮主编.自动控制原理习题解答[M].清华大学出版社,2013:195.</p>
<p>[3] 王天威编著.控制之美[M].清华大学出版社,2022.</p>
<p>[4] 李昆.智能技术在室内LED照明系统中的应用研究[J].光源与照明,2024,(10):51-53.</p>
<p>[5] 郑盛梅.恒照度自动调光台灯的设计[J].光源与照明,2023,(01):69-71.</p>
<p>[6] 侯耀华,陈萍,於崇干.直流电源系统高级功能在无人值班变电站的应用[J].供用电,2015,(02):19-24.</p>
<p>[7] 许桂敏,解皓月,张子泉,等.基于Simulink的光伏电池特性及MPPT算法仿真研究[J].智能建筑电气技术,2024,18(06):36-39+60.</p>
<p>[8] 王青苗.PLC模糊PID控制系统在隧道照明节能控制中的应用[J].微型电脑应用,2024,40(06):114-118+122.</p>
<p>[9] 陈礼俊,兰志勇.单片机控制的双调控高压直流电源[J].现代电子技术,2017,40(12):165-168.</p>
<p>[10] 樊战亭,万欣,王超.太阳能电池板自动追光控制系统设计[J].咸阳师范学院学报,2024,39(06):12-16.</p>
<p>[11] Gene F. Franklin, J. David Powell, Abbas Emami-Naeini, et al. Feedback control of dynamic systems[M].Publishing House of Electronics Industry,2013:14,590.</p>
<p>[12] Karl Johan Astrom, Richard M. Murray.自动控制多学科视角[M].人民邮电出版社,2010:310.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-STM32闭环PI控制程序"><a href="#1-STM32闭环PI控制程序" class="headerlink" title="1 STM32闭环PI控制程序"></a>1 STM32闭环PI控制程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"PWM.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AD.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Serial.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_FREQUENCY 10000    <span class="comment">// PWM频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PWM_VALUE 1000     <span class="comment">// PWM最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PERIOD 3000  <span class="comment">// PWM周期为1000个计数单位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KP 0.1          <span class="comment">// 比例增益</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KI 0.01         <span class="comment">// 积分增益</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KD 0.01</span></span><br><span class="line"><span class="type">float</span> voltage_ref = <span class="number">10</span>;  <span class="comment">// 设定的输出电压 </span></span><br><span class="line"><span class="type">float</span> voltage_fb = <span class="number">0.0</span>;   <span class="comment">// 反馈的实际输出电压</span></span><br><span class="line"><span class="type">float</span> duty_cycle = <span class="number">0.0</span>;   <span class="comment">// 占空比</span></span><br><span class="line"><span class="type">float</span> error = <span class="number">0.0</span>;        <span class="comment">// 误差</span></span><br><span class="line"><span class="type">float</span> integral = <span class="number">0.0</span>;     <span class="comment">// 积分项</span></span><br><span class="line"><span class="type">float</span> control_signal = <span class="number">0.0</span>;  <span class="comment">// 控制信号</span></span><br><span class="line"><span class="type">float</span> last_error = <span class="number">0.0</span>;   <span class="comment">// 上一次的误差</span></span><br><span class="line"><span class="type">float</span> derivative = <span class="number">0.0</span>;   <span class="comment">// 微分项</span></span><br><span class="line"><span class="type">int</span> sample_index = <span class="number">0</span>;  <span class="comment">// 样本计数器</span></span><br><span class="line"><span class="type">float</span> trueVoltage=<span class="number">0.0</span>;     <span class="comment">// 实际输出电压值</span></span><br><span class="line"><span class="type">float</span> VREF;</span><br><span class="line"><span class="type">uint32_t</span> time_counter = <span class="number">0</span>;  <span class="comment">// 用于记录时间的计数器</span></span><br><span class="line"><span class="type">uint8_t</span> voltage_state = <span class="number">0</span>;  <span class="comment">// 0 表示电压为8V，1 表示电压为10V</span></span><br><span class="line"><span class="type">uint16_t</span> ADValue;</span><br><span class="line"><span class="type">float</span> Voltage;</span><br><span class="line"><span class="type">float</span> i;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">control_buck</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    voltage_fb = (<span class="type">float</span>)AD_GetValue()*<span class="number">3.3</span>/<span class="number">4096</span>;  <span class="comment">//读取ADC的值</span></span><br><span class="line">    trueVoltage = voltage_fb*<span class="number">1050</span>*<span class="number">20000</span>/<span class="number">2500</span>/<span class="number">1000</span>;  <span class="comment">// 计算实际电压 (根据外部电路参数)</span></span><br><span class="line">    error = voltage_ref*<span class="number">2500</span>*<span class="number">1000</span>/<span class="number">1050</span>/<span class="number">20000</span> - voltage_fb;  <span class="comment">// 计算误差</span></span><br><span class="line">    integral += error;  <span class="comment">// 积分计算</span></span><br><span class="line">    derivative = error - last_error;  <span class="comment">// 微分计算</span></span><br><span class="line">    control_signal = KP * error + KI * integral + KD * derivative;  <span class="comment">// PID控制输出</span></span><br><span class="line">    <span class="keyword">if</span> (control_signal &gt; <span class="number">0.8</span>)</span><br><span class="line">        control_signal = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (control_signal &lt; <span class="number">0.2</span>)</span><br><span class="line">        control_signal = <span class="number">0.2</span>;</span><br><span class="line">    duty_cycle = control_signal * PWM_PERIOD;  <span class="comment">// 更新占空比</span></span><br><span class="line">    i = (<span class="type">int</span>)duty_cycle;</span><br><span class="line">    PWM_SetCompare1(i);</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    OLED_Init();</span><br><span class="line">    PWM_Init();</span><br><span class="line">    AD_Init();</span><br><span class="line">    Delay_ms(<span class="number">10</span>);</span><br><span class="line">    NVIC_Configuration();</span><br><span class="line">    Serial_Init();  <span class="comment">// 初始化串口</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>){</span><br><span class="line">        control_buck();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-自动调光程序"><a href="#2-自动调光程序" class="headerlink" title="2 自动调光程序"></a>2 自动调光程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"PWM.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AD.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Serial.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"HC05.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_FREQUENCY 10000    <span class="comment">// PWM频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PWM_VALUE 1000     <span class="comment">// PWM最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PERIOD 3000  <span class="comment">// PWM周期为1000个计数单位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KP 0.1          <span class="comment">// 比例增益</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KI 0.01         <span class="comment">// 积分增益</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KD 0.01</span></span><br><span class="line"><span class="type">float</span> Light_Intensity = <span class="number">0.0</span>;    <span class="comment">// 光敏实际模拟量</span></span><br><span class="line"><span class="type">float</span> voltage_ref = <span class="number">5</span> * <span class="number">1.38</span>;  <span class="comment">// 设定的输出电压 </span></span><br><span class="line"><span class="type">float</span> voltage_fb = <span class="number">0.0</span>;   <span class="comment">// 反馈的实际输出电压</span></span><br><span class="line"><span class="type">float</span> duty_cycle = <span class="number">0.0</span>;   <span class="comment">// 占空比</span></span><br><span class="line"><span class="type">float</span> error = <span class="number">0.0</span>;        <span class="comment">// 误差</span></span><br><span class="line"><span class="type">float</span> integral = <span class="number">0.0</span>;     <span class="comment">// 积分项</span></span><br><span class="line"><span class="type">float</span> control_signal = <span class="number">0.0</span>;  <span class="comment">// 控制信号</span></span><br><span class="line"><span class="type">float</span> last_error = <span class="number">0.0</span>;   <span class="comment">// 上一次的误差</span></span><br><span class="line"><span class="type">float</span> derivative = <span class="number">0.0</span>;   <span class="comment">// 微分项</span></span><br><span class="line"><span class="comment">//int sample_index = 0;  // 样本计数器</span></span><br><span class="line"><span class="type">float</span> trueVoltage=<span class="number">0.0</span>;     <span class="comment">// 实际输出电压值</span></span><br><span class="line"><span class="type">float</span> VREF;</span><br><span class="line"><span class="type">uint32_t</span> time_counter = <span class="number">0</span>;  <span class="comment">// 用于记录时间的计数器</span></span><br><span class="line"><span class="type">uint8_t</span> voltage_state = <span class="number">0</span>;  <span class="comment">// 0 表示电压为8V，1 表示电压为10V</span></span><br><span class="line"><span class="type">uint16_t</span> ADValue;</span><br><span class="line"><span class="type">float</span> Voltage;</span><br><span class="line"><span class="type">float</span> i;</span><br><span class="line"><span class="type">uint8_t</span> RxSTA = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> RxData[<span class="number">100</span>] = <span class="string">"N"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">control_buck</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    voltage_fb = (<span class="type">float</span>)AD_GetValue(ADC_Channel_4)*<span class="number">3.3</span>/<span class="number">4096</span>;  <span class="comment">//读取ADC的值</span></span><br><span class="line">    trueVoltage = voltage_fb*<span class="number">1050</span>*<span class="number">20000</span>/<span class="number">2500</span>/<span class="number">1000</span>;  <span class="comment">// 计算实际电压 (根据外部电路参数)</span></span><br><span class="line">    error = voltage_ref*<span class="number">2500</span>*<span class="number">1000</span>/<span class="number">1050</span>/<span class="number">20000</span> - voltage_fb;  <span class="comment">// 计算误差</span></span><br><span class="line">    integral += error;  <span class="comment">// 积分计算</span></span><br><span class="line">    derivative = error - last_error;  <span class="comment">// 微分计算</span></span><br><span class="line">    control_signal = KP * error + KI * integral + KD * derivative;  <span class="comment">// PID控制输出</span></span><br><span class="line">    <span class="keyword">if</span> (control_signal &gt; <span class="number">0.8</span>)</span><br><span class="line">        control_signal = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (control_signal &lt; <span class="number">0</span>)</span><br><span class="line">        control_signal = <span class="number">0</span>;</span><br><span class="line">   duty_cycle = control_signal * PWM_PERIOD;  <span class="comment">// 更新占空比</span></span><br><span class="line">     i = (<span class="type">int</span>)duty_cycle;</span><br><span class="line">     PWM_SetCompare1(i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    OLED_Init();</span><br><span class="line">    PWM_Init();</span><br><span class="line">    AD_Init();</span><br><span class="line">    Delay_ms(<span class="number">10</span>);</span><br><span class="line">    NVIC_Configuration();  <span class="comment">// NVIC初始化</span></span><br><span class="line">    Serial_Init();  <span class="comment">// 初始化串口</span></span><br><span class="line">	HC05_Init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>){</span><br><span class="line">        <span class="comment">// 蓝牙读取开关</span></span><br><span class="line">        HC05_GetData(RxData);</span><br><span class="line">        <span class="keyword">if</span> (RxSTA == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(RxData, <span class="string">"LL"</span>) == <span class="number">0</span>){</span><br><span class="line">                RxSTA = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">                    <span class="comment">// 读取光敏模拟输入量</span></span><br><span class="line">                    Light_Intensity = (<span class="type">float</span>)AD_GetValue(ADC_Channel_5);</span><br><span class="line">                    voltage_ref = (Light_Intensity * <span class="number">2</span> / <span class="number">3500</span> + <span class="number">8</span>) * <span class="number">1.38</span>;</span><br><span class="line">                    control_buck();                                               </span><br><span class="line">                    HC05_GetData(RxData);</span><br><span class="line">                    <span class="keyword">if</span> (RxSTA == <span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(RxData, <span class="string">"on"</span>) == <span class="number">0</span>)</span><br><span class="line">                voltage_ref = <span class="number">10</span> * <span class="number">1.38</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(RxData, <span class="string">"off"</span>) == <span class="number">0</span>)</span><br><span class="line">                voltage_ref = <span class="number">5</span> * <span class="number">1.38</span>;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="type">int</span> num = atoi(RxData); </span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">100</span>)</span><br><span class="line">                    voltage_ref = ((<span class="type">float</span>)num / <span class="number">100</span> * <span class="number">2</span> + <span class="number">8</span>) * <span class="number">1.38</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; <span class="number">100</span>)</span><br><span class="line">                    voltage_ref = <span class="number">10</span> * <span class="number">1.38</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    voltage_ref = <span class="number">5</span> * <span class="number">1.38</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">memset</span>(RxData, <span class="number">0</span>, <span class="keyword">sizeof</span>(RxData));</span><br><span class="line">            <span class="built_in">strcpy</span>(RxData, <span class="string">"N"</span>);</span><br><span class="line">            RxSTA = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        control_buck();  <span class="comment">//      控制输出电压</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-12-15T21:52:03.000Z" title="2024/12/16 05:52:03">2024-12-16</time>发表</span><span class="level-item"><time datetime="2025-03-02T17:57:26.782Z" title="2025/3/3 01:57:26">2025-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/">产品设计</a></span><span class="level-item">2 分钟读完 (大约297个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/12/16/rubbish/">厨余垃圾处理器</a></p><div class="content"><div id="postchat_postcontent"><p>以下为课程项目设计产品“厨余垃圾处理器”的结题汇报PPT。</p>
<p><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%871.JPG" alt="1"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%872.JPG" alt="2"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%873.JPG" alt="3"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%874.JPG" alt="4"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%875.JPG" alt="5"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%876.JPG" alt="6"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%877.JPG" alt="7"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%878.JPG" alt="8"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%879.JPG" alt="9"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8710.JPG" alt="10"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8711.JPG" alt="11"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8712.JPG" alt="12"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8713.JPG" alt="13"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8714.JPG" alt="14"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8715.JPG" alt="15"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8716.JPG" alt="16"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8717.JPG" alt="17"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8718.JPG" alt="18"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8719.JPG" alt="19"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8720.JPG" alt="20"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8721.JPG" alt="21"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8722.JPG" alt="22"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8723.JPG" alt="23"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8724.JPG" alt="24"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8725.JPG" alt="25"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8726.JPG" alt="26"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8727.JPG" alt="27"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8728.JPG" alt="28"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8729.JPG" alt="29"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8730.JPG" alt="30"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8731.JPG" alt="31"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8732.JPG" alt="32"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8733.JPG" alt="33"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8734.JPG" alt="34"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8735.JPG" alt="35"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8736.JPG" alt="36"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8737.JPG" alt="37"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8738.JPG" alt="38"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8739.JPG" alt="39"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8740.JPG" alt="40"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8741.JPG" alt="41"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8742.JPG" alt="42"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8743.JPG" alt="43"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8744.JPG" alt="44"><br><img src="/images/rubbish/%E5%B9%BB%E7%81%AF%E7%89%8745.JPG" alt="45"></p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-12-05T13:31:03.000Z" title="2024/12/5 21:31:03">2024-12-05</time>发表</span><span class="level-item"><time datetime="2025-03-01T09:37:00.419Z" title="2025/3/1 17:37:00">2025-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95II/">定量工程设计方法II</a></span><span class="level-item">27 分钟读完 (大约4107个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/12/05/document/">基于STM32F407实现的信号发生与采集分析系统</a></p><div class="content"><div id="postchat_postcontent"><p>演示视频已上传至Bilibili视频平台：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wUiRYxE8z">https://www.bilibili.com/video/BV1wUiRYxE8z</a></p>
 <br>

<h2 id="一、系统功能与整体架构设计"><a href="#一、系统功能与整体架构设计" class="headerlink" title="一、系统功能与整体架构设计"></a>一、系统功能与整体架构设计</h2><h3 id="系统实现功能"><a href="#系统实现功能" class="headerlink" title="系统实现功能"></a>系统实现功能</h3><p>（1）单片机在按键控制下，产生1kHz的正弦波或方波；</p>
<p>（2）单片机能够采集波形，并且显示；</p>
<p>（3）单片机能够分析采集波形的频谱，并且显示频谱与基波频率。</p>
<h3 id="整体架构设计图"><a href="#整体架构设计图" class="headerlink" title="整体架构设计图"></a>整体架构设计图</h3><p><img src="/images/img/21.jpg"></p>
<h3 id="系统主页与按键对应功能简介"><a href="#系统主页与按键对应功能简介" class="headerlink" title="系统主页与按键对应功能简介"></a>系统主页与按键对应功能简介</h3><p><img src="/images/img/3.jpg"></p>
<p>每次启动系统都会默认直接进入该主页面：</p>
<p>（1）蓝色部分的文字为系统名称与作者姓名，这会在后续的每个功能页面中都有显示；</p>
<p>（2）黑色部分的文字为各按键对应的功能介绍。</p>
<p>正如主页的功能介绍栏所示：</p>
<p>（1）按下KEY0：PA4引脚开始持续输出1kHz的正弦波信号，并在屏幕上实时显示从PA5引脚采集到的输入信号波形；</p>
<p>（2）按下KEY1：PA4引脚开始持续输出1kHz的方波信号，并在屏幕上实时显示从PA5引脚采集到的输入信号波形；</p>
<p>（3）按下KEY2：在屏幕上实时显示从PA5引脚采集到的输入信号的频谱分析结果（幅值谱，频率范围为0~1000Hz）；</p>
<p>（3）按下KEY3（KEY_UP）：在屏幕上实时显示从PA5引脚采集到的输入信号的频谱分析结果（幅值谱，频率范围为0~8000Hz）。</p>
<br>

<h2 id="二、各部分功能实现"><a href="#二、各部分功能实现" class="headerlink" title="二、各部分功能实现"></a>二、各部分功能实现</h2><h3 id="1、1kHz正弦波与方波的产生"><a href="#1、1kHz正弦波与方波的产生" class="headerlink" title="1、1kHz正弦波与方波的产生"></a>1、1kHz正弦波与方波的产生</h3><h4 id="模块功能架构设计"><a href="#模块功能架构设计" class="headerlink" title="模块功能架构设计"></a>模块功能架构设计</h4><p><img src="/images/img/22.jpg"></p>
<p>在实际单片机编程实现时，导入并调用DSP库加速信号数组（正弦波）的计算，并通过时钟TIM6（分频）控制DMA的数据搬运过程，并设置DAC数模转换将搬运后的信号数字数据在PA4引脚以模拟信号形式输出。</p>
<h4 id="模块功能实现依据"><a href="#模块功能实现依据" class="headerlink" title="模块功能实现依据"></a>模块功能实现依据</h4><p>为使用单片机产生指定频率的波形，需要根据上述架构设置对应的参数，基本的设置逻辑如下：</p>
<p>（1）首先，这里使用定时器TIM6来控制DMA搬移数据的过程，在CubeMX中已预先设置其时钟频率为84MHz；</p>
<p>（2）在生成信号数组时，C语言程序中设定数组长度为1024（与后续采集一致，为4的整数次幂以便于进行快速傅里叶变换FFT）；</p>
<p>（3）事实上，对于信号数组长度N、定时器频率fT与信号基波频率f而言存在如下关系式：f = fT / N，这意味着以输出基波频率f = 1kH的信号为例，经过时钟分频后的定时器频率fT是可以直接确定的，进而可以确定分频倍数（时钟频率/分频后定时器频率）。</p>
<p>经过计算，当分频倍数设置为82时（实际单片机控制程序中为两次分频，取第一次分频倍数为41、第二次分频倍数为2即二分频），输出的信号基波频率f约为1000（由于数组长度为1024，在分频倍数必须取整的情况下，基波频率无法精准等于1000Hz，实际约为1000.38Hz）。</p>
<p>在MATLAB中，可以编写简单的测试程序模拟这一过程：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TIM6_Frequency = <span class="number">84000000</span>; <span class="comment">%DAC_DMA时钟TIM6频率</span></span><br><span class="line">DAC_DMA_Divide1 = <span class="number">41</span>; <span class="comment">%DAC_DMA时钟一次分频</span></span><br><span class="line">DAC_DMA_Divide2 = <span class="number">2</span>; <span class="comment">%DAC_DMA时钟二次分频</span></span><br><span class="line">DAC_DMA_Frequency = TIM6_Frequency / (DAC_DMA_Divide1 * DAC_DMA_Divide2); <span class="comment">%分频后时钟频率</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">1024</span>; <span class="comment">%数组长度与采样点数</span></span><br><span class="line"></span><br><span class="line">f = DAC_DMA_Frequency / N; <span class="comment">%产生信号频率（期望值1000）</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="模块功能实现效果"><a href="#模块功能实现效果" class="headerlink" title="模块功能实现效果"></a>模块功能实现效果</h4><p>启动系统后按压按键KEY_0启动正弦波生成，将示波器的通道正极与信号输出引脚PA4连接，示波器的通道负极与单片机的地GND连接，可在示波器上显示出如下波形：</p>
<p><img src="/images/img/1.jpg"></p>
<p>可以看到输出的波形形状为标准的正弦波，输出电平范围为0<del>3.3V（对应生成的正弦信号数组振幅为2048、偏置为2047即数据点范围位于0</del>4095），均值为1.6V，且周期约为1kHz（示波器显示1.00045kHz；一个周期大致占据五格、每格代表200us即一个周期为1ms）。</p>
<p>按压按键KEY_1切换为生成方波，可在示波器上显示出如下波形：</p>
<p><img src="/images/img/2.jpg"></p>
<p>可以看到输出的波形形状为标准的方波（占空比50%），输出低电平为0V、高电平为3.3V（对应生成的方波信号数组前一半值为0、后一半值为4095），均值为1.6V，且周期约为1kHz（示波器显示1.00043kHz；一个周期大致占据五格、每格代表200us即一个周期为1ms）。</p>
<h3 id="2、波形信号的采集与显示"><a href="#2、波形信号的采集与显示" class="headerlink" title="2、波形信号的采集与显示"></a>2、波形信号的采集与显示</h3><h4 id="模块功能架构设计-1"><a href="#模块功能架构设计-1" class="headerlink" title="模块功能架构设计"></a>模块功能架构设计</h4><p><img src="/images/img/23.jpg"></p>
<p>在实际单片机编程实现时，通过定时器控制从PA5引脚读入模拟信号，通过ADC模数转换为数字数组并通过DMA搬运将其存入长度为1024（为4的整数次幂以便于进行快速傅里叶变换FFT）的数组中，存满一次数组即中断一次DMA搬运并将该数组数据（即采集波形）显示在显示屏上，短暂延迟（控制屏幕刷新速度合适）后进行新一轮的信号采集、搬运与波形显示。</p>
<h4 id="模块功能实现依据-1"><a href="#模块功能实现依据-1" class="headerlink" title="模块功能实现依据"></a>模块功能实现依据</h4><p>为使用单片机采集信号数据并以合适的形式将波形显示在显示屏上，需要根据上述架构设置对应的参数，基本的设置逻辑如下：</p>
<p>（1）首先，控制ADC1的定时器在CubeMX中已预先设置其时钟频率为84MHz，但根据相关手册与文档，硬件上对于分频后的ADC实际频率有限制，不能高于30MHz，在这样的条件下一般取四分频（仅分频一次，以对应结构体参数hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4实现），即分频后定时器频率为21MHz；</p>
<p>（2）其次，根据相关手册与文档，完成一次采样至少会花费12个时钟周期，为调控实际采样频率通常还可以设置额外的时钟周期（库函数限制只能为特定的几个值），即实际的采样频率Fs应为：分频后定时器频率（21MHz）/一次采样花费的时钟周期数（12+额外设置的时钟周期）；</p>
<p>（3）事实上，要想控制屏幕上显示的波形不过于松散/密集，需要控制一次采样（填满数组，DMA中断）内包含的信号周期数量，这可以通过将信号产生的定时器频率fT除以采样频率Fs得到；</p>
<p>（4）另一方面还需要注意为使得采集到的波形没有失真（频域混叠）现象，要求采样频率Fs与待采集波形频率f满足：Fs≥2f。</p>
<p>经过计算与测试，当额外设置的时钟周期设置为112时（sConfig.SamplingTime = ADC_SAMPLETIME_112CYCLES），一次采样中包含（屏幕上显示）的信号周期约为6，这样的显示效果较为合理；同时此时的采样频率Fs约为42683Hz，远大于待采集波形频率f = 1000Hz的两倍，不会发生频谱混叠。</p>
<p>在MATLAB中，可以编写简单的测试程序模拟这一过程（以正弦信号为例）：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ADC_Timer_Frequency = <span class="number">84000000</span>; <span class="comment">%ADC时钟频率</span></span><br><span class="line"><span class="comment">%硬件限制：要求ADC实际时钟频率不能超过30MHz</span></span><br><span class="line">ADC_Divide = <span class="number">4</span>; <span class="comment">%取四分频，分完后达到21MHz满足要求</span></span><br><span class="line">ADC_Frequency = ADC_Timer_Frequency / ADC_Divide; <span class="comment">%分频后ADC时钟频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%完成一次采样需要多个时钟周期</span></span><br><span class="line">Collect1 = <span class="number">12</span>; <span class="comment">%固定消耗12次循环，无法更改</span></span><br><span class="line">Collect2 = <span class="number">112</span>; <span class="comment">%可设置额外消耗循环数以调整采样频率</span></span><br><span class="line">Fs = ADC_Frequency / (Collect1 + Collect2); <span class="comment">%ADC采样频率</span></span><br><span class="line"></span><br><span class="line">Cycle = DAC_DMA_Frequency / Fs; <span class="comment">%一次采样采出多少个周期</span></span><br><span class="line"></span><br><span class="line">A = <span class="number">2047</span>; <span class="comment">%幅值</span></span><br><span class="line">B = <span class="number">2048</span>; <span class="comment">%直流偏置分量</span></span><br><span class="line">t = <span class="number">0</span> : <span class="number">1</span> / Fs : (N - <span class="number">1</span>) / Fs;</span><br><span class="line">x = A * <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * f * t) + B;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制原始信号</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, x);</span><br><span class="line">title(<span class="string">'正弦波信号'</span>);</span><br><span class="line">xlabel(<span class="string">'时间 (秒)'</span>);</span><br><span class="line">ylabel(<span class="string">'幅值'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该MATLAB程序，绘制出一次采样采集到的波形如下图所示：</p>
<p><img src="/images/img/24.png"></p>
<h4 id="模块功能实现效果-1"><a href="#模块功能实现效果-1" class="headerlink" title="模块功能实现效果"></a>模块功能实现效果</h4><p>启动系统后按压按键KEY_0启动正弦波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，屏幕上显示采集波形效果如下：</p>
<p><img src="/images/img/13.jpg"></p>
<p>按压按键KEY_1切换为生成方波信号并采集，屏幕上显示采集波形效果如下：</p>
<p><img src="/images/img/9.jpg"></p>
<p>图上的横坐标单位为ms；可以看到屏幕上显示的即为6个周期的信号波形，这与MATLAB的模拟计算结果是完全一致的，且波形无失真。</p>
<h3 id="3、采集波形信号的频谱分析"><a href="#3、采集波形信号的频谱分析" class="headerlink" title="3、采集波形信号的频谱分析"></a>3、采集波形信号的频谱分析</h3><h4 id="模块功能实现依据-2"><a href="#模块功能实现依据-2" class="headerlink" title="模块功能实现依据"></a>模块功能实现依据</h4><p>在频谱分析与频谱图显示方面，有如下要点需要注意：</p>
<p>（1）首先，频谱分析依赖于对于信号的傅里叶变换，在数字信号层面对于离散的数据点则需要采用离散傅里叶变换，但这样的变换计算速度往往很感人，因此需要利用其快速算法，即快速傅里叶变换FFT，MATLAB可直接调用fft函数实现，单片机编程中在DSP库中也有相应的函数可以实现完全相同的过程，但要求信号数组的长度应为4的整数次幂，故先前均选取1024作为发生与采集信号的数组长度；</p>
<p>（2）其次，经过FFT变换后会得到一个长度相同（1024）的新数组，其中每一个数字的下标index对应的实际频率应为index*Fs/1024，这意味着如果直接将整个FFT变换结果数组作为频谱图显示到屏幕上，横坐标的跨度实际上为Fs≈42683Hz，为使得频谱图更加直观，需要限制绘制频谱图的频率范围，并对应控制绘制数组中的部分数据；</p>
<p>（3）事实上，FFT变换结果的数组中各数值并不是期望的对应频率的幅值，还需要除以数组长度1024（单片机程序中对于起始点只需要除以一半的数组长度即512）才可得到正确的幅值。</p>
<p>由于涉及到信号的基波频率检测以及方波的频谱分析，在KEY_2和KEY_UP按键分别设置了频谱频率范围为0<del>1000Hz与0</del>8000Hz两种模式。在MATLAB中，可以编写简单的测试程序模拟频谱分析过程并在0~8000Hz的频段上展示频谱：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f_range = <span class="built_in">linspace</span>(<span class="number">0</span>, Fs, N);<span class="comment">%频域横坐标，注意奈奎斯特采样定理，最大原信号最大频率不超过采样频率的一半</span></span><br><span class="line">xk = fft(x) / N; <span class="comment">%用fft得出离散傅里叶变换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算并绘制频谱</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(f_range(<span class="number">1</span>:<span class="number">50</span>),<span class="built_in">abs</span>(xk(<span class="number">1</span>:<span class="number">50</span>)));<span class="comment">%画双侧频谱幅度图</span></span><br><span class="line">title(<span class="string">'正弦波频谱'</span>);</span><br><span class="line">xlabel(<span class="string">'频率 (Hz)'</span>);</span><br><span class="line">ylabel(<span class="string">'幅度'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该MATLAB程序，绘制出一次采样采集到的波形如下图所示（以正弦信号为例）：</p>
<p><img src="/images/img/25.png"></p>
<p>可以看到该信号具有直流分量（频率为0）以及1000Hz除的正弦分量，两者幅值均为2048（与产生波形时的一致）。</p>
<p>除此之外，在单片机编程中，为寻找并在屏幕上打印出信号的基波频率，还需要在显示频率波形的同时完成对于除直流分量外最高幅值对应频率的计算（数组返回最大值对应下表，算法较简单在此省略实现过程）。</p>
<h4 id="模块功能实现效果-2"><a href="#模块功能实现效果-2" class="headerlink" title="模块功能实现效果"></a>模块功能实现效果</h4><p>启动系统后按压按键KEY_0启动1000Hz正弦波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，并按压按键KEY_2可启动短频段0~1000Hz的频谱显示如下：</p>
<p><img src="/images/img/8.jpg"></p>
<p>按压按键KEY_UP可启动长频段0~8000Hz的频谱显示如下：</p>
<p><img src="/images/img/12.jpg"></p>
<p>可以看到此时只有直流分量和1000Hz的正弦分量两个尖峰，与MATLAB模拟计算结果一致。</p>
<p>按压按键KEY_1，切换为1000Hz方波波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，并按压按键KEY_2可启动短频段0~1000Hz的频谱显示如下：</p>
<p><img src="/images/img/11.jpg"></p>
<p>按压按键KEY_UP可启动长频段0~8000Hz的频谱显示如下：</p>
<p><img src="/images/img/20.jpg"></p>
<p>可以看到此时在0<del>1000Hz频段只有直流分量和1000Hz的正弦分量两个尖峰，但在0</del>8000Hz频段，由于方波实质上是不同频率的正弦信号的叠加，所以频谱会在基波的奇数倍（1、3、5……）处也有尖峰，但尖峰的幅值会远小于基波1000Hz处，且倍数越大幅值越小，这使得按照先前的算法也能识别出基波频率约为1000Hz。</p>
<h3 id="4、补充测试"><a href="#4、补充测试" class="headerlink" title="4、补充测试"></a>4、补充测试</h3><p>由于还需要对于基波频率在0~1000Hz范围内的任意输入信号进行频谱分析，经过调试后，当输入信号频率为200Hz时，为使得显示波形合理，将ADC环节设置的额外时钟周期由112调整至480，结果如下所示：</p>
<p>200Hz正弦波：</p>
<p>时域：</p>
<p><img src="/images/img/15.jpg"></p>
<p>频域：</p>
<p>短频段（0~1000Hz）：</p>
<p><img src="/images/img/6.jpg"></p>
<p>长频段（0~8000Hz）：</p>
<p><img src="/images/img/17.jpg"></p>
<p>200Hz方波：</p>
<p>时域：</p>
<p><img src="/images/img/18.jpg"></p>
<p>频域：</p>
<p>短频段（0~1000Hz）：</p>
<p><img src="/images/img/7.jpg"></p>
<p>长频段（0~8000Hz）：</p>
<p><img src="/images/img/14.jpg"></p>
<p>在ADC环节额外时钟周期设置为480的情况下，可以计算得出，对于频率为1000Hz的信号，一次采样（即屏幕内显示）包含21个周期（正好为整数），结果如下所示：</p>
<p>1000Hz正弦波：</p>
<p>时域：</p>
<p><img src="/images/img/4.jpg"></p>
<p>频域：</p>
<p>长频段（0~8000Hz）：</p>
<p><img src="/images/img/16.jpg"></p>
<p>1000Hz方波：</p>
<p>时域：</p>
<p><img src="/images/img/10.jpg"></p>
<p>频域：</p>
<p>长频段（0~8000Hz）：</p>
<p><img src="/images/img/5.jpg"></p>
<p>可以看到此时虽然时域上波形显示更加狭窄密集，但是频域上尖峰的变化过程也有了迅速的提升，且测得的基波频率也更加精准。</p>
<br>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>通过本次项目实践，不仅在实验中进一步加深了对于数字信号的产生、采集与频谱分析处理过程的理解，特别是通过期望发生信号频率去计算定时器分频系数、采样频率的计算过程以及FFT计算与频谱图像绘制的过程；而且也增加了对于STM32F407单片机开发的实战经验，在巩固了引脚GPIO与时钟配置相关内容的同时，又对于DMA内存搬运及其中断以及DAC数模转换输出与ADC模数转换输入等功能模块有了更深刻的认识，包括定时器对于这些过程的调控也涉及到相关频率的计算，所有模块的配置之间都有着密切的联系。</p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-06-29T14:33:03.000Z" title="2024/6/29 22:33:03">2024-06-29</time>发表</span><span class="level-item"><time datetime="2025-07-01T13:10:59.402Z" title="2025/7/1 21:10:59">2025-07-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/">概率论与数理统计</a></span><span class="level-item">1 小时读完 (大约9410个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/29/project2/">机器学习分类算法项目</a></p><div class="content"><div id="postchat_postcontent"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本项目围绕机器学习分类算法展开， 以支持向量机（support vector machine，SVM）为主要研究对象，探究其分类性能、模型改进与优化算法。SVM和Logistic回归模型都可以用于解决二分类问题，但模型设计的思路不同，因此希望能够比较两者在分类性能上的差异。项目过程中代码完全基于R语言实现，主要以二维样本数据为研究对象，生成模拟数据并基于经典硬间隔SVM模型和Logistic回归模型分别进行建模与训练，在测试集上对模型进行验证，最终比较两者的分类效果差异。实验结果表明，当样本数据本身区分度不明显时，两种分类模型效果均较差，但Logistic模型明显优于经典硬间隔SVM；当样本数据本身具有明显的差异性时，两种分类模型效果均较好，SVM略优于Logistic。此外，还对改进后的SVM模型（核函数由线性函数更换为高斯核函数）进行性能测试，发现其在区分度不明显的数据集上显著优于经典硬间隔SVM，说明其显著提升了其在非线性可分数据上的分类效果；但在区分度较明显的数据集上分类效果反而略逊于经典SVM模型。最后，对两篇有关SVM改进模型的文献进行了阅读与调研，总结了软间隔SVM模型在正则项和损失项拓展方面的研究进展，并介绍了柔性套索惩罚和快速截断Huber损失等改进方法。</p>
<p><strong>关键词: 机器学习分类算法、二分类、支持向量机（SVM）、Logistic回归、硬间隔、软间隔、高斯核函数、改进的SVM模型、柔性套索惩罚、快速截断Huber损失、R语言</strong></p>
<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>人工智能的概念是在1956年首次被提出，其目标旨在希望通过计算机模拟人的思维能力或智能行为，从而让计算机能够像人类一样进行思考。目前，人工智能已经在机器翻译、智能控制、图像识别、语音识别、游戏博弈等领域得到广泛的应用。</p>
<p>机器学习作为人工智能的一个发展方向，起源于20世纪50年代的感知机数学模型，其目标是使得机器能够像人类一样具有学习能力。机器学习的基本过程主要是基于样本数据（客体）去训练/学习某个模型或决策函数（主体）。一般而言，正则化框架下的机器学习过程主要由<strong>学习机、损失项和正则项（惩罚项）</strong>三个部分构成，最终通过学习得到模型。</p>
<p><img src="/images/project02/media/image1.jpeg"></p>
<p>支持向量机(support vector machine，SVM)最早由Cortes和Vapnik二人于1995年为解决二分类问题而提出[^1]。作为经典的机器学习模型之一，SVM有坚实的统计理论基础，算法实现容易，且决策函数具有很强的几何含义。由于其在模式识别等数据分析问题中的优越表现，SVM如今已成为最经典的判别分析方法之一。与SVM相类似，广义线性回归统计模型中的Logistic回归模型同样也可用于解决二分类问题。本质上来说，两种方法都注重研究一组协变量X_1, …, X_p是如何影响二元的响应变量Y的，在用途上具有极大的相似性，因而希望研究并比较两者分类效果的差异性。</p>
<p>除此之外，SVM作为一种经典且基础的机器学习算法，在漫长的发展历程中也经历了多次迭代，有多种多样的改进版本。最基本的版本为硬间隔SVM，但由于实际的样本数据很可能不满足线性可分的理想情况，又发展出了采用不同求解算法的软间隔SVM模型以及基于核函数升维思想实现的非线性SVM，基于软间隔SVM模型又集中在模型损失项与正则项两个方面进行了理论上的拓展。这样的发展是永无止境的，在此希望对过去的部分研究改进成果进行理论总结与代码实现，以更好地了解SVM模型的发展现状。</p>
<h3 id="项目任务"><a href="#项目任务" class="headerlink" title="项目任务"></a>项目任务</h3><p>在本次项目中，需要随机生成模拟数据，并在该样本数据基础上分别利用经典SVM模型与Logistic模型进行统计建模，同时对比两者的分类效果；此外还需要总结并实现部分改进版本的SVM算法，分析其预测效果。具体而言可细分为如下任务：</p>
<ul>
<li><p>任务<strong>1</strong>:随机生成200条模拟数据并将其分为训练数据集与测试数据集，利用训练数据集分别基于经典硬间隔SVM模型与Logistic广义线性回归模型建立统计模型，实现样本数据的分类且在测试数据集上进行验证，比较两者的分类效果差异。</p>
</li>
<li><p>任务<strong>2</strong>:代码实现某一种改进版本的SVM模型，简单测试其性能并将其分类结果与经典版本进行对比。</p>
</li>
<li><p>任务<strong>3</strong>:查阅SVM模型改进相关的文献，基于正则化框架对于文献中涉及的模型（学习机、损失项、正则项）、创新点与求解算法进行重述与总结。</p>
</li>
</ul>
<h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><p>本项目代码部分完全基于R语言实现，主要涉及样本模拟数据的生成，以及SVM（经典与改进版本）与Logistic回归模型的建立、训练与测试。</p>
<h3 id="模拟数据生成"><a href="#模拟数据生成" class="headerlink" title="模拟数据生成"></a>模拟数据生成</h3><p>本项目中涉及到的样本数据完全由模拟方法生成。具体而言，不论是SVM还是Logistic回归模型，其目的都是为了研究一系列协变量对于一个二元的响应变量的影响。为方便起见，选择采用协变量的维度为二维，即二元响应变量Y只由两个变量X_1, X_2决定。在生成数据时，为了较好地区分出两类数据，分别在正态总体下以均值为0和均值为1生成两组模拟数据（同一条数据中的两个变量X_1, X_2来自同一均值的总体），并分别打上分类标签（即对应Y的取值为）0或1：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set.seed<span class="punctuation">(</span><span class="number">123</span><span class="punctuation">)</span> <span class="comment">#设置随机种子，固定每次运行程序生成的随机数，使结果可重复</span></span><br><span class="line">n <span class="operator">&lt;-</span> 200  <span class="comment"># 每个类别的数据点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成类别0的数据</span></span><br><span class="line">x1 <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span>rnorm<span class="punctuation">(</span>n <span class="operator">*</span> <span class="number">2</span><span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">y1 <span class="operator">&lt;-</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> n<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 生成类别1的数据</span></span><br><span class="line">x2 <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span>rnorm<span class="punctuation">(</span>n <span class="operator">*</span> <span class="number">2</span><span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">y2 <span class="operator">&lt;-</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> n<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 合并数据</span></span><br><span class="line">x <span class="operator">&lt;-</span> rbind<span class="punctuation">(</span>x1<span class="punctuation">,</span> x2<span class="punctuation">)</span></span><br><span class="line">y <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>y1<span class="punctuation">,</span> y2<span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<p>绘制样本点对应的散点图，初步观察其分类情况：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载 ggplot2 包</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据框</span></span><br><span class="line">data <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>x1 <span class="operator">=</span> x<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> x2 <span class="operator">=</span> x<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> y <span class="operator">=</span> factor<span class="punctuation">(</span>y<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置点的大小和透明度</span></span><br><span class="line">p <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> x1<span class="punctuation">,</span> y <span class="operator">=</span> x2<span class="punctuation">,</span> color <span class="operator">=</span> y<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">geom_point<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> alpha <span class="operator">=</span> <span class="number">0.7</span><span class="punctuation">)</span> <span class="operator">+</span>  <span class="comment"># 调整点的大小和透明度</span></span><br><span class="line">scale_color_manual<span class="punctuation">(</span>values <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">"blue"</span><span class="punctuation">,</span> <span class="string">"red"</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">"x1"</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">"x2"</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">"Class"</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">theme_minimal<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整背景和边界线</span></span><br><span class="line">p <span class="operator">+</span> theme<span class="punctuation">(</span>panel.background <span class="operator">=</span> element_rect<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">"white"</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">"black"</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">panel.border <span class="operator">=</span> element_rect<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">"black"</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">axis.line <span class="operator">=</span> element_line<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">"black"</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">ggsave<span class="punctuation">(</span><span class="string">"2.png"</span><span class="punctuation">,</span> plot <span class="operator">=</span> p<span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">"in"</span><span class="punctuation">,</span> dpi <span class="operator">=</span> <span class="number">300</span><span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/project02/media/image3.png"><img src="/images/project02/media/image4.png"></p>
<p>观察上左图可知，由于基于正态总体生成模拟数据时仅制定了均值而未指定方差（默认为1），导致令均值为0和1的情况下两类数据没有办法明显的区分开来，这样的分类效果显然是不好的。经过调试，当设置两类数据均值分别为0和5时，数据点呈现良好的区分性（如上右图所示）。</p>
<p>为便于后续的模型训练，还需要将样本模拟数据分成训练集与测试集两部分，根据经验，较为合适的数据集数量比例为7：3，即样本数据中的70%为训练集，另外30%为测试集用于验证。</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据分为训练集和测试集</span></span><br><span class="line">train_index <span class="operator">&lt;-</span> sample<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="punctuation">(</span><span class="number">2</span> <span class="operator">*</span> n<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">0.7</span> <span class="operator">*</span> <span class="number">2</span> <span class="operator">*</span> n<span class="punctuation">)</span></span><br><span class="line">x_train <span class="operator">&lt;-</span> x<span class="punctuation">[</span>train_index<span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">y_train <span class="operator">&lt;-</span> y<span class="punctuation">[</span>train_index<span class="punctuation">]</span></span><br><span class="line">x_test <span class="operator">&lt;-</span> x<span class="punctuation">[</span><span class="operator">-</span>train_index<span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">y_test <span class="operator">&lt;-</span> y<span class="punctuation">[</span><span class="operator">-</span>train_index<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并 </span></span><br><span class="line">train_data <span class="operator">&lt;-</span> cbind<span class="punctuation">(</span>x_train<span class="punctuation">,</span> y_train<span class="punctuation">)</span></span><br><span class="line">test_data <span class="operator">&lt;-</span> cbind<span class="punctuation">(</span>x_test<span class="punctuation">,</span> y_test<span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<p>在此对部分训练集数据进行罗列：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#观察数据集</span></span><br><span class="line">head<span class="punctuation">(</span>train_data<span class="punctuation">,</span><span class="number">10</span><span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>x.1</th>
<th>x.2</th>
<th>y</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>5.8641525</td>
<td>2.78936689</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>-1.9666172</td>
<td>-0.72306597</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0.8215811</td>
<td>-0.57438869</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>-1.2512714</td>
<td>0.84573154</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>1.3686023</td>
<td>0.09049665</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>-0.2153805</td>
<td>2.41677335</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>6.0466288</td>
<td>5.10719041</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td>1.0057385</td>
<td>0.68430943</td>
<td>0</td>
</tr>
<tr>
<td>9</td>
<td>4.6738561</td>
<td>3.67224452</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>-0.4727914</td>
<td>-1.28471572</td>
<td>0</td>
</tr>
</tbody></table>
<h3 id="基于经典硬间隔SVM模型的建模"><a href="#基于经典硬间隔SVM模型的建模" class="headerlink" title="基于经典硬间隔SVM模型的建模"></a>基于经典硬间隔<strong>SVM</strong>模型的建模</h3><p>硬间隔支持向量机是一种基于<strong>线性可分数据集</strong>的分类模型。线性可分，意味着可用一条直线将两类数据分开。显然这样的直线有无穷多条，但对应直线的上下移动又因分类要求的限制而存在极限位置。因此，硬间隔支持向量机所要解决的<strong>关键问题</strong>就是，<strong>如何从无穷多条直线（对应无穷多个分类器）中选择最优？</strong></p>
<p>实际上，具有”最大间隔”的分类器就是SVM要寻找的最优解，而最优解对应的两侧虚线（上下极限状态）所穿过的样本点，就是SVM中的支持样本点，称为<strong>"支持向量"</strong>。SVM中寻找最优分类器的问题，本质上是一个优化问题。对于一般的优化问题，往往有3个基本要素需要重点关注：</p>
<ul>
<li><p><strong>目标函数</strong>:希望优化的目标指标；</p>
</li>
<li><p><strong>优化对象</strong>:期望通过改变哪些因素（协变量）使目标函数达到最优；</p>
</li>
<li><p><strong>约束条件</strong>:优化对象一般需要满足一些特定的约束条件。</p>
</li>
</ul>
<p>假定<br>$$<br>{ {({x_i}^T,y_i)} }_{i=1}^n<br>$$<br>表示一个二分类数据集，其中第i个样本x_i ∈ R^p，样本对应的标签y_i ∈ {-1,+1}, i=1, …, n。对于<strong>优化对象x_i</strong>而言，可以根据解析几何的基本知识构造其分类器（超平面）的一般表达式：</p>
<p>$$<br>w_1x_1+\cdots+w_px_p+b=w^Tx+b=0<br>$$<br>其中<br>$$<br>w={(w_1,\cdots,w_p)}^T<br>$$<br>为该超平面的法向量，b为超平面的截距。</p>
<p>显然，SVM中的优化对象就是上述分类器，或者说超平面中的参数w, b。在本项目的模拟数据中，令样本协变量维度p=2，此时分类器为R^3上的平面。</p>
<p>在线性SVM算法中，<strong>目标函数</strong>显然就是”分类间隔”，即目标是最大化“分类间隔”W=2d (如下图所示)。其中d表示“支持向量”到最优分类器的距离，最大化W等价于最大化d。</p>
<p><img src="/images/project02/media/image5.jpeg"></p>
<p>最后是<strong>约束条件</strong>的确定。首先要考虑的就是，如何判断超平面是否将样本点正确分类？此外，目标函数本质上是求距离<em>d</em>的最大值，要确定约束条件，还必须要找到哪些是”支持向量”。总而言之，对于目标函数d的取值范围受到的限制和约束条件的确定，关键问题是如何将其数学化。</p>
<p>以上述平面上的分类问题为例：对任意一点x_i，其到最优分类直线的距离为<br>$$<br>d_i=\frac{|w^Tx_i+b|}{||w||}<br>$$<br>一方面，如果此时最优分类直线确实实现了分类目标，则所有样本点(y_i =1 or -1)必定都要满足约束(d 为最优距离)：<br>$$<br>d_i=\frac{|w^Tx_i+b|}{||w||}\geq d \Leftrightarrow<br>    \begin{cases}<br>        \frac{w^Tx_i+b}{||w||}\geq d,\ y_i=1\ \<br>        \frac{w^Tx_i+b}{||w||}\le-d,\ y_i=-1<br>    \end{cases}<br>    \Leftrightarrow \ y_i\bullet\frac{w^Tx_i+b}{||w||}\geq d\<br>    \Leftrightarrow \frac{1}{||w||d}\bullet y_i(w^Tx_i+b)\geq1<br>$$<br>注意到:<br>$$<br>w^Tx+b=0与\frac{1}{||w||d}\bullet(w^Tx+b)=0<br>$$<br>本质上代表同一个超平面，因此上述约束条件可以等价改写为：<br>$$<br>y_i(w^Tx_i+b)\geq1<br>$$<br>另一方面，注意到”支持向量”都是位于最优分类超平面上，即若点(x_i, y_i)为”支持向量”，则必有：<br>$$<br>w^Tx_i+b=1<br>$$<br>于是最大化目标函数(“支持向量”到最优分类超平面的间隔)，等价于最大化：<br>$$<br>\frac{1}{||w||}<br>$$<br>也等价于最小化：<br>$$<br>\frac{1}{2}{||w||}^2<br>$$<br>综上所述，硬间隔SVM的基本数学模型可以描述为如下不等式约束的二次型函数的约束优化问题：<br>$$<br>\begin{cases}<br>        \mathop{min}\limits_{w,b}{ {\frac{1}{2}||w||}^{2} }\<br>        st:\ y_i(w^Tx_i+b)\geq1,\ i=1,\cdots,n \<br>\end{cases}<br>$$<br>该优化问题由于受不等式约束，因此求解过程中还需要考察拉格朗日对偶问题和KKT条件。基于不等式约束的凸优化问题，可以基于拉格朗日对偶问题和KKT条件，然后利用<strong>SMO算法求解</strong>,得到最优w*, b*，从而可构造最优分类超平面：<br>$$<br>{(w^\ast)}^Tx+b^\ast=0<br>$$<br>对待分类的样本点<em>x</em>，根据以下决策函数来进行分类判别<br>$$<br>f(x)=sgn({(w^\ast)}^Tx+b^\ast)<br>$$<br>即当<br>$$<br>{(w^\ast)}^Tx+b^\ast&gt;0<br>$$<br>时返回0，否则返回1。</p>
<p>基于以上理论， 可实现经典硬间隔SVM模型建构。在R语言中，e1071程序包内的svm()函数是对于经典硬间隔SVM模型的封装实现，其基本用法如下：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练 SVM 模型</span></span><br><span class="line">model <span class="operator">&lt;-</span> svm<span class="punctuation">(</span>formula<span class="punctuation">,</span>data<span class="punctuation">,</span>labels<span class="punctuation">,</span>scale<span class="operator">=</span><span class="literal">TRUE</span><span class="operator">/</span><span class="literal">FALSE</span><span class="punctuation">,</span>kernel<span class="punctuation">,</span><span class="built_in">gamma</span><span class="operator">=</span>g<span class="punctuation">,</span>degree<span class="operator">=</span>d<span class="punctuation">,</span>cost<span class="operator">=</span>C<span class="punctuation">,</span>epsilon<span class="operator">=</span><span class="number">0.1</span><span class="punctuation">,</span>na.action<span class="operator">=</span>na.omit<span class="operator">/</span>na.fail<span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中：</p>
<ul>
<li><p><strong>formula</strong>:拟合公式，以R公式的形式指定输出变量和输入变量，其格式一般为：输出变量名 输入变量名；</p>
</li>
<li><p><strong>data</strong>:训练数据集（各协变量），通常是一个数据框或矩阵；</p>
</li>
<li><p><strong>labels</strong>:标签数据（二元响应变量），通常是一个因子向量，用于指定那些将被用来训练模型的采样数据;</p>
</li>
<li><p><strong>scale</strong>:逻辑向量，指定特征数据是否需要标准化(默认标准化为均值0，方差1)，默认为True;</p>
</li>
<li><p><strong>kernel</strong>:核函数类型， 常用的有"linear"、"polynomial"、"radial" (RBF) 和 "sigmoid";</p>
</li>
<li><p><strong>gamma</strong>:用于指定多项式核以及径向基核中的参数，默认gamma是线性核中的常数项，等于1/p(p为特征空间中的维度);</p>
</li>
<li><p><strong>degree</strong>:用于指定多项式核中的阶数d;</p>
</li>
<li><p><strong>cost</strong>:惩罚参数，用于控制误分类的惩罚程度;</p>
</li>
<li><p><strong>epsilon</strong>:用于指定支持向量回归中的带，默认值为0.1;</p>
</li>
<li><p><strong>na.action</strong>:用于指定当样本数据中存在无效的空数据时系统应该进行的处理，默认值na.omit表明程序会忽略那些数据缺失的样本；另外一个可选的赋值是na.fail，它指示系统在遇到空数据时给出一条错误信息。</p>
</li>
</ul>
<p>硬间隔支持向量机（Hard-Margin SVM）是支持向量机的一种特殊情况，适用于数据完全线性可分的情况。它通过最大化间隔来找到一个分离超平面，使得所有数据点都在间隔之外且没有误分类点。为实现<strong>经典的硬间隔SVM模型</strong>，可以将svm()函数的参数如下设置：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练硬间隔SVM模型</span></span><br><span class="line">library<span class="punctuation">(</span>e1071<span class="punctuation">)</span> <span class="comment"># 需要先导入e1071库</span></span><br><span class="line">cost_value <span class="operator">&lt;-</span> 1e5 <span class="comment"># 设置 cost 为一个非常大的值，从而确保没有误分类</span></span><br><span class="line">svm_model <span class="operator">&lt;-</span> svm<span class="punctuation">(</span>x_train<span class="punctuation">,</span>y_train<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">"C-classification"</span><span class="punctuation">,</span> kernel <span class="operator">=</span> <span class="string">"linear"</span><span class="punctuation">,</span> cost <span class="operator">=</span> cost_value<span class="punctuation">,</span> scale <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以通过summary()方法查看训练出的模型的信息：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>svm_model<span class="punctuation">)</span></span><br><span class="line">	</span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">svm.default<span class="punctuation">(</span>x <span class="operator">=</span> x_train<span class="punctuation">,</span> y <span class="operator">=</span> y_train<span class="punctuation">,</span> scale <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">"C-classification"</span><span class="punctuation">,</span></span><br><span class="line">kernel <span class="operator">=</span> <span class="string">"linear"</span><span class="punctuation">,</span> cost <span class="operator">=</span> cost_value<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Parameters<span class="operator">:</span></span><br><span class="line">SVM<span class="operator">-</span>Type<span class="operator">:</span>  C<span class="operator">-</span>classification   <span class="comment">#模型类别</span></span><br><span class="line">SVM<span class="operator">-</span>Kernel<span class="operator">:</span>  linear   <span class="comment">#模型使用的核函数</span></span><br><span class="line">cost<span class="operator">:</span>  <span class="number">1e+05</span>   <span class="comment">#模型确定的约束违反成本</span></span><br><span class="line">Number of Support Vectors<span class="operator">:</span>  <span class="number">2</span>	<span class="punctuation">(</span> <span class="number">1</span> <span class="number">1</span> <span class="punctuation">)</span>  </span><br><span class="line"><span class="comment">#模型找到的支持向量数量，两类各有一个</span></span><br><span class="line">Number of Classes<span class="operator">:</span>  <span class="number">2</span></span><br><span class="line">Levels<span class="operator">:</span>	<span class="number">0</span> <span class="number">1</span>   <span class="comment">#模型中分类的目标类别</span></span><br></pre></td></tr></tbody></table></figure>

<p>至此已经基于训练集数据完成了经典硬间隔SVM模型的建立与训练过程。</p>
<h3 id="基于Logistic回归模型的建模"><a href="#基于Logistic回归模型的建模" class="headerlink" title="基于Logistic回归模型的建模"></a>基于Logistic回归模型的建模</h3><p>与SVM模型类似，Logistic回归模型也旨在研究协变量X_1, …, X_p是如何影响响应变量<em>y</em>的。但不同的是，Logistic作为广义线性回归模型的一种，本质上还是基于”回归”的基本思想，在多元线性回归的基础上进行调整从而能够处理离散的二元数据。</p>
<p>假定对二元响应变量y有n次观测：<br>$$<br>\ y_i \sim B(1,\mu_i),\ i=1,\cdots,n<br>$$<br>显然其均值方差分别为：<br>$$<br>{E(y}<em>i)=\mu_i;\ Var(y_i)=\mu_i(1-\mu_i)<br>$$<br>同时，对协变量X_1, …, X_p也有n次观测，且记其线性组合分别为：<br>$$<br>\eta_i=\beta_0+x</em>{i1}\beta_1+\cdots+x_{ip}\beta_p=x_i^T\beta,\ i=1,\cdots,n<br>$$<br>其中：<br>$$<br>x_i={(1,x_{i1},\cdots,x_{ip})}^T, \beta={(\beta_0,\beta_1,\cdots,\beta_p)}^T<br>$$<br>在多元线性回归的过程中，由于响应变量y连续，因此可以直接令其均值E(y)等于协变量与未知参数的线性组合η；但对于二元（取值仅存在0或1两种情况）的响应变量而言，这样简单粗暴的处理方式显然是不合适的，需要在原来的方法上做推广，即”广义”的线性回归模型：既然无法直接令两者相等，不妨寻找一个<strong>链接函数</strong>，将多元线性回归中值域为<em>R</em>的协变量线性组合<br>$$<br>\eta_i=x_i^T\beta<br>$$<br>映射到μ_i ∈ (0*,* 1)区间上，从而便于分类过程的实现。</p>
<p>具体而言，在建立广义线性回归模型的过程中，需要在多元线性回归的基础上选取合适的链接函数g(•)把y_i的期望µ_i = E(y)和协变量的线性组合η _i = x_i^T * β联系起来，使得g(µ _i) = η _i。这样的链接函数应该具有良好的性质（如光滑等），才便于后续计算。</p>
<p>针对二元响应变量的分类过程，常用的连接函数为Logistic链接函数：<br>$$<br>g(x)=ln{\frac{x}{1-x}},\ x\in(0,1)<br>$$<br>基于Logistic链接函数构造的广义线性回归模型即为Logistic回归模型，其基本内容如下：<br>$$<br>\begin{cases}<br>         y_i \sim B(1,\mu_i), i=1,\cdots,n \<br>         g(\mu_i)=\mu_i=x_i^T\beta<br>    \end{cases}<br>$$<br>事实上，基于给定的样本数据（训练集数据），训练模型的过程即为对未知参数向量β进行极大似然估计的过程，但与线性模型不同的是，该模型中极大似然估计并没有显式解，因此需要基于特定的算法进行数值求解，一般采用Newton-Raphson迭代算法，这里不详细展开求解过程。</p>
<p>在R语言中，Logistic模型的训练由基本包中自带的glm()函数实现，其基本用法如下：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练广义线性模型</span></span><br><span class="line">model <span class="operator">&lt;-</span> glm<span class="punctuation">(</span>formula<span class="punctuation">,</span> data <span class="operator">=</span> mydata<span class="punctuation">,</span> family <span class="operator">=</span> family<span class="punctuation">(</span>link <span class="operator">=</span> <span class="string">"link_function"</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中：</p>
<ul>
<li><p><strong>formula</strong>:表示响应变量与解释变量的关系公式，如y ∼ x1 + x2；</p>
</li>
<li><p><strong>data</strong>:所用的数据集（需要为数据框格式来识别特征和标签）；</p>
</li>
<li><p><strong>family</strong>:表示所拟合的GLM模型类型，包括（但不限于）高斯、二项分布、泊松分布等;</p>
</li>
<li><p><strong>link</strong>:表示链接函数，常见的有"identity"、”logit”、"log"等。</p>
</li>
</ul>
<p>为实现广义回归模型中的Logistic回归模型，可按照如下方式进行调用：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将训练数据转换为数据框</span></span><br><span class="line">train_data <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>x <span class="operator">=</span> x_train<span class="punctuation">,</span> y <span class="operator">=</span> as.factor<span class="punctuation">(</span>y_train<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练Logistic回归模型</span></span><br><span class="line">logistic_model <span class="operator">&lt;-</span> glm<span class="punctuation">(</span>y <span class="operator">~</span> .<span class="punctuation">,</span> data <span class="operator">=</span> train_data<span class="punctuation">,</span> family <span class="operator">=</span> binomial<span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<p>同样采用summary()方法查看训练模型的信息：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>logistic_model<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span>   <span class="comment"># 调用信息, 说明模型使用了二元逻辑回归和所有特征。</span></span><br><span class="line">glm<span class="punctuation">(</span>formula <span class="operator">=</span> y <span class="operator">~</span> .<span class="punctuation">,</span> family <span class="operator">=</span> binomial<span class="punctuation">,</span> data <span class="operator">=</span> train_data<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span>   <span class="comment"># 估计值、标准误差、z值和p值的表格。</span></span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>  <span class="operator">-</span><span class="number">169.33</span>   <span class="number">32205.14</span>  <span class="operator">-</span><span class="number">0.005</span>    <span class="number">0.996</span></span><br><span class="line"><span class="comment"># 截距项的估计值、标准误差、z值和p值。</span></span><br><span class="line">x.1            <span class="number">15.32</span>    <span class="number">5873.78</span>   <span class="number">0.003</span>    <span class="number">0.998</span></span><br><span class="line"><span class="comment"># 第一个特征x.1的估计值、标准误差、z值和p值。</span></span><br><span class="line">x.2            <span class="number">63.10</span>   <span class="number">13139.18</span>   <span class="number">0.005</span>    <span class="number">0.996</span></span><br><span class="line"><span class="comment"># 第二个特征x.2的估计值、标准误差、z值和p值。</span></span><br><span class="line"><span class="punctuation">(</span>Dispersion parameter <span class="keyword">for</span> binomial family taken to be <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 二项分布的离散参数被设定为1。</span></span><br><span class="line">Null deviance<span class="operator">:</span> <span class="number">3.8815e+02</span>  on <span class="number">279</span>  degrees of freedom</span><br><span class="line"><span class="comment"># 零偏差：模型中只有截距时的偏差, 279个自由度。</span></span><br><span class="line">Residual deviance<span class="operator">:</span> <span class="number">6.1211e-08</span>  on <span class="number">277</span>  degrees of freedom</span><br><span class="line"><span class="comment"># 残差偏差：模型拟合后的偏差, 277个自由度。</span></span><br><span class="line">AIC<span class="operator">:</span> <span class="number">6</span>	<span class="comment"># AIC 值（信息准则）, 用于模型选择。</span></span><br><span class="line">Number of Fisher Scoring iterations<span class="operator">:</span> <span class="number">25</span>   </span><br><span class="line"><span class="comment"># Fisher评分算法的迭代次数。</span></span><br></pre></td></tr></tbody></table></figure>

<p>至此已经基于训练集数据完成了Logistic回归模型的建立与训练过程。</p>
<h3 id="二者分类效果的比较"><a href="#二者分类效果的比较" class="headerlink" title="二者分类效果的比较"></a>二者分类效果的比较</h3><p>前文在生成模拟数据的过程中提到，若生成时设置的正态总体均值差异不同，其聚集效果也会不同，在默认方差为1的情况下，设置均值为0和1的数据点区分不明显，而设置均值为0和5的数据点区分明显。在模型效果测试中，为保证模型聚合等多方面因素，分别选用均值为0和1（数据点区分不明显），以及均值为0和2.8的数据（数据点区分明显）进行模型训练与性能测试。</p>
<p>首先是选用均值为0和1的数据，即标签为0的数据应聚集在点(0, 0)附近，标签为1的数据应聚集在点(1, 1)附近。将训练好的模型应用于测试集上并计算其分类准确率，同时绘制其分类结果与分类器效果图像：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用SVM模型进行预测</span></span><br><span class="line">svm_predictions <span class="operator">&lt;-</span> predict<span class="punctuation">(</span>svm_model<span class="punctuation">,</span> x_test<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 计算SVM模型的分类准确率</span></span><br><span class="line">svm_accuracy <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>svm_predictions <span class="operator">==</span> y_test<span class="punctuation">)</span> <span class="operator">/</span> <span class="built_in">length</span><span class="punctuation">(</span>y_test<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Logistic回归模型进行预测</span></span><br><span class="line">logistic_probabilities <span class="operator">&lt;-</span> predict<span class="punctuation">(</span>logistic_model<span class="punctuation">,</span> newdata <span class="operator">=</span> data.frame<span class="punctuation">(</span>x <span class="operator">=</span> x_test<span class="punctuation">)</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">"response"</span><span class="punctuation">)</span></span><br><span class="line">logistic_predictions <span class="operator">&lt;-</span> ifelse<span class="punctuation">(</span>logistic_probabilities <span class="operator">&gt;</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 计算Logistic回归模型的分类准确率</span></span><br><span class="line">logistic_accuracy <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>logistic_predictions <span class="operator">==</span> y_test<span class="punctuation">)</span> <span class="operator">/</span> <span class="built_in">length</span><span class="punctuation">(</span>y_test<span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/project02/media/image7.png"><img src="/images/project02/media/image8.png"><img src="/images/project02/media/image9.png"></p>
<p>运行程序，得到该情况下<strong>SVM</strong>模型的分类准确率为<strong>0.525</strong>，<strong>Logistic</strong>回归模型的分类准确率为<strong>0.767</strong>。结合观察图像可知，此时对于区分不明显的数据，两个模型的分类效果都较差（90%以下），但<strong>Logistic</strong>回归模型在数据区分不明显的情况下分类性能要明显优于经典硬间隔<strong>SVM</strong>模型。</p>
<p>然后选用均值为0和2.8的数据，即标签为0的数据应聚集在点(0, 0)附近，标签为1的数据应聚集在点(2*.<em>8, 2</em>.*8)附近。将训练好的模型应用于测试集上并计算其分类准确率，同时绘制其分类结果与分类器效果图像：</p>
<p><img src="/images/project02/media/image11.png"><img src="/images/project02/media/image12.png"><img src="/images/project02/media/image13.png"></p>
<p>运行程序，得到该情况下<strong>SVM</strong>模型的分类准确率为<strong>0.967</strong>，<strong>Logistic</strong>回归模型的分类准确率为<strong>0.950</strong>。结合观察图像可知，此时对于区分较明显的数据，两个模型的分类效果都较好（90%以上），但<strong>经典硬间隔SVM模型在数据区分较明显的情况下分类性能会略优于Logistic回归模型</strong>，但总体而言差异并不是很大。</p>
<h3 id="改进后SVM模型的性能测试"><a href="#改进后SVM模型的性能测试" class="headerlink" title="改进后SVM模型的性能测试"></a>改进后<strong>SVM</strong>模型的性能测试</h3><p>上述内容中用到的经典硬间隔SVM模型实际上对于数据有着较高的要求，其实现依赖于样本数据为线性可分这一假设条件，但现实中的实际数据往往很难满足这一点，这也是其缺陷所在。针对不是线性可分的数据，Cortes和Vapnik采用了一种非常巧妙的方式进行改进，即借助函数映射，将低维数据映射到高维空间中，使得在低维空间原来不能线性可分的数据，在高维空间变得线性可分，且可以证明这样的映射始终存在。</p>
<p><img src="/images/project02/media/image14.jpeg"></p>
<p>具体而言，构造升维函数：<br>$$<br>K(x,z)=\varphi(x)\bullet\varphi(z)<br>$$<br>并构造相应的非线性SVM：<br>$$<br>\begin{cases}<br>        \mathop{min}\limits_{w,\ b,\ \delta_i} { {\frac{1}{2}||w||}^2}         \<br>        st:\ y_i(w^TK(x_i,z)+b)\geq1,\ \ i=1,\cdots,n<br>    \end{cases}<br>$$<br>相应的最优分类超平面为：<br>$$<br>{(w^\ast)}^TK(x_i,z)+b^\ast=0<br>$$<br>这里选择<strong>高斯函数(径向基函数RBF)<strong>作为核函数，将每一个样本点映射到一个无穷维的特征空间从而实现降维，构造改进的SVM模型：<br>$$<br>K(x, x’) = \exp\left(-\gamma | x - x’ |^2\right)<br>$$<br>高斯核函数实现的</strong>功能</strong>是：先将原始的数据点(x, y)映射为新的样本(x′, y′)，再将新的特征向量点乘(x′, y′)，返回其点乘结果。其主要目的是找到更有利分类任务的新的空间，<strong>本质</strong>是在衡量样本和样本之间的”相似度”，在一个刻画”相似度”的空间中，让同类样本更好的聚在一起，进而线性可分。</p>
<p>在R语言中，要实现高斯核函数，仅需将调用的svm()函数中的参数进行改变：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练改进后的非线性SVM模型</span></span><br><span class="line">svm_model_modify <span class="operator">&lt;-</span> svm<span class="punctuation">(</span>x_train<span class="punctuation">,</span>y_train<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">"C-classification"</span><span class="punctuation">,</span> kernel <span class="operator">=</span> <span class="string">"radial"</span><span class="punctuation">,</span> <span class="built_in">gamma</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> cost <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> scale <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中核函数类型的参数kernel由原先的线性函数”linear”更换为高斯核函数”radial”，并对核函数中的参数gamma以及控制误分类的惩罚参数cost进行了相应调整。</p>
<p>在<strong>样本数据区分不明显</strong>（即总体均值设置为0和1）的情况下，运行程序，得到<strong>改进后的非线性SVM模型的分类准确率为0.767</strong>，与Logistic回归模型在该样本下的分类准确率一致，<strong>较原先经典硬间隔SVM的预测准确率0.525有显著提升</strong>。改进后模型的分类效果如下图所示。</p>
<p><img src="/images/project02/media/image16.png"><img src="/images/project02/media/image17.png"></p>
<p>在<strong>样本数据区分较明显</strong>（即总体均值设置为0和2.8）的情况下，运行程序，得到<strong>改进后的非线性SVM模型的分类准确率为0.958</strong>，虽然仍优于Logistic回归模型在该样本下的分类效果，但<strong>较原先经典硬间隔SVM的预测准确率0.967有略微下降</strong>。尽管如此，<strong>改进后的模型分类准确率仍然在0.95以上，具有良好的分类效果</strong>。改进后模型的分类效果如下图所示。</p>
<p><img src="/images/project02/media/image18.png"><img src="/images/project02/media/image19.png"></p>
<h2 id="文献调研"><a href="#文献调研" class="headerlink" title="文献调研"></a>文献调研</h2><p>硬间距SVM要求构建的分类超平面完全正确的分类所有训练数据，但由于实际样本被假设成线性可分的条件太强，为避免过拟合，更多时候需要考虑软间距（soft-margin）SVM模型。</p>
<p>所谓软间距，就是允许一些点不满足线性可分的约束条件，即：<br>$$<br>y_i\left(w^Tx_i+b\right)&lt;1<br>$$<br>当然，为保证拟合模型仍然为一种SVM方法的”本性”，我们希望这样的点不能太多，因此要对违反约束的样本点(x_i, y_i)施加一定的非负惩罚（松弛变量）δ_i：<br>$$<br>\delta_i=max{0, 1-y_i\left(w^Tx_i+b\right)}=<br>    \begin{cases}<br>        0, y_i\left(w^Tx_i+b\right)\geq1\         \<br>        1-y_i\left(w^Tx_i+b\right),\ y_i\left(w^Tx_i+b\right)&lt;1<br>    \end{cases}<br>$$<br>这样就可以得到软间隔SVM的基本数学模型：<br>$$<br>\begin{cases}<br>        \mathop{min}\limits_{w,\ b,\ \delta_i} { {\frac{1}{2}||w||}^2+c\sum_{i=1}^{n}\delta_i}         \<br>        st:\ y_i(w^Tx_i+b)+\delta_i\geq1,\ \delta_i\geq0,\ i=1,\cdots,n<br>    \end{cases}<br>$$<br>值得注意的是，每一个样本都有一个对应的松弛变量，表征该样本不满足约束的程度；c&gt;0为惩罚参数，其值越大，对分类的惩罚越大。跟硬间隔SVM一样，先用拉格朗日乘子法得到拉格朗日函数，再求其对偶问题。</p>
<p>在正则化的框架下，软间隔SVM的基本数学模型结构还可改写为：<br>$$<br>\mathop{min}\limits_{w,\ b,\ \delta_i} { {\frac{1}{2}||w||}^2+c\sum_{i=1}^{n}\delta_i}<br>$$<br>其中学习机、损失项、正则化项分别定义为：</p>
<ul>
<li><p><strong>学习机</strong>：<br>$$<br>f\left(w\right)=w^Tx+b<br>$$</p>
</li>
<li><p><strong>损失项</strong>：<br>$$<br>c\sum_{i=1}^{n}\delta_i<br>$$</p>
</li>
<li><p><strong>正则项</strong>：<br>$$<br>\frac{1}{2}w^Tw={\frac{1}{2}||w||}^2<br>$$</p>
</li>
</ul>
<p>基于软间隔SVM模型，理论上的拓展主要集中在模型<strong>损失项</strong>与<strong>正则项</strong>两个方面，针对这两个方面，接下来将分别选取一篇文献，对其改进模型、求解算法与创新点进行简单的书面总结。</p>
<h3 id="正则项拓展：柔性套索惩罚-2"><a href="#正则项拓展：柔性套索惩罚-2" class="headerlink" title="正则项拓展：柔性套索惩罚[^2]"></a>正则项拓展：柔性套索惩罚[^2]</h3><h4 id="模型重述"><a href="#模型重述" class="headerlink" title="模型重述"></a>模型重述</h4><p>柔性套索（Pliable lasso）是一种新的互动模型，由Robert Tibshirani和Jerome Friedman于2018年提出。该模型是原始套索问题的扩展，允许套索回归模型接受修改变量、预测因子和结果。原始的套索（Lasso）问题本质上是将1-范数作为正则项，而柔性套索是在此基础上的改进。1-范数支持向量机的缺点之一是，在一些输入高度相关的情况下，并且所有输入都与输出相关，1-范数惩罚最终会挑选出少数输入，并将其余的减少到零，这意味着”群体选择”将是对1范数支持向量机的挑战。</p>
<p>柔性套索惩罚允许估计协变量X的主要影响以及协变量与一组修饰符Z之间的相互作用影响，以处理相互作用效应。为了处理变量选择并帮助选择相关变量组，引入修正变量Z，并将柔性套索作为正则项（惩罚项），得到具有柔性套索惩罚的SVM目标函数：<br>$$<br>\min_{\beta, h} \left( \frac{1}{n} \sum_{i=1}^n (1 - y_i (\beta_0 + x_i^T \beta))<em>+^2 + \lambda_1 \left( \sum</em>{j=1}^p |\beta_j|<em>1 + \sum</em>{j=1}^p |h_j|_1 \right) + \frac{\lambda_2}{2} \left( |\beta|<em>2^2 + \sum</em>{j=1}^p |h_j|_2^2 \right) \right)<br>$$<br>其中，学习机、损失项和正则化项（惩罚项）定义如下：</p>
<ul>
<li><p><strong>学习机</strong>：<br>$$<br>y = \beta_0 + Z h_0 + \sum_{j=1}^p X_j (\beta_j + Z h_j) + \epsilon_i<br>$$</p>
</li>
<li><p><strong>损失项</strong>：损失平方和（hinge函数）<br>$$<br>\frac{1}{n} \sum_{i=1}^n (1 - y_i (\beta_0 + x_i^T \beta))^2<br>$$</p>
</li>
<li><p><strong>正则项</strong>：柔性套索惩罚<br>$$<br>\lambda_1 \left( \sum_{j=1}^p |\beta_j|<em>1 + \sum</em>{j=1}^p |h_j|_1 \right) + \frac{\lambda_2}{2} \left( |\beta|<em>2^2 + \sum</em>{j=1}^p |h_j|_2^2 \right)<br>$$</p>
</li>
</ul>
<h4 id="求解算法与创新点"><a href="#求解算法与创新点" class="headerlink" title="求解算法与创新点"></a>求解算法与创新点</h4><p>在目标函数优化的求解过程中， 主要使用块方向坐标下降过程（the block-wise coordinate descent procedure）优化目标函数：</p>
<p><img src="/images/project02/media/1.png"></p>
<p>本篇文章在过去已有模型的基础上再次进行了改进，创造性地把柔性套索（优化后的1-范数）作为惩罚项（正则项）引入软间隔SVM模型中，创新点有如下几条：</p>
<ul>
<li><p><strong>可调套索惩罚的应用</strong>：将可调套索惩罚应用于支持向量机，能够有效估计协变量与修饰变量之间的交互作用。</p>
</li>
<li><p><strong>交互项排除机制</strong>：通过可调套索，能够在相应主效应为零时自动排除交互项，提高模型的解释性和简洁性。</p>
</li>
<li><p><strong>平方铰链损失结合块坐标下降算法</strong>:使用该组合优化目标函数，在模拟和实际数据（结肠癌和前列腺癌数据集）上验证了方法的有效性。</p>
</li>
</ul>
<h3 id="损失项拓展：快速截断Huber损失-3"><a href="#损失项拓展：快速截断Huber损失-3" class="headerlink" title="损失项拓展：快速截断Huber损失[^3]"></a>损失项拓展：快速截断<strong>Huber</strong>损失[^3]</h3><h4 id="模型重述-1"><a href="#模型重述-1" class="headerlink" title="模型重述"></a>模型重述</h4><p>支持向量机作为一种有用的分类工具，在许多领域得到了广泛的应用。然而，在非常大的样本数据集上，它可能会导致计算上的不可行性。为了解决这一问题，该文章提出了一种新颖的带有<strong>截断Huber损失的稀疏鲁棒支持向量机模型</strong>，即L_th-SVM，其基本数学模型如下：<br>$$<br>\min_{w \in \mathbb{R}^n, b \in \mathbb{R}} \frac{1}{2} |w|^2 + \gamma \sum_{i=1}^m \ell_{th}(1 - y_i(\langle w, x_i \rangle + b))<br>$$<br>也可写作：<br>$$<br>\min_{w \in \mathbb{R}^n, b \in \mathbb{R}} \frac{1}{2} |w|^2 + \gamma \sum_{i=1}^m \ell_{th}(h)<br>$$<br>其中，学习机、损失项和正则化项（惩罚项）定义如下：</p>
<ul>
<li><p><strong>学习机</strong>：<br>$$<br>h:= \mathbf{1} - \mathcal{G}\mathbf{w} - b\mathbf{y} \in \mathbb{R}^{m},其中\begin{aligned}<br>            \mathcal{G} &amp;:= \left[ \begin{array}{cccc}<br>                y_{1}x_{1} &amp; y_{2}x_{2} &amp; \cdots &amp; y_{m}x_{m}<br>            \end{array} \right]^{\top} \in \mathbb{R}^{m \times n}<br>            \end{aligned}<br>$$</p>
</li>
<li><p><strong>损失项</strong>：快速截断Huber损失（Truncated Huber Loss）：<br>$$<br>\ell_{\text{th}}(t) = \begin{cases}<br>    1, &amp; \text{if } t &gt; 1 + \frac{\delta}{2}, \<br>    t - \frac{\delta}{2}, &amp; \text{if } t \in \left[\delta, 1 + \frac{\delta}{2}\right], \<br>    \frac{t^2}{2\delta}, &amp; \text{if } t \in [0, \delta), \<br>    0, &amp; \text{if } t &lt; 0.<br>\end{cases}<br>$$</p>
</li>
<li><p><strong>正则项</strong>：L2正则化<br>$$<br>\frac{1}{2}w^Tw={\frac{1}{2}||w||}^2<br>$$</p>
</li>
</ul>
<h4 id="求解算法与创新点-1"><a href="#求解算法与创新点-1" class="headerlink" title="求解算法与创新点"></a>求解算法与创新点</h4><p>针对L_th-SVM问题，文章提出了一种新颖高效的乘子与工作集交替方向的方法L_th-ADMM)，证明了L_th-ADMM产生的序列是L_th-SVM的局部最小值，并且在工作集很小的情况下具有较低的计算复杂度。大量的数值实验表明，L_th-ADMM能够提供更高的预测精度，提供更少的支持向量，并且运行速度快，特别是在大规模数据集设置中。其求解算法大致如下：</p>
<p><img src="/images/project02/media/2.png"></p>
<p><img src="/images/project02/media/3.png"></p>
<p>本文的创新点主要包括以下几个方面：</p>
<ul>
<li><p><strong>截断Huber损失函数的提出</strong>：提出了一种新的截断Huber损失函数，该函数能够在保持稀疏性的同时，增加对异常值的鲁棒性。与现有的hinge损失、huberized pinball损失和Huber损失相比，截断Huber损失函数在稀疏性和鲁棒性方面表现出更优的性能。</p>
</li>
<li><p><strong>稀疏鲁棒SVM模型的构建</strong>：基于截断Huber损失函数，构建了新的稀疏鲁棒支持向量机模型（Lth-SVM）。该模型不仅继承了SVM分类能力强、理论框架完善等优点，还通过引入截断Huber损失函数提高了模型的稀疏性和鲁棒性，使其在处理大规模分类问题时更加有效。</p>
</li>
<li><p><strong>一阶最优性条件的建立</strong>：为L_th-SVM模型建立了基于新引入的P-稳定点的一阶必要和充分条件，定义了L_th支持向量和工作集。这些条件为算法设计提供了理论基础，同时也证明了所有L_th-SVM支持向量仅占整个训练集的一小部分，这为后续开发高效算法提供了可能。</p>
</li>
<li><p><strong>L_th-ADMM求解算法的设计</strong>：提出了一种具有工作集的新型交替方向乘子法（L_th-ADMM）来求解L_th-SVM。该算法通过引入工作集策略，显著降低了每次迭代中的计算复杂度，使得算法在处理大规模数据集时能够快速收敛。同时，理论证明表明，该算法生成的序列能够收敛到L_th-SVM的一个局部极小值。</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[^1]: Cortes C, Vapnik V. Support-vector networks[J]. Machine learning, 1995, 20(3): 273-297.<br>[^2]: Asenso, T. Q., Wang, P., &amp; Zhang, H. (2022). Pliable lasso for the support vec- tor machine. Communications in Statistics - Simulation and Computation, 53(2), 786–798.<br>[^3]: Huajun Wang, Yuanhai Shao, Fast truncated Huber loss SVM for large scale clas- sification, Knowledge-Based Systems, Volume 260, 2023.</p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-06-28T10:03:03.000Z" title="2024/6/28 18:03:03">2024-06-28</time>发表</span><span class="level-item"><time datetime="2025-03-03T09:56:46.090Z" title="2025/3/3 17:56:46">2025-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/">概率论与数理统计</a></span><span class="level-item">42 分钟读完 (大约6298个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/28/project1/">产品质量管理项目</a></p><div class="content"><div id="postchat_postcontent"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本项目的核心任务是通过统计过程控制（SPC）方法，对某工厂生产的滚珠直径数据进行产品质量管理，评估产品工艺水平及其生产过程是否受控。统计过程控制作为一种基于概率统计的过程控制方法，自1924年由Shewhart博士提出控制图以来，已广泛应用于现代制造过程的质量控制中。本项目基于Matlab软件开发，对于收集到的数据，通过描述性统计分析、正态性检验、总体均值检验、工序能力指数计算与绘制均值控制图和方差控制图等多种方式，对数据进行全面分析，最终评估工艺水平及生产过程的受控状态。具体而言，首先，在数据收集过程中，结合实际数据与模拟数据，得到25组产品质量样本数据（每组至少5个样本）；随后，通过描述性统计分析方法对数据进行宏观的认知，根据均值、方差、极差、直方图等指标对数据进行初步分析；接着又利用假设检验的方法，分别通过Pearson卡方检验与t检验等方法验证数据是否符合正态分布，并对其总体均值进行检验。基于对于正态总体及其均值、方差的检验合理性，最终计算并评估了数据的工序能力指数，同时绘制了均值控制图和方差控制图，以直观反映生产过程中的数据波动情况。通过多种方法的综合分析，最终得出了工厂生产的滚珠直径的工艺水平评价和生产过程的受控状态判断。</p>
<p><strong>关键词: 产品质量管理、统计过程控制（SPC）、假设检验、Shewhart控制图、Matlab</strong></p>
<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>现代产品质量管理主要有两个核心目标：第一，评价产品的工艺水平如何，即产品质量如何；第二，评价产品的生产过程是否受控，即产品可靠性如何。从现代质量控制的角度看，一方面要求产品质量好，另一方面还要求可靠性高。</p>
<p>统计过程控制(Statistical Process Control, SPC)是一种基于概率统计的过程控制方法。1924年美国贝尔实验室的Shewhart博士提出控制图，标志着产品统计质量控制的正式起点。作为现代质量管理的重要方法，SPC广泛应用于现代制造过程的质量控制。20实际80年代，国际上半导体制造过程已经普遍采用SPC技术提升产品合格率和可靠性。比如Motorola公司提出并在美国通用电器公司等广泛应用的6σ管理，其主要技术基础就是SPC理论。</p>
<p>生产过程是否处于统计受控状态，取决于生产过程是否存在异常因素导致产品质量的起伏变化。产品加工结果是否满足加工规范要求，反应的是工艺水平的高低；而工艺是否受控，反应的是生产过程是否存在异常因素。</p>
<h3 id="项目任务"><a href="#项目任务" class="headerlink" title="项目任务"></a>项目任务</h3><p>在本次项目中，需要收集批量产品质量数据，利用SPC方法对其进行管理，分析整体工艺水平并判断生产过程是否处于统计受控状态，具体而言可细分为如下任务：</p>
<ul>
<li><p><strong>任务 1</strong>:收集或生成25组以上的数据，每组至少5个样本。</p>
</li>
<li><p><strong>任务2</strong>:根据均值，方差，极差，直方图等指标，对数据进行描述性统计分析。</p>
</li>
<li><p><strong>任务 3</strong>:对数据进行正态性检验与总体的均值检验。</p>
</li>
<li><p><strong>任务 4</strong>:计算数据工序能力指数并对其进行评估。</p>
</li>
<li><p><strong>任务 5</strong>:描绘均值控制图和方差控制图。</p>
</li>
<li><p><strong>任务 6</strong>:得出结论：工艺水平如何；生产过程是否处于统计受控状态。</p>
</li>
</ul>
<h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><p>本项目完全基于Matlab代码实现SPC方法进行产品质量管理。</p>
<h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>本项目中的数据收集采用实际数据与模拟数据结合的方式，其中实际数据以书本7.4节的例题7.4.4[^1]为主要来源，在此基础上利用生成的模拟数据对其进行扩充，最终得到25组产品质量样本数据，每组中含有5个数据。</p>
<p>具体而言，本项目的问题情境为对工厂生产的滚珠直径（单位：$mm$）进行产品质量管理。书本上的例题提供了50个直径数据，将其作为扩充生成模拟数据的源数据source_data，即：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">source_data=[<span class="number">15.0</span>,<span class="number">15.8</span>,<span class="number">15.2</span>,<span class="number">15.1</span>,<span class="number">15.9</span>,</span><br><span class="line">             <span class="number">14.7</span>,<span class="number">14.8</span>,<span class="number">15.5</span>,<span class="number">15.6</span>,<span class="number">15.3</span>,</span><br><span class="line">             <span class="number">15.0</span>,<span class="number">15.6</span>,<span class="number">15.7</span>,<span class="number">15.8</span>,<span class="number">14.5</span>,</span><br><span class="line">             <span class="number">15.1</span>,<span class="number">15.3</span>,<span class="number">14.9</span>,<span class="number">14.9</span>,<span class="number">15.2</span>,</span><br><span class="line">             <span class="number">15.9</span>,<span class="number">15.0</span>,<span class="number">15.3</span>,<span class="number">15.6</span>,<span class="number">15.1</span>,</span><br><span class="line">             <span class="number">14.9</span>,<span class="number">14.2</span>,<span class="number">14.6</span>,<span class="number">15.8</span>,<span class="number">15.2</span>,</span><br><span class="line">             <span class="number">15.2</span>,<span class="number">15.0</span>,<span class="number">14.9</span>,<span class="number">14.8</span>,<span class="number">15.1</span>,</span><br><span class="line">             <span class="number">15.5</span>,<span class="number">15.5</span>,<span class="number">15.1</span>,<span class="number">15.1</span>,<span class="number">15.0</span>,</span><br><span class="line">             <span class="number">15.3</span>,<span class="number">14.7</span>,<span class="number">14.5</span>,<span class="number">15.5</span>,<span class="number">15.0</span>,</span><br><span class="line">             <span class="number">14.7</span>,<span class="number">14.6</span>,<span class="number">14.2</span>,<span class="number">14.2</span>,<span class="number">14.5</span>]; </span><br></pre></td></tr></tbody></table></figure>

<p>设置扩充后的数据组数num_groups以及各组样本数据个数samples_per_groups：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_groups = <span class="number">25</span>;</span><br><span class="line">samples_per_group = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>两者相乘得到样本数据总数num_data_points：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num_data_points = num_groups * samples_per_group;</span><br></pre></td></tr></tbody></table></figure>

<p>要对原始数据进行扩充，首先需要复制原始数据并添加随机扰动：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replicated_data = <span class="built_in">repmat</span>(source_data, <span class="number">1</span>, <span class="built_in">ceil</span>(num_data_points / <span class="built_in">length</span>(source_data)));</span><br><span class="line">perturbed_data = replicated_data(<span class="number">1</span>:num_data_points) + <span class="number">0.05</span> * <span class="built_in">randn</span>(<span class="number">1</span>, num_data_points);</span><br></pre></td></tr></tbody></table></figure>

<p>接着使用插值生成更多数据点，并保留一位小数：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>:<span class="built_in">length</span>(perturbed_data);</span><br><span class="line">xi = <span class="built_in">linspace</span>(<span class="number">1</span>, <span class="built_in">length</span>(perturbed_data), num_data_points);</span><br><span class="line">interpolated_data = interp1(x, perturbed_data, xi, <span class="string">'spline'</span>);</span><br><span class="line">interpolated_data = <span class="built_in">round</span>(interpolated_data, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>最后将生成的模拟数据点重新组织为25组，每组5个数据，得到完整样本数据：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expanded_data = <span class="built_in">reshape</span>(interpolated_data, samples_per_group, num_groups)';</span><br><span class="line">data = expanded_data;</span><br></pre></td></tr></tbody></table></figure>

<p>最终的样本数据如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>15.0000</td>
<td>14.6000</td>
<td>15.0000</td>
<td>15.1000</td>
<td>16.0000</td>
</tr>
<tr>
<td>2</td>
<td>14.9000</td>
<td>15.2000</td>
<td>15.5000</td>
<td>15.2000</td>
<td>14.7000</td>
</tr>
<tr>
<td>3</td>
<td>15.7000</td>
<td>14.7000</td>
<td>15.6000</td>
<td>15.2000</td>
<td>15.0000</td>
</tr>
<tr>
<td>4</td>
<td>14.2000</td>
<td>15.1000</td>
<td>15.5000</td>
<td>14.7000</td>
<td>14.6000</td>
</tr>
<tr>
<td>5</td>
<td>15.2000</td>
<td>15.5000</td>
<td>15.7000</td>
<td>14.9000</td>
<td>15.3000</td>
</tr>
<tr>
<td>6</td>
<td>14.7000</td>
<td>14.9000</td>
<td>15.1000</td>
<td>14.4000</td>
<td>14.3000</td>
</tr>
<tr>
<td>7</td>
<td>15.1000</td>
<td>15.6000</td>
<td>15.8000</td>
<td>14.8000</td>
<td>15.6000</td>
</tr>
<tr>
<td>8</td>
<td>15.9000</td>
<td>14.8000</td>
<td>15.1000</td>
<td>15.5000</td>
<td>14.3000</td>
</tr>
<tr>
<td>9</td>
<td>16.0000</td>
<td>15.3000</td>
<td>14.6000</td>
<td>15.3000</td>
<td>15.1000</td>
</tr>
<tr>
<td>10</td>
<td>15.2000</td>
<td>15.1000</td>
<td>15.1000</td>
<td>14.9000</td>
<td>14.6000</td>
</tr>
<tr>
<td>11</td>
<td>15.0000</td>
<td>14.8000</td>
<td>14.9000</td>
<td>15.1000</td>
<td>15.9000</td>
</tr>
<tr>
<td>12</td>
<td>14.9000</td>
<td>15.3000</td>
<td>15.5000</td>
<td>15.2000</td>
<td>14.7000</td>
</tr>
<tr>
<td>13</td>
<td>15.8000</td>
<td>14.8000</td>
<td>15.6000</td>
<td>15.3000</td>
<td>14.9000</td>
</tr>
<tr>
<td>14</td>
<td>14.1000</td>
<td>15.1000</td>
<td>15.4000</td>
<td>14.7000</td>
<td>14.6000</td>
</tr>
<tr>
<td>15</td>
<td>15.2000</td>
<td>15.5000</td>
<td>15.7000</td>
<td>14.9000</td>
<td>15.3000</td>
</tr>
<tr>
<td>16</td>
<td>14.6000</td>
<td>14.9000</td>
<td>15.0000</td>
<td>14.5000</td>
<td>14.3000</td>
</tr>
<tr>
<td>17</td>
<td>15.2000</td>
<td>15.6000</td>
<td>15.8000</td>
<td>14.9000</td>
<td>15.6000</td>
</tr>
<tr>
<td>18</td>
<td>15.8000</td>
<td>14.8000</td>
<td>15.1000</td>
<td>15.5000</td>
<td>14.2000</td>
</tr>
<tr>
<td>19</td>
<td>15.9000</td>
<td>15.3000</td>
<td>14.5000</td>
<td>15.2000</td>
<td>15.1000</td>
</tr>
<tr>
<td>20</td>
<td>15.2000</td>
<td>15.1000</td>
<td>15.0000</td>
<td>15.0000</td>
<td>14.5000</td>
</tr>
<tr>
<td>21</td>
<td>15.0000</td>
<td>14.7000</td>
<td>15.0000</td>
<td>15.1000</td>
<td>16.0000</td>
</tr>
<tr>
<td>22</td>
<td>14.9000</td>
<td>15.1000</td>
<td>15.6000</td>
<td>15.3000</td>
<td>14.6000</td>
</tr>
<tr>
<td>23</td>
<td>15.7000</td>
<td>14.9000</td>
<td>15.6000</td>
<td>15.4000</td>
<td>14.9000</td>
</tr>
<tr>
<td>24</td>
<td>14.2000</td>
<td>15.0000</td>
<td>15.5000</td>
<td>14.8000</td>
<td>14.7000</td>
</tr>
<tr>
<td>25</td>
<td>15.2000</td>
<td>15.4000</td>
<td>15.6000</td>
<td>14.9000</td>
<td>15.2000</td>
</tr>
</tbody></table>
<p>其中每行表示一组数据，共25组，每组中有5个数据。</p>
<h3 id="描述性统计分析"><a href="#描述性统计分析" class="headerlink" title="描述性统计分析"></a>描述性统计分析</h3><p>描述性统计量主要有以下几种：</p>
<ul>
<li><p><strong>均值 (Mean)</strong>: 计算每组数据的平均值，反映该组数据的中心位置。</p>
</li>
<li><p><strong>方差 (Variance)</strong>: 度量数据分散程度，数值越大表示数据的波动越大。</p>
</li>
<li><p><strong>标准差 (Standard Deviation)</strong>: 方差的平方根，同样反映数据的分散程度，但单位与数据相同。</p>
</li>
<li><p><strong>极差 (Range)</strong>: 最大值与最小值的差，表示数据的跨度。</p>
</li>
</ul>
<p>利用Matlab软件中自带的库函数，可以分别实现对于各组数据均值、方差、标准差与极差等统计量的计算：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">means = <span class="built_in">mean</span>(data, <span class="number">2</span>); </span><br><span class="line">variances = var(data, <span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">ranges = range(data, <span class="number">2</span>); </span><br><span class="line">stds = std(data, <span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>各组均值</th>
<th>各组方差</th>
<th>各组标准差</th>
<th>各组极差</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>15.14</td>
<td>0.268</td>
<td>0.51769</td>
<td>1.4</td>
</tr>
<tr>
<td>2</td>
<td>15.1</td>
<td>0.095</td>
<td>0.30822</td>
<td>0.8</td>
</tr>
<tr>
<td>3</td>
<td>15.24</td>
<td>0.173</td>
<td>0.41593</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>14.82</td>
<td>0.247</td>
<td>0.49699</td>
<td>1.3</td>
</tr>
<tr>
<td>5</td>
<td>15.32</td>
<td>0.092</td>
<td>0.30332</td>
<td>0.8</td>
</tr>
<tr>
<td>6</td>
<td>14.68</td>
<td>0.112</td>
<td>0.33466</td>
<td>0.8</td>
</tr>
<tr>
<td>7</td>
<td>15.38</td>
<td>0.172</td>
<td>0.41473</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td>15.12</td>
<td>0.382</td>
<td>0.61806</td>
<td>1.6</td>
</tr>
<tr>
<td>9</td>
<td>15.26</td>
<td>0.253</td>
<td>0.50299</td>
<td>1.4</td>
</tr>
<tr>
<td>10</td>
<td>14.98</td>
<td>0.057</td>
<td>0.23875</td>
<td>0.6</td>
</tr>
<tr>
<td>11</td>
<td>15.14</td>
<td>0.193</td>
<td>0.43932</td>
<td>1.1</td>
</tr>
<tr>
<td>12</td>
<td>15.12</td>
<td>0.102</td>
<td>0.31937</td>
<td>0.8</td>
</tr>
<tr>
<td>13</td>
<td>15.28</td>
<td>0.187</td>
<td>0.43243</td>
<td>1</td>
</tr>
<tr>
<td>14</td>
<td>14.78</td>
<td>0.247</td>
<td>0.49699</td>
<td>1.3</td>
</tr>
<tr>
<td>15</td>
<td>15.32</td>
<td>0.092</td>
<td>0.30332</td>
<td>0.8</td>
</tr>
<tr>
<td>16</td>
<td>14.66</td>
<td>0.083</td>
<td>0.2881</td>
<td>0.7</td>
</tr>
<tr>
<td>17</td>
<td>15.42</td>
<td>0.132</td>
<td>0.36332</td>
<td>0.9</td>
</tr>
<tr>
<td>18</td>
<td>15.08</td>
<td>0.387</td>
<td>0.62209</td>
<td>1.6</td>
</tr>
<tr>
<td>19</td>
<td>15.2</td>
<td>0.25</td>
<td>0.5</td>
<td>1.4</td>
</tr>
<tr>
<td>20</td>
<td>14.96</td>
<td>0.073</td>
<td>0.27019</td>
<td>0.7</td>
</tr>
<tr>
<td>21</td>
<td>15.16</td>
<td>0.243</td>
<td>0.49295</td>
<td>1.3</td>
</tr>
<tr>
<td>22</td>
<td>15.1</td>
<td>0.145</td>
<td>0.38079</td>
<td>1</td>
</tr>
<tr>
<td>23</td>
<td>15.3</td>
<td>0.145</td>
<td>0.38079</td>
<td>0.8</td>
</tr>
<tr>
<td>24</td>
<td>14.84</td>
<td>0.223</td>
<td>0.47223</td>
<td>1.3</td>
</tr>
<tr>
<td>25</td>
<td>15.26</td>
<td>0.068</td>
<td>0.26077</td>
<td>0.7</td>
</tr>
</tbody></table>
<p>以及计算总体数据的均值、方差、标准差与极差：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">overall_mean = <span class="built_in">mean</span>(data(:)); </span><br><span class="line">overall_variance = var(data(:)); </span><br><span class="line">overall_range = range(data(:)); </span><br><span class="line">overall_std = std(data(:));</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>总体均值</th>
<th>15.1064</th>
</tr>
</thead>
<tbody><tr>
<td>总体方差</td>
<td>0.18657</td>
</tr>
<tr>
<td>总体标准差</td>
<td>0.43194</td>
</tr>
<tr>
<td>总体极差</td>
<td>1.9</td>
</tr>
</tbody></table>
<p>值得注意的是，Matlab中计算方差的函数 var(A) 默认会按照 N-1（N是观测值数量，即上文中的num_data_points）实现归一化，从而可以作为对于总体分布的方差的无偏估计。上述得到的均为修正后的样本方差。</p>
<p>通过对于上述四个描述性统计量的样本观测结果进行初步分析，可以得到如下结论：</p>
<ul>
<li><p>滚珠直径的总体平均值约为15.1mm，可作为后续总体均值检验的检验目标。</p>
</li>
<li><p>各组数据的方差均在0.5以内，总体方差与标准差也较低，说明生产过程中数据波动较小，产品质量稳定性较高。</p>
</li>
<li><p>数据极差范围适中，总体极差不超过2，处于合理区间。</p>
</li>
</ul>
<p>除此之外，还可以通过绘制频数分布直方图的方式对于样本数据进行描述性统计分析：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = histogram(data);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/project1/1.png" alt="image"></p>
<p>观察图表可知，<strong>数据的频数分布大致呈”两边少，中间多”的趋势，推测其总体大致服从正态分布</strong>，需要进行进一步检验。</p>
<h3 id="数据正态性检验"><a href="#数据正态性检验" class="headerlink" title="数据正态性检验"></a>数据正态性检验</h3><p>要验证总体是否服从正态分布，需要采用Pearson卡方检验方法，对总体的分布类型进行检验。</p>
<p>Matlab软件中，有相应的函数chi2gof可通过Pearson卡方检验来验证总体分布类型是否为正态分布：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[result, p_chi2] = chi2gof(data(:));</span><br></pre></td></tr></tbody></table></figure>

<p>chi2gof函数是使用Pearson卡方检验返回原假设的检验决策，其原假设假定样本数据来自正态分布的总体，备择假设是样本数据不来自正态分布的总体。默认情况（仅将样本数据data输入chi2gof函数）下，检验的显著性水平为δ=0.05，且默认检验总体是否服从正态分布；通过增加函数的输入参数可以对显著性水平和检验的分布类型进行更改，在此不再赘述。</p>
<p>返回的参数result为正态性检验的结果，若result=0，说明无法拒绝原假设，即可认为样本数据来自正态分布的总体；若result=1，则拒绝原假设，认为数据不来自正态分布的总体。另一返回参数p_chi2则为该检验的p值，当其大于显著性水平δ时不拒绝原假设。</p>
<p><strong>通过对样本数据进行正态性检验，可认为数据来自正态分布的总体，正态性检验的p值为0.37005。</strong></p>
<p>从原理出发，也可根据假设检验的基本方法流程对总体的分布类型进行检验：</p>
<p>首先，提出原假设与备择假设：</p>
<ul>
<li><p><strong>H_0</strong>：总体服从正态分布，即<br>$$<br>F(x) = \phi(\frac{x-\mu}{\sigma})<br>$$</p>
</li>
<li><p><strong>H_1</strong>：总体不服从正态分布，即<br>$$<br>F(x) \neq \phi(\frac{x-\mu}{\sigma})<br>$$</p>
</li>
</ul>
<p>其中F(x)为总体的分布，μ和σ为正态分布的均值与方差（均为未知参数）。</p>
<p>接着，根据假设的提出给出对应的拒绝域形式：<br>$$<br>R_0 = \left{ T&gt;c \right}<br>$$<br>其中T为构造的统计量：</p>
<p>$$<br>T=\sum_{i=1}^{r}\frac{ {(n_i-n{p}_i)}^2}{np_i}<br>$$<br>若将对总体X所有可能的取值范围分割成$r个两两不交的部分，则式中：</p>
<ul>
<li><strong>n_i</strong>：统计样本中实际落入第i个部分的个数（实际频数）；</li>
<li><strong>n</strong>：样本数据总数，即上文代码中的num_data_points；</li>
<li><strong>p_i</strong>：任一样本落入第$i$个部分的概率。</li>
</ul>
<p>显然，当原假设<br>$$<br>H_0: F(x) = \phi(\frac{x-\mu}{\sigma})<br>$$<br>成立时，理论频数n*p_i应与实际频数n_i较为接近，这也是拒绝域形式的确定依据。</p>
<p>可以注意到，Pearson卡方统计量<br>$$<br>T=\sum_{i=1}^{r}\frac{ { {(n_i-np}_i)}^2}{np_i}<br>$$<br>服从如下的大样本分布：</p>
<p>$$<br>\hat{T}=\sum_{i=1}^{r}\frac { { {(n_i-n\hat{p}}_i)}^2}{n{\hat{p} }_i}\rightarrow X^2(r-1-s)<br>$$<br>其中：</p>
<p>s表示待估未知参数的个数，显然本项目中s=2；</p>
<p>hat(p)_i为任一样本落入第i部分的概率p_i的估计值，这是由于假定的分布类型中含有未知参数，因此需要先根据样本数据对未知参数进行极大似然估计，再代入得到概率的估计值。</p>
<p>然后，需要计算犯第一类错误的概率<br>$$<br>\alpha=P \left{H_1|H_0\right} = \left{T&gt;c|\F(x)=F_0(x)\right}<br>$$<br>并根据α = δ = 0.05求得拒绝域中未知参数c的临界值criticalValue = 11.0705：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deta=<span class="number">0.05</span>;</span><br><span class="line">mu_MLE = overall_mean;</span><br><span class="line">sigma2_MLE = overall_variance*(num_data_points<span class="number">-1</span>)/num_data_points; </span><br><span class="line">sigma_MLE = <span class="built_in">sqrt</span>(sigma2_MLE);</span><br><span class="line">dimension=numBins<span class="number">-1</span><span class="number">-2</span>;</span><br><span class="line">criticalValue = chi2inv(<span class="number">1</span> - deta, dimension);</span><br></pre></td></tr></tbody></table></figure>

<p>事实上，上文中提到Matlab软件中的var(A)函数默认按照N-1实现归一化，而正态分布方差的极大似然估计应为未修正的样本方差，故特此进行更正；同时，在2.2节的描述性统计分析过程中，涉及到频数直方图的绘制时已经对数据完成了分组，可直接通过读取上述的图表属性获取分组数numBins（对应上文中r）、各组频数binCounts（对应上文中实际频数n_i与各分组边界binEdges（可用于计算p_i））：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numBins = h.NumBins;</span><br><span class="line">binCounts = h.Values;</span><br><span class="line">binEdges = h.BinEdges;</span><br></pre></td></tr></tbody></table></figure>

<p>最后，通过样本数据计算出对应卡方统计量T的观测kafang = 2.6897：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kafang=<span class="number">0</span>;</span><br><span class="line">p_hat(<span class="number">1</span>)= normcdf(binEdges(<span class="number">2</span>), mu_MLE, sigma_MLE);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:numBins<span class="number">-1</span></span><br><span class="line">    p_hat(<span class="built_in">i</span>)= normcdf(binEdges(<span class="built_in">i</span>+<span class="number">1</span>), mu_MLE, sigma_MLE)-normcdf(binEdges(<span class="built_in">i</span>), mu_MLE, sigma_MLE);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">p_hat(numBins)= <span class="number">1</span>-normcdf(binEdges(numBins), mu_MLE, sigma_MLE);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:numBins</span><br><span class="line">    kafang=kafang+(binCounts(<span class="built_in">i</span>)-num_data_points*p_hat(<span class="built_in">i</span>))^<span class="number">2</span> / (num_data_points*p_hat(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>由于kafang&lt;criticalValue，即不位于拒绝域内，因此无法拒绝原假设H_0，即可以认为数据确实来自正态分布的总体</strong>，与直接调用Matlab内置库函数的结果一致。</p>
<h3 id="总体均值检验"><a href="#总体均值检验" class="headerlink" title="总体均值检验"></a>总体均值检验</h3><p>通过Pearson卡方检验，已经可以认为在显著性水平δ=0.05的情况下，总体近似服从正态分布。进一步地，还希望对该正态总体的均值参数μ进行假设检验。在2.2节的描述性统计分析过程中，已经计算得到样本的总体均值（实际上也是正态分布参数μ的无偏估计与最大似然估计）μ_0 约为15.1(mm)，因此接下来的假设检验过程就将其作为检验对象：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miu0=<span class="number">15.1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>在正态总体的均值检验过程中，主要采取t检验的方法，即认为正态总体的另一参数σ未知。这样的检验方法的合理性是显然的，此时需要构造服从t分布的统计量以进行t检验。</p>
<p>在Matlab软件中，对于t检验仍然有相对应的库函数ttest()可以调用：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[result1, ttest_p_value] = ttest(data(:),miu0);</span><br></pre></td></tr></tbody></table></figure>

<p>函数ttest(data(:),miu0)使用单样本t检验返回原假设的检验决策，其原假设假定数据data来自均值等于输入参数miu0且方差未知的正态分布，而备择假设是总体分布的均值不等于miu0。如果该检验在默认为5%的显著性水平上拒绝原假设，则函数的返回值result1为1，即认为正态总体的均值不为miu0，否则为0；而另一返回值ttest_p_value则为该检验的p值，当其大于显著性水平时不拒绝原假设，即可认为正态总体的均值等于miu0。</p>
<p>运行代码可得：<strong>正态总体均值检验p值ttest_p_value=0.8687，可认为正态总体的均值约为μ_0=15.1。</strong></p>
<p>同样的，这样的假设检验过程也可以基于一般的统计方法实现：</p>
<p>首先，提出原假设与备择假设：</p>
<ul>
<li><strong>H_0</strong>：正态总体的均值为15.1，即μ=μ_0=15.1；</li>
<li><strong>H_1</strong>：正态总体的均值不为15.1，即μ ≠ μ_0。</li>
</ul>
<p>接着，根据假设的提出给出对应的拒绝域形式：<br>$$<br>R_0 = \left{ (x_1, x_2,…,x_n)^T :|\bar{x}-\mu_0| &gt;c \right}<br>$$<br>该拒绝域形式的构造是具有合理性的，因为显然可证明样本均值bar{x}是对于正态总体参数μ的无偏估计，若原假设H_0成立，则说明bar{x}应与设定检验值μ_0较为接近，反之可得其拒绝域应描述为bar{x}与μ _0相距较远的情形，基于这样的原理也可构造其他形式的拒绝域，这里只是给出一种可能性。</p>
<p>然后，需要计算犯第一类错误的概率<br>$$<br>\alpha=P \left{H_1|H_0\right} = \left{\bar{x}-\mu_0| &gt;c|\mu=\mu_0\right}<br>$$<br>并根据α = δ = 0.05求得拒绝域中未知参数c的临界值tcriticalValue = 0.0765：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deta=<span class="number">0.05</span>;</span><br><span class="line">dimension=num_data_points<span class="number">-1</span>;</span><br><span class="line">s=<span class="built_in">sqrt</span>(var(data(:)));</span><br><span class="line">tCriticalValue = tinv(<span class="number">1</span> - deta/<span class="number">2</span>, dimension)*s/<span class="built_in">sqrt</span>(num_data_points);</span><br></pre></td></tr></tbody></table></figure>

<p>上述计算操作的依据是，在对第一类错误发生概率α的计算过程中，可以根据抽样分布定理构造出对应的t统计量<br>$$<br>\frac{\bar{x}-\mu_0}{s/\sqrt{n}} \sim t(n-1)<br>$$<br>从而查表进行计算求解得到临界值<br>$$<br>c=\frac{t_{1-\frac{\delta}{2}}(n-1)*s}{\sqrt{n}}<br>$$<br>其中s为样本数据的标准差（修正后），n为样本容量num_data_points。</p>
<p>最后，前文已经计算出样本均值为bar{x}，若将其与待检验值μ_0之间的距离|bar{x}-μ _0|定义为参数d，则在判定是否处于拒绝域中时只需要比较d与临界值tcriticalValue即可：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d=<span class="built_in">abs</span>(overall_mean-miu0);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>计算得到d=0.0064，小于临界值tcriticalValue = 0.0765，即不位于拒绝域内，因此无法拒绝原假设，可认为正态总体的均值μ约为15.1。</strong>这同样与直接调用Matlab内置函数的结果相一致。事实上，只要μ_0在样本均值bar{x}=15.1064上下tcriticalValue = 0.0765的区间范围内，都可在显著性水平δ=0.05的情况下认为是正态总体的均值μ。</p>
<h3 id="数据工序能力指数的计算与评估"><a href="#数据工序能力指数的计算与评估" class="headerlink" title="数据工序能力指数的计算与评估"></a>数据工序能力指数的计算与评估</h3><p>在2.3节和2.4节中，通过假设检验的方法已经分别证明在显著性水平平δ=0.05的情况下，可以认为总体近似服从正态分布，且正态总体的均值μ约为15.1mm。基于类似的方法，不难得到正态总体的标准差σ约等于样本数据的标准差（修正）s=0.4319。基于这样的假设并通过假设检验验证其合理性之后，可以对于产品的生产质量利用数据工序能力指数等指标进行评估。</p>
<p>在工业生产中，为了综合表示工艺水平满足工艺参数规范要求的程度，通常借助于工序能力指数 (Process Capability index, Cp or Cpk) 来描述生产线是否具有较高的工艺水平能否生产出质量好的产品。潜在工序能力指数Cp的定义为：</p>
<p>$$<br>Cp=\frac{T_U-T_L}{6\sigma}<br>$$<br>其中T_U，T_L分别表示工艺参数规范的上限和下限。在本项目的问题背景之下，一般认为滚珠直径在14mm-16mm都可视为合理；但值得注意的是，在此定义中，隐含要求工艺参数分布中心μ与工艺规范要求的中心值T_0=(T_U+T_L)/2相重合。由2.4节的均值检验过程可知，μ约为15.1且上下限14和16的均值15不在可以通过假设检验的区间范围内，因此在此先进行近似处理，假定T_U=16.1，T_L=14.1，则可以计算出<strong>此时的潜在工序能力指数Cp=0.7717</strong>：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tu=<span class="number">16.1</span>;</span><br><span class="line">Tl=<span class="number">14.1</span>;</span><br><span class="line">spec_limits = [Tl, Tu]; </span><br><span class="line">sigma = std(data(:)); </span><br><span class="line">cp = (spec_limits(<span class="number">2</span>) - spec_limits(<span class="number">1</span>)) / (<span class="number">6</span> * sigma);</span><br></pre></td></tr></tbody></table></figure>

<p>而事实上，在原设定T_U=16，T_L=14的条件下，由于规范中心T_0=(T_U+T_L)/2与参数分布中心μ不重合，上述的近似处理并不能很准确在的反映其工序能力，此时则需要采用实际工序能力指数Cpk来度量工艺水平的高低：</p>
<p>$$<br>Cpk=\frac{T_U-T_L}{6\sigma}(1-K)<br>$$<br>其中K用于度量工艺参数分布均值μ对规范中心T_0的相对偏离度，即：</p>
<p>$$<br>K=\frac { {|\mu-T}_0|} { {(T}_U-T_L)/2}<br>$$</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tu=<span class="number">16</span>;</span><br><span class="line">Tl=<span class="number">14</span>;</span><br><span class="line">spec_limits = [Tl, Tu]; </span><br><span class="line">T0=(spec_limits(<span class="number">2</span>) + spec_limits(<span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">k=<span class="built_in">abs</span>(overall_mean-T0)*<span class="number">2</span>/(spec_limits(<span class="number">2</span>) - spec_limits(<span class="number">1</span>));</span><br><span class="line">cpk=(spec_limits(<span class="number">2</span>) - spec_limits(<span class="number">1</span>)) *(<span class="number">1</span>-k)/ (<span class="number">6</span> * sigma);</span><br></pre></td></tr></tbody></table></figure>

<p>计算得到：<strong>相对偏离度K=0.1064，实际工序能力指数Cpk=0.6896</strong>。其中相对偏离度K&lt;1，说明均值未偏离到规范范围外，表明工艺加工结果合适，且实际工序能力指数Cpk&gt;0，表明该工序具有一定的生产能力，但并未达到国际上的普遍要求Cpk&gt;1.5，说明生产水平还存在相当大的提升空间。</p>
<p>除此之外，还可以计算单侧规范下的实际工序能力指数C_PU和C_PL:</p>
<p>若工艺参数只有上规范T_U的要求，则实际工序能力指数C_PU定义为：<br>$$<br>C_{PU}=\frac{T_U-\mu}{3\sigma}<br>$$<br>若工艺参数只有下规范T_L的要求，则实际工序能力指数C_PL定义为：<br>$$<br>C_{PL}=\frac { {\mu-T}_L}{3\sigma}<br>$$</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpu = (spec_limits(<span class="number">2</span>) - <span class="built_in">mean</span>(data(:))) / (<span class="number">3</span> * sigma);</span><br><span class="line">cpl = (<span class="built_in">mean</span>(data(:)) - spec_limits(<span class="number">1</span>)) / (<span class="number">3</span> * sigma);</span><br></pre></td></tr></tbody></table></figure>

<p>计算得到：<strong>实际工序能力指数C_PU=0.6896、C_PL=0.8538</strong>，也并未达到国际一般标准。</p>
<h3 id="均值控制图与方差控制图"><a href="#均值控制图与方差控制图" class="headerlink" title="均值控制图与方差控制图"></a>均值控制图与方差控制图</h3><p>Shewhart控制图是实施SPC过程中判断生产过程是否处于统计受控状态的基本工具，其中使用最为广泛的为均值控制图和方差（标准差）控制图。通过连续采集工艺参数数据，可以利用Shewhart控制图来定量分析和度量生产线的运行过程处于统计受控状态。</p>
<h4 id="均值控制图"><a href="#均值控制图" class="headerlink" title="均值控制图"></a>均值控制图</h4><p>在均值控制图中，包含有三条水平线，分别是：</p>
<ul>
<li><p>**UCL(Upper Control Limit)**：表示上控制限；</p>
</li>
<li><p>**LCL(Lower Control Limit)**：表示下控制限；</p>
</li>
<li><p>**CL(Center Line)/Avg(Average)**：表示中心线。</p>
</li>
</ul>
<p>对于各批次的样本数据，用折线连接每批次的均值，从而得到反映不同批次数据均值波动情况的折线图。</p>
<p>对于服从正态分布总体N(μ, σ^2)的工艺参数而言，其取值落在(μ ± 3σ)区间范围内的概率为99.73%，因此可以采用如下的<strong>3σ准则</strong>来确定均值控制图的中心线以及上下控制限：</p>
<p>$$<br>UCL=\mu+3\sigma<br>$$</p>
<p>$$<br>CL=\mu<br>$$</p>
<p>$$<br>LCL=\mu-3\sigma<br>$$</p>
<p>* 我国标准”GB/T 4091常规控制图(2001版)”规定采用上述法则来计算控制限。</p>
<p>基于以上法则，可绘制均值控制图如下：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">miu_hat=overall_mean;</span><br><span class="line">sigma_hat=overall_variance;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(means, <span class="string">'o-'</span>);</span><br><span class="line">CL= miu_hat;</span><br><span class="line">UCL=miu_hat+<span class="number">3</span>*sigma_hat;</span><br><span class="line">LCL=miu_hat<span class="number">-3</span>*sigma_hat</span><br><span class="line">yline(CL, <span class="string">'r-'</span>, <span class="string">'CL'</span>);</span><br><span class="line">yline(UCL, <span class="string">'r--'</span>, <span class="string">'UCL'</span>);</span><br><span class="line">yline(LCL, <span class="string">'r--'</span>, <span class="string">'LCL'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/project1/2.png" alt="image"></p>
<p>但在实际生产实践中，并不是所有的产品工艺指标都会近似服从正态分布。因此，在实际操作中，均值控制限常用如下公式估算：</p>
<p>$$<br>UCL=\hat{\mu}+A_s\bullet \hat{s}<br>$$</p>
<p>$$<br>CL=\hat{\mu}<br>$$</p>
<p>$$<br>LCL=\hat{\mu}-A_s\bullet \hat{s}<br>$$</p>
<p>其中，若采集工艺参数样本数据组数k=25，各批次数据数量n=5，令x_ij表示第i批次的第j个数据，bar{x_i}表示组内均值；则可用μ表示个各批次所有数据的样本均值，hat{s}表示各个批次数据标准偏差的算数平均值，即：</p>
<p>$$<br>{\bar{x}}<em>i=\frac{1}{n}\sum</em>{j=1}^{n}x_{ij}<br>$$</p>
<p>$$<br>\hat{s}=\frac{1}{k}\sum_{i=1}^{k}{\hat{s}}_i<br>$$</p>
<p>$$<br>\hat{\mu}=\frac{1}{k}\sum_{i=1}^{k}{\bar{x}}<em>i=\frac{1}{kn}\sum</em>{i=1}^{k}\sum_{j=1}^{n}x_{ij}<br>$$</p>
<p>$$<br>{\hat{s}}<em>i=\sqrt{\frac{1}{n-1}\sum</em>{j=1}^{n}{ {(x}_{ij}-{\bar{x} }_i)}^2}<br>$$</p>
<p>又查表[^2]可得：当每批次样本数据数n=5时，有A_s=1.427。</p>
<p>于是绘制出实际均值控制图：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(means, <span class="string">'o-'</span>);</span><br><span class="line">xi=<span class="built_in">mean</span>(data, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:num_groups</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:samples_per_group</span><br><span class="line">        sum=sum+((data(<span class="built_in">i</span>,<span class="built_in">j</span>)-xi(<span class="built_in">i</span>))^<span class="number">2</span>);   </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    si_hat(<span class="built_in">i</span>)=<span class="built_in">sqrt</span>(sum/(num_groups<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">s_hat=<span class="built_in">mean</span>(si_hat);</span><br><span class="line">As=<span class="number">1.427</span>;</span><br><span class="line">CL= miu_hat;</span><br><span class="line">UCL=miu_hat+s_hat*As;</span><br><span class="line">LCL=miu_hat-s_hat*As;</span><br><span class="line">yline(CL, <span class="string">'r-'</span>, <span class="string">'CL'</span>);</span><br><span class="line">yline(UCL, <span class="string">'r--'</span>, <span class="string">'UCL'</span>);</span><br><span class="line">yline(LCL, <span class="string">'r--'</span>, <span class="string">'LCL'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/project1/3.png" alt="image"></p>
<h4 id="方差控制图"><a href="#方差控制图" class="headerlink" title="方差控制图"></a>方差控制图</h4><p>方差控制图的结构与均值控制图非常类似，也是由中心线以及上下控制限构成。只是图中的数据点描述的每批次数据的标准偏差，因此可用于定量判断不同批次数据的标准偏差(数据的波动性)在变化中是否存在”异常因素”。</p>
<p>类似于均值控制图，在实际操作中，常用如下公式估算其中心线以及上下控制限：</p>
<p>$$<br>UCL=B_U\bullet\ \hat{s}<br>$$</p>
<p>$$<br>CL=\hat{s}<br>$$</p>
<p>$$<br>LCL=B_L\bullet\hat{s}<br>$$</p>
<p>其中B_U、B_L为依赖于每批次样本数据数n的常数参数，查表[^2]可得：当每批次样本数据数n=5时，有B_U=2.089、B_L=0。</p>
<p>据此可绘制出对应的方差控制图：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bu=<span class="number">2.089</span>;</span><br><span class="line">Bl=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(variances, <span class="string">'o-'</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">UCL=(Bu*s_hat);</span><br><span class="line">CL=(s_hat);</span><br><span class="line">LCL=(Bl*s_hat);</span><br><span class="line">yline(CL, <span class="string">'r-'</span>, <span class="string">'CL'</span>);</span><br><span class="line">yline(UCL, <span class="string">'r--'</span>, <span class="string">'UCL'</span>);</span><br><span class="line">yline(LCL, <span class="string">'r--'</span>, <span class="string">'LCL'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/project1/4.png" alt="image"></p>
<h2 id="产品质量分析结论"><a href="#产品质量分析结论" class="headerlink" title="产品质量分析结论"></a>产品质量分析结论</h2><p>为根据Shewhart控制图判断产品生产过程是否受控，可对于均值控制图与方差控制图分别采用如下八条常见规则（规则均不能触碰，否则视为不受控），以识别产品生产过程是否仅受到随机因素影响：</p>
<ul>
<li><p><strong>规则 1</strong>:控制图上有一个点(对应某个批次数据)位于控制限以外；</p>
</li>
<li><p><strong>规则 2</strong>:连续9个点落在中心线同一侧；</p>
</li>
<li><p><strong>规则 3</strong>:连续6个点递增或者递减；</p>
</li>
<li><p><strong>规则 4</strong>:连续14个点交替上下；</p>
</li>
<li><p><strong>规则 5</strong>:连续3个点中有2个点落在中心线同侧的B区以外；</p>
</li>
<li><p><strong>规则 6</strong>:连续5个点中有4个点落在中心线同侧的C区以外；</p>
</li>
<li><p><strong>规则 7</strong>:连续15个点落在中心线两侧的C区；</p>
</li>
<li><p><strong>规则 8</strong>:连续8个点落在中心线两侧且无一点在C区以内。</p>
</li>
</ul>
<p>其中，A、B、C分区如下图^^[@2]^^所示，C区为以CL控制限为对称轴的中心区域，B、A两区向两侧延伸至上下控制限UCL与LCL。</p>
<p><img src="/images/project1/5.png" alt="image"></p>
<p>实际上，Matlab软件中对于Shewhart控制图以及SPC统计过程控制方法有一套完整封装的库函数controlchart()，调用结果如下所示：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load parts</span><br><span class="line">[st,plotdata] = controlchart(data,<span class="string">'charttype'</span>,{<span class="string">'xbar'</span> <span class="string">'s'</span>});</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/project1/6.png" alt="image"></p>
<p>其中第一张图为均值控制图，第二张图为标准差控制图。</p>
<p>通过观察图像，基于八大规则进行判断并通过查看返回对象plotdata的ooc属性（Logical that is true for points that are out of control）可知，<strong>该产品生产过程确实处于统计受控状态</strong>。除此之外，<strong>样本均值也在15.1mm左右，符合对于滚珠直径的一般行业要求，工艺水平良好；但实际工序能力指数Cpk仅有0.6896，说明工艺水平还有上升空间</strong>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[^1]: 茆诗松,程依明,濮晓龙编著. 概率论与数理统计教程[M]. 高等教育出版社, 2019.<br>[^2]: 贾新章 .. [等] 编著. 统计过程控制理论与实践[M]. 电子工业出版社, 2017.</p>
</div></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">1</a></li><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/page/2/">2</a></li><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/head2.png" alt="Jinghua Xu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jinghua Xu</p><p class="is-size-6 is-block">明月科创实验班人工智能专业 本科大三在读</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>重庆 重庆大学国家卓越工程师学院</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">32</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">91</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Asgard-Tim" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Asgard-Tim"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://www.weibo.com/u/6315188431"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/171895120"><i class="fab fa-bilibili"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:20224546@stu.cqu.edu.cn"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Phone" href="tel:+86 19132050174"><i class="fas fa-phone"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2025/04/23/project02/"><img src="/images/project2/1.png" alt="图像插值算法及其优化"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-22T18:07:03.000Z">2025-04-23</time></p><p class="title"><a href="/2025/04/23/project02/">图像插值算法及其优化</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">工程数值分析</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/04/18/3DVLA/"><img src="/images/3dvla/6.png" alt="3D-VLA： A 3DVision-Language-Action Generative World Model"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-18T11:00:03.000Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/3DVLA/">3D-VLA： A 3DVision-Language-Action Generative World Model</a></p><p class="categories"><a href="/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">具身智能论文阅读</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/04/10/project01/"><img src="/images/project01/17.png" alt="求矩阵特征值与特征向量：乘幂法及其改进算法"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-10T09:44:03.000Z">2025-04-10</time></p><p class="title"><a href="/2025/04/10/project01/">求矩阵特征值与特征向量：乘幂法及其改进算法</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">工程数值分析</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/04/07/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><img src="/images/phi.png" alt="第二章 数据结构"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-07T05:26:58.000Z">2025-04-07</time></p><p class="title"><a href="/2025/04/07/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">第二章 数据结构</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/">算法基础课</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/04/06/RT-1/"><img src="/images/rt1/1.png" alt="RT-1：Robotics Transformer for Real-world Control at Scale"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-06T09:24:03.000Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/RT-1/">RT-1：Robotics Transformer for Real-world Control at Scale</a></p><p class="categories"><a href="/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">具身智能论文阅读</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/About-XJH/"><span class="level-start"><span class="level-item">About XJH</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/About-XJH/%E6%98%8E%E6%85%B5/"><span class="level-start"><span class="level-item">明慵</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/About-XJH/%E6%98%8E%E8%AF%9A/"><span class="level-start"><span class="level-item">明诚</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">个人项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"><span class="level-start"><span class="level-item">具身智能论文阅读</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">动手学深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"><span class="level-start"><span class="level-item">算法基础课</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">课程项目</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">产品设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95I/"><span class="level-start"><span class="level-item">定量工程设计方法I</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95II/"><span class="level-start"><span class="level-item">定量工程设计方法II</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E6%95%88%E5%AD%A6/"><span class="level-start"><span class="level-item">工效学</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">工程原理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">工程数值分析</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">工程设计</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"><span class="level-start"><span class="level-item">数学物理方法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"><span class="level-start"><span class="level-item">智能图像处理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">机器人基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"><span class="level-start"><span class="level-item">概率论与数理统计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"><span class="level-start"><span class="level-item">线性代数</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">自动控制原理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">软件设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">七月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/3D-VLA/"><span class="tag">3D-VLA</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ADS1292/"><span class="tag">ADS1292</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Buck%E5%8F%98%E6%8D%A2%E5%99%A8/"><span class="tag">Buck变换器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C51/"><span class="tag">C51</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/COMSOL/"><span class="tag">COMSOL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ChatGPT/"><span class="tag">ChatGPT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FIR/"><span class="tag">FIR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FPGA/"><span class="tag">FPGA</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FreeRTOS/"><span class="tag">FreeRTOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IIR/"><span class="tag">IIR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Logistic%E5%9B%9E%E5%BD%92/"><span class="tag">Logistic回归</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MATLAB/"><span class="tag">MATLAB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Matlab/"><span class="tag">Matlab</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PID%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/"><span class="tag">PID闭环控制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QQbot/"><span class="tag">QQbot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RANSAC/"><span class="tag">RANSAC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ROS/"><span class="tag">ROS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Robotics-Transformer/"><span class="tag">Robotics Transformer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/R%E8%AF%AD%E8%A8%80/"><span class="tag">R语言</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STM32/"><span class="tag">STM32</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shewhart%E6%8E%A7%E5%88%B6%E5%9B%BE/"><span class="tag">Shewhart控制图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ubuntu/"><span class="tag">Ubuntu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Unity/"><span class="tag">Unity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VLA/"><span class="tag">VLA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XJH/"><span class="tag">XJH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B9%98%E5%B9%82%E6%B3%95/"><span class="tag">乘幂法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E7%B1%BB/"><span class="tag">二分类</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%A7%E5%93%81%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"><span class="tag">产品质量管理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"><span class="tag">人机交互</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BC%A0%E7%83%AD%E5%AD%A6/"><span class="tag">传热学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"><span class="tag">信号与系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"><span class="tag">假设检验</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"><span class="tag">傅里叶变换</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%89%E4%BC%8FMPPT/"><span class="tag">光伏MPPT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD/"><span class="tag">具身智能</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F/"><span class="tag">动力学仿真</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">动手学深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"><span class="tag">单片机</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"><span class="tag">卷积神经网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8C%E4%B8%89%E6%AC%A1%E6%8F%92%E5%80%BC/"><span class="tag">双三次插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/"><span class="tag">双线性插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"><span class="tag">可视化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%9B%E5%B9%B3%E9%9D%A2%E6%8F%92%E5%80%BC/"><span class="tag">四平面插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC/"><span class="tag">图像插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%83%8F%E6%94%BE%E5%A4%A7/"><span class="tag">图像放大</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC/"><span class="tag">图像旋转</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"><span class="tag">图像识别</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B/"><span class="tag">多模态大模型</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="tag">学习笔记</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90/"><span class="tag">定量分析</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E8%BD%A6/"><span class="tag">小车</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E7%A8%8B%E7%83%AD%E5%8A%9B%E5%AD%A6/"><span class="tag">工程热力学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%83%E7%94%B5%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86/"><span class="tag">心电信号采集</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%AB%E9%80%9F%E6%88%AA%E6%96%ADHuber%E6%8D%9F%E5%A4%B1/"><span class="tag">快速截断Huber损失</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%89%A9%E6%95%A3%E6%96%B9%E7%A8%8B/"><span class="tag">扩散方程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"><span class="tag">支持向量机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%91%E7%81%BE%E6%9C%BA%E5%99%A8%E4%BA%BA/"><span class="tag">救灾机器人</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%80%BC%E8%BF%AD%E4%BB%A3%E6%B1%82%E8%A7%A3/"><span class="tag">数值迭代求解</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"><span class="tag">数字信号处理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"><span class="tag">数据处理分析</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%91%E5%8A%A8%E6%9C%BA/"><span class="tag">斯特林发动机</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%BE%AA%E7%8E%AF/"><span class="tag">斯特林循环</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E8%BF%91%E9%82%BB%E6%8F%92%E5%80%BC/"><span class="tag">最近邻插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%89%E9%99%90%E5%85%83%E4%BB%BF%E7%9C%9F/"><span class="tag">有限元仿真</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%AC%E5%BE%81%E5%80%BC%E6%B1%82%E8%A7%A3/"><span class="tag">本征值求解</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/"><span class="tag">机械臂</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E6%A2%B0%E8%AE%BE%E8%AE%A1/"><span class="tag">机械设计</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9F%94%E6%80%A7%E5%A5%97%E7%B4%A2%E6%83%A9%E7%BD%9A/"><span class="tag">柔性套索惩罚</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BB%A4%E6%B3%A2%E5%99%A8/"><span class="tag">滤波器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%9F%E9%9B%BE%E6%89%A9%E6%95%A3/"><span class="tag">烟雾扩散</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/"><span class="tag">电机控制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A9%E9%98%B5%E7%89%B9%E5%BE%81%E5%80%BC/"><span class="tag">矩阵特征值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">算法与数据结构</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"><span class="tag">线性代数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%9F%E8%AE%A1%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6/"><span class="tag">统计过程控制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"><span class="tag">自动控制原理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%B0%83%E5%85%89/"><span class="tag">自动调光</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/"><span class="tag">自编码器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%88%B9/"><span class="tag">船</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"><span class="tag">计算机视觉</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/"><span class="tag">设计思维</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%9D%E7%A6%BB%E7%89%B9%E6%80%A7/"><span class="tag">距离特性</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="tag">路径规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/"><span class="tag">闭环控制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/"><span class="tag">频谱分析</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E6%96%AF%E6%A0%B8%E5%87%BD%E6%95%B0/"><span class="tag">高斯核函数</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/title1.png" alt="Homepage of Jinghua Xu" height="28"></a><p class="is-size-7"><span>© 2025 Tim</span>&nbsp;&nbsp;Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>&nbsp;&amp;&nbsp;<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© Copyright by Jinghua Xu</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Asgard-Tim"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer=""></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer=""></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer=""></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer=""></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer=""></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer=""></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer=""></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer=""></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/chitose.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script>
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = 'S-TA3IX28M1ZT7TILW';
        let tianliGPT_postSelector = '#postchat_postcontent';
        let tianliGPT_Title = '文章摘要';
        let tianliGPT_postURL = '/^https?://[^/]+/[0-9]{4}/[0-9]{2}/[0-9]{2}/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '1000';
        let tianliGPT_typingAnimate = true;
        let tianliGPT_theme = 'default';
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: true,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "PostChat",
          userDesc: "如果你对网站的内容有任何疑问，可以来问我哦～",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://ai.tianli0.top/static/img/PostChat.webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };
    </script>
    <script data-postchat_key="S-TA3IX28M1ZT7TILW" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>