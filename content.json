{"posts":[{"title":"个人简历","text":"教育背景 重庆大学 人工智能（明月班） 本科 2022-至今 成绩： 89.94 / 100 | GPA：3.79 / 4.00 排名：1 / 22 英语水平：CET-4：582 ; CET-6：503 数学课程：数理综合（100）、线性代数（95）、概率论与数理统计（94）、数学物理方法（95） 专业基础课程：软件设计（96）、智能图像处理（99）、定量工程设计方法（91）、工程设计(91)、自动控制原理（90）、工程原理（83）、机器人基础（82） 项目经历 车道线与道路边缘的检测与识别数据集标注（Labelme）与深度学习（Pytorch） 课题组项目 2024年3月–2024年6月 大部分路况在道路边缘并无车道线分隔，但道路边缘具有比一般车道线更高的危险度，目前还没有能够显著识别出道路边缘的车道线识别模型 编写Python脚本读取公开车道线数据集TuSimple并进行转换，同时利用Labelme工具进行补充标注，额外标注出道路边缘 利用Pytorch框架构建基于anchor的CLRnet模型，编写训练与测试代码 基于ZNCC方法的双目视觉点云构建算法优化C++算法实习 中科融合感知智能研究院 2024年7月–2024年8月 阅读相关文献，在OpenCV已有的SGBM方法基础上引入ZNCC（零均值归一化互相关）模板匹配算法，优化双目视觉的视差计算过程 完成双目视觉相机的标定与图像数据采集，并基于视差与相机标定数据生成点云 有效提升了生成点云的速度与精度，单组图片点云生成速度在15ms左右，平均距离误差小于1% 实时修音麦克风Python 学院创新创业项目 2024年11月–2025年1月 利用开源模型实现人声分离与BPM检测，并基于帧检测方法实时修正音调 采用AI大模型技术模拟真实人声，实现局部垫音伴唱，帮助用户提升唱歌体验 针对实际应用场景中的失真等问题进行优化迭代，并将功能实装至硬件产品 专业技能 编程语言: C++, Python（Pytorch/Tensorflow）, Matlab, R 其他技能: 机械建模（SolidWorks/Fusion 360）, 嵌入式开发（C51, STM32F1/F4, Arduino, FPGA）, 机器人操作系统（ROS）, 物理有限元仿真（COMSOL）,机械动力学仿真（Adams）, 移动应用开发（QT）, 网页开发（html/css）， Unity 兴趣爱好：声乐，羽毛球，摄影，音游 竞赛经历 第十五届中国大学生物理学术竞赛（CUPT）组长 校级一等奖 2023年9月–2023年12月 完成Pumping Straw和Droplet Microscope两个赛题 对问题进行物理建模与分析求解，使用COMSOL有限元分析工具对物理过程进行仿真，利用Matlab进行数值计算与物理过程动画演示 设计（制造）实验装置进行定量实验，验证理论分析结果 2024 美国大学生数学建模竞赛编程手 国际级成功参赛 2024年2月 选取E赛题：Sustainability of Property Insurance 建立数学模型帮助保险公司进行承保决策，针对若干小问综合EWM、TOPSIS、CVM、ARIMA、AHP等多种数学模型进行建模 从多篇论文与数据网站获取参考数据，基于Python与Matlab对数据进行处理、分析与建模，解读程序运行结果并给出结论与建议 荣誉奖项 国家奖学金 2024年 校级优秀学生综合奖学金（乙等两次，丙等两次） 2023、2024年 重庆市艺术教育活动先进个人 2024年 校级优秀学生、校级文化艺术先进个人 2023、2024年 第七届大学生艺术展演声乐项目集体合唱本科甲组, 国家级二等奖 2024年6月","link":"/2025/02/22/index/"},{"title":"基于自编码器和卷积网络的肺炎图像识别","text":"1 项目背景与研究意义1.1 项目背景肺炎作为一种常见的呼吸系统疾病，对人类健康构成了长期威胁，特别是随着COVID-19新冠肺炎疫情的全球爆发，其公共健康影响更为显著。COVID-19肺炎具有传播速度快、感染范围广、诊断难度大的特点，对全球医疗系统和社会经济产生了深远影响。特别是在疫情高峰期，医疗资源的短缺和诊断效率的瓶颈，进一步突显了快速、准确诊断工具的重要性。 传统肺炎诊断方法主要依赖医生对胸部X光片或CT图像的人工分析，既耗时又容易受到经验和疲劳的影响，尤其在COVID-19疫情期间，大量影像数据的涌现使得人工诊断难以满足需求。与此同时，COVID-19的影像表现与其他类型肺炎的重叠性增加了诊断的复杂性，这进一步加剧了对智能化诊断系统的需求。 随着人工智能技术的快速发展，深度学习为医疗影像分析带来了全新的解决方案。卷积神经网络（Convolutional Neural Network, CNN）凭借其强大的图像特征提取能力，在自动化诊断中展现了巨大潜力。同时，由于不同医疗机构的CT扫描设备性能差异显著，特别是在医疗资源较为匮乏的地区，CT影像常常受到设备老化、分辨率低或操作不规范等因素的影响，图像质量参差不齐，这不仅增加了诊断的复杂性，还对自动化系统的鲁棒性提出了更高要求；而自编码器（Autoencoder）作为一种有效的降噪工具，为医疗影像数据预处理提供了重要支持。通过自编码器的引入，可以有效消除图像中的噪声干扰，减少不同设备间的成像差异，为后续的分类和识别模型提供高质量的输入数据。因此，本项目提出结合自编码器和卷积神经网络的深度学习框架，开发一套针对肺炎（包括COVID-19）CT影像识别的智能诊断系统。 1.2 研究意义本项目以新型冠状病毒肺炎为切入点，面向未来医学智能化需求，开发的诊断系统不仅能够应对当下疫情挑战，还具有推广至其他医学影像诊断场景的潜力，从而为全球公共健康事业的发展提供有力支持。 面向新冠肺炎疫情期间大规模肺部影像数据的快速诊断需求，本系统依托深度学习技术，有效提升了诊断效率，为疫情防控和患者管理提供重要的技术支持。通过先进的模型算法，系统能够精准识别肺部CT影像中的病变特征，减少人为误差，确保诊断结果的准确性和一致性，大幅降低不同医疗机构和医生之间的诊断差异，避免误诊和漏诊风险，从而更好地保障患者安全。 针对基层医院或偏远地区医疗资源匮乏的现状，本系统可作为一种可靠的辅助诊断工具，为医生提供科学的决策支持，帮助缓解诊断能力不足带来的压力。其高效的处理能力不仅提高了基层医疗服务水平，也为疫情防控的全面推进提供了技术保障，为应对紧急医疗需求的地区解决实际困难。 此外，本系统在高效处理和分析海量肺部CT影像数据的基础上，还为研究新冠肺炎的病理特征及流行规律提供了宝贵的数据支持。这些分析结果可进一步应用于疫情传播趋势预测和公共卫生政策制定，为疫情防控策略的科学性和有效性奠定了坚实基础。 同时，本系统也为患者病情的动态管理提供了重要帮助。通过智能分析新冠肺炎影像特征的变化趋势，系统能够为临床医生提供精确的病情评估建议，有助于及时调整治疗方案。这种基于影像数据的技术支持，不仅提高了患者管理的科学性和有效性，还为医疗资源的合理分配提供了重要依据，进一步推动了疫情防控工作的高效开展。 2 数据集获取与预处理2.1 数据集介绍本项目使用的肺部X-光片数据集从Kaggle网站（链接：https://www.kaggle.com/datasets/alsaniipe/chest-x-ray-image）获取，共分为三类标签：新冠肺炎COVID19、正常NORMAL和普通肺炎PNEUMONIA，该数据集已经事先划分好了训练集与测试集。此外，为测试模型对于不同质量CT影像的识别精度，还对测试集中的部分图像使用高斯噪声进行扰动，以模拟实际CT扫描的成像质量差异。 数据分布如下表所示： 表2.1：数据集数据分布情况 COVID19 NORMAL PNEUMONIA Train 460 1266 3418 Test 116 317 855 Noisy_Test 26 20 20 2.2 编程环境搭建本项目中所有的代码编写与运行均是在配备NVIDIA GeForce RTX 3060显卡、16GB运行内存、12th Gen Inter(R) Core(TM) i7-12700@2.10GHz处理器与Microsoft Windows 11操作系统的工作站上使用Python编程语言完成的。 软件环境方面，采用Conda进行环境管理，在控制台中通过命令”conda create -n covid python=3.12”创建虚拟环境，并在激活环境后使用pip install命令依次安装所需的各种依赖库；全部安装并测试完成后，通过命令”pip freeze &gt;requirements.txt”将虚拟环境中安装的所有依赖库及对应版本写入文件requirements.txt，后续移植时可在新的运行环境中运行命令”pip install -r requirements.txt”完成环境的一键配置。 值得注意的是，在PyTorch（包括torch、torchvision与torchaudio库）安装时需要根据自己电脑使用的CUDA版本（使用CPU则直接在命令行中使用pip install安装即可）在PyTorch官网中找到对应的安装命令进行安装。我使用的CUDA版本为12.6，安装命令的选取如下图所示： 下面对于项目中使用到的主要依赖库进行简要介绍： 其中，plt用于绘图，nn中包含了用于构建神经网络的隐藏层（全连接层、卷积层等），F中包含了各种激活函数（ReLu、Sigmoid等），DataLoader用于在训练时加载数据，datasets和transforms用于读取和处理数据集，tqdm用于进度条可视化，torchmetrics用于模型精度的测试，torchviz和torchsummary用于以图形与文字的方式描述模型架构概况。 2.3 图像数据读取torch对于一些常用的数据集做了封装，可以直接调用，例如datasets.MNIST()。但此处我们使用的是本地的图片数据，可以使用ImageFolder将一个文件夹下的图片读取成数据集并完成数据增强工作。在读取完数据集后，还需要定义DataLoader用于加载数据为可分批次（batch）读取的迭代器以供后续使用。为使得代码更加简洁，将上述的数据读取与加载过程为封装在getDataLoader函数中，并在主函数中通过指定不同的目录加载训练集、测试集或是含噪声测试集。 可以看到，其中构建了数据增强器transform，在读取数据时进行相应处理： Grayscale: 指以灰度图的形式读取。 Resize: 由于图像尺寸各不相同，在训练前需将它们重塑成相同尺寸256*256。 ToTensor: 将图片格式转换成张量形式，torch的计算以张量的形式进行。 除此之外，在构建数据加载器时需要指定一个批次（batch）中的图片数据数量batch_size，在模型训练时训练批次大小TRAIN_BATCH_SIZE也是会影响最终模型性能的重要超参数之一。在训练过程中，设定TRAIN_BATCH_SIZE为32，而在测试过程中，为提高测试效率，将TEST_BATCH_SIZE设置为66并对函数进行对应修改。 2.4 叠加噪声函数不论是构建噪声测试集，还是在利用无噪声的训练集进行训练时，都需要手动添加噪声，故编写add_noise函数，默认的噪声强度为0.5，并在添加噪声后进行归一化以确保图像值位于[0,1]范围内。 3 模型构建与网络训练3.1 整体模型框架整体模型框架由两个核心部分组成，分别是用于去噪的数据预处理模块和负责分类的卷积神经网络（CNN）。去噪模块采用自编码器（Autoencoder）的架构，专注于从输入数据中去除噪声，以提升后续分类的准确性；分类模块基于卷积神经网络，其强大的特征提取和模式识别能力使其成为分类任务的理想选择。 两个模块相辅相成，通过有效的数据处理和特征提取，确保模型能够在噪声干扰较大的环境中实现高精度分类。噪声数据首先经过自编码器处理，生成质量优化的特征表示，然后被CNN接收并完成分类任务。这一整体框架设计非常适合肺炎图像识别任务，通过结合去噪和分类两大模块的优势，模型不仅能够有效提高数据质量，还能充分挖掘数据中的有用特征，从而能够在复杂的医学影像处理中表现出卓越的鲁棒性和准确性，满足肺炎诊断的实际需求。 3.2 自编码器自编码器模型用于处理输入数据中的噪声问题，提升后续分类的准确性。其核心思想是通过编码器将输入数据压缩至低维潜在表示（latent representation），再由解码器将其还原至去噪后的重构数据，从而实现降噪效果。 3.2.1 网络结构设计 自编码器网络结构由编码器encoder与解码器decoder组成： 编码器由两层卷积（Conv2d）和两次池化（MaxPool2d）操作组成，用于提取特征； 解码器通过两次反卷积（ConvTranspose2d）和两次上采样（UpsamplingNearest2d）逐步恢复图像尺寸到原始大小； 最后使用Sigmoid激活函数将输出值限制在[0,1]区间。 模型定义代码如下： 模型继承自nn.Module类，在__init__()函数中定义模型的结构，在forward()函数中定义模型的前向传播过程。 通过调用torchviz和torchsummary库，可以输出该模型结构的基本信息： 3.2.2 模型训练基本的训练流程集成在函数train_autoencoder_process中，如下图所示： 其中指定优化器optimizer为Adam，损失函数为均方误差MSE，并使用超参数：训练轮数Epochs=50、学习率lr=0.001。每轮（Epoch）训练中均需要以多个batch的形式遍历训练集中的所有数据，并在每个batch后对模型进行更新，具体而言每次更新均需执行如下操作： 从加载器中获取输入数据 使用add_noise函数对干净图像加噪 将加噪后图像输入自编码器模型并计算模型输出 根据模型输出和标签计算损失Loss 清空梯度 反向传播 更新模型 值得注意的是，由于用于训练的图像数据没有噪声，因此训练时首先需要对输入的图像进行加噪处理，再输入自编码器模型进行训练。 训练过程中还利用tqdm进度条函数对训练进程进行可视化，并在每轮训练完成后打印出当轮训练过程中模型的平均损失： 在训练过程中，将每轮训练的平均损失存储在列表中，并在训练结束后将平均损失的变化过程以图像形式呈现： 可以看到，经过多轮训练，模型的损失函数值在不断减小且逐渐趋近于0，这意味着该自编码器的模型训练过程是收敛的，模型具有较稳定的工作性能。 3.3 卷积神经网络卷积神经网络负责从图像中提取多层次的空间特征，通过逐步减少图像尺寸和增加特征通道来捕捉关键信息，从而实现去噪后肺部CT图像的分类功能。CNN以其强大的特征提取能力，能够有效处理图像的局部依赖性和空间不变性，高效处理结构化数据（如图像、时序数据）。模型简单且高效，具有较强的泛化能力，适合处理小规模数据集的图像分类问题。 3.3.1 网络结构设计 卷积神经网络结构（如上图，通过NN-SVG工具绘制）由两层卷积层（Conv2d）和池化层（MaxPool2d）组成，激活函数均选用ReLU，逐步提取特征并将输入图像的尺寸从原始大小减小到64×64。卷积后的特征图展平后通过三个全连接层（Linear），分别将特征维度从32×64×64降至128，再降至32，最后输出3个类别（Covid19、Normal、Pneumonia）的预测结果。 模型定义代码如下： 模型继承自nn.Module类，在__init__()函数中定义模型的结构，在forward()函数中定义模型的前向传播过程。 通过调用torchviz和torchsummary库，可以输出该模型结构的基本信息： 3.3.2 模型训练基本的训练流程集成在函数train_cnn_process中，如下图所示： 其中指定优化器optimizer为Adam，损失函数为交叉熵损失CrossEntropy，并使用超参数：训练轮数Epochs=50、学习率lr=0.001。每轮（Epoch）训练中均需要以多个batch的形式遍历训练集中的所有数据，并在每个batch后对模型进行更新，具体而言每次更新均需执行如下操作： 从加载器中获取输入数据 使用add_noise函数对干净图像加噪 将加噪后图像输入训练好的自编码器模型trained_autoencoder_model 将经过自编码器去噪后的图像输入CNN模型并计算模型输出 根据模型输出和标签计算损失Loss 清空梯度 反向传播 更新模型 值得注意的是，由于用于训练的图像数据没有噪声，为与实际的输入情况一致，首先需要对输入的图像进行加噪处理，再利用训练好的自编码器模型进行降噪（为了不在更新CNN的同时更新自编码器，这一步不需要产生梯度），才能输入CNN分类模型进行训练。 训练过程中还利用tqdm进度条函数对训练进程进行可视化，并在每轮训练完成后打印出当轮训练过程中模型的平均损失与在训练集上的测试精度： 在训练过程中，将每轮训练的平均损失与模型在训练集上的测试精度存储在列表中，并在训练结束后将两者的变化过程以图像形式呈现： 可以看到，经过多轮训练，模型的损失函数值在不断减小且逐渐趋近于0，这意味着该自编码器的模型训练过程是收敛的，模型具有较稳定的工作性能；同时随着训练轮数增加，模型在训练集上的精度也逐渐增高（波动上升），在模型训练完成时，卷积神经网络在训练集上的分类精度已经可以达到99.59%（一度达到99.90%），接近百分之百，说明模型的分类能力较好。 4 模型测试及应用4.1 自编码器降噪效果在自编码器模型的训练过程中，每隔10轮对模型参数进行了一次存档；在测试过程中，分别使用训练轮数为10、20、30、40、50的自编码器模型对于加噪后的模型进行降噪处理，效果如下图所示： 通过对比不同训练轮数的自编码器模型降噪效果可以发现，随着训练轮数的增加，自编码器模型的降噪效果在逐渐提升，但在Epoch到达30之后，训练带来的降噪效果提升就不如先前显著了。尽管由于较大的噪声强度（0.5）导致降噪后的图像仍然比较模糊，但通过肉眼还是能粗略观察处肺部骨骼的轮廓等特征，后续实验也证明了卷积神经网络确实可以从这样清晰度的图像中提取相应的特征来进行分类，该自编码器模型的设计有效。 4.2 卷积神经网络分类精度在卷积神经网络的分类精度上，训练过程中已经实时对于每一轮训练后的模型在训练集上进行了精度测试（3.2.2节中已有提及），而在测试集上，可以编写与训练过程类似的代码利用torchmetrics库对模型分类精度进行测试，只是不会更新模型，代码如下： 可以看到，由于我们的测试集分为含噪声和不含噪声两类，因此编写了不同的函数对模型分类精度进行测试。两个函数的主要差别就在于，由于含噪声测试集是已经加噪的图片（噪声与手动通过add_noise函数添加的不同），因此在含噪声测试集的测试代码中不必再次手动添加噪声，而是直接将图像输入自编码器降噪后再输入CNN分类模型中进行分类；而对于不含噪声的测试集而言，为模拟与训练集同样的处理流程，会先进行手动加噪再通过自编码器降噪之后才输入CNN分类模型中进行分类。 运行测试代码后，得到模型在含噪测试集上的分类精度为96.97%，在不含噪声的测试集上的分类精度为94.57%，在两个测试集上的分类精度水平均较高，说明该模型具有良好的分类效果。 4.3 模型应用：基于CT影像的肺炎诊断Web服务通过对比多组超参数的模型降噪与分类效果，最终选定如下的超参数： 训练轮数Epochs=50； 学习率LR=0.001； 训练批次大小Train_Batch_Size=32。 选定参数后，将整体代码抽离为model.py（包含模型定义类代码），run.py（服务端代码）和train.py（训练函数），并将模型部署到实际应用中，使用Flask作为服务端，以Web形式用户提供操作接口以上传图片进行诊断。由于主要功能是提供接口，故网页只做了很简易的一个index.html，给用户提供上传图片的按钮，并在用户上传有噪声的CT影像后返回诊断结果及去噪后的图像。除此之外，还将挂载在本地端口上的Web通过内网穿透映射到公网，以供实时访问。 网页初始界面如下图所示： 接下来分别测试当输入COVID19、NORMAL和PNEUMONIA三个组别的图片，模型能否正确判断： 可以发现，模型在大多数情况下可以正确识别图像来源，但也会出现错误识别的情况，这和Test 集上的Accuracy相符合；此外，在测试时还注意到，模型识别结果偶尔会出现不稳定的现象，即输入同一张图像有时识别为某一类别，有时又会识别为另一类别，这是由模型内部部分随机参数导致的，这也反映了模型在一些模棱两可的情况下（两类别概率接近）做出判断时的不稳定性。在实际应用中，为尽可能减少误诊对于患者带来的各方面影响，还需要采取更多优化措施提升模型性能，并对模型在模棱两可的情况下做出的判断进行合理的限制。 5 总结与展望本项目全部代码（不包含数据集）已上传至Github仓库，仓库URL地址：https://github.com/Asgard-Tim/Pneumonia-Image-Recognition 5.1 项目总结本项目基于深度学习技术，结合自编码器和卷积神经网络，开发了一套智能诊断系统，用于快速、高效地识别肺部的CT影像并判断该患者是否患有肺炎（包括COVID-19）。自编码器模块有效去除了噪声，提升了图像质量，而卷积神经网络以其强大的特征提取能力，实现了高精度的分类。本项目在数据预处理、模型设计、网络训练及测试等环节中均采用了创新性的技术方案，最终实现了在含噪声测试集上96.97%和在无噪声测试集上94.57%的分类精度，表现出了较高的鲁棒性和实用价值。同时，系统已通过Flask框架部署为Web服务，能够实时接收CT影像并给出诊断结果，为疫情期间大规模影像数据的快速诊断及基层医疗资源匮乏地区的医疗支持提供了重要的技术保障。 5.2 课程收获与反思本次选修《智能图像处理》这门课程确实让我学到了很多东西，其实自己之前也自己看过一些机器学习方面的内容，有一定的知识基础与环境搭建经验，但由于各方面原因总是没有系统性的去学习计算机视觉的相关知识，也缺乏足够的实战代码与项目经验。通过这门课程的学习，很大程度上锻炼了我Python的代码能力，也在Coding的过程中不断熟悉OpenCV、Pytorch等库的使用，更在实践的过程中不断加深对于各种算法模型（AlexNet、ResNet、YOLO等）的理解。 本次项目让我完整地经历了从数据集获取、论文调研及算法代码实现，再到代码调试与模型训练测试，最终将模型应用到实际系统中的全过程，在项目实现的过程中收获了很多课程教学与实验中涉及不到的东西，包括数据集的收集、模型的选择以及作为一个完整项目的代码实现等等多个方面，这也是我第一次使用GPU资源去进行。虽然由于时间等条件的限制，在模型选择上并没有进行深入的调研与充分的对比试验，只是基于自己已知的一些知识对于架构较为简单的自编码器模型与卷积神经网络进行了复现与设计，最终模型的分类精度还有一定的提升空间，但是这也为我后续的自主学习打下了一个良好的基础，希望未来我能在计算机视觉方面有更加深入的学习与探索，也感谢老师的耐心指导与悉心教学。 参考文献[1] Nosa-Omoruyi M, Oghenekaro L U. AutoEncoder Convolutional Neural Network for Pneumonia Detection[J]. arXiv preprint arXiv:2409.02142, 2024. [2] Ratiphaphongthon W, Panup W, Wangkeeree R. An improved technique for pneumonia infected patients image recognition based on combination algorithm of smooth generalized pinball SVM and variational autoencoders[J]. IEEE Access, 2022, 10: 107431-107445. [3] Gayathri J L, Abraham B, Sujarani M S, et al. A computer-aided diagnosis system for the classification of COVID-19 and non-COVID-19 pneumonia on chest X-ray images by integrating CNN with sparse autoencoder and feed forward neural network[J]. Computers in biology and medicine, 2022, 141: 105134. [4] García-Ordás M T, Benítez-Andrades J A, García-Rodríguez I, et al. Detecting respiratory pathologies using convolutional neural networks and variational autoencoders for unbalancing data[J]. Sensors, 2020,20(4): 1214. [5] Xia Y. Enhanced Pneumonia Detection in Chest X-Rays Based on Integrated Denoising Autoencoders and Convolutional Neural Networks[J]. [6] El-Shafai W, El-Nabi S A, El-Rabaie E S M, et al. Efficient Deep-Learning-Based Autoencoder Denoising Approach for Medical Image Diagnosis[J]. Computers, Materials &amp; Continua, 2022, 70(3). [7] Rana N, Marwaha H. Auto encoder-guided Feature Extraction for Pneumonia Identification from Chest X-ray Images[C]//E3S Web of Conferences. EDP Sciences, 2024, 556: 01011. [8] Ankayarkanni B, Sangeetha P. An Autoencoder-BiLSTM framework for classifying multiple types of lung diseases from CXR images[J]. Multimedia Tools and Applications, 2024: 1-30. [9] 孙敬,丁嘉伟,冯光辉.一种基于自编码器降维的神经卷积网络入侵检测模型[J/OL].电信科学,1-7[2025-01-05]. [10] 张淙越,杨晓玲.基于卷积神经网络的新冠肺炎CT图像识别系统[J].电脑与信息技术,2022,30(03):12-14+40.","link":"/2025/01/05/graph/"},{"title":"基于STM32F407实现的信号发生与采集分析系统","text":"演示视频已上传至Bilibili视频平台：https://www.bilibili.com/video/BV1wUiRYxE8z 一、系统功能与整体架构设计系统实现功能（1）单片机在按键控制下，产生1kHz的正弦波或方波； （2）单片机能够采集波形，并且显示； （3）单片机能够分析采集波形的频谱，并且显示频谱与基波频率。 整体架构设计图 系统主页与按键对应功能简介 每次启动系统都会默认直接进入该主页面： （1）蓝色部分的文字为系统名称与作者姓名，这会在后续的每个功能页面中都有显示； （2）黑色部分的文字为各按键对应的功能介绍。 正如主页的功能介绍栏所示： （1）按下KEY0：PA4引脚开始持续输出1kHz的正弦波信号，并在屏幕上实时显示从PA5引脚采集到的输入信号波形； （2）按下KEY1：PA4引脚开始持续输出1kHz的方波信号，并在屏幕上实时显示从PA5引脚采集到的输入信号波形； （3）按下KEY2：在屏幕上实时显示从PA5引脚采集到的输入信号的频谱分析结果（幅值谱，频率范围为0~1000Hz）； （3）按下KEY3（KEY_UP）：在屏幕上实时显示从PA5引脚采集到的输入信号的频谱分析结果（幅值谱，频率范围为0~8000Hz）。 二、各部分功能实现1、1kHz正弦波与方波的产生模块功能架构设计 在实际单片机编程实现时，导入并调用DSP库加速信号数组（正弦波）的计算，并通过时钟TIM6（分频）控制DMA的数据搬运过程，并设置DAC数模转换将搬运后的信号数字数据在PA4引脚以模拟信号形式输出。 模块功能实现依据为使用单片机产生指定频率的波形，需要根据上述架构设置对应的参数，基本的设置逻辑如下： （1）首先，这里使用定时器TIM6来控制DMA搬移数据的过程，在CubeMX中已预先设置其时钟频率为84MHz； （2）在生成信号数组时，C语言程序中设定数组长度为1024（与后续采集一致，为4的整数次幂以便于进行快速傅里叶变换FFT）； （3）事实上，对于信号数组长度N、定时器频率fT与信号基波频率f而言存在如下关系式：f = fT / N，这意味着以输出基波频率f = 1kH的信号为例，经过时钟分频后的定时器频率fT是可以直接确定的，进而可以确定分频倍数（时钟频率/分频后定时器频率）。 经过计算，当分频倍数设置为82时（实际单片机控制程序中为两次分频，取第一次分频倍数为41、第二次分频倍数为2即二分频），输出的信号基波频率f约为1000（由于数组长度为1024，在分频倍数必须取整的情况下，基波频率无法精准等于1000Hz，实际约为1000.38Hz）。 在MATLAB中，可以编写简单的测试程序模拟这一过程： 12345678TIM6_Frequency = 84000000; %DAC_DMA时钟TIM6频率DAC_DMA_Divide1 = 41; %DAC_DMA时钟一次分频DAC_DMA_Divide2 = 2; %DAC_DMA时钟二次分频DAC_DMA_Frequency = TIM6_Frequency / (DAC_DMA_Divide1 * DAC_DMA_Divide2); %分频后时钟频率N = 1024; %数组长度与采样点数f = DAC_DMA_Frequency / N; %产生信号频率（期望值1000） 模块功能实现效果启动系统后按压按键KEY_0启动正弦波生成，将示波器的通道正极与信号输出引脚PA4连接，示波器的通道负极与单片机的地GND连接，可在示波器上显示出如下波形： 可以看到输出的波形形状为标准的正弦波，输出电平范围为03.3V（对应生成的正弦信号数组振幅为2048、偏置为2047即数据点范围位于04095），均值为1.6V，且周期约为1kHz（示波器显示1.00045kHz；一个周期大致占据五格、每格代表200us即一个周期为1ms）。 按压按键KEY_1切换为生成方波，可在示波器上显示出如下波形： 可以看到输出的波形形状为标准的方波（占空比50%），输出低电平为0V、高电平为3.3V（对应生成的方波信号数组前一半值为0、后一半值为4095），均值为1.6V，且周期约为1kHz（示波器显示1.00043kHz；一个周期大致占据五格、每格代表200us即一个周期为1ms）。 2、波形信号的采集与显示模块功能架构设计 在实际单片机编程实现时，通过定时器控制从PA5引脚读入模拟信号，通过ADC模数转换为数字数组并通过DMA搬运将其存入长度为1024（为4的整数次幂以便于进行快速傅里叶变换FFT）的数组中，存满一次数组即中断一次DMA搬运并将该数组数据（即采集波形）显示在显示屏上，短暂延迟（控制屏幕刷新速度合适）后进行新一轮的信号采集、搬运与波形显示。 模块功能实现依据为使用单片机采集信号数据并以合适的形式将波形显示在显示屏上，需要根据上述架构设置对应的参数，基本的设置逻辑如下： （1）首先，控制ADC1的定时器在CubeMX中已预先设置其时钟频率为84MHz，但根据相关手册与文档，硬件上对于分频后的ADC实际频率有限制，不能高于30MHz，在这样的条件下一般取四分频（仅分频一次，以对应结构体参数hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4实现），即分频后定时器频率为21MHz； （2）其次，根据相关手册与文档，完成一次采样至少会花费12个时钟周期，为调控实际采样频率通常还可以设置额外的时钟周期（库函数限制只能为特定的几个值），即实际的采样频率Fs应为：分频后定时器频率（21MHz）/一次采样花费的时钟周期数（12+额外设置的时钟周期）； （3）事实上，要想控制屏幕上显示的波形不过于松散/密集，需要控制一次采样（填满数组，DMA中断）内包含的信号周期数量，这可以通过将信号产生的定时器频率fT除以采样频率Fs得到； （4）另一方面还需要注意为使得采集到的波形没有失真（频域混叠）现象，要求采样频率Fs与待采集波形频率f满足：Fs≥2f。 经过计算与测试，当额外设置的时钟周期设置为112时（sConfig.SamplingTime = ADC_SAMPLETIME_112CYCLES），一次采样中包含（屏幕上显示）的信号周期约为6，这样的显示效果较为合理；同时此时的采样频率Fs约为42683Hz，远大于待采集波形频率f = 1000Hz的两倍，不会发生频谱混叠。 在MATLAB中，可以编写简单的测试程序模拟这一过程（以正弦信号为例）： 123456789101112131415161718192021222324ADC_Timer_Frequency = 84000000; %ADC时钟频率%硬件限制：要求ADC实际时钟频率不能超过30MHzADC_Divide = 4; %取四分频，分完后达到21MHz满足要求ADC_Frequency = ADC_Timer_Frequency / ADC_Divide; %分频后ADC时钟频率%完成一次采样需要多个时钟周期Collect1 = 12; %固定消耗12次循环，无法更改Collect2 = 112; %可设置额外消耗循环数以调整采样频率Fs = ADC_Frequency / (Collect1 + Collect2); %ADC采样频率Cycle = DAC_DMA_Frequency / Fs; %一次采样采出多少个周期A = 2047; %幅值B = 2048; %直流偏置分量t = 0 : 1 / Fs : (N - 1) / Fs;x = A * sin(2 * pi * f * t) + B;% 绘制原始信号figure;subplot(2,1,1);plot(t, x);title('正弦波信号');xlabel('时间 (秒)');ylabel('幅值'); 运行该MATLAB程序，绘制出一次采样采集到的波形如下图所示： 模块功能实现效果启动系统后按压按键KEY_0启动正弦波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，屏幕上显示采集波形效果如下： 按压按键KEY_1切换为生成方波信号并采集，屏幕上显示采集波形效果如下： 图上的横坐标单位为ms；可以看到屏幕上显示的即为6个周期的信号波形，这与MATLAB的模拟计算结果是完全一致的，且波形无失真。 3、采集波形信号的频谱分析模块功能实现依据在频谱分析与频谱图显示方面，有如下要点需要注意： （1）首先，频谱分析依赖于对于信号的傅里叶变换，在数字信号层面对于离散的数据点则需要采用离散傅里叶变换，但这样的变换计算速度往往很感人，因此需要利用其快速算法，即快速傅里叶变换FFT，MATLAB可直接调用fft函数实现，单片机编程中在DSP库中也有相应的函数可以实现完全相同的过程，但要求信号数组的长度应为4的整数次幂，故先前均选取1024作为发生与采集信号的数组长度； （2）其次，经过FFT变换后会得到一个长度相同（1024）的新数组，其中每一个数字的下标index对应的实际频率应为index*Fs/1024，这意味着如果直接将整个FFT变换结果数组作为频谱图显示到屏幕上，横坐标的跨度实际上为Fs≈42683Hz，为使得频谱图更加直观，需要限制绘制频谱图的频率范围，并对应控制绘制数组中的部分数据； （3）事实上，FFT变换结果的数组中各数值并不是期望的对应频率的幅值，还需要除以数组长度1024（单片机程序中对于起始点只需要除以一半的数组长度即512）才可得到正确的幅值。 由于涉及到信号的基波频率检测以及方波的频谱分析，在KEY_2和KEY_UP按键分别设置了频谱频率范围为01000Hz与08000Hz两种模式。在MATLAB中，可以编写简单的测试程序模拟频谱分析过程并在0~8000Hz的频段上展示频谱： 123456789f_range = linspace(0, Fs, N);%频域横坐标，注意奈奎斯特采样定理，最大原信号最大频率不超过采样频率的一半xk = fft(x) / N; %用fft得出离散傅里叶变换% 计算并绘制频谱subplot(2,1,2);plot(f_range(1:50),abs(xk(1:50)));%画双侧频谱幅度图title('正弦波频谱');xlabel('频率 (Hz)');ylabel('幅度'); 运行该MATLAB程序，绘制出一次采样采集到的波形如下图所示（以正弦信号为例）： 可以看到该信号具有直流分量（频率为0）以及1000Hz除的正弦分量，两者幅值均为2048（与产生波形时的一致）。 除此之外，在单片机编程中，为寻找并在屏幕上打印出信号的基波频率，还需要在显示频率波形的同时完成对于除直流分量外最高幅值对应频率的计算（数组返回最大值对应下表，算法较简单在此省略实现过程）。 模块功能实现效果启动系统后按压按键KEY_0启动1000Hz正弦波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，并按压按键KEY_2可启动短频段0~1000Hz的频谱显示如下： 按压按键KEY_UP可启动长频段0~8000Hz的频谱显示如下： 可以看到此时只有直流分量和1000Hz的正弦分量两个尖峰，与MATLAB模拟计算结果一致。 按压按键KEY_1，切换为1000Hz方波波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，并按压按键KEY_2可启动短频段0~1000Hz的频谱显示如下： 按压按键KEY_UP可启动长频段0~8000Hz的频谱显示如下： 可以看到此时在01000Hz频段只有直流分量和1000Hz的正弦分量两个尖峰，但在08000Hz频段，由于方波实质上是不同频率的正弦信号的叠加，所以频谱会在基波的奇数倍（1、3、5……）处也有尖峰，但尖峰的幅值会远小于基波1000Hz处，且倍数越大幅值越小，这使得按照先前的算法也能识别出基波频率约为1000Hz。 4、补充测试由于还需要对于基波频率在0~1000Hz范围内的任意输入信号进行频谱分析，经过调试后，当输入信号频率为200Hz时，为使得显示波形合理，将ADC环节设置的额外时钟周期由112调整至480，结果如下所示： 200Hz正弦波： 时域： 频域： 短频段（0~1000Hz）： 长频段（0~8000Hz）： 200Hz方波： 时域： 频域： 短频段（0~1000Hz）： 长频段（0~8000Hz）： 在ADC环节额外时钟周期设置为480的情况下，可以计算得出，对于频率为1000Hz的信号，一次采样（即屏幕内显示）包含21个周期（正好为整数），结果如下所示： 1000Hz正弦波： 时域： 频域： 长频段（0~8000Hz）： 1000Hz方波： 时域： 频域： 长频段（0~8000Hz）： 可以看到此时虽然时域上波形显示更加狭窄密集，但是频域上尖峰的变化过程也有了迅速的提升，且测得的基波频率也更加精准。 三、总结通过本次项目实践，不仅在实验中进一步加深了对于数字信号的产生、采集与频谱分析处理过程的理解，特别是通过期望发生信号频率去计算定时器分频系数、采样频率的计算过程以及FFT计算与频谱图像绘制的过程；而且也增加了对于STM32F407单片机开发的实战经验，在巩固了引脚GPIO与时钟配置相关内容的同时，又对于DMA内存搬运及其中断以及DAC数模转换输出与ADC模数转换输入等功能模块有了更深刻的认识，包括定时器对于这些过程的调控也涉及到相关频率的计算，所有模块的配置之间都有着密切的联系。","link":"/2024/12/05/document/"},{"title":"QQ聊天记录分析 QQMsgAnalysis","text":"从PC端QQ中以txt格式导出聊天记录，存为message.txt。 需要安装的库: numpy, seaborn, pandas, wordcloud, tdqm, paddlepaddle, paddlenlp 准备阶段引入包 pandas: 基础数据框架 matplotlib &amp; seaborn: 主要绘图框架 jieba: 中文分词 wordcloud: 词云 paddlenlp: 情感分析 123456789101112131415161718import reimport timeimport numpy as npimport pandas as pdimport jiebaimport jieba.posseg as psegfrom PIL import Imagefrom wordcloud import WordCloudimport seaborn as snsimport matplotlib.ticker as mtickerimport matplotlib.transforms as mtransformsfrom matplotlib.colors import ListedColormapfrom matplotlib import pyplot as pltimport matplotlib.pyplot as pltfrom matplotlib import font_manager as fmfrom tqdm import tqdmfrom paddlenlp import Taskflow%matplotlib inline 数据预处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import csvfrom datetime import datetimedef convert_messages(input_file, output_file): # 定义CSV文件头部 header = [&quot;LocalId&quot;, &quot;TalkerId&quot;, &quot;Type&quot;, &quot;SubType&quot;, &quot;IsSender&quot;, &quot;CreateTime&quot;, &quot;Status&quot;, &quot;StrContent&quot;, &quot;StrTime&quot;, &quot;Remark&quot;, &quot;NickName&quot;, &quot;Sender&quot;] # 打开输入和输出文件 with open(output_file, 'w', newline='', encoding='utf-8') as outfile: csv_writer = csv.writer(outfile) csv_writer.writerow(header) # 写入头部 # 用集合存储姓名 names = set() # 逐行读取txt文件内容并转换为csv格式 with open(input_file, 'r', encoding='utf-8') as file: lines = file.readlines() for i in range(0, len(lines), 3): timestamp_and_name = lines[i].strip().split(' ', 2) date_time = timestamp_and_name[0] + ' ' + timestamp_and_name[1] # 日期时间 name = timestamp_and_name[2] # 姓名（或用户名） # 根据姓名判断是否在指定范围内，如果不在，则跳过该条消息 if name not in [&quot;王婧怡(清辉)&quot;, &quot;成王败寇。&quot;, &quot;皇后&quot;, &quot;王婧怡&quot;, &quot;世界之巅&quot;, &quot;2558749399&quot;]: continue message = lines[i + 1].strip() # 消息内容 # 如果消息内容为空，则跳过该条消息 if not message: continue # 根据消息内容设置Type字段的值 if &quot;[图片]&quot; in message: type_value = 3 elif &quot;[表情]&quot; in message: type_value = 47 else: type_value = 1 # 默认为1 # 根据姓名设置IsSender字段的值 if name in [&quot;王婧怡(清辉)&quot;, &quot;成王败寇。&quot;, &quot;皇后&quot;, &quot;王婧怡&quot;]: is_sender = 0 elif name in [&quot;世界之巅&quot;, &quot;2558749399&quot;]: is_sender = 1 # 将姓名添加到集合中，如果之前没有出现过的话 if name not in names: # print(name) names.add(name) # 自动生成LocalId local_id = i // 3 + 1 # 构建CSV行 csv_row = [local_id, 1, type_value, 0, is_sender, i, '', message, date_time, '', '', ''] csv_writer.writerow(csv_row) print(f&quot;转换完成，结果保存在 {output_file}&quot;)# 使用示例# convert_messages(&quot;message.txt&quot;, &quot;messages.csv&quot;) 绘图设置1234sns.set_theme(style=&quot;ticks&quot;)font = &quot;simsun.ttc&quot;fp = fm.FontProperties(fname=font)plt.rcParams[&quot;axes.unicode_minus&quot;] = False 人名标签1labels = [&quot;WJY&quot;, &quot;XJH&quot;] 数据读取 filePath: 消息记录文件的路径 dStart: 开始的时间 dEnd: 结束的时间 tZone: 时区，例如北京时间为 +8 1234filePath = &quot;messages.csv&quot;dStart = &quot;2022-08-07 00:00:00 +0800&quot;dEnd = &quot;2024-02-10 23:59:59 +0800&quot;tZone = 8 12345678df = pd.read_csv(filePath, encoding=&quot;utf-8&quot;)df.loc[:, &quot;StrTime&quot;] = pd.to_datetime(df[&quot;StrTime&quot;])df.loc[:, &quot;day&quot;] = pd.to_datetime(df[&quot;StrTime&quot;]).dt.dayofweekdf.loc[:, &quot;hour&quot;] = pd.to_datetime(df[&quot;StrTime&quot;]).dt.hourdf.loc[:, &quot;Count&quot;] = 1dfs = [df.query(&quot;IsSender == 0&quot;), df.query(&quot;IsSender == 1&quot;)] 消息过滤123456789def textFilter(text: str): text = text.lower() # try: # co = re.compile(&quot;[\\U00010000-\\U0010ffff]&quot;) # except re.error: # co = re.compile(&quot;[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]&quot;) # text = co.sub(&quot; &quot;, text) co = re.compile(&quot;\\[[\\u4e00-\\u9fa5]+\\]&quot;) return co.sub(&quot; &quot;, text) 获取文本消息1234texts = [ [textFilter(i) for i in dfs[0].query(&quot;Type == 1&quot;)[&quot;StrContent&quot;].to_list()], [textFilter(i) for i in dfs[1].query(&quot;Type == 1&quot;)[&quot;StrContent&quot;].to_list()],] 消息频率分析类型分析根据消息的类型进行分类，可以看出喜欢发送的消息类型，同时也可以看出谁发的多 1 = Text 3 = Image 34 = Voice 43 = Video 47 = Sticker 48 = Location 10000 = System 12345678910111213141516171819202122232425262728data = {}for i in range(2): data[labels[i]] = [ len(dfs[i].query(&quot;Type == 1&quot;)), len(dfs[i].query(&quot;Type == 3&quot;)), len(dfs[i].query(&quot;Type == 34&quot;)), len(dfs[i].query(&quot;Type == 43&quot;)), len(dfs[i].query(&quot;Type == 47&quot;)), ]data = ( pd.DataFrame(data, index=[&quot;Text&quot;, &quot;Image&quot;, &quot;Voice&quot;, &quot;Video&quot;, &quot;Sticker&quot;]) .reset_index() .melt(&quot;index&quot;) .rename(columns={&quot;index&quot;: &quot;Type&quot;, &quot;variable&quot;: &quot;Person&quot;, &quot;value&quot;: &quot;Count&quot;}))g = sns.catplot(data, kind=&quot;bar&quot;, x=&quot;Type&quot;, y=&quot;Count&quot;, hue=&quot;Person&quot;, palette=&quot;dark&quot;, alpha=0.6, height=6)for ax in g.axes.ravel(): for i in range(2): ax.bar_label(ax.containers[i], fontsize=9)sns.move_legend(g, &quot;upper right&quot;)plt.yscale(&quot;log&quot;)g.figure.set_size_inches(6, 5)g.figure.set_dpi(150)plt.show()plt.close() 消息长度分析 sN: 设置显示范围：$$\\mu + \\mathrm{sN} * \\sigma$$ multiple: 直方图堆叠格式 12sN = 3multiple = &quot;dodge&quot; 12345678910111213141516171819202122232425262728293031mu, std = 0, 0data = {&quot;Length&quot;: [], &quot;Person&quot;: []}for i in range(2): length = [len(textFilter(i)) for i in texts[i]] data[&quot;Length&quot;] += length data[&quot;Person&quot;] += [labels[i]] * len(length) if np.mean(length) + sN * np.std(length) &gt; mu + std: mu, std = np.mean(length), np.std(length)xlim = int(np.ceil(mu + sN * std))data = pd.DataFrame(data)bins = np.linspace(0, xlim, xlim + 1)ax = sns.histplot( data=data, x=&quot;Length&quot;, hue=&quot;Person&quot;, bins=bins, multiple=multiple, edgecolor=&quot;.3&quot;, linewidth=0.5, palette=&quot;dark&quot;, alpha=0.6,)ax.set_xlim(0, xlim)ax.set_xlabel(&quot;Length of Message&quot;)ax.figure.set_size_inches(8, 4)ax.figure.set_dpi(150)plt.show()plt.close() 每日活跃分析划分每日24小时内每小时发送的消息数，可以得知每天的活跃的时间段 123456789101112131415161718192021222324252627282930data = {&quot;Time&quot;: [], &quot;Person&quot;: []}for i in range(2): hour = dfs[i][&quot;hour&quot;].to_list() data[&quot;Time&quot;] += hour data[&quot;Person&quot;] += [labels[i]] * len(hour)data = pd.DataFrame(data)bins = np.arange(0, 25, 1)ax = sns.histplot( data=data, x=&quot;Time&quot;, hue=&quot;Person&quot;, bins=bins, multiple=multiple, edgecolor=&quot;.3&quot;, linewidth=0.5, palette=&quot;dark&quot;, alpha=0.6,)ax.set_xticks(bins)ax.set_xticklabels(bins)ax.set_xlabel(&quot;Hour&quot;)ax.set_xlim(0, 24)sns.move_legend(ax, loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, 1.2), ncol=2)ax.figure.set_size_inches(8, 4)ax.figure.set_dpi(150)plt.show()plt.close() 每周活跃分析查看一周内从周一到周日每天发送的消息数 12345678910111213grouper = pd.Grouper(key=&quot;day&quot;)data = df.groupby(grouper)[&quot;Count&quot;].sum()data = data.sort_index()data.index = [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;]ax = sns.barplot(data=data, errorbar=None)ax.set_xlabel(&quot;Weekday&quot;)ax.bar_label(ax.containers[0], fontsize=10)ax.figure.set_size_inches(5, 5)ax.figure.set_dpi(150)plt.show()plt.close() 按周划分年度活跃分析划分每7天内发送的消息数，可以得知每周的活跃的时间段 wTicks: 每个刻度相差的数值 wStart: 当年第一个周一的日期 wEnd: 次年第一个周一的日期 123wTicks = 500wStart = &quot;2022-08-01&quot;wEnd = &quot;2024-02-09&quot; 12345678910111213141516171819202122232425262728grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;W-MON&quot;)data = df.groupby(grouper)[&quot;Count&quot;].sum().to_frame()data.index = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;)data.columns = [&quot;Count&quot;]vM = np.ceil(data[&quot;Count&quot;].max() / wTicks) * wTicksnorm = plt.Normalize(0, vM)sm = plt.cm.ScalarMappable(cmap=&quot;Reds&quot;, norm=norm)ax = sns.barplot(x=data.index, y=data[&quot;Count&quot;], hue=data[&quot;Count&quot;], hue_norm=norm, palette=&quot;Reds&quot;)ax.set_xlabel(&quot;Date&quot;)plt.xticks(rotation=60)for bar in ax.containers: ax.bar_label(bar, fontsize=10, fmt=&quot;%.0f&quot;)ax.get_legend().remove()axpos = ax.get_position()caxpos = mtransforms.Bbox.from_extents(axpos.x1 + 0.02, axpos.y0, axpos.x1 + 0.03, axpos.y1)cax = ax.figure.add_axes(caxpos)locator = mticker.MultipleLocator(wTicks)formatter = mticker.StrMethodFormatter(&quot;{x:.0f}&quot;)cax.figure.colorbar(sm, cax=cax, ticks=locator, format=formatter)ax.figure.set_size_inches(20, 8)ax.figure.set_dpi(150)plt.show()plt.close() f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) 按周划分聊天热情分析划分每7天内的聊天热情指数，聊天热情指数为发送的消息数减去收到的消息数与总消息数的比值：$$E = \\frac{Q_\\mathrm{S} - Q_\\mathrm{R}}{Q_\\mathrm{S} + Q_\\mathrm{R}}$$ 1234567891011121314151617181920212223242526272829303132333435363738grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;W-MON&quot;)df_W1 = dfs[0].groupby(grouper)[&quot;Count&quot;].sum()df_W2 = dfs[1].groupby(grouper)[&quot;Count&quot;].sum()data = pd.DataFrame({&quot;E&quot;: (df_W1 - df_W2) / (df_W1 + df_W2)})data.index = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;)vM = data[&quot;E&quot;].abs().max()vm = data[&quot;E&quot;].min()norm = plt.Normalize(-vM, vM)sm = plt.cm.ScalarMappable(cmap=&quot;coolwarm&quot;, norm=norm)print(data.index)print(data[&quot;E&quot;])if data[&quot;E&quot;].isna().any(): print(&quot;列 'E' 中包含NaN项&quot;)else: print(&quot;列 'E' 中不包含NaN项&quot;)data[&quot;E&quot;].fillna(0, inplace=True)ax = sns.barplot(x=data.index, y=data[&quot;E&quot;], hue=data[&quot;E&quot;], hue_norm=norm, palette=&quot;coolwarm&quot;)ax.set_xlabel(&quot;Date&quot;)plt.xticks(rotation=60)ax.set_ylabel(&quot;Enthusiasm Index&quot;)for bar in ax.containers: ax.bar_label(bar, fontsize=10, fmt=&quot;%.2f&quot;)ax.get_legend().remove()axpos = ax.get_position()caxpos = mtransforms.Bbox.from_extents(axpos.x1 + 0.02, axpos.y0, axpos.x1 + 0.03, axpos.y1)cax = ax.figure.add_axes(caxpos)locator = mticker.MultipleLocator(0.1)formatter = mticker.StrMethodFormatter(&quot;{x:.2f}&quot;)cax.figure.colorbar(sm, cax=cax, ticks=locator, format=formatter)ax.figure.set_size_inches(20, 8)ax.figure.set_dpi(150)plt.show()plt.close() f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) F:\\user\\Temp\\ipykernel_9048\\3741989350.py:18: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method. The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy. For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. ​​ data[“E”].fillna(0, inplace=True) Index(['08-01', '08-08', '08-15', '08-22', '08-29', '09-05', '09-12', '09-19', '09-26', '10-03', '10-10', '10-17', '10-24', '10-31', '11-07', '11-14', '11-21', '11-28', '12-05', '12-12', '12-19', '12-26', '01-02', '01-09', '01-16', '01-23', '01-30', '02-06', '02-13', '02-20', '02-27', '03-06', '03-13', '03-20', '03-27', '04-03', '04-10', '04-17', '04-24', '05-01', '05-08', '05-15', '05-22', '05-29', '06-05', '06-12', '06-19', '06-26', '07-03', '07-10', '07-17', '07-24', '07-31', '08-07', '08-14', '08-21', '08-28', '09-04', '09-11', '09-18', '09-25', '10-02', '10-09', '10-16', '10-23', '10-30', '11-06', '11-13', '11-20', '11-27', '12-04', '12-11', '12-18', '12-25', '01-01', '01-08', '01-15', '01-22', '01-29', '02-05'], dtype='object') 08-01 0.120000 08-08 0.109091 08-15 0.071633 08-22 -0.007092 08-29 0.075426 ... 01-08 -0.003752 01-15 0.100529 01-22 0.159184 01-29 0.068273 02-05 0.014085 Name: E, Length: 80, dtype: float64 列 'E' 中包含NaN项 按日划分年度活跃分析以热力图的方式展示按日划分的年度活跃情况 123456789101112131415161718192021222324252627282930313233grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;D&quot;)data = df.groupby(grouper)[&quot;Count&quot;].sum()data = data.to_frame()wStart = &quot;2023-01-01&quot;wEnd = &quot;2024-01-01&quot;data[&quot;date&quot;] = data.indexdata[&quot;week&quot;] = data[&quot;date&quot;].dt.isocalendar()[&quot;week&quot;]data[&quot;day&quot;] = data[&quot;date&quot;].dt.dayofweekdata.index = range(len(data))for i in range(7): if data.loc[i, &quot;week&quot;] &gt; 1: data.loc[i, &quot;week&quot;] = 0print(data)data = data.pivot_table(index=&quot;day&quot;, columns=&quot;week&quot;, values=&quot;Count&quot;)data.index = [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;]data.columns = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;)ax = sns.heatmap( data, annot=False, linewidths=0.5, cbar_kws={&quot;orientation&quot;: &quot;vertical&quot;, &quot;location&quot;: &quot;left&quot;, &quot;pad&quot;: 0.03}, cmap=&quot;Reds&quot;,)ax.set_xlabel(&quot;Week&quot;)ax.set_ylabel(&quot;Weekday&quot;)ax.figure.set_size_inches(24, 4)ax.figure.set_dpi(150)plt.show()plt.close() f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) Count date week day 0 46 2022-08-07 0 6 1 104 2022-08-08 0 0 2 100 2022-08-09 0 1 3 47 2022-08-10 0 2 4 3 2022-08-11 0 3 .. ... ... ... ... 547 76 2024-02-05 6 0 548 0 2024-02-06 6 1 549 0 2024-02-07 6 2 550 47 2024-02-08 6 3 551 24 2024-02-09 6 4 [552 rows x 4 columns] 词语分析分词词典、停止词与去除词性1234jieba.load_userdict(&quot;thuocl.txt&quot;)jieba.load_userdict(&quot;userdict.txt&quot;)stopwords = [line.strip() for line in open(&quot;stopwords.txt&quot;, &quot;r&quot;).readlines()] + [&quot; &quot;, &quot;\\n&quot;, &quot;\\r\\n&quot;]wordclass = [&quot;v&quot;, &quot;u&quot;, &quot;vd&quot;, &quot;r&quot;, &quot;p&quot;, &quot;w&quot;] 分词函数123456789101112131415def wordSplit(texts, wordclass): words = [] pbar = tqdm(total=len(texts)) for i in range(len(texts)): res = pseg.lcut(texts[i]) for pair in res: if pair.word in stopwords: continue if pair.flag in wordclass: continue words.append(pair.word) if i % 1000 == 0: pbar.update(1000) pbar.close() return words 1words = [wordSplit(texts[i], wordclass) for i in range(2)] 15000it [00:08, 1837.45it/s] 17000it [00:07, 2395.06it/s] 词云绘制 font: 字体路径，至少支持中文，最好同时支持中文和emoji mask: 词云的蒙版，影响词云的形状 cmap: 色阶 12345678910111213141516171819font = &quot;simsun.ttc&quot;mask = np.array(Image.open(&quot;mask.png&quot;))masks = [np.array(Image.open(&quot;mask_L.jpg&quot;)), np.array(Image.open(&quot;mask_F.jpg&quot;))]cmap = ListedColormap( [ &quot;#fac1cf&quot;, &quot;#a9d7ba&quot;, &quot;#58b1db&quot;, &quot;#f296ab&quot;, &quot;#5dab81&quot;, &quot;#3d9ec4&quot;, &quot;#e16a8d&quot;, &quot;#237b50&quot;, &quot;#1e8299&quot;, &quot;#8d3549&quot;, &quot;#35563b&quot;, &quot;#2d5d73&quot;, ]) 123456789101112def wordCloud(text, font, mask, cmap): wc = WordCloud( background_color=&quot;white&quot;, scale=5, font_path=font, mask=mask, colormap=cmap, collocations=False, ).generate(text) plt.imshow(wc) plt.axis(&quot;off&quot;) plt.show() 1wordCloud(&quot; &quot;.join(words[0]), font, masks[0], cmap) 1wordCloud(&quot; &quot;.join(words[1]), font, masks[1], cmap) 1wordCloud(&quot; &quot;.join(words[0] + words[1]), font, mask, cmap) 高频词排行列出常用的 N 个词，并且展示双方的贡献 wN: 词的数目，默认为50 1wN = 50 12345678910111213data = pd.DataFrame( { &quot;words&quot;: words[0] + words[1], &quot;L&quot;: [1] * len(words[0]) + [0] * len(words[1]), &quot;F&quot;: [0] * len(words[0]) + [1] * len(words[1]), &quot;S&quot;: [1] * len(words[0]) + [1] * len(words[1]), })grouper = pd.Grouper(key=&quot;words&quot;)data = data.groupby(grouper).sum()data = data.sort_values(by=&quot;S&quot;, ascending=False)data = data.iloc[:wN] 123456789101112# 将部分无法识别的 emoji 转化为文字tmp = data.index.to_list()for i in range(wN): if tmp[i] == &quot;😘&quot;: tmp[i] = &quot;[亲亲]&quot; elif tmp[i] == &quot;😂&quot;: tmp[i] = &quot;[笑哭]&quot; elif tmp[i] == &quot;🤦&quot;: tmp[i] = &quot;[捂脸]&quot; elif tmp[i] == &quot;😁&quot;: tmp[i] = &quot;[呲牙]&quot;data.index = tmp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061ratio = data[&quot;L&quot;] / data[&quot;S&quot;]norm = plt.Normalize(0, 1)sm = plt.cm.ScalarMappable(cmap=&quot;coolwarm&quot;, norm=norm)fig = plt.figure(figsize=(10, 10), dpi=300)grid = plt.GridSpec(1, 4, wspace=0.5)ax0 = fig.add_subplot(grid[0, 0])sns.barplot(x=-data[&quot;L&quot;], y=data.index, ax=ax0, hue=ratio, hue_norm=norm, palette=&quot;coolwarm&quot;)ax1 = fig.add_subplot(grid[0, 1:])sns.barplot(x=data[&quot;F&quot;], y=data.index, ax=ax1, hue=(1 - ratio), hue_norm=norm, palette=&quot;coolwarm&quot;)ax0.set_xlabel(&quot;Word Frequency&quot;)ax0.set_ylabel(&quot;&quot;)ax0.set_xticks(range(-400, 1, 200))ax0.set_xticklabels([400, 200, 0])ax0.set_xlim(-400, 0)ax0.set_yticks([])ax0.spines[&quot;left&quot;].set_visible(False)ax0.spines[&quot;top&quot;].set_visible(False)ax0.spines[&quot;right&quot;].set_visible(False)ax0.set_title(&quot;WJY&quot;)ax0.get_legend().remove()ax1.set_xlabel(&quot;Word Frequency&quot;)ax1.set_ylabel(&quot;&quot;)ax1.set_xticks(range(0, 1201, 200))ax1.set_xticklabels([0, 200, 400, 600, 800, 1000, 1200])ax1.set_xlim(0, 1200)ax1.set_yticks([])ax1.spines[&quot;left&quot;].set_visible(False)ax1.spines[&quot;top&quot;].set_visible(False)ax1.spines[&quot;right&quot;].set_visible(False)ax1.set_title(&quot;XJH&quot;)ax1.get_legend().remove()axpos = ax1.get_position()caxpos = mtransforms.Bbox.from_extents(axpos.x0 + 0.06, axpos.y0 + 0.03, axpos.x1, axpos.y0 + 0.04)cax = ax1.figure.add_axes(caxpos)locator = mticker.MultipleLocator(0.1)formatter = mticker.StrMethodFormatter(&quot;{x:.1f}&quot;)cax.figure.colorbar(sm, cax=cax, orientation=&quot;horizontal&quot;, ticks=locator, format=formatter)# cax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)cax.set_title(&quot;ratio&quot;)x0 = ax0.get_position().x1x1 = ax1.get_position().x0xm = (x0 + x1) / 2y0 = ax0.get_position().y0y1 = ax0.get_position().y1for i in range(wN): fig.text( xm, y0 + (y1 - y0) * (wN - i - 0.5) / wN, data.index[i], color=&quot;black&quot;, ha=&quot;center&quot;, va=&quot;center&quot;, fontproperties=fp )fig.set_dpi(150)plt.show()plt.close() 情感分析使用 paddlenlp 进行情感分析，得到的分数在 [-1, 1] 之间，越小越消极，越大越积极 12dfE = df.query(&quot;Type == 1&quot;)[[&quot;IsSender&quot;, &quot;StrContent&quot;, &quot;StrTime&quot;, &quot;hour&quot;]]dfE.index = range(len(dfE)) 1senta = Taskflow(&quot;sentiment_analysis&quot;, home_path=&quot;./&quot;) 12scores = pd.DataFrame(senta([textFilter(i) for i in dfE[&quot;StrContent&quot;].to_list()]))scores.loc[scores[&quot;label&quot;] == &quot;negative&quot;, &quot;score&quot;] = 1 - scores.loc[scores[&quot;label&quot;] == &quot;negative&quot;, &quot;score&quot;] 12345dfE[&quot;score&quot;] = scores[&quot;score&quot;]dfE[&quot;score&quot;] = 2 * dfE[&quot;score&quot;] - 1dfE[&quot;Person&quot;] = dfE.apply(lambda x: labels[x[&quot;IsSender&quot;]], axis=1)dfEs = [dfE.query(&quot;IsSender == 0&quot;), dfE.query(&quot;IsSender == 1&quot;)] 年度总体情感分布12345678910ax = sns.histplot(data=dfE, x=&quot;score&quot;, hue=&quot;Person&quot;, palette=&quot;dark&quot;, alpha=0.6, bins=100)ax.set_xlabel(&quot;Sentiment Score&quot;)ax.set_ylabel(&quot;Count&quot;)ax.set_title(&quot;Sentiment Distribution&quot;)ax.set_xlim(-1, 1)ax.figure.set_size_inches(8, 3)ax.figure.set_dpi(150)plt.show() 按周统计平均情感指数1234567891011121314151617181920212223242526272829303132333435def weekAvgSenScore(df): wStart = &quot;2022-08-01&quot; wEnd = &quot;2024-02-10&quot; grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;W-MON&quot;) data = df.groupby(grouper)[&quot;score&quot;].mean().to_frame() data.index = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;) data.columns = [&quot;score&quot;] vM = data[&quot;score&quot;].abs().max() norm = plt.Normalize(-vM, vM) sm = plt.cm.ScalarMappable(cmap=&quot;coolwarm&quot;, norm=norm) data[&quot;score&quot;].fillna(0, inplace=True) ax = sns.barplot(x=data.index, y=data[&quot;score&quot;], hue=data[&quot;score&quot;], hue_norm=norm, palette=&quot;coolwarm&quot;) ax.set_xlabel(&quot;Date&quot;) plt.xticks(rotation=60) for bar in ax.containers: ax.bar_label(bar, fontsize=10, fmt=&quot;%.2f&quot;) ax.get_legend().remove() axpos = ax.get_position() caxpos = mtransforms.Bbox.from_extents(axpos.x1 + 0.02, axpos.y0, axpos.x1 + 0.03, axpos.y1) cax = ax.figure.add_axes(caxpos) locator = mticker.MultipleLocator(0.02) formatter = mticker.StrMethodFormatter(&quot;{x:.2f}&quot;) cax.figure.colorbar(sm, cax=cax, ticks=locator, format=formatter) ax.figure.set_size_inches(20, 8) ax.figure.set_dpi(150) plt.show() plt.close() return data[&quot;score&quot;] 1avgSenScore0 = weekAvgSenScore(dfEs[0]) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) F:\\user\\Temp\\ipykernel_9048\\3472776600.py:13: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method. The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy. For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. ​​ data[“score”].fillna(0, inplace=True) 1avgSenScore1 = weekAvgSenScore(dfEs[1]) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) F:\\user\\Temp\\ipykernel_9048\\3472776600.py:13: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method. The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy. For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. ​​ data[“score”].fillna(0, inplace=True) 1_ = weekAvgSenScore(dfE) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) F:\\user\\Temp\\ipykernel_9048\\3472776600.py:13: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method. The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy. For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. ​​ data[“score”].fillna(0, inplace=True) 12345678910111213ax = sns.lineplot(data=avgSenScore0, linewidth=3, marker=&quot;s&quot;, markersize=15, label=labels[0])ax = sns.lineplot(data=avgSenScore1, linewidth=3, marker=&quot;^&quot;, markersize=15, ax=ax, label=labels[1])ax.set_xlabel(&quot;Date&quot;)plt.xticks(rotation=60)ax.set_ylabel(&quot;Average Sentiment Score&quot;)ax.set_xlim(0, 52)ax.legend(prop={&quot;size&quot;: 24})ax.figure.set_size_inches(20, 8)ax.figure.set_dpi(150)plt.show()plt.close() 按周统计累计情感指数123456789101112131415161718192021222324252627282930313233def weekTotSenScore(df): wStart = &quot;2022-08-01&quot; wEnd = &quot;2024-02-10&quot; grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;W-MON&quot;) data = df.groupby(grouper)[&quot;score&quot;].sum().to_frame() data.index = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;) data.columns = [&quot;score&quot;] vM = data[&quot;score&quot;].abs().max() norm = plt.Normalize(-vM, vM) sm = plt.cm.ScalarMappable(cmap=&quot;coolwarm&quot;, norm=norm) ax = sns.barplot(x=data.index, y=data[&quot;score&quot;], hue=data[&quot;score&quot;], hue_norm=norm, palette=&quot;coolwarm&quot;) ax.set_xlabel(&quot;Date&quot;) plt.xticks(rotation=60) for bar in ax.containers: ax.bar_label(bar, fontsize=10, fmt=&quot;%.2f&quot;) ax.get_legend().remove() axpos = ax.get_position() caxpos = mtransforms.Bbox.from_extents(axpos.x1 + 0.02, axpos.y0, axpos.x1 + 0.03, axpos.y1) cax = ax.figure.add_axes(caxpos) locator = mticker.MultipleLocator(20) formatter = mticker.StrMethodFormatter(&quot;{x:.2f}&quot;) cax.figure.colorbar(sm, cax=cax, ticks=locator, format=formatter) ax.figure.set_size_inches(20, 8) ax.figure.set_dpi(150) plt.show() plt.close() return data[&quot;score&quot;] 1totSenScore0 = weekTotSenScore(dfEs[0]) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) 1totSenScore1 = weekTotSenScore(dfEs[1]) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) 1_ = weekTotSenScore(dfE) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) 12345678910111213ax = sns.lineplot(data=totSenScore0, linewidth=3, marker=&quot;s&quot;, markersize=15, label=labels[0])ax = sns.lineplot(data=totSenScore1, linewidth=3, marker=&quot;^&quot;, markersize=15, ax=ax, label=labels[1])ax.set_xlabel(&quot;Date&quot;)plt.xticks(rotation=60)ax.set_ylabel(&quot;Total Sentiment Score&quot;)ax.set_xlim(0, 52)ax.legend(prop={&quot;size&quot;: 24})ax.figure.set_size_inches(20, 8)ax.figure.set_dpi(150)plt.show()plt.close() 每日平均情感分析12345678910111213141516171819202122232425262728293031323334353637383940414243grouper = pd.Grouper(key=&quot;hour&quot;)data = []for k in range(2): tmp = dfEs[k].groupby(grouper)[&quot;score&quot;].mean().sort_index() for i in range(24): if i in tmp.index: data.append(tmp[i]) else: data.append(0) data.append(0)data = pd.DataFrame( { &quot;Score&quot;: data, &quot;Person&quot;: [labels[0]] * 25 + [labels[1]] * 25, })xBins = [i for i in range(25)]ax = sns.histplot( data=data, x=xBins * 2, bins=xBins, weights=&quot;Score&quot;, hue=&quot;Person&quot;, multiple=multiple, edgecolor=&quot;.3&quot;, linewidth=0.5, palette=&quot;dark&quot;, alpha=0.6,)ax.set_xticks(range(25))ax.set_xticklabels(range(25))ax.set_xlabel(&quot;Hour&quot;)ax.set_xlim(0, 24)ax.set_ylim(np.min([0, np.floor(data[&quot;Score&quot;].min() / 0.05) * 0.05]), np.ceil(data[&quot;Score&quot;].max() / 0.05) * 0.05)sns.move_legend(ax, loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, 1.2), ncol=2)ax.figure.set_size_inches(8, 4)ax.figure.set_dpi(150)plt.show()plt.close() 每日累计情感分析12345678910111213141516171819202122232425262728293031323334353637383940414243grouper = pd.Grouper(key=&quot;hour&quot;)data = []for k in range(2): tmp = dfEs[k].groupby(grouper)[&quot;score&quot;].sum().sort_index() for i in range(24): if i in tmp.index: data.append(tmp[i]) else: data.append(0) data.append(0)data = pd.DataFrame( { &quot;Score&quot;: data, &quot;Person&quot;: [labels[0]] * 25 + [labels[1]] * 25, })xBins = [i for i in range(25)]ax = sns.histplot( data=data, x=xBins * 2, bins=xBins, weights=&quot;Score&quot;, hue=&quot;Person&quot;, multiple=multiple, edgecolor=&quot;.3&quot;, linewidth=0.5, palette=&quot;dark&quot;, alpha=0.6,)ax.set_xticks(range(25))ax.set_xticklabels(range(25))ax.set_xlabel(&quot;Hour&quot;)ax.set_xlim(0, 24)ax.set_ylim(np.min([0, np.floor(data[&quot;Score&quot;].min() / 0.05) * 0.05]), np.ceil(data[&quot;Score&quot;].max() / 0.05) * 0.05)sns.move_legend(ax, loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, 1.2), ncol=2)ax.figure.set_size_inches(8, 4)ax.figure.set_dpi(150)plt.show()plt.close()","link":"/2024/02/11/QQmsganalysis/"},{"title":"课题：斯特林发动机机械系统动力学仿真","text":"一、初始设计参数与热力学计算对于我们设计的β型斯特林发动机，提出了如下的设计目标： 物理参数 数值（单位） 输出功率 0.5W 在我们初步设计的斯特林发动机（模型如下图所示）中，相关的尺寸参数如下： 物理参数 数值（单位） 排气活塞行程h1 42mm 做功活塞行程h2 45mm 相位角α 85° 气缸内径r 10mm 排气活塞半径r0 8mm 气缸内气体压强最小值Pmin 101300Pa（与环境大气压一致） 将设计好的模型导入Ansys软件中进行静态热力学的仿真（如下图所示），可以得到气体温度的状态参数如下： 压缩空间气体温度Tc 439K 膨胀空间气体温度Te 611K 根据史密特理论的相关计算公式，可以编写相应程序，由以上参数为基础计算并绘制P-V图以及单次循环所作功，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243afa=2*85*pi/360;theta=0:0.01:pi*2;tc=439;te=611;l1=0.021;h1=l1*2;l2=0.0225;h2=l2*2;r=0.01;r0=0.008;vse=r0*r0*pi*h1;vsc=r*r*pi*h2;ve=vse.*(1-cos(theta))./2;vb=(vse+vsc)./2-sqrt((vse.*vse+vsc.*vsc)./4-vse.*vsc.*cos(afa)./2);vc=vse.*(1+cos(theta))./2+vsc.*(1-cos(theta-afa))./2-vb;vr=(r*r-r0*r0)*0.02*pi;tao=tc/te;k=vsc/te;xb=vb/vse;x=vr/vse;fai=atan(k.*sin(afa)./(1-tao-k.*cos(afa)));s=tao+4.*tao.*x./(1+tao)+k+1-2.*xb;b=sqrt(tao.*tao+2.*k.*(tao-1).*cos(afa)+k.*k-2.*tao+1);deta=b./s;pmin=101300;p=pmin.*(1+deta)./(1-deta.*cos(theta-fai));plot(rad2deg(theta),p);xlabel('角度θ（°）');ylabel('压强P（Pa）');title('α=85°时θ-P图线');v=ve+vr+vc;figure;plot(rad2deg(theta),v);xlabel('角度θ（°）');ylabel('体积V（m^3）');title('α=85°时θ-V图线');figure;plot(v,p);xlabel('体积V（m^3）');ylabel('压强P（Pa）');title('α=85°时P-V图线');w=10000000*pmin.*vse.*pi.*deta.*(1-tao).*sin(fai).*sqrt(1-deta)./((1+sqrt(1-deta.*deta)).*sqrt(1+deta));disp(w); 通过运行上述代码，可绘制出如下热力学数据图线，并计算出单次循环做功为**0.0523J**。 因此，若要达到设计目标的0.5W功率要求，需要转速达到rmin=0.5*60/0.0523≈573.6rpm。 此外，以上设计参数所得到的P-V图线偏扁圆形，与常见的P-V图线形状有一定差异，这主要是与设定的初始相位角有关，若将相位角改为45°，则可以得出如下P-V图线，并可计算得出此时对应的单次循环做功为0.0608J，较先前有所提高；但在β型斯特林发动机中，相位角是由相关零件的设计直接确定的，故在后面的仿真中仍然保持相位角α=85°的设定。 二、Adams动力学仿真在不考虑各类摩擦的情况下，对于基本的曲柄连杆传动机构来说，有如下基本公式： 根据此公式可得到如下代码，绘制转矩变化曲线如下图： 12345678910ap=pi*l2*l2; fp=ap.*(p-pmin); tq=(sin(theta)-cos(theta)).*fp.*r; t_qm=w/2/pi; t_qm_(1,1:629)=t_qm; figure; plot(rad2deg(theta),tq,rad2deg(theta),t_qm_); xlabel('角度θ（°）'); ylabel('转矩'); title('转矩变化曲线'); 根据如下仿真步骤，将Fusion360建模软件中建立完成的模型导出为STEP格式，进入Adams仿真软件中进行进一步的动力学仿真。 在第一次仿真时，仅仅将原有模型中设计到传动的部分保留，并将简化后的模型导入仿真，主要反映出两大问题，第一时间进行了修改（以上给的参数均为该次修改后确定的）： （1）传动部分设计失误，主要表现为各个曲柄的转动不同轴而导致角速度不一致，从而无法达到稳定的压缩与膨胀之间的状态转换，即活塞体系无法完成循环； （2）连杆设计尺寸不合适，导致部件之间出现穿模问题。 通过修改转动轴连接方式，重新捋清传动循环原理并对不合适的尺寸进行修改（将连接排气活塞的连杆长度缩短），最终实现了在给定初始转速下动力学仿真模型的稳定运转（演示效果见PPT）。 在验证Adams模型与连接建立设置的可行性后，为进行下一步仿真，设置了系统单元变量（推力，对应的力矩，飞轮转动角度与角速度），并将前两者作为输入，后两者作为输出，利用Controls插件导出对应文件以供与MATLAB中Simulink的联合仿真。 三、Simulink联合仿真打开Adams导出的m文件并运行从而加载对应系统变量，在命令行中输入adams_sys指令即可进入Simulink仿真界面。根据计算与仿真需求，建立Simulink原理图如下： 通过上述分析可知，对于整个发动机来说，我们需要根据不同时刻气缸中密封气体的状态来计算其对活塞的推力，并将其转换为转矩施加在飞轮上，从而形成对整个发动机循环工作的驱动。因此，在Adams建立系统单元时，我们选择气体推力及其等效飞轮转矩（无摩擦情况下）作为整个系统的输入变量，而将飞轮转动的实时角度作为输出量，同时设置飞轮转动的角速度即转速作为最终需要监测的关键输出变量。其中，气体对活塞产生的推力本质上与飞轮转动的实时角度息息相关，也正因此需要将该角度作为Adams仿真系统中的输出变量，以便于在Simulink中回传至模型中进行迭代仿真。而实现角度信息到推力乃至转矩数据的转换，就需要在Simulink中插入S-Function进行实时计算处理。在本原理图中，左侧的plant框体即为我们设置的S-Function函数。 事实上，计算推力乃至转矩关键就要计算气缸内密封气体对于活塞产生的压强，也就是气压值P，而这一值在前面的热力学分析中已有提及，并有相应的公式可以根据实时的飞轮转动角度给出对应气压P的计算。于是，通过对于上述热力学斯特林循环代码的简单改写，结合推力与转矩的转换，可以得到plant函数代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function [sys,x0,str,ts,simStateCompliance] = plant(t,x,u,flag)switch flag,case 0,[sys,x0,str,ts,simStateCompliance]=mdlInitializeSizes;case 1,sys=mdlDerivatives(t,x,u);case 2,sys=mdlUpdate(t,x,u);case 3,sys=mdlOutputs(t,x,u);case 4,sys=mdlGetTimeOfNextVarHit(t,x,u);case 9,sys=mdlTerminate(t,x,u);otherwiseDAStudio.error('Simulink:blocks:unhandledFlag', num2str(flag));endendfunction [sys,x0,str,ts,simStateCompliance]=mdlInitializeSizessizes = simsizes;sizes.NumContStates = 0;sizes.NumDiscStates = 0;sizes.NumOutputs = 2;sizes.NumInputs = 1;sizes.DirFeedthrough = 1;sizes.NumSampleTimes = 1; sys = simsizes(sizes);x0 = [];str = [];ts = [0 0];simStateCompliance = 'UnknownSimState';endfunction sys=mdlDerivatives(t,x,u)sys = [];endfunction sys=mdlUpdate(t,x,u)sys = [];endfunction sys=mdlOutputs(t,x,u)theta=u;afa=2*85*pi/360;tc=439;te=611;h1=0.042;h2=0.045;r=0.01;r0=0.008;vse=r0*r0*pi*h1;vsc=r*r*pi*h2;vb=(vse+vsc)./2-sqrt((vse.*vse+vsc.*vsc)./4-vse.*vsc.*cos(afa)./2);vr=(r*r-r0*r0)*0.02*pi;tao=tc/te;k=vsc/te;xb=vb/vse;x1=vr/vse;fai=atan(k.*sin(afa)./(1-tao-k.*cos(afa)));s=tao+4.*tao.*x1./(1+tao)+k+1-2.*xb;b=sqrt(tao.*tao+2.*k.*(tao-1).*cos(afa)+k.*k-2.*tao+1);deta=b./s;pmin=101300;P=pmin.*(1+deta)./(1-deta.*cos(theta-fai));Ap=pi*r*r;Fp=Ap.*(P-pmin);%对曲柄转矩 N.mif t&lt;0.1force=0;torque=-0.4;elseTq=(sin(theta)-cos(theta)).*Fp*r;force=0;torque=Tq;endsys(1)=force;sys(2)=torque;endfunction sys=mdlGetTimeOfNextVarHit(t,x,u)sampleTime = 1; % Example, set the next hit to be one second later.sys = t + sampleTime;endfunction sys=mdlTerminate(t,x,u)sys = [];% end mdlTerminateend 除此之外，由于两个仿真系统之间的运算单位不统一，在将Adams中角度单位改为rad（弧度），长度单位改为m后，仍然需要对相应的角度与转速数据进行单位上的换算处理（如下图所示），从而可以得到数量级正确的数据图线。 经过以上处理，并将adams_sub单元中的仿真模式（改为interactive）与步长（根据情况改为0.0001或0.0005较为合适）进行对应调整后，可以得到仿真结果的数据波形图如下（仿真时间设置为5s)： **图线结果分析**： （1）转速开始突增的原因：初始转矩设置为0.4（负方向），相对于后续整体产生的转矩值都较大，因此在开始时转速在迅速增长后又回落； （2）可以看到转速在短暂突增后逐渐趋于平稳，但稳定在3000rpm左右，这个转速较快，在现实中可能较难实现，会超过实际材料的承受极限； （3）但转速在稳定后仍有较大波动，初步判定是由于飞轮质量较轻导致其转动产生的震荡较大，初步观察图线可以发现其在平均值附近最大有将近±300rpm的浮动，需要在后续处理中予以优化； （4）角度的变化较为规律，且在单位换算调整后能够基本稳定在-180°到180°之间（偶尔有小的浮动），说明仿真运行基本正常； （5）转矩的变换也与前面动力学分析时绘制的转矩图线基本吻合，随角度变化也呈周期性变化，符合理想情况。 四、迭代改进及其仿真在上述章节中，我们已经完成了从Adams力学建模仿真到接入Simulink建立联合仿真并得到转速变化图线结果的全过程，但仍然存在一些问题，需要进行进一步修改以达到预期效果并指导发动机对应尺寸的设计修改。 1.初次修改——调节设计参数在之前的初步仿真中，得出的转速会在短暂突增后稳定在3000rpm左右，这在实际中对于我们设计的结构规模来说是不太可能实现的，同时也远远超出了实际材料的结构强度与承受范围，因此为了将稳定时的转速降低，同时进行了如下两处改动以达到效果： （1）减小活塞与气缸半径 减小活塞与气缸半径实质上是减小了活塞受气体推力作用的横截面积，同时也减小了气缸中容纳的气体体积，但由于密封前仍与外界空气联通，故初始气压（即Pmin）仍与大气压一致，也因此该改动实际上是降低了相同温度状态下气体的压强，从而导致气体对活塞推力的减小，传动到飞轮上的转矩也随之减小，最终导致了转速的降低。 在本次改动中，我们对活塞与气缸半径均进行了减小处理，并在plant函数中对应的结构参数部分做出了对应的调整，调整后的参数如下表所示： 物理参数 数值（单位） 气缸内径r 5mm 排气活塞半径r0 4mm 该设计参数的调节也同步影响到了单次循环做功的数值，通过重新代入修改后的参数进行热力学参数的计算，得到此参数下单次斯特林循环的做功数值为**0.0327J**。 （2）增大飞轮质量（转动惯量） 在之前的仿真中为便于贴合加工处理将所有部件的材质设置为铝（密度较低，质量轻），但是结果显示转速在大致稳定后仍然出现了一定程度的震荡浮动，这是我们想要避免的。因此，一方面为了降低转速的浮动幅度，另一方面也是为了通过增加转动惯量加大负载从而降低转速，我们希望将飞轮的质量增大；同时，为了尽可能减少我们的修正对于整体建模结构的影响，我们尽量不去改动飞轮本身的尺寸，而是在Adams中对于飞轮部件的质量特性做出调整，通过将其材质由铝转换为密度更大的不锈钢从而实现增加飞轮质量的效果。 综合以上两点调整后，再次进入Simulink中运行仿真，同时由于调整结构设计参数降低了气体对活塞做功施加到飞轮上的等效转矩的整体数值，因此也将初始驱动力矩降低为-0.2（尽可能贴近气体膨胀压缩产生等效力矩的浮动范围）以尽可能降低初始力矩对于最终稳定转速的影响，得到仿真结果如下图（演示视频见PPT）： **图线结果分析**： （1）转速在仿真开始阶段的突增消失； （2）转速在短暂的增加后迅速达到平稳状态，且稳定在1450rpm左右，较先前有了明显的降低，同时结合更改参数后热力学计算得到的单次斯特林循环做功数值为0.0327J，可以得出此时斯特林发动机运行的理论功率为0.7906W，满足初始设定的设计要求； （3）但转速在稳定后的波动明显减小，观察图线可以发现其在平均值附近仅有±50rpm左右的浮动，运行基本处于稳定状态； （4）角度的变化较为规律，且在单位换算调整后能够基本稳定在-180°到180°之间（偶尔有小的浮动），说明仿真运行基本正常； （5）转矩的变换也与前面动力学分析时绘制的转矩图线基本吻合，随角度变化也呈周期性变化，符合理想情况。 2.汇报后的更正——活塞推力的给予方式改变以及传动机构间摩擦的添加在12月5号课程的汇报中，老师对于我们的仿真提出了一些指导意见，其中最主要的就是提到将气体对活塞推力转化为飞轮转矩的合理性，以及随之带来的传动过程中的摩擦问题。同时老师还提到，不要轻易的去改动原先设计的尺寸参数，事实上在第一阶段的改动中仅仅是在热力学计算以及对应推力与转矩计算中改动了对应的参数，而由于修改模型再重新导入Adams设置连接与参数过于麻烦所以并未对应进行调整，所以我们对于气缸与活塞半径的修改进行了回退处理。 事实上，基于斯特林发动机整体的运作机理考虑，首先需要在预热的同时人为拨动飞轮，本质上与给予初始转矩相对应，因此在t&lt;0.1s的启动阶段，仍然保留了初始力矩值torque的设定，而在后续的循环运作阶段传出实时气体对活塞的推力Fp作为force的值，因此改动plant函数对应部分如下： 1234567891011121314pmin=101300;P=pmin.*(1+deta)./(1-deta.*cos(theta-fai));Ap=pi*r*r;Fp=Ap.*(P-pmin);if t&lt;0.1force=0;torque=-0.4;elseforce=Fp;torque=0;endsys(1)=force;sys(2)=torque;end 同时为监测对应的推力改变情况，修改Simulink系统原理图如下： 经过对于各种参数的多次调整与运行，我们进行了如下的补充仿真： （1）给定初始力矩对于转速的影响 我们分别设定t&lt;0.1s时给定的初始转矩Torque=-0.5和-0.05，运行仿真并得出转矩图线： 通过观察上述两图并对比可以发现，事实上初始转矩的大小是决定运行初期转速变化情况的主要因素，具体体现为若初始转矩较大则会出现转速突增现象而降低初始转矩后则该现象消失，同时初始转矩较低时稳定后的转速也有对应降低，但降低幅度有限，大致还是稳定在1200rpm左右；同时在取消转换为传动后力矩这一操作后，转速也较之前有了明显的降低，说明各部件之间连接在动力学实际运作过程中的影响不可忽略，主要是由于各传动部件存在质量且相互的配合之间会产生摩擦。 （2）增加飞轮与支架在旋转时产生的摩擦 综合各因素的调整与尝试，发现在各部件的传动摩擦中只有飞轮与支架之间由于飞轮旋转而产生的摩擦对于整体装置运作的影响相对较大，因此加上原本设置的气缸——做功活塞与做功活塞——排气活塞间摩擦（动摩擦系数均设置为0.5），运行Simulink仿真有如下结果： 观察图线可以发现，增加传动摩擦后，转速在短暂增长（由于初始转矩）后迅速衰减，并在0.34s左右停止转动。 为改变这一现象，计划采取润滑的方式降低动摩擦系数，因此在设置时将动摩擦系数降为0.2，重新运行Simulink仿真，转速图线结果如下： 观察图线可知，当摩擦系数降低后，转速衰减速率也明显降低，但仍有明显衰减且在2.5s左右发生反转现象，且转速逐渐增大。 （3）反转带来的反思——改变初始力矩方向（符号） 根据上述图线，我们发现在0.1s初始力矩作用后正向转速达到最大值，此后却一直衰减直至反向，而飞轮反向旋转后转速却一直增大，且在5s仿真末尾阶段有逐渐平稳的趋势。因此，我们考虑将初始力矩的符号改变（即方向更改）观察仿真效果如下（设置torque=0.05)： 可以发现，在初始力矩反向之后，转速的方向也随之改变，且在初始力矩施加的0.1s后迅速趋于平稳，稳定后转速平均值在**1100rpm左右，仍然大于热力学计算中理论所需的最低转速573.6rpm，满足设计要求**。 该情况下对应的推力force与转角theta图线如下图所示： 五、感悟与总结通过完成本次动力学仿真，对于斯特林发动机的热力循环过程以及机械转动部分的运作过程有了更加细致和深刻的理解，同时也通过函数的编写与变量的选取对于定量计算中的细节有了更深刻的把握。特别是Adams仿真过程中在建立变量（系统单元）时对于角度和角速度测量的坐标系选取，非常考验对于体系运动过程中细节的把握，究竟是哪个点绕着哪个点转才是正确的角速度，只有正确选取才可能得到正确的结论；单位换算也是仿真过程中的一大难点，不仅要在Adams中对于默认的单位进行修改，还要在MATLAB中编写对应的函数完成转换（Simulink图中的MATLAB Function图标中的函数内容），才可以得到正确的数值结果。除此之外，整个仿真过程中由于涉及到两个软件的联动，对于电脑的性能与配置也有不小的要求（具体体现为把MATLAB和Adams都重装了至少三遍最后还是被迫在别人的电脑上完成，说来也神奇，同样的模型，同样的代码，传到别人电脑上就能跑，我的就不行）。 在完成了整套仿真的流程并得到了正确的数值与图线结果后，还需要针对我们所需要的性能，结合实际情况的可行性，对于对应参数进行修改。经过不断的尝试和摸索，目前有如下的初步结论： （1）调大飞轮的质量（改变材质，增大材料密度而不改变原本飞轮的尺寸设计），可以使得转速在稳定后的周期性波动幅度明显减小； （2）为贴近真实情况，应该直接采用气体膨胀压缩对活塞的推力作为输入变量进入Adams仿真系统中进行仿真，转速会比转换为等效转矩作用于飞轮上的更低（因为传动部件本身具有的质量不可忽略，且各部件间存在摩擦）； （3）传动部分的摩擦损耗主要体现在飞轮在旋转过程中与支架的摩擦力； （4）如果代入铝材间原有的摩擦系数，发动机无法正常工作，需要通过加润滑油等方式来实现摩擦系数的降低； （5）初始力矩对应的是发动机在预热阶段用手拨动飞轮产生的驱动力，该转矩会直接影响飞轮在发动机工作初期的转速，并对后续的稳定转速产生一定的影响；因此给定的初始力矩要与后续气体推力对应的等效转矩浮动范围尽可能贴近，以免出现开始时转速突增的现象； （6）改变气缸与活塞的设计尺寸也能显著改变稳定后的转速，但并不建议这么做，因为需要每次重新导入对应修改后尺寸参数的新模型进行Adams中连接的创立，同时对于加工方面频繁的尺寸修改也不是长久之计。 总而言之，装置的转速与气缸与活塞的尺寸、飞轮质量（转动惯量）、摩擦系数等多方面因素有关。这次的仿真也指导了我们在后续的设计与加工过程中进行进一步的改进，并为发动机整体功率是否满足设计要求从计算上给出了合理的科学依据。","link":"/2023/12/10/%E6%9C%BA%E6%A2%B0%E7%B3%BB%E7%BB%9F%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F/"},{"title":"课题：斯特林发动机热力循环计算及分析","text":"根据选定的斯特林发动机类型，确定具体的传动机构，开展斯特林发动机的热力循环计算；从最大化斯特林发动机单次循环的输出功角度出发，优化斯特林发动机系统所涉及的传动机构、相位角等参数。 一、背景介绍通过学习本课程，我们需要完成斯特林发动机的设计与制造过程，在此过程中掌握工程设计全流程中的基本技能。之所以选择斯特林发动机，是因为能够将热能转化为机械能，并具有以下特点： 效率高：斯特林发动机的热效率相对较高，与理论上最高热效率的卡诺循环相同，实际中可以达到30%以上，远高于传统内燃机； 噪音低：斯特林发动机工作过程中没有爆炸过程，工作过程相对平滑，噪音和振动较小； 热源多：斯特林发动机作为一种外燃机，可以直接利用任何可用热源，如太阳能、地热能与生物质能等可再生能源； 排放少：斯特林发动机在工作过程中没有直接燃烧，为闭口系统，工质环境友好，没有任何有害物排放； 寿命长：连续运行，安全可靠，对高温侧材料要求较高。 斯特林发动机的概念可以追溯到19世纪初，但由于技术限制和市场竞争，长期以来并没有像内燃机那样广泛应用。最近，随着对环保和能源效率的关注不断增加，斯特林发动机再次引起了一些研究兴趣，在水下动力、太阳能动力、空间站动力、热泵空调动力，车用混合推进动力等方面得到了广泛的研究与重视，并且已得到了一些成功的应用。 斯特林发动机按照结构可分为α型、β型和γ型三类，其中α型又称为双动力活塞式发动机，β型和γ型又称为配气活塞式发动机。 通过对于三种类型发动机的基本结构和工作原理的分析与比较，我们最终选择β型斯特林发动机进行实际设计制作。同时考虑到整体项目要求、制作难度与成本等方面，选择单作用斯特林发动机进行制作。 β型斯特林发动机属于配气活塞式发动机，基本结构中包含配气与动力（做功）两种活塞。其中，配气活塞只起到配气作用，并不对外做功，其上下两端压力一致，用于使工质在循环回路中来回流动；动力活塞上、下两腔气压差很大，必须进行密封处理。 斯特林发动机的基本工作原理为斯特林循环。理想的斯特林循环主要包括定温压缩、定容吸热、定温膨胀和定容放热共四个过程，其中两个为定温过程，两个为定容过程： 定温压缩：工作气体在活塞的压力作用下被压缩，使得气体温度降低； 定容吸热：压缩后的工作气体通过外部热源加热，吸收热能，温度升高； 定温膨胀：加热后的工作气体在活塞的推动下膨胀，产生机械功，带动发电机等设备工作； 定容放热：膨胀后的工作气体通过冷却器冷却，使其温度降低，回到压缩前的状态。 上述四个过程循环往复，共同构成斯特林循环。为了确定并验证我们所初步设计的发动机模型能否满足课题要求的最大输出功率达到0.5W，我们需要分析研究在设定条件（与实际设计结构一致）下单次斯特林循环的输出功，并通过计算结果返回迭代传动结构、尺寸与相位角等参数的设计与确定，以实现斯特林发动机单次循环输出功的最大化。 二、物理模型本报告将给出根据我们目前设计的具体结构参数计算的单次斯特林循环输出功，并建立目标函数通过优化相位角等参数最大化单次循环输出功。 传动机构传动机构方面，我们采用曲柄连杆机构，基本的物理模型图与我们的设计建模图如下： 上述设计的相关参数如下： 【1】连杆比λ： 通过实际加热测试测定，四个过程状态下活塞的位置参数大致如下： （1）定温压缩 （2）定容吸热 （3）定温膨胀 （4）定容放热 根据以上实际测试结果，可得到配气活塞行程s=20-5=15mm，动力活塞行程S=54-24=30mm，我们将其设计为与连杆机构活塞位移最大值 max（x）=2R=30mm一致，于是有曲柄半径R=15mm，再设定连杆长度L=100mm，可得到连杆比λ=R/L=0.15； 【2】转速初步设定为n=120r/min； 【3】气缸内部半径为1cm（与动力活塞一致），长度为24mm; 【4】排气活塞半径为0.8cm，长度为20mm。 热力学模型为分析整个斯特林循环过程，结合我们以上的模型设计，给出如下热力学参数与假设： （1）系统气密性良好、无泄漏；气缸内部半径为1cm，长度为24mm，因此未进行加热时，内部初始的工质（空气）体积，由此可得到工质总质量为(空气密度为1.29kg/m3)； （2）工质为理想气体，气体常数为，比热容为； （3）通过Ansys静态热力学仿真分析（如图），在给定特定酒精灯热源的情况下，根据设计的气缸活塞模型（加上散热片），得到工质等温膨胀及等温压缩过程的温度分别为和； （4）系统等容加热及等容冷却过程的体积（如状态位置参数图所示）之比为=54mm/24mm； （5）忽略循环过程中的各种不可逆性。 三、循环计算分析理论情况在背景介绍中提到，一次斯特林循环主要分为四个过程，接下来将结合p-v图与物理模型中提到的实际参数数据对四个过程依次进行分析： 理论p-v图： 根据斯特林循环理论，有如下过程与单次循环做功计算结果： （1）1-2：定温压缩过程 （2）2-3：定容吸热过程 （3）3-4：定温膨胀过程 （4）4-1：定容放热过程 通过综合考虑由以上四个过程循环往复进行的斯特林循环，可以初步计算得出单次斯特林循环理论所作功为 在此情况下，若设定转速为n=120r/min=2r/s，则此时该斯特林发动机的功率P=0.389*2=0.778W&gt;0.5W，故此设计方案理论上符合项目功能要求。 特别的，如果回热器性能完全（即回热器效率ηR=1），则有Qin=Q34=1.382J，此时可计算得出该斯特林循环的单次做功效率为η=Wi/Qin=28.1%。 实际情况无法达到理想的等温或定容过程，因此需要借助史密特理论进行计算才能更接近真实情况下的单次循环做功大小。 基于史密特理论，暂时设定相位角为90°，可以得到实际中的p-v图如下（设定气缸内气体压强最小值即初始压强pmin为标准大气压=100kPa)： 根据理论推导公式，编写代码如下： 123456789101112131415161718192021222324252627afa=pi./2; theta=0:0.1:pi*2; tc=439; te=611; vse=15.*pi; vsc=30.*pi; ve=vse.*(1-cos(theta))./2; vb=(vse+vsc)./2-sqrt((vse.*vse+vsc.*vsc)./4-vse.*vsc.*cos(afa)./2); vc=vse.*(1+cos(theta))./2+vsc.*(1-cos(theta-afa))-vb; vr=(1-0.64).*20.*pi; tao=tc./te; k=vsc./te; xb=vb./vse; x=vr./vse; fai=atan(k.*sin(afa)./(1-tao-k.*cos(afa))); s=tao+4.*tao.*x./(1+tao)+k+1-2.*xb; b=sqrt(tao.*tao+2.*k.*(tao-1).*cos(afa)+k.*k-2.*tao+1); deta=b./s; pmin=100000; p=pmin.*(1+deta)./(1-deta.*cos(theta-fai)); v=ve+vr+vc; figure; plot(v,p); xlabel('体积V（mm^3）'); ylabel('压强P（Pa）'); title('α=90°时P-V图线'); w=pmin.*vse.*pi.*deta.*(1-tao).*sin(fai).*sqrt(1-deta)./((1+sqrt(1-deta.*deta)).*sqrt(1+deta))/1000000; 通过运行上述代码段，可以得到如上图所示的p-v图线，并计算出此时单次斯特林循环的实际做功大小W=0.1429J。 在此情况下，若设定转速为n=120r/min=2r/s，则此时该斯特林发动机的功率P=0.1429*2=0.2858W&lt;0.5W，故此设计方案理论上暂不符合项目功能要求；但若增加转速至n’=P0/W=3.5r/s=210r/min，即可满足设计要求。 四、优化在上述的设计过程中，我们将曲柄连杆机构中曲柄的半径设计为活塞在气体膨胀压缩过程中运动的最大距离（即行程）的一半，并设定相位角（排气器活塞与动力活塞的相位差角度值）为90°（依据已有的设计经验）。事实上，通过分析史密特理论的计算式不难发现，随着相位角的改变，最终计算出的单次循环所作功也发生改变，因此在优化时需要通过绘制W-α图像直观反映二者间的关系，并找到合适的相位角α值以最大化单次循环所作功W。 以下是设计的MATLAB代码与绘制的对应图像： 1234567891011121314151617181920212223242526afa=0:0.1:pi*2;theta=0:0.1:pi*2;tc=439;te=611;vse=15.*pi;vsc=30.*pi;ve=vse.*(1-cos(theta))./2;vb=(vse+vsc)./2-sqrt((vse.*vse+vsc.*vsc)./4-vse.*vsc.*cos(afa)./2);vc=vse.*(1+cos(theta))./2+vsc.*(1-cos(theta-afa))-vb;vr=(1-0.64).*20.*pi;tao=tc./te;k=vsc./te;xb=vb./vse;x=vr./vse;fai=atan(k.*sin(afa)./(1-tao-k.*cos(afa)));s=tao+4.*tao.*x./(1+tao)+k+1-2.*xb;b=sqrt(tao.*tao+2.*k.*(tao-1).*cos(afa)+k.*k-2.*tao+1);deta=b./s;pmin=100000;p=pmin.*(1+deta)./(1-deta.*cos(theta-fai));v=ve+vr+vc;w=pmin.*vse.*pi.*deta.*(1-tao).*sin(fai).*sqrt(1-deta)./((1+sqrt(1-deta.*deta)).*sqrt(1+deta))/1000000;plot(rad2deg(afa),w)xlabel('相位角α（°）');ylabel('单次循环所作功W（J）');title('单次循环所作功W随相位角α的变化关系图线'); 由图像可见，当相位角α=51.6°左右时，单次循环所作功达到最大值Wmax=0.169J，较原先相位角为90°的方案有所提升，只需要转速达到nmin=P0/Wmax≈2.96r/s=178r/min即可满足设计功能要求，实现了优化效果。 五、总结在本次课题任务中，借助了热力学方法研究气缸内的封闭气体，从而对于我们小组初步设计的β型斯特林发动机模型的动力（做功）性能进行了一定的评估分析，并在此基础上通过MATLAB工具绘制函数图像，通过对于目标函数的优化以指导我们进行结构上的进一步改进以提升性能。 在热力学分析过程中，从斯特林循环的四个基本环节入手，结合我们设计的气缸、活塞等尺寸参数、实际测试得到的经验参数以及简单的传动机构设计（曲柄连杆机构），从理论分析逐步逼近实际，最终借助一阶的史密特等温分析方法理论实现了较为接近实际的计算模拟，得到了单次斯特林循环对外做功的数值解从而给出达到目标功率所需要设定的飞轮转速。 同时，在此基础上，通过改变相位角等参数，基于史密特理论中单次循环做功的计算公式，得到了可以进行优化（求极值）的目标函数，并得到了当前尺寸参数下的最大单次循环做功及其对应的相位角，有效实现了基于理论计算的迭代与优化。","link":"/2023/11/12/%E6%96%AF%E7%89%B9%E6%9E%97%E5%BE%AA%E7%8E%AF/"},{"title":"课题：发动机驱动部件的制作（气缸）","text":"一、需求分析β型斯特林发动机是一种热机，通过气体的循环膨胀和压缩过程来产生功。气缸作为该发动机的核心部件之一，承担了容纳工作气体和推动活塞的重要职责，将工质气体受热膨胀的能量转化为机械功。本文旨在分析β型斯特林发动机气缸的工作原理及相关参数的确定与结构设计以满足一定的性能要求，同时在此过程中提升对气体膨胀做功及整个过程中密封、摩擦、公差设计、基本加工工艺、材料传热性能乃至动力学等的认识。 广义的设计要求 高热效率: 气缸必须具备高效的热传导和隔热性能，以确保最小的热能损失和高工作效率。 耐高温性: 由于斯特林发动机工作温度较高，气缸的材料需要能够承受高温环境，同时保持结构稳定。 公差精度: 在气缸的内径、外径和活塞直径等关键尺寸上需要达到高精度的公差，以确保气缸和活塞的匹配度。 耐腐蚀性: 考虑到工作气体可能包含腐蚀性物质，气缸的材料应耐腐蚀，以延长使用寿命。 轻量化: 尽量降低气缸的质量，以减小发动机的整体质量，提高机动性。 制造工艺: 采用精密的机械加工工艺，以确保气缸内外表面的平滑度和尺寸精度。 热传导设计: 优化气缸的热传导设计，以提高热能的传递效率。 具体的设计要求针对最终需要完成的斯特林发动机，需要满足如下几条设计指标与功能要求： 最大输出功率: 不小于0.5W 热源:普通酒精灯 连续运行时间:不小于30分钟 密封性能: 气缸必须能够有效密封工作气体，具有良好的密封性能以确保高效的热循环过程。 材料选择: 选择常用的适当材料与零部件以满足高温环境下的性能需求。 满足这些需求将有助于确保β型斯特林发动机的性能优越，同时提高其在各种应用领域的适用性。制作气缸需要综合考虑这些需求，并在制造过程中严格控制相关参数，以获得卓越的产品性能。 二、方案提出1. 加工方式——机加工选用机加工方法制作缸筒与活塞的理由如下： 精确尺寸控制：机加工可以实现非常高的尺寸精确度，确保气缸内径和活塞直径的精确匹配。这是确保气缸与活塞之间的紧密密封以及减少能量损失的关键。精确尺寸控制也有助于降低磨损，延长气缸和活塞的寿命。 表面质量：机加工可以产生平滑、光洁的表面，减少摩擦和磨损。这对于斯特林发动机的效率至关重要，因为高效的热循环需要最小的摩擦损失。 公差控制：机加工允许对关键尺寸的公差进行严格控制，确保气缸和活塞的尺寸在允许范围内，从而确保它们可以良好地配合。公差控制还有助于提高气缸和活塞的互换性，降低制造成本。 材料选择：机加工允许使用各种高强度、耐高温材料，如高温合金或陶瓷，以满足斯特林发动机在高温工作环境下的要求。这有助于提高耐高温性，确保气缸和活塞在极端条件下保持结构稳定。 加工复杂几何形状：斯特林发动机的气缸和活塞通常具有复杂的几何形状，以实现最佳性能。机加工可以实现这些复杂形状，包括内部凹凸和特殊的密封表面，以确保气缸能够有效地容纳工作气体。 总的来说，机加工满足了精确性、表面质量、公差控制、材料选择和复杂几何形状等多个需求，这些需求都对斯特林发动机的性能和产品质量产生显著影响。通过机加工，可以确保气缸和活塞能够稳定、高效地工作，从而提高发动机的性能和可靠性。 2. 装置主要部件确定β型斯特林发动机是一种热机，其原理基于气体的周期性膨胀和压缩过程，使发动机能够执行其热循环，将热能转化为机械能。基于实际的需求与制造情况，为方便后期接入整个斯特林发动机，考虑到β型斯特林发动机的基本工作原理，本驱动部件主要由如下四个主要部分构成： 气缸：气缸是β型斯特林发动机的关键组成部分，用于容纳和引导工作气体，包括热源和冷源。在工作过程中，气体会经历周期性的膨胀和压缩，这需要一个容器来容纳和引导气体。因此，气缸是必不可少的。 排气活塞：排气活塞是β型斯特林发动机的重要组成部分，它在工作过程中与冷源接触，以帮助气体压缩。排气活塞的运动导致气体的压缩，从而提供负功。它的存在有助于形成热循环，从而使发动机能够持续工作。 做功活塞：做功活塞是另一个重要的部件，它与热源接触，推动气体膨胀，从而提供正功。做功活塞的运动是热机的关键部分，因为它将热能转化为机械功，实现发动机的工作。 散热片：散热片在β型斯特林发动机中的必要性主要取决于工作条件和设计要求。由于发动机工作时产生热量，散热片用于冷却气缸和活塞，以确保它们不过热。如果不进行散热，发动机温度将升高，可能导致性能下降、部件损坏或设备故障。因此，散热片在保持发动机温度稳定和可控的情况下是必要的。 这些部件共同协作，构成了发动机的关键部分，使β型斯特林发动机能够将热能转化为机械能，并提供功率输出。 3. 材料选择基于需求分析与相关指标的要求，综合考虑各材料的导热性能与相关参数，基于这两种材料的特性和性能在斯特林发动机应用中的相对优势，最终选择**不锈钢-304材料用于制作活塞、铝合金-0001材料用于制作气缸**，理由如下： 不锈钢-304用于活塞制作： 高耐磨性和耐腐蚀性：不锈钢-304是一种耐磨性和耐腐蚀性较高的材料，这在活塞的应用中是非常重要的。不锈钢的表面抵抗摩擦和腐蚀，有助于提高活塞的寿命。 高强度：不锈钢-304具有相对较高的强度，这对于承受活塞运动和高压力的应力非常重要。这有助于确保活塞的结构稳定性。 高温稳定性：不锈钢-304在一定温度范围内表现出良好的稳定性，这对于斯特林发动机在高温环境下的应用非常有利。 可加工性：不锈钢-304相对容易加工，使其适合制作复杂几何形状的活塞，以满足特定的设计需求。 铝合金-0001用于气缸制作： 轻质高导热性：铝合金-0001具有较低的密度，因此相对轻便，有助于降低整个发动机的质量。此外，铝合金具有良好的导热性，其导热系数相对于其他材料而言更高，可以有效地传导热量，有利于优化发动机的热传导性能。 耐高温性：虽然铝合金的熔点较低，但在典型的斯特林发动机工作温度范围内，铝合金-0001表现出足够的耐高温性。此外，铝合金在高温下也能保持较好的强度。 可加工性：铝合金易于加工，因此可以比较容易地制造气缸的复杂几何形状，以确保其密封性和热性能。 这样的选择有助于确保活塞和气缸能够在高温、高压和高效率的工作环境下稳定运行，并且提高了产品的寿命和性能。 除此之外，考虑到成本、加工难度与加工时间等客观限制条件因素，这两种材料也易于获取与加工，有效控制了整个制造过程的经济与时间成本。 4. 散热片的型号选择与相关尺寸的确定散热片的主要作用是从热源（如电子元件、发动机、LED等）吸收热量，并将其有效地散发到周围环境中。使用散热片的主要原因： 保持温度稳定：散热片有助于保持热源的温度在可接受范围内。过高的温度可能导致设备故障或元件损坏，因此散热片对于稳定运行至关重要。 延长寿命：有效的散热可以延长设备和元件的寿命。高温环境可能导致元件老化，降低其寿命。通过散热片，可以有效地冷却元件并延长其寿命。 提高性能：在高温环境下，设备性能通常下降。通过散热片，可以确保设备在更长时间内保持高性能，以满足连续运行时间的需求。 安全性：一些应用中，如电子设备，高温可能导致火灾或其他安全问题。散热片有助于维持较低的温度，减少了潜在的安全风险。 考虑到制造过程的时间和经济成本有限，计划设计的大致尺寸均较小；同时为了提升散热效率，决定选用现成的特定型号的散热片，并根据散热片的相关尺寸参数确定设计的气缸与活塞的具体尺寸数据。如下图1所示，是本项目中所选用的散热片，其外径为32mm，内径为17mm，厚度为10mm。 图1：散热片型号选择 在确定了选用的散热片内径为17mm后，计划制造的气缸外径也随之确定为17mm。为尽可能地提高传热效率，气缸的侧壁厚应尽量小，在此设定为2mm。于是做功活塞的外径也随之确定为17-2=15mm。除此之外，排气活塞的圆柱长杆半径也应与做工活塞的孔洞内径保持一致，设定为5mm；排气活塞的活塞头半径应大于圆柱长杆半径且小于气缸内径，在此设定为12mm。 5. 热力学参数分析假设： 圆柱形气缸的半径 r=15mm=0.015m。 圆柱形气缸底部与排气活塞顶部之间的预留距离 L*=30mm=0.03m。 工质气体是空气。 温度差 ΔT = 高温 - 低温。 假设在气缸内，高温 T*h= 525°C = 798K，低温 Tc = 25°C = 298K（外部环境温度）。 以下是计算功率的推导过程： （1）计算气缸的截面积 A：A=π⋅r*^2=*π⋅(0.015m)^2≈7.07×10−4m2 （2）计算气缸内原有的空气的体积 V：V=A⋅L=(7.07×10−4m2)⋅(0.03m)=2.12×10−5m3 （3）计算气缸内的气体摩尔数 n。使用理想气体状态方程：PV=n R T 其中，P 是气体压力， V 是体积， n 是摩尔数， R 是气体常数， T 是温度。 解出 n：n=PV/RT 其中，P 可以根据工作条件确定， T 是绝对温度， R 是空气的气体常数。 （4）计算热力学效率 η，根据斯特林循环的定义：η=1−Tc/Th 其中，Tc 和 Th 分别是低温和高温的绝对温度。Tc=298K ,Th=798K 于是有η≈0.625 （5）计算气缸内的热量 Qh 和 Qc。根据斯特林循环的热量关系： Qh=Qc=n⋅Cp⋅ΔT 其中，Cp 是空气的定压比热容。Cp≈1005J/(kg*K) ΔT=Th−Tc=798K−298K=500K Qh=Qc=n⋅Cp⋅ΔT≈PV⋅Cp⋅Δ*T/RT （6）计算功率 P。功率是通过工质气体对气缸内工作物体做功而获得的热量。 斯特林发动机的热功率可以通过以下公式计算： P=Qh⋅η−Qc⋅η P=n⋅Cp⋅ΔT⋅η P≈P⋅V⋅Cp⋅ΔT⋅η/（R⋅T） 代入已知值，可计算得到功率 P 的数值解：**P≈0.839W&gt;0.5W，满足制造与设计需求。** 三、样机制作1. Fusion360 建模基于以上的设计方案，进一步细化各个部件各部分的尺寸，分别进行做功活塞、排气活塞与气缸的三维建模并结合已有的特定型号散热片完成总装，如下图2、3、4、5所示。图6为总装整体部件的剖面图。 图2：做功活塞建模效果图 图3：排气活塞建模效果图 图4：气缸建模效果图 图5：总装建模效果图 图6：总装剖面图 2. 图纸绘制为进一步将建模得到的部件模型通过机加工的方式制造出来，还需要进行工程制图以便进一步的加工与修改并最终提交给厂家进行制作。做功活塞、排气活塞与气缸的图纸如下图7、8、9所示。 图7：做功活塞工程图 图8：排气活塞工程图 图9：气缸工程图 在完成工程图后，与加工制造厂家确认尺寸无误后，按照以上图纸开始投入加工，历时半个月拿到加工完成的样机，并在公差的基础上对于个别部件进行简单的车削处理使各部分能够紧密连接并尽可能地减小摩擦力。 四、最终效果各部件加工效果如下图10、11、12所示，最终总装效果图如图13所示。 图10：做功活塞实物图 图11：排气活塞实物图 图12：气缸实物图 图13：总装实物图 其中做工活塞在加工时出现错误，中间的连杆原本设计为圆筒形，加工时外层错加工为正方形，但并不影响整体性能。 1020实际测试更新版测试视频见附件：气缸活塞演示视频 图14：测试始态与终态对比图 测试结果：在加热至18秒左右时，做功活塞有明显的运动，并在之后持续对外做功 通过实际验证实验可知，**在排气活塞预留30mm空气柱的情况下，对于气缸底部受热段进行一定时间的预热与加热，做功活塞可以成功被推出，并以一定的功率对外做功，满足基本设计需求。** 但由于未做密封圈等进一步设计，该驱动部件的气密性并不是特别良好，且做功活塞与气缸壁之间以及排气活塞与做功活塞之间的摩擦力相对较大，因此实际测试过程中并未达到理论计算的功率结果，需要在后续发动机的整体制造中进行进一步的设计改进。 五、总结在本项目中，成功制作了β型斯特林发动机的基本驱动部件：气缸与活塞，整体装置由排气活塞、做功活塞、气缸和散热片四个部件组成。在制作过程中，主要完成了从分析需求与设计要求，到提出具体的设计方案，再到实际建模确定具体尺寸参数并绘制工程图纸以进行机加工，最终完成了整个驱动部件的制造。在设计的同时也对确定的参数进行了一定的热力学数值分析进行验证使得制造出的部件能够初步满足最终斯特林发动机输出功率等方面的性能要求。 通过完成本次项目课题，对于气体受热膨胀做功有了更深层次的认识并将这一热力学原理成功运用于设计与制造实践中，同时也提升了对密封、摩擦、公差设计、基本加工工艺、材料传热性能等多方面的认识。该驱动部件的成功制作也为后续斯特林发动机的整体制造完善与效果参数实现打下了良好的基础，有助于后续进一步设计与制造流程的开展。 在本次项目课题中，从自己设计、建模出图纸到寻找加工方再到最终成品的组装与测试，大体完成了金属件从设计到加工再到实际测试的全流程。最终的测试结果并不算令人满意，主要是由于在设计阶段缺乏对于气密性的考虑，并未进行密封圈的设计与选型，特别是β型斯特林发动机的驱动部件，由于其有做功与排气两个活塞，两个活塞连杆之间的空隙也对整体装置的气密性造成了一定影响。除此之外，在图纸设计过程中，缺乏公差的预留也让最终加工出的成品在组装时遇到了一些小的瑕疵，进行了局部的二次微小加工才顺利完成安装，并在气密性上带来了一定的影响。不过也正是因为完成该驱动部件的制作，才能在实际的操作过程中体会到加工过程中可能存在的问题，这也有利于后面在发动机整体的一代与二代样机的过程中减少不必要的时间与加工成本，少走弯路。相信这次加工制作中所遇到的问题能在接下来的完整样机制作中得到进一步解决。","link":"/2023/10/13/%E6%B0%94%E7%BC%B8%E6%B4%BB%E5%A1%9E%E6%8A%A5%E5%91%8A/"},{"title":"3.线性神经网络","text":"3.1 线性回归123456789101112131415161718192021222324252627282930313233343536373839%matplotlib inlineimport mathimport timeimport numpy as npimport torchfrom d2l import torch as d2ln=10000a=torch.ones([n])b=torch.ones([n])#定义计时器class Timer: #@save #记录多次运行时间 def __init__(self): self.times=[] self.start() def start(self): #启动计时器 self.tik=time.time() def stop(self): #停止计时器并将时间记录在列表中 self.times.append(time.time()-self.tik) return self.times[-1] def avg(self): #返回平均时间 return sum(self.times)/len(self.times) def sum(self): #返回时间总和 return sum(self.times) def cumsum(self): #返回累计时间 return np.array(self.times).cumsum().tolist() 12345c=torch.zeros(n)timer=Timer()for i in range(n): c[i]=a[i]+b[i]f'{timer.stop():.5f}sec' '0.14660sec' 123timer.start()d=a+bf'{timer.stop():.5f}sec' '0.00000sec' 12345678910def normal(x,mu,sigma): p=1/math.sqrt(2*math.pi*sigma**2) return p*np.exp(-0.5/sigma**2*(x-mu)**2)#再次使用numpy进行可视化x=np.arange(-7,7,0.01)#均值和标准差对params=[(0,1),(0,2),(3,1)]d2l.plot(x,[normal(x,mu,sigma)for mu,sigma in params],xlabel='x',ylabel='p(x)',figsize=(4.5,2.5),legend=[f'mean{mu},std{sigma}'for mu,sigma in params]) ​​ 3.2 线性回归的从零开始实现123456789101112131415161718%matplotlib inlineimport randomimport torchfrom d2l import torch as d2l#生成数据集def synthetic_data(w,b,num_examples): #@save #生成y=Xw+b+噪声 X=torch.normal(0,1,(num_examples,len(w))) y=torch.matmul(X,w)+b y+=torch.normal(0,0.01,y.shape) return X,y.reshape((-1,1))true_w=torch.tensor([2,-3.4])true_b=4.2features,labels=synthetic_data(true_w,true_b,1000)print('features:',features[0],'\\nlabel:',labels[0]) features: tensor([ 0.7328, -0.5520]) label: tensor([7.5513]) 12d2l.set_figsize()d2l.plt.scatter(features[:,1].detach().numpy(),labels.detach().numpy(),1); ​​ 123456789101112131415#读取数据集def data_iter(batch_size,features,labels): num_examples=len(features) indices=list(range(num_examples)) #这些样本是随机读取的，没有特定顺序 random.shuffle(indices) for i in range(0,num_examples,batch_size): batch_indices=torch.tensor(indices[i:min(i+batch_size,num_examples)]) yield features[batch_indices],labels[batch_indices] batch_size=10for X,y in data_iter(batch_size,features,labels): print(X,'\\n',y) break tensor([[ 0.9175, -0.1441], [-0.3328, -0.4237], [-0.1287, 1.6801], [ 0.8705, -0.9030], [-0.4966, 1.4015], [ 1.3378, -1.8026], [ 0.5129, 1.2806], [ 1.1026, 1.2080], [ 0.6151, 0.6337], [-0.4683, -0.4388]]) tensor([[ 6.5336], [ 4.9801], [-1.7645], [ 9.0089], [-1.5652], [12.9979], [ 0.8680], [ 2.2893], [ 3.2902], [ 4.7695]]) 123456789101112131415161718192021222324252627282930313233343536373839#初始化模型参数w=torch.normal(0,0.01,size=(2,1),requires_grad=True)b=torch.zeros(1,requires_grad=True)#定义模型def linreg(X,w,b): #@save #线性回归模型 return torch.matmul(X,w)+b#定义损失函数def squared_loss(y_hat,y): #@save #均方损失 return(y_hat-y.reshape(y_hat.shape))**2/2#定义优化算法——小批量随机梯度下降#lr:学习速率(梯度下降步长)；batch_size:批量大小def sgd(params,lr,batch_size): #@save #小批量随机梯度下降 with torch.no_grad(): for param in params: param-=lr*param.grad/batch_size param.grad.zero_() #训练#设置超参数lr=0.03#学习率num_epochs=3#迭代周期个数net=linregloss=squared_lossfor epoch in range(num_epochs): for X,y in data_iter(batch_size,features,labels): l=loss(net(X,w,b),y)#X和y的小批量损失 #因为l的形状是（batch_size,1），而不是一个标量。l中的所有元素被加到一起，并以此计算关于[w,b]的梯度 l.sum().backward() sgd([w,b],lr,batch_size)#使用参数的梯度以更新参数 with torch.no_grad(): train_l=loss(net(features,w,b),labels) print(f'epoch{epoch+1},loss{float(train_l.mean()):f}') epoch1,loss0.036941 epoch2,loss0.000134 epoch3,loss0.000049 12print(f'w的估计误差：{true_w-w.reshape(true_w.shape)}')print(f'b的估计误差：{true_b-b}') w的估计误差：tensor([ 0.0002, -0.0002], grad_fn=&lt;SubBackward0&gt;) b的估计误差：tensor([0.0002], grad_fn=&lt;RsubBackward1&gt;) 3.3 线性回归的简洁实现1234567891011121314151617181920#生成数据集import numpy as npimport torchfrom torch.utils import datafrom d2l import torch as d2ltrue_w=torch.tensor([2,-3.4])true_b=4.2features,labels=d2l.synthetic_data(true_w,true_b,1000)#读取数据集def load_array(data_arrays,batch_size,is_train=True): #@save #构造一个pytorch数据迭代器 dataset=data.TensorDataset(*data_arrays) return data.DataLoader(dataset,batch_size,shuffle=is_train)batch_size=10data_iter=load_array((features,labels),batch_size)next(iter(data_iter)) [tensor([[-0.6422, -0.7470], [-2.1785, 0.3340], [ 1.4011, -1.1104], [-0.8083, -0.3035], [ 0.1077, -0.1201], [-0.4151, -0.1079], [ 1.8074, 0.0904], [-0.3707, 0.6197], [ 0.3739, 0.2972], [ 0.2383, 1.1791]]), tensor([[ 5.4457], [-1.3122], [10.7837], [ 3.6281], [ 4.8105], [ 3.7284], [ 7.5017], [ 1.3465], [ 3.9247], [ 0.6800]])] 123456#定义模型from torch import nn#nn:神经网络net=nn.Sequential(nn.Linear(2,1))#初始化模型参数net[0].weight.data.normal_(0,0.01),net[0].bias.data.fill_(0) (tensor([[ 0.0106, -0.0055]]), tensor([0.])) 1234#定义损失函数loss=nn.MSELoss()#均方误差：MSELoss类，平方L2范数#定义优化算法trainer=torch.optim.SGD(net.parameters(),lr=0.03) 123456789num_epochs=3#迭代周期个数for epoch in range(num_epochs): for X,y in data_iter: l=loss(net(X),y)#X和y的小批量损失 trainer.zero_grad() l.backward() trainer.step()#使用参数的梯度以更新参数 l=loss(net(features),labels) print(f'epoch{epoch+1},loss{l:f}') epoch1,loss0.000223 epoch2,loss0.000112 epoch3,loss0.000112 1234w=net[0].weight.dataprint('w的估计误差：',true_w-w.reshape(true_w.shape))b=net[0].bias.dataprint('b的估计误差：',true_b-b) w的估计误差： tensor([ 0.0014, -0.0004]) b的估计误差： tensor([0.0008]) 3.5 图像分类数据集12345678%matplotlib inlineimport torchimport torchvisionfrom torch.utils import datafrom torchvision import transformsfrom d2l import torch as d2ld2l.use_svg_display() 12345#通过框架内内置函数将Fashion-MNIST数据集下载并读取到内存中#通过ToTensor实例将图像数据由PIL类型变换为32位浮点数格式，并除以255使得所有像素数值均在0-1之间trans=transforms.ToTensor()mnist_train=torchvision.datasets.FashionMNIST(root=&quot;../data&quot;,train=True,transform=trans,download=True)mnist_test=torchvision.datasets.FashionMNIST(root=&quot;../data&quot;,train=False,transform=trans,download=True) 1len(mnist_train),len(mnist_test) (60000, 10000) 1mnist_train[0][0].shape torch.Size([1, 28, 28]) 123456789101112131415161718192021222324252627#在数字标签索引与文本名称之间进行转换def get_fashion_mnist_labels(labels): #@save #返回Fashion-MNIST数据集的文本标签 text_labels=['t-shirt','trouser','pullover','dress','coat','sandal','shirt','sneaker','bag','ankle boot'] return [text_labels[int(i)] for i in labels]#可视化样本def show_images(imgs,num_rows,num_cols,titles=None,scale=1.5): #@save #绘制图像列表 figsize=(num_cols*scale,num_rows*scale) _,axes=d2l.plt.subplots(num_rows,num_cols,figsize=figsize) axes=axes.flatten() for i,(ax,img) in enumerate(zip(axes,imgs)): if torch.is_tensor(img): #图片张量 ax.imshow(img.numpy()) else: #PIL图片 ax.imshow(img) ax.axes.get_xaxis().set_visible(False) ax.axes.get_yaxis().set_visible(False) if titles: ax.set_title(titles[i]) return axesX,y=next(iter(data.DataLoader(mnist_train,batch_size=50)))show_images(X.reshape(50,28,28),10,5,titles=get_fashion_mnist_labels(y)); ​​ 1234567891011121314#读取小批量batch_size=256 #批量大小def get_dataloader_workers(): #@save #使用4个进程来读取数据 return 4train_iter=data.DataLoader(mnist_train,batch_size,shuffle=True,num_workers=get_dataloader_workers())#读取训练数据所需时间timer=d2l.Timer()for X,y in train_iter: continuef'{timer.stop():.2f}sec' '2.11sec' 1234567891011121314def load_data_fashion_mnist(batch_size,resize=None): #@save #下载Fashion-MNIST数据集，然后将其加载到内存中 trans=[transforms.ToTensor()] if resize: trans.insert(0,transforms.Resize(resize)) trans=transforms.Compose(trans) mnist_train=torchvision.datasets.FashionMNIST(root=&quot;../data&quot;,train=True,transform=trans,download=True) mnist_test=torchvision.datasets.FashionMNIST(root=&quot;../data&quot;,train=False,transform=trans,download=True) return(data.DataLoader(mnist_train,batch_size,shuffle=True,num_workers=get_dataloader_workers()),data.DataLoader(mnist_test,batch_size,shuffle=False,num_workers=get_dataloader_workers()))train_iter,test_iter=load_data_fashion_mnist(32,resize=64)for X,y in train_iter: print(X.shape,X.dtype,y.shape,y.dtype) break torch.Size([32, 1, 64, 64]) torch.float32 torch.Size([32]) torch.int64 3.6 softmax回归的从零开始实现123456import torchfrom IPython import displayfrom d2l import torch as d2lbatch_size=256train_iter,test_iter=d2l.load_data_fashion_mnist(batch_size) 123456#初始化模型参数num_inputs=784num_outputs=10W=torch.normal(0,0.01,size=(num_inputs,num_outputs),requires_grad=True)#用正态分布初始化权重Wb=torch.zeros(num_outputs,requires_grad=True)#偏置b初始化为0 12X=torch.tensor([[1.0,2.0,3.0],[4.0,5.0,6.0]])X.sum(0,keepdim=True),X.sum(1,keepdim=True) (tensor([[5., 7., 9.]]), tensor([[ 6.], [15.]])) 123456789#定义softmax操作def softmax(X): X_exp=torch.exp(X) partition=X_exp.sum(1,keepdim=True) return X_exp/partition #应用广播机制X=torch.normal(0,1,(2,5))X_prob=softmax(X)X_prob,X_prob.sum(1) (tensor([[0.2143, 0.0127, 0.1268, 0.2248, 0.4214], [0.3360, 0.2826, 0.0913, 0.1454, 0.1446]]), tensor([1.0000, 1.0000])) 123#定义模型def net(X): return softmax(torch.matmul(X.reshape((-1,W.shape[0])),W)+b) #使用reshape函数将每张原始图像展平为向量 123y=torch.tensor([0,2])y_hat=torch.tensor([[0.1,0.3,0.6],[0.3,0.2,0.5]])y_hat[[0,1],y] tensor([0.1000, 0.5000]) 12345#定义交叉熵损失函数def cross_entropy(y_hat,y): return - torch.log(y_hat[range(len(y_hat)),y])cross_entropy(y_hat,y) tensor([2.3026, 0.6931]) 12345678def accuracy(y_hat,y): #@save #计算正确预测的数量 if len(y_hat.shape)&gt;1 and y_hat.shape[1]&gt;1: y_hat=y_hat.argmax(axis=1) cmp=y_hat.type(y.dtype)==y return float(cmp.type(y.dtype).sum())accuracy(y_hat,y)/len(y) #正确预测的概率（分类精度率） 0.5 12345678910111213141516171819202122232425def evaluate_accuracy(net,data_iter): #@save #计算在指定数据集上模型的精度 if isinstance(net,torch.nn.Module): net.eval() #将模型设置为评估模式 metric=Accumulator(2) #正确预测数、预测总数的叠加 with torch.no_grad(): for X,y in data_iter: metric.add(accuracy(net(X),y),y.numel()) #accracy(net(X),y):正确预测数；y.numel()预测总数 return metric[0]/metric[1]class Accumulator: #@save #在n个变量上累加 def __init__(self,n): self.data=[0.0]*n def add(self,*args): self.data=[a+float(b) for a,b in zip(self.data,args)] def reset(self): self.data=[0.0]*len(self.data) def __getitem__(self,idx): return self.data[idx] evaluate_accuracy(net,test_iter) 0.1326 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#训练def train_epoch_ch3(net,train_iter,loss,updater): #@save #训练模型一个迭代周期 #将模型设置为训练模型 if isinstance(net,torch.nn.Module): net.train() #训练损失总和、训练准确度总和、样本数 metric=Accumulator(3) for X,y in train_iter: #计算梯度并更新参数 y_hat=net(X) l=loss(y_hat,y) if isinstance(updater,torch.optim.Optimizer): #使用PyTorch内置的优化器和损失函数 updater.zero_grad() l.mean().backward() updater.step() else: #使用定制的优化器和损失函数 l.sum().backward() updater(X.shape[0]) metric.add(float(l.sum()),accuracy(y_hat,y),y.numel()) #返回训练损失和训练精度 return metric[0]/metric[2],metric[1]/metric[2]class Animator: #@save #在动画中绘制数据 def __init__(self, xlabel=None, ylabel=None, legend=None, xlim=None,ylim=None, xscale='linear', yscale='linear',fmts=('-', 'm--', 'g-.', 'r:'), nrows=1, ncols=1,figsize=(3.5, 2.5)): # 增量地绘制多条线 if legend is None: legend = [] d2l.use_svg_display() self.fig, self.axes = d2l.plt.subplots(nrows, ncols, figsize=figsize) if nrows * ncols == 1: self.axes = [self.axes, ] # 使用lambda函数捕获参数 self.config_axes = lambda: d2l.set_axes( self.axes[0], xlabel, ylabel, xlim, ylim, xscale, yscale, legend) self.X, self.Y, self.fmts = None, None, fmts def add(self, x, y): # 向图表中添加多个数据点 if not hasattr(y, &quot;__len__&quot;): y = [y] n = len(y) if not hasattr(x, &quot;__len__&quot;): x = [x] * n if not self.X: self.X = [[] for _ in range(n)] if not self.Y: self.Y = [[] for _ in range(n)] for i, (a, b) in enumerate(zip(x, y)): if a is not None and b is not None: self.X[i].append(a) self.Y[i].append(b) self.axes[0].cla() for x, y, fmt in zip(self.X, self.Y, self.fmts): self.axes[0].plot(x, y, fmt) self.config_axes() display.display(self.fig) display.clear_output(wait=True) def train_ch3(net,train_iter,test_iter,loss,num_epochs,updater): #@save #训练模型 animator=Animator(xlabel='epoch',xlim=[1,num_epochs],ylim=[0.3,0.9],legend=['train loss','train acc','test acc']) for epoch in range(num_epochs): train_metrics=train_epoch_ch3(net,train_iter,loss,updater) test_acc=evaluate_accuracy(net,test_iter) animator.add(epoch+1,train_metrics+(test_acc,)) train_loss,train_acc=train_metrics assert train_loss&lt;0.5,train_loss assert train_acc&lt;=1 and train_acc&gt;0.7,train_acc assert test_acc&lt;=1 and test_acc&gt;0.7,test_acc lr=0.1 #学习率def updater(batch_size): return d2l.sgd([W,b],lr,batch_size)#小批量随机梯度下降num_epochs=10 #迭代周期train_ch3(net,train_iter,test_iter,cross_entropy,num_epochs,updater) ​​ 1234567891011#预测def predict_ch3(net,test_iter,n=6): #@save #预测标签 for X,y in test_iter: break trues=d2l.get_fashion_mnist_labels(y) preds=d2l.get_fashion_mnist_labels(net(X).argmax(axis=1)) titles=[true+'\\n'+pred for true,pred in zip(trues,preds)] d2l.show_images(X[0:n].reshape((n,28,28)),1,n,titles=titles[0:n]) predict_ch3(net,test_iter) ​​ 3.7 softmax回归的简洁实现123456import torchfrom torch import nnfrom d2l import torch as d2lbatch_size=256train_iter,test_iter=d2l.load_data_fashion_mnist(batch_size) 123456789#初始化模型参数#PyTorch不会隐式地调整输入的形状，因此，我们在线性层前定义了展平层（flatten),来调整网络输入的形状net=nn.Sequential(nn.Flatten(),nn.Linear(784,10))def init_weights(m): if type(m)==nn.Linear: nn.init.normal_(m.weight,std=0.01)net.apply(init_weights); 1loss=nn.CrossEntropyLoss(reduction='none') #保留softmax函数，但在计算交叉熵损失函数时传递未规范化的预测并同时计算softmax及其对数以防止数值上溢或下溢 12#优化算法：学习度为0.1的小批量随机梯度下降trainer=torch.optim.SGD(net.parameters(),lr=0.1) 123#训练num_epochs=10d2l.train_ch3(net,train_iter,test_iter,loss,num_epochs,trainer) ​​","link":"/2023/10/05/3.%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"title":"课题：典型建筑墙体的稳态传热分析","text":"一、背景介绍建筑墙体作为建筑的重要组成部分，在维护室内舒适温度和能源效率方面起着重要作用，研究其作用及在传热过程中的特性对生态建筑的可持续发展具有重要的指导意义。发展生态节能建筑最终的目标就是要在满足室内居住者的热舒适基础上降低建筑的能耗，对实际居住者而言较关注的是如何以较低的能耗获得舒适的建筑室内热环境。考虑到当前大部分大型公共建筑、工业建筑与高层住宅的主要承重构件包括梁、板、柱等均采用钢筋混凝土结构，因此本文将着重针对此种结构简化模型的传热过程进行分析。 稳态传热是指传热系统中各点的温度仅随位置而变化，不随时间而改变的传热过程，对于这一传热过程的分析有助于评估墙体在不同环境条件下的隔热性能，其中一个关键参数是环境空气流速。本研究旨在分析单位面积上典型建筑墙体的稳态散热过程，特别关注墙体散热量随环境空气流速的变化关系。 二、物理模型钢筋混凝土墙体结构的物理模型如下图1、2、3所示。 图1：钢筋结构图解 图2：墙体结构物理模型 图3：墙体处传热物理模型 在上述简化模型中，选取房间中心为坐标原点，定义有如下参数： （1）室内方墙高宽比为Ar=L/H； （2）模型左端设有厚度为s的墙体； （3）墙体内侧空气流速为V1，墙体外侧空气流速为V2； （4）墙体内侧温度为Tf1，墙体外侧温度为Tf2，且由于研究室内散热过程，默认Tf1&gt;Tf2； （5）钢筋混凝土结构内表面温度为Tw1，钢筋混凝土结构外表面温度为Tw2，且由于研究室内散热过程，默认Tw1&gt;Tw2。 注意：模型中方腔右侧墙体及上、下墙体均为绝热且不考虑厚度。 三、传热过程分析该简化传热过程主要可以分为以下三个环节： （1）墙体内侧的对流换热该过程为热对流过程，由牛顿冷却公式可得：单位面积墙体上的对流传热量Q1=hΔT1 其中，h为表面对流换热系数，通过查询相关文献与手册（《民用建筑热工设计规范》 GB 50176-2016)可得，当Ar=L/H&lt;=0.3时，空气在钢筋混凝土内表面的对流换热系数约为8.7W/m^2-K；当Ar=L/H&gt;0.3时，空气在钢筋混凝土内表面的对流换热系数约为7.6W/m^2-K（如图4所示）。ΔT1为室内空气温度Tf1与钢筋混凝土内表面的温度Tw1之差。 图4:内表面换热系数αi和内表面换热阻Ri （2）通过墙壁的导热（散热）过程该过程为热传导过程，由傅里叶定律可得：单位面积墙体上的传导热量Q2=λΔT2/Δx 其中，λ为钢筋混凝土结构的导热系数，通过查询相关文献与手册（《民用建筑热工设计规范》 GB 50176-2016)可得其值约为1.74W/m-K；ΔT2为钢筋混凝土内外表面两侧的温度差，由于传热总是自发由高温向低温处进行，故此处特别定义为Tw1-Tw2；Δx则为墙体厚度s。 （3）墙体外侧的对流换热该过程为热对流过程，由牛顿冷却公式可得：单位面积墙体上的对流传热量Q3=hΔT3 其中，h为表面对流换热系数，通过查询相关文献与手册（《民用建筑热工设计规范》 GB 50176-2016)可得，冬季时，空气在钢筋混凝土外表面的对流换热系数约为23.0W/m^2-K；夏季时，空气在钢筋混凝土外表面的对流换热系数约为19.0W/m^2-K（如图5所示）。ΔT3为钢筋混凝土外表面温度Tw2与室外空气温度Tf2之差。 图5:外表面换热系数αe和外表面换热阻Re 全热路过程分析在分别考虑上述三个传热过程环节后，针对整个完整的传热过程，通过查阅相关文献资料（详见《民用建筑热工设计规范》 GB 50176-2016：3.4 基本计算方法），有如下公式： 单位面积墙体上的散热量Q=Q1+Q2+Q3=KΔT； 其中ΔT为室内与室外的温度差值Tf1-Tf2；K为该传热过程的传热系数； 传热系数K=1/R0，R0为整个结构的传热阻值； R0=Ri+R+Re，其中Ri为内表面换热阻，R为钢筋混凝土材料的热阻，Re为外表面换热阻； Ri,Re的一般数值均可查表获得，如上图4、5所示； 通过查阅资料，钢筋混凝土结构的热阻计算可采用公式R=δ/λ，其中δ即为墙壁厚度s，λ查表可得约为1.74W/m-K。 至此即可在给定的条件下计算出单位面积墙体稳态散热量（传热方程与热路图如下图6、7所示）。 图6:传热方程——单位面积墙体稳态散热量的定量表达式 图7:典型建筑墙体稳态传热过程的简化热路图 如需要计算夏季Ar=L/H&gt;0.3的房屋（钢筋混凝土结构），厚度s=0.5m的单位面积墙体稳态散热量，则依据上述数据，取Ri=0.13m^2-K/W,Re=0.05m^2-K/W,λ=1.74W/m-K,则可计算得出总热阻R0≈0.467m^2-K/W，传热系数K≈2.141W/m^2-K，若室内外温差为10K，则可计算得出此时单位面积上墙体的散热量Q约等于21.41W。 值得注意的是，上述数据均取自于实际的民用建筑热工设计规范标准，因此较接近于大部分情况下建筑墙体的实际情况。但事实上，表面对流换热系数的数值与换热过程中流体的物理性质、换热表面的形状、部位以及流体的流速等都有密切关系。物体表面附近的流体的流速愈大，其表面对流换热系数也愈大，一般采用经验公式进行计算。目前相关的参考资料较少，无法给出针对该典型建筑墙体结构的准确的定量计算公式衡量对流换热系数与流体流速之间的数值对应关系，只能进行定性分析与查表获取一般情况。 四、结论通过对于上述分析所得到公式的整理与总结，综合可能影响墙体的表面对流换热系数等关键参数的因素，可以得出如下结论： 墙体导热系数λ和墙体厚度s(δ）的增加都会导致墙体散热量减小。 外部环境空气流速V的增加会增加墙体散热量，尤其是在寒冷的条件下，但暂时无法给出定量的公式分析，不同的场景下该因素对于散热量的影响不同。 对流换热系数h的增加会显著增加墙体散热量，这取决于墙体表面特性和空气性质。 因此，我们可以根据这些分析结果来优化建筑墙体的隔热性能，选择合适的材料、厚度和对流措施，以提高能源效率并确保室内舒适度。在寒冷气候下，特别要注意增加对流传热（可以通过加快内外空气对流的方式）以减少能源损失。","link":"/2023/10/01/%E6%8A%A5%E5%91%8A/"},{"title":"2.预备知识","text":"2.1 数据操作123import torchx = torch.arange(12)x tensor([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) 1x.shape torch.Size([12]) 1x.numel() 12 12X=x.reshape(3,4)X tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 1X.shape torch.Size([3, 4]) 12Y=x.reshape(-1,4)Y tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 12Z=x.reshape(3,-1)Z tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 1torch.zeros((2,3,4)) tensor([[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]], [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]]) 1torch.ones((2,3,4)) tensor([[[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]], [[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]]) 1torch.randn(3,4) tensor([[ 1.6438, -1.2879, 0.2324, 0.2719], [-0.6636, 0.9939, -0.8435, -1.0906], [-0.5617, 0.2107, -0.9530, 0.7362]]) 123x=torch.tensor([1.0,2,4,8])y=torch.tensor([2,2,2,2])x+y,x-y,x*y,x/y,x**y (tensor([ 3., 4., 6., 10.]), tensor([-1., 0., 2., 6.]), tensor([ 2., 4., 8., 16.]), tensor([0.5000, 1.0000, 2.0000, 4.0000]), tensor([ 1., 4., 16., 64.])) 1torch.exp(x) tensor([2.7183e+00, 7.3891e+00, 5.4598e+01, 2.9810e+03]) 12X=torch.arange(12,dtype=torch.float32).reshape((3,4))X tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]]) 12Y=torch.tensor([[2.0,1,4,3],[1,2,3,4],[4,3,2,1]])Y tensor([[2., 1., 4., 3.], [1., 2., 3., 4.], [4., 3., 2., 1.]]) 1torch.cat((X,Y),dim=0) tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [ 2., 1., 4., 3.], [ 1., 2., 3., 4.], [ 4., 3., 2., 1.]]) 1torch.cat((X,Y),dim=1) tensor([[ 0., 1., 2., 3., 2., 1., 4., 3.], [ 4., 5., 6., 7., 1., 2., 3., 4.], [ 8., 9., 10., 11., 4., 3., 2., 1.]]) 1X==Y,X&lt;Y (tensor([[False, True, False, True], [False, False, False, False], [False, False, False, False]]), tensor([[ True, False, True, False], [False, False, False, False], [False, False, False, False]])) 1X.sum() tensor(66.) 123a=torch.arange(6).reshape(3,2,1)b=torch.arange(2).reshape(1,2)a,b (tensor([[[0], [1]], [[2], [3]], [[4], [5]]]), tensor([[0, 1]])) 12c=a+bc tensor([[[0, 1], [1, 2]], [[2, 3], [3, 4]], [[4, 5], [5, 6]]]) 1c[0] tensor([[0, 1], [1, 2]]) 1X[-1],X[1:3] (tensor([ 8., 9., 10., 11.]), tensor([[ 4., 5., 6., 7.], [ 8., 9., 10., 11.]])) 12X[1,2]=9X tensor([[ 0., 1., 2., 3.], [ 4., 5., 9., 7.], [ 8., 9., 10., 11.]]) 12X[0:2,:]=12X tensor([[12., 12., 12., 12.], [12., 12., 12., 12.], [ 8., 9., 10., 11.]]) 123before=id(Y)Y=Y+Xid(Y)==before False 12Z=torch.zeros_like(Y)Z tensor([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) 1print('id(Z):',id(Z)) id(Z): 3055861362752 12Z[:]=X+Yprint('id(Z):',id(Z)) id(Z): 3055861362752 123before=id(X)X+=Yid(X)==before True 123A=X.numpy()B=torch.tensor(A)type(A),type(B) (numpy.ndarray, torch.Tensor) 1A,B (array([[26., 25., 28., 27.], [25., 26., 27., 28.], [20., 21., 22., 23.]], dtype=float32), tensor([[26., 25., 28., 27.], [25., 26., 27., 28.], [20., 21., 22., 23.]])) 12a=torch.tensor([3.5])a,a.item(),float(a),int(a) (tensor([3.5000]), 3.5, 3.5, 3) 123x = torch.arange(12)X=x.reshape(3,2,2)X tensor([[[ 0, 1], [ 2, 3]], [[ 4, 5], [ 6, 7]], [[ 8, 9], [10, 11]]]) 2.2 数据预处理12345678910import osos.makedirs(os.path.join('..', 'data'), exist_ok=True)data_file = os.path.join('..', 'data', 'house_tiny.csv')with open(data_file, 'w') as f: f.write('NumRooms,Alley,Price\\n') # 列名 f.write('NA,Pave,127500\\n') # 每行表示一个数据样本 f.write('2,NA,106000\\n') f.write('4,NA,178100\\n') f.write('NA,NA,140000\\n') 1234import pandas as pddata = pd.read_csv(data_file)print(data) NumRooms Alley Price 0 NaN Pave 127500 1 2.0 NaN 106000 2 4.0 NaN 178100 3 NaN NaN 140000 123inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]inputs = inputs.fillna(inputs.mean())print(inputs) NumRooms Alley 0 3.0 Pave 1 2.0 NaN 2 4.0 NaN 3 3.0 NaN 123inputs = pd.get_dummies(inputs)#inputs = pd.get_dummies(inputs, dummy_na=True)print(inputs) NumRooms Alley_Pave Alley_nan 0 3.0 1 0 1 2.0 0 1 2 4.0 0 1 3 3.0 0 1 123456import torchX = torch.tensor(inputs.to_numpy(dtype=float))y = torch.tensor(outputs.to_numpy(dtype=float))#X，y = torch.tensor(inputs.values),torch.tensor(outputs.values)X, y (tensor([[3., 1., 0.], [2., 0., 1.], [4., 0., 1.], [3., 0., 1.]], dtype=torch.float64), tensor([127500., 106000., 178100., 140000.], dtype=torch.float64)) 2.3 线性代数123456import torchx = torch.tensor(3.0)y = torch.tensor(2.0)x + y, x * y, x / y, x**y (tensor(5.), tensor(6.), tensor(1.5000), tensor(9.)) 12x=torch.arange(4)x tensor([0, 1, 2, 3]) 1x[-1] tensor(3) 1len(x) 4 1x.shape torch.Size([4]) 12A=torch.arange(20).reshape(5,4)A tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19]]) 1A.T tensor([[ 0, 4, 8, 12, 16], [ 1, 5, 9, 13, 17], [ 2, 6, 10, 14, 18], [ 3, 7, 11, 15, 19]]) 12B=torch.tensor([[1,2,3],[2,0,4],[3,4,5]])B tensor([[1, 2, 3], [2, 0, 4], [3, 4, 5]]) 1B==B.T tensor([[True, True, True], [True, True, True], [True, True, True]]) 12X=torch.arange(24).reshape(2,3,4)X tensor([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) 123A=torch.arange(20,dtype=torch.float32).reshape(5,4)B=A.clone()A,A+B (tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.], [16., 17., 18., 19.]]), tensor([[ 0., 2., 4., 6.], [ 8., 10., 12., 14.], [16., 18., 20., 22.], [24., 26., 28., 30.], [32., 34., 36., 38.]])) 1A*B tensor([[ 0., 1., 4., 9.], [ 16., 25., 36., 49.], [ 64., 81., 100., 121.], [144., 169., 196., 225.], [256., 289., 324., 361.]]) 123a=2X=torch.arange(24).reshape(2,3,4)a+X,(a*X).shape (tensor([[[ 2, 3, 4, 5], [ 6, 7, 8, 9], [10, 11, 12, 13]], [[14, 15, 16, 17], [18, 19, 20, 21], [22, 23, 24, 25]]]), torch.Size([2, 3, 4])) 12x=torch.arange(4,dtype=torch.float32)x,x.sum() (tensor([0., 1., 2., 3.]), tensor(6.)) 1A.shape,A.sum() (torch.Size([5, 4]), tensor(190.)) 12A_sum_axis0=A.sum(axis=0)A_sum_axis0,A_sum_axis0.shape (tensor([40., 45., 50., 55.]), torch.Size([4])) 12A_sum_axis1=A.sum(axis=1)A_sum_axis1,A_sum_axis1.shape (tensor([ 6., 22., 38., 54., 70.]), torch.Size([5])) 1A.sum(axis=[0,1]) tensor(190.) 1A.mean(),A.sum(),A.numel(),A.sum()/A.numel() (tensor(9.5000), tensor(190.), 20, tensor(9.5000)) 1A.mean(axis=0),A.sum(axis=0)/A.shape[0] (tensor([ 8., 9., 10., 11.]), tensor([ 8., 9., 10., 11.])) 12sum_A=A.sum(axis=1,keepdims=True)sum_A tensor([[ 6.], [22.], [38.], [54.], [70.]]) 1A / sum_A tensor([[0.0000, 0.1667, 0.3333, 0.5000], [0.1818, 0.2273, 0.2727, 0.3182], [0.2105, 0.2368, 0.2632, 0.2895], [0.2222, 0.2407, 0.2593, 0.2778], [0.2286, 0.2429, 0.2571, 0.2714]]) 1A.cumsum(axis=0) tensor([[ 0., 1., 2., 3.], [ 4., 6., 8., 10.], [12., 15., 18., 21.], [24., 28., 32., 36.], [40., 45., 50., 55.]]) 12y=torch.ones(4,dtype=torch.float32)x,y,torch.dot(x,y) (tensor([0., 1., 2., 3.]), tensor([1., 1., 1., 1.]), tensor(6.)) 1torch.sum(x*y) tensor(6.) 1A.shape,x.shape,torch.mv(A,x) (torch.Size([5, 4]), torch.Size([4]), tensor([ 14., 38., 62., 86., 110.])) 12B=torch.ones(4,3)torch.mm(A,B) tensor([[ 6., 6., 6.], [22., 22., 22.], [38., 38., 38.], [54., 54., 54.], [70., 70., 70.]]) 12u=torch.tensor([3.0,-4.0])torch.norm(u) tensor(5.) 1torch.abs(u).sum() tensor(7.) 1torch.norm(torch.ones((4,9))) tensor(6.) 12x=torch.arange(24,dtype=torch.float32).reshape((2,3,4))x,len(x) (tensor([[[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]], [[12., 13., 14., 15.], [16., 17., 18., 19.], [20., 21., 22., 23.]]]), 2) 1x.sum(axis=0),x.sum(axis=1),x.sum(axis=2) (tensor([[12., 14., 16., 18.], [20., 22., 24., 26.], [28., 30., 32., 34.]]), tensor([[12., 15., 18., 21.], [48., 51., 54., 57.]]), tensor([[ 6., 22., 38.], [54., 70., 86.]])) 12y=torch.arange(120,dtype=torch.float32).reshape(2,3,4,5)y tensor([[[[ 0., 1., 2., 3., 4.], [ 5., 6., 7., 8., 9.], [ 10., 11., 12., 13., 14.], [ 15., 16., 17., 18., 19.]], [[ 20., 21., 22., 23., 24.], [ 25., 26., 27., 28., 29.], [ 30., 31., 32., 33., 34.], [ 35., 36., 37., 38., 39.]], [[ 40., 41., 42., 43., 44.], [ 45., 46., 47., 48., 49.], [ 50., 51., 52., 53., 54.], [ 55., 56., 57., 58., 59.]]], ​​ [[[ 60., 61., 62., 63., 64.],​ [ 65., 66., 67., 68., 69.],​ [ 70., 71., 72., 73., 74.],​ [ 75., 76., 77., 78., 79.]],​​ [[ 80., 81., 82., 83., 84.],​ [ 85., 86., 87., 88., 89.],​ [ 90., 91., 92., 93., 94.],​ [ 95., 96., 97., 98., 99.]],​ [[100., 101., 102., 103., 104.], [105., 106., 107., 108., 109.], [110., 111., 112., 113., 114.], [115., 116., 117., 118., 119.]]]]) 123456z=torch.linalg.norm(y)#torch.linalg.norm函数可用于求解多轴张量的类L2范数，要求张量各元素数据类型为浮点数或者复数#z=torch.linalg.norm(input,p,dim)#input：输入张量。它的数据类型必须是浮点型或复数型。对于复数的输入，范数使用每个元素的绝对值。注意，输入张量中元素的数据类型一定得是浮点型或者是复数哦，不然就会报错！这个就是主要变化，其次是不能使用 input.norm#p：范数的阶数。默认是2阶—“fro”，也就是弗罗贝尼乌斯范数（Frobenius norm）。如果输入p=某个正整数，则求解对应的p阶范数。其公式为 sum(abs(x)**p)**(1./p)。#dim：对输入的张量计算其指定维度（如dim=1，则表示计算第二个维度）上所有元素的范数。如果不对dim进行赋值，则会计算输入张量所有维度上的范数。当然如果指定维数不在输入张量的尺寸之内，将出现错误。z tensor(754.2015) 2.4 微积分1234567891011121314import numpy as npfrom matplotlib_inline import backend_inlinefrom d2l import torch as d2ldef f(x): return 3*x**2-4*xdef numerical_lim(f,x,h): return (f(x+h)-f(x))/hh=0.1for i in range(5): print(f'h={h:.5f},numerical limit={numerical_lim(f,1,h):.5f}') h*=0.1 h=0.10000,numerical limit=2.30000 h=0.01000,numerical limit=2.03000 h=0.00100,numerical limit=2.00300 h=0.00010,numerical limit=2.00030 h=0.00001,numerical limit=2.00003 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#三个用于图形配置的函数def use_svg_display(): #@save ##@save标记可将对应函数/类/语句保存在d2l包中，以后无需定义就可以直接调用；e.g:d2l.use_svg_display() #使用svg格式在Jupyter中显示绘图 backend_inline.set_matplotlib_formats('svg')from matplotlib import pyplot as pltdef set_figsize(figsize=(3.5,2.5)): #@save #设置matplotlib的图表大小 use_svg_display() d2l.plt.rcParams['figure.figsize']=figsize #@savedef set_axes(axes,xlabel,ylabel,xlim,ylim,xscale,yscale,legend): #设置matplotlib的轴 axes.set_xlabel(xlabel) axes.set_ylabel(ylabel) axes.set_xscale(xscale) axes.set_yscale(yscale) axes.set_xlim(xlim) axes.set_ylim(ylim) if legend: axes.legend(legend) axes.grid() #plot函数：可绘制多条曲线#@savedef plot(X,Y=None,xlabel=None,ylabel=None,legend=None,xlim=None,ylim=None,xscale='linear',yscale='linear',fmts=('-','m--','g-.','r:'),figsize=(3.5,2.5),axes=None): #绘制数据点 if legend is None: legend=[] set_figsize(figsize) axes=axes if axes else d2l.plt.gca() #如果X有一个轴，输出True def has_one_axis(X): return(hasattr(X,&quot;ndim&quot;) and X.ndim==1 or isinstance(X,list) and not hasattr(X[0],&quot;__len__&quot;)) if has_one_axis(X): X=[X] if Y is None: X,Y=[[]]*len(X),X elif has_one_axis(Y): X=X*len(Y) if len(X)!=len(Y): X=X*len(Y) axes.cla() for x,y,fmt in zip(X,Y,fmts): if len(x): axes.plot(x,y,fmt) else: axes.plot(y,fmt) set_axes(axes,xlabel,ylabel,xlim,ylim,xscale,yscale,legend) 12x=np.arange(0,3,0.1)plot(x,[f(x),2*x-3],'x','f(x)',legend=['f(x)','Tangent line(x=1)']) ​​ 123def g(x): return x**3-(1/x)plot(x,[g(x),4*x-4],'x','g(x)',legend=['g(x)','Tangent line(x=1)']) F:\\user\\Temp\\ipykernel_25528\\1423519574.py:2: RuntimeWarning: divide by zero encountered in true_divide return x**3-(1/x) 2.5 自动微分1234import torchx=torch.arange(4.0)x tensor([0., 1., 2., 3.]) 12y=2*torch.dot(x,x)y tensor(28.) 12x.requires_grad_(True) #等价于x=torch.arange(4.0,requires_grad=True)x.grad #默认值为None 12y=2*torch.dot(x,x)y tensor(28., grad_fn=&lt;MulBackward0&gt;) 12y.backward()#通过调用反向传播函数自动计算y关于x每个分量的梯度x.grad tensor([ 0., 4., 8., 12.]) 1x.grad==4*x tensor([True, True, True, True]) 12345x.grad.zero_()#在默认情况下，PyTorch会累积梯度，我们需要清除之前的值y=x.sum()y.backward()x.grad tensor([1., 1., 1., 1.]) 123456#对非标量变量：不计算微分矩阵，而是单独计算批量中每个样本的偏导数之和#对[非标量]调用backward需要传入一个gradient参数，该参数指定微分函数关于self的梯度x.grad.zero_()y=x*xy.sum().backward()#等价于y.backward(torch.ones(len(x)))——传递1的梯度合适：只求偏导数的和y,x.grad (tensor([0., 1., 4., 9.], grad_fn=&lt;MulBackward0&gt;), tensor([0., 2., 4., 6.])) 1234567x.grad.zero_()y=x*xu=y.detach()#分离变量（复制副本，保留计算结果，后续处理的u不带有y除数值外的其他性质）z=u*xz.sum().backward()x.grad==u tensor([True, True, True, True]) 123x.grad.zero_()y.sum().backward()x.grad==2*x tensor([True, True, True, True]) 123456789101112131415def f(a): b=a*2 while b.norm()&lt;1000: b=b*2 if b.sum()&gt;0: c=b else: c=100*b return ca=torch.randn(size=(),requires_grad=True)d=f(a)d.backward()#注意：运行backward函数会自动清除计算图；但可通过在第一次backward中加一句retain_grad=True，即d.backward(retain_graph=True)，意思为一直保留计算图a,d,a.grad==d/a,a.grad (tensor(0.1050, requires_grad=True), tensor(1719.5204, grad_fn=&lt;MulBackward0&gt;), tensor(True), tensor(16384.)) 2.6 概率123456import torchfrom torch.distributions import multinomial#multinomial 多项分布from d2l import torch as d2lfair_probs=torch.ones([6])/6fair_probs,multinomial.Multinomial(1,fair_probs).sample() (tensor([0.1667, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667]), tensor([0., 0., 0., 0., 1., 0.])) 1multinomial.Multinomial(10,fair_probs).sample() tensor([2., 0., 1., 3., 1., 3.]) 12counts=multinomial.Multinomial(1000,fair_probs).sample()#将结果储存为float32以进行除法counts/1000#相对频率作为估计值 tensor([0.1640, 0.1610, 0.1720, 0.1730, 0.1610, 0.1690]) 1234567891011counts=multinomial.Multinomial(10,fair_probs).sample((500,))cum_counts=counts.cumsum(dim=0)#cumsum:累加函数estimates=cum_counts/cum_counts.sum(dim=1,keepdims=True)d2l.set_figsize((6,4.5))for i in range(6): d2l.plt.plot(estimates[:,i].numpy(),label=(&quot;P(die=&quot;+str(i+1)+&quot;)&quot;))d2l.plt.axhline(y=0.167,color='black',linestyle='dashed')d2l.plt.gca().set_xlabel('Groups of experiments')d2l.plt.gca().set_ylabel('Estimated probability')d2l.plt.legend(); ​​ 2.7 查阅文档12import torchprint(dir(torch.distributions)) ['AbsTransform', 'AffineTransform', 'Bernoulli', 'Beta', 'Binomial', 'CatTransform', 'Categorical', 'Cauchy', 'Chi2', 'ComposeTransform', 'ContinuousBernoulli', 'CorrCholeskyTransform', 'CumulativeDistributionTransform', 'Dirichlet', 'Distribution', 'ExpTransform', 'Exponential', 'ExponentialFamily', 'FisherSnedecor', 'Gamma', 'Geometric', 'Gumbel', 'HalfCauchy', 'HalfNormal', 'Independent', 'IndependentTransform', 'Kumaraswamy', 'LKJCholesky', 'Laplace', 'LogNormal', 'LogisticNormal', 'LowRankMultivariateNormal', 'LowerCholeskyTransform', 'MixtureSameFamily', 'Multinomial', 'MultivariateNormal', 'NegativeBinomial', 'Normal', 'OneHotCategorical', 'OneHotCategoricalStraightThrough', 'Pareto', 'Poisson', 'PowerTransform', 'RelaxedBernoulli', 'RelaxedOneHotCategorical', 'ReshapeTransform', 'SigmoidTransform', 'SoftmaxTransform', 'SoftplusTransform', 'StackTransform', 'StickBreakingTransform', 'StudentT', 'TanhTransform', 'Transform', 'TransformedDistribution', 'Uniform', 'VonMises', 'Weibull', 'Wishart', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'bernoulli', 'beta', 'biject_to', 'binomial', 'categorical', 'cauchy', 'chi2', 'constraint_registry', 'constraints', 'continuous_bernoulli', 'dirichlet', 'distribution', 'exp_family', 'exponential', 'fishersnedecor', 'gamma', 'geometric', 'gumbel', 'half_cauchy', 'half_normal', 'identity_transform', 'independent', 'kl', 'kl_divergence', 'kumaraswamy', 'laplace', 'lkj_cholesky', 'log_normal', 'logistic_normal', 'lowrank_multivariate_normal', 'mixture_same_family', 'multinomial', 'multivariate_normal', 'negative_binomial', 'normal', 'one_hot_categorical', 'pareto', 'poisson', 'register_kl', 'relaxed_bernoulli', 'relaxed_categorical', 'studentT', 'transform_to', 'transformed_distribution', 'transforms', 'uniform', 'utils', 'von_mises', 'weibull', 'wishart'] 1help(torch.ones) Help on built-in function ones in module torch: ones(...) ones(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -&gt; Tensor Returns a tensor filled with the scalar value `1`, with the shape defined by the variable argument :attr:`size`. Args: size (int...): a sequence of integers defining the shape of the output tensor. Can be a variable number of arguments or a collection like a list or tuple. Keyword arguments: out (Tensor, optional): the output tensor. dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor. Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`). layout (:class:`torch.layout`, optional): the desired layout of returned Tensor. Default: ``torch.strided``. device (:class:`torch.device`, optional): the desired device of returned tensor. Default: if ``None``, uses the current device for the default tensor type (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types. requires_grad (bool, optional): If autograd should record operations on the returned tensor. Default: ``False``. Example:: &gt;&gt;&gt; torch.ones(2, 3) tensor([[ 1., 1., 1.], [ 1., 1., 1.]]) &gt;&gt;&gt; torch.ones(5) tensor([ 1., 1., 1., 1., 1.]) ​ 1torch.ones(4) tensor([1., 1., 1., 1.]) 1? 1list? 1help(list) Help on class list in module builtins: class list(object) | list(iterable=(), /) | | Built-in mutable sequence. | | If no argument is given, the constructor creates a new empty list. | The argument must be an iterable if specified. | | Methods defined here: | | __add__(self, value, /) | Return self+value. | | __contains__(self, key, /) | Return key in self. | | __delitem__(self, key, /) | Delete self[key]. | | __eq__(self, value, /) | Return self==value. | | __ge__(self, value, /) | Return self&gt;=value. | | __getattribute__(self, name, /) | Return getattr(self, name). | | __getitem__(...) | x.__getitem__(y) &lt;==&gt; x[y] | | __gt__(self, value, /) | Return self&gt;value. | | __iadd__(self, value, /) | Implement self+=value. | | __imul__(self, value, /) | Implement self*=value. | | __init__(self, /, *args, **kwargs) | Initialize self. See help(type(self)) for accurate signature. | | __iter__(self, /) | Implement iter(self). | | __le__(self, value, /) | Return self&lt;=value. | | __len__(self, /) | Return len(self). | | __lt__(self, value, /) | Return self&lt;value. | | __mul__(self, value, /) | Return self*value. | | __ne__(self, value, /) | Return self!=value. | | __repr__(self, /) | Return repr(self). | | __reversed__(self, /) | Return a reverse iterator over the list. | | __rmul__(self, value, /) | Return value*self. | | __setitem__(self, key, value, /) | Set self[key] to value. | | __sizeof__(self, /) | Return the size of the list in memory, in bytes. | | append(self, object, /) | Append object to the end of the list. | | clear(self, /) | Remove all items from list. | | copy(self, /) | Return a shallow copy of the list. | | count(self, value, /) | Return number of occurrences of value. | | extend(self, iterable, /) | Extend list by appending elements from the iterable. | | index(self, value, start=0, stop=9223372036854775807, /) | Return first index of value. | | Raises ValueError if the value is not present. | | insert(self, index, object, /) | Insert object before index. | | pop(self, index=-1, /) | Remove and return item at index (default last). | | Raises IndexError if list is empty or index is out of range. | | remove(self, value, /) | Remove first occurrence of value. | | Raises ValueError if the value is not present. | | reverse(self, /) | Reverse *IN PLACE*. | | sort(self, /, *, key=None, reverse=False) | Sort the list in ascending order and return None. | | The sort is in-place (i.e. the list itself is modified) and stable (i.e. the | order of two equal elements is maintained). | | If a key function is given, apply it once to each list item and sort them, | ascending or descending, according to their function values. | | The reverse flag can be set to sort in descending order. | | ---------------------------------------------------------------------- | Class methods defined here: | | __class_getitem__(...) from builtins.type | See PEP 585 | | ---------------------------------------------------------------------- | Static methods defined here: | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | ---------------------------------------------------------------------- | Data and other attributes defined here: | | __hash__ = None ​ 1list??","link":"/2023/09/27/2.%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"title":"基于ROS（机器人操作系统）的数据展示系统","text":"tips:请在使用该系统前安装好相应的库文件（详见附录二），并在不同控制台分别运行roscore（ros操作系统内核）、rosbag play –loop –pause all.bag（ros数据包展示）和rosrun gmapping slam_gmapping（任务四建图处理进程） 该系统程序名为final_system，使用以下命令克隆git仓库： 1git clone https://github.com/Asgard-Tim/ROS-Coding.git 安装好相关库文件后可通过以下命令运行系统程序： 12345678910111213//项目构建cd /home/ubuntu/project/catkin_wscatkin_make//程序运行source /home/ubuntu/project/catkin_ws/devel/setup.bashcd /home/ubuntu/project/catkin_wsrosrun final_system final_system 完整代码已上传至Github平台，URL地址：Asgard-Tim/ROS-Coding: 重庆大学明月科创实验班软件设计课程作业 (github.com) Bilibili同步上传系统演示视频Demo，链接：重庆大学明月科创实验班软件设计作业–ROS数据展示系统_哔哩哔哩_bilibili 程序主要结构与算法分析在**main()**函数中： 创建ROS节点和节点句柄。 调用**initialize()**函数显示初始菜单:提示用户选择登录、注册或退出系统。 定义一个user类，用于保存用户的用户名和密码信息;根据用户选择执行不同的操作： 登录：要求用户输入用户名和密码，然后检查是否匹配存储在文件中的用户信息。 注册：要求用户输入新的用户名和密码，然后将用户信息保存到文件中。 退出系统：结束程序运行。 如果登录成功，调用**systeminitialize()**函数显示登录成功后的菜单:提示用户选择不同的数据可视化选项或退出系统。 根据用户选择执行不同的数据可视化操作： 任务一：用命令行窗口显示小车的IMU和里程计（odometry）数据 IMU数据：订阅IMU数据的ROS话题，将数据传递给回调函数callback1进行处理。 回调函数callback1，处理IMU数据： 从接收到的IMU消息中获取线性加速度和角速度信息。 使用std::cout打印出线性加速度和角速度信息。 里程计数据：订阅里程计数据的ROS话题，将数据传递给回调函数callback2进行处理。 回调函数callback2，处理里程计数据： 从接收到的里程计消息中获取位置和姿态信息。 使用std::cout打印出位置和姿态信息。 任务二：用图形界面显示颜色相机和深度相机的数据（利用OpenCV库） 颜色相机数据：订阅颜色相机数据的ROS话题，将数据传递给回调函数callback3进行处理。 回调函数callback3，处理颜色相机数据： 将接收到的彩色图像消息转换为OpenCV的图像格式。 使用OpenCV的窗口显示彩色图像。 深度相机数据：订阅深度相机数据的ROS话题，将数据传递给回调函数callback4进行处理。 回调函数callback4，处理深度相机数据： 将接收到的深度图像消息转换为OpenCV的图像格式。 使用OpenCV的窗口显示深度图像。 任务三：用图形界面显示激光雷达的点云数据（利用PCL库） 点云数据：订阅点云数据的ROS话题，将数据传递给回调函数callback5进行处理。 **pcl::visualization::CloudViewer viewer(“Cloud Viewer”);**：创建一个PCL点云可视化器。 回调函数callback5，处理点云数据： 将接收到的点云消息转换为PCL的点云格式。 使用PCL的可视化器显示点云。 任务四：自行选择一种高级算法（例如语义分割、三维重建、导航定位（SLAM）等），实现该算法（可以直接利用第三方库），将其集成到系统中 选择Gmapping算法（一个基于2D激光雷达使用RBPF（Rao-Blackwellized Particle Filters）算法完成二维栅格地图构建的SLAM算法） 占据栅格地图数据：订阅占据栅格地图数据的ROS话题，将数据传递给回调函数callback6进行处理。 回调函数callback6，处理占据栅格地图数据： 从接收到的占据栅格地图消息中获取分辨率、宽度和高度等信息。 创建一个OpenCV的图像对象，用于绘制地图。 遍历地图的每个栅格，根据栅格的值绘制不同的颜色圆点。 使用OpenCV的窗口显示地图。 各功能部分构建过程与实现效果1.系统界面（1）登录界面 （2）功能选择界面 2.各部分功能整体架构思路（以imu数据显示为例，其余任务基本一致）： （1）在运行rosbag后利用rostopic list指令查看当前开放的所有话题 （2）找到所需数据所对应的话题（如imu数据对应的是/imu/data_raw这一topic)，利用rostopic info指令查看其消息类型(如图中Type所示) （3）根据获得的消息类型（如上图Type所示应为sensor_msg/Imu),利用rosmsg show指令查看其对应的各部分数据类型 （4）根据获得的数据类型，编写对应callback函数展示对应数据 12345678910111213141516171819202122232425262728293031323334353637383940void callback1(const sensor_msgs::Imu::ConstPtr&amp; ptr){ cout &lt;&lt; &quot;std_msgs/Header header&quot; &lt;&lt; endl; cout &lt;&lt; &quot; uint32 seq: &quot; &lt;&lt; ptr-&gt;header.seq &lt;&lt; endl; cout &lt;&lt; &quot; time stamp: &quot; &lt;&lt; ptr-&gt;header.stamp &lt;&lt; endl; cout &lt;&lt; &quot; string frame_id: &quot; &lt;&lt; ptr-&gt;header.frame_id &lt;&lt; endl; cout &lt;&lt; &quot;geometry_msgs/Quaternion orientation&quot; &lt;&lt; endl; cout &lt;&lt; &quot; float64 x: &quot; &lt;&lt; ptr-&gt;orientation.x &lt;&lt; endl; cout &lt;&lt; &quot; float64 y: &quot; &lt;&lt; ptr-&gt;orientation.y &lt;&lt; endl; cout &lt;&lt; &quot; float64 z: &quot; &lt;&lt; ptr-&gt;orientation.z &lt;&lt; endl; cout &lt;&lt; &quot; float64 w: &quot; &lt;&lt; ptr-&gt;orientation.w &lt;&lt; endl; cout &lt;&lt; &quot;float64[9] orientation_covariance&quot; &lt;&lt; endl; cout &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; ptr-&gt;orientation_covariance[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;geometry_msgs/Vector3 angular_velocity&quot; &lt;&lt; endl; cout &lt;&lt; &quot; float64 x: &quot; &lt;&lt; ptr-&gt;angular_velocity.x &lt;&lt; endl; cout &lt;&lt; &quot; float64 y: &quot; &lt;&lt; ptr-&gt;angular_velocity.y &lt;&lt; endl; cout &lt;&lt; &quot; float64 z: &quot; &lt;&lt; ptr-&gt;angular_velocity.z &lt;&lt; endl; cout &lt;&lt; &quot;float64[9] angular_velocity_covariance&quot; &lt;&lt; endl; cout &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; ptr-&gt;angular_velocity_covariance[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;geometry_msgs/Vector3 linear_acceleration&quot; &lt;&lt; endl; cout &lt;&lt; &quot; float64 x: &quot; &lt;&lt; ptr-&gt;linear_acceleration.x &lt;&lt; endl; cout &lt;&lt; &quot; float64 y: &quot; &lt;&lt; ptr-&gt;linear_acceleration.y &lt;&lt; endl; cout &lt;&lt; &quot; float64 z: &quot; &lt;&lt; ptr-&gt;linear_acceleration.z &lt;&lt; endl; cout &lt;&lt; &quot;float64[9] linear_acceleration_covariance&quot; &lt;&lt; endl; cout &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; ptr-&gt;linear_acceleration_covariance[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------------------------------------------&quot; &lt;&lt; endl; return ;} （5）编写主函数程序建立订阅者节点订阅话题内容，并调用对应callback函数进行数据处理与显示 1234567ros::init(argc, argv, &quot;imu&quot;);ros::NodeHandle nodeHandle;ros::Subscriber subscriber = nodeHandle.subscribe(&quot;/imu/data_raw&quot;, 1000, callback1);ros::spin(); 注意：在任务二、三中，对应的callback函数需要分别调用opencv和pcl库，将读取的数据进行处理，以可视化图形界面的形式显示出来。 这里以任务三为例展示如何使用库文件进行数据处理并进行图形化界面显示： 123456789101112void callback5(const sensor_msgs::PointCloud2::ConstPtr&amp; msg){ pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud; // 创建一个存储PointXYZ类型点云数据的PointCloud对象，每个点有三个坐标值 pcl::PCLPointCloud2 pcl_pc; // 创建一个PCLPointCloud2对象，用于存储传感器消息中的点云数据 pcl_conversions::toPCL(*msg, pcl_pc); // 将ROS中的sensor_msgs::PointCloud2类型消息转换为PCL中的PCLPointCloud2类型 pcl::fromPCLPointCloud2(pcl_pc, cloud); // 将PCLPointCloud2类型转换为PointCloud&lt;pcl::PointXYZ&gt;类型 viewer.showCloud(cloud.makeShared()); // 在可视化窗口中显示点云数据} 最终各部分功能实现的效果图如下： （1）展示imu数据 （2）展示里程计数据 （3）展示颜色相机数据 （4）展示深度相机数据 （5）展示激光雷达点云数据 3.Gmapping建图算法的实现（1）msg数据类型查询 （2）启动Gmapping算法功能包输入如下命令： 1rosrun gmapping slam_gmapping （3）编写回调函数，利用opencv库绘制2D地图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void callback6(const nav_msgs::OccupancyGrid::ConstPtr&amp; ptr){ std::cout &lt;&lt; &quot;resolution: &quot; &lt;&lt; ptr-&gt;info.resolution &lt;&lt; std::endl; std::cout &lt;&lt; &quot;width: &quot; &lt;&lt; ptr-&gt;info.width &lt;&lt; std::endl; std::cout &lt;&lt; &quot;height: &quot; &lt;&lt; ptr-&gt;info.height &lt;&lt; std::endl; double scale = 1.0; int width = 1200; int height = 1200; cv::Point offset(-1600, -1600); cv::Mat map = cv::Mat::zeros(cv::Size(width, height), CV_8UC3); for (int i = 0; i &lt; ptr-&gt;info.width * ptr-&gt;info.height; ++i) { int x = (i % ptr-&gt;info.width + offset.x) * scale, y = (i / ptr-&gt;info.width + offset.y) * scale; if (ptr-&gt;data[i] == -1) { cv::circle(map, cv::Point(x, y), 1, cv::Scalar(255, 255, 255), -1); } else if (ptr-&gt;data[i] &gt;= 80) { cv::circle(map, cv::Point(x, y), 3, cv::Scalar(0, 0, 0), -1); } else { cv::circle(map, cv::Point(x, y), 3, cv::Scalar(0, 255, 0), -1); } } cv::imshow(&quot;map&quot;, map); cv::waitKey(1000); return ;} （4）建立节点并订阅/map话题，调用回调函数1234ros::init(argc, argv, &quot;show_map&quot;);ros::NodeHandle nodeHandle;ros::Subscriber subscriber = nodeHandle.subscribe(&quot;/map&quot;, 1000, callback6);ros::spin(); （5）建图结果 附录一：必要的库文件和头文件： ****：用于输入输出操作。 ****：用于文件读写操作。 ****：用于处理字符串。 ****：用于时间相关操作。 ****：用于格式化输出。 **”ros/ros.h”**：ROS的主要头文件。 **”sensor_msgs/Imu.h”**：ROS中IMU（惯性测量单元）数据的消息类型。 **”nav_msgs/Odometry.h”**：ROS中里程计数据的消息类型。 ****：用于C风格字符串操作。 **&lt;opencv2/opencv.hpp&gt;**：OpenCV库的头文件。 **”cv_bridge/cv_bridge.h”**：ROS中用于将ROS图像消息转换为OpenCV图像格式的库。 **”image_transport/image_transport.h”**：ROS中用于图像传输的库。 ****：用于内存管理。 **”pcl/visualization/cloud_viewer.h”**：PCL（点云库）中用于可视化点云的类。 **”pcl_conversions/pcl_conversions.h”**：PCL与ROS消息类型转换的库。 **”pcl/point_types.h”**：定义了PCL中常用的点类型。 **”pcl/PCLPointCloud2.h”**：PCL中点云数据的消息类型。 **”pcl/conversions.h”**：PCL与ROS消息类型转换的库。 **”pcl_ros/transforms.h”**：PCL中点云坐标系变换的库。 **”nav_msgs/OccupancyGrid.h”**：ROS中占据栅格地图数据的消息类型。 附录二：安装各库文件的命令 sudo apt-get update 123452. 更新包管理器的软件包列表。3. ``` sudo apt-get upgrade 升级系统中的所有已安装软件包。 sudo apt-get install libopencv-dev 123456. 安装OpenCV库的开发文件。7. ``` sudo apt-get install libopencv-contrib-dev 安装OpenCV贡献模块的开发文件。 sudo apt-get update 1234510. 再次更新包管理器的软件包列表。11. ``` sudo apt-get install libproj-dev 安装Proj库的开发文件，Proj库提供了地理投影转换的功能。 sudo apt-get install libpcl-dev 1234514. 安装PCL（Point Cloud Library）库的开发文件，PCL库用于点云数据处理和分析。15. ``` sudo apt-get install libsdl1.2-dev 安装SDL 1.2库的开发文件，SDL库用于创建图形用户界面和处理多媒体。 sudo apt install libsdl-image1.2-dev 1234518. 安装SDL_image 1.2库的开发文件，SDL_image库提供了图像处理功能。19. ``` sudo apt-get install ros-kinetic-gmapping 安装ROS Kinetic版本中的gmapping软件包，gmapping是用于构建占据栅格地图的SLAM算法。 sudo apt-get install ros-kinetic-slam-gmapping 安装ROS Kinetic版本中的slam_gmapping软件包，slam_gmapping提供了用于构建占据栅格地图的SLAM算法。","link":"/2023/07/02/ROS%20Task/"},{"title":"QQ聊天机器人(接入ChatGPT)","text":"更新记录 V1.0 成功搭建QQ机器人，接入ChatGPT的API 机器人QQ号：2641924697 可以选择与机器人私聊或者在群中@机器人进行提问（tips:在群聊中@机器人提问时，转发消息中的@无效） 提问时直接输入想要提问的问题即可 V1.1 新增功能： 聊天过程机器人可以联系上下文作出回答 用户发送“再见”时或累计发送词数超过1024时自动清除聊天记录（之前发送的消息无法在之后的提问中进行复现） 漏洞修复： 修复了无法识别提问信息中“+”符号的bug 项目搭建过程 想法来源事实上，在ChatGPT的整体使用过程中，对于稳定的科学上网渠道始终有着一定的要求，一些客观因素日益严苛的限制条件使得使用的体验与便捷度并不尽如人意。基于这样的考量，同时也是受到软件设计老师提供的公用ChatGPT对话脚本（现已无法使用）的启发，决定基于python并利用网上开源的go-cqhttp和OpenAI官网提供的API接口使用方法例程等资源搭建QQ端的接口，使得更多人能够更加便捷地享受这一空前的语言模型带来的巨大红利。 具体实施在利用ChatGPT进行咨询学习的过程中，我也意识到网页端ChatGPT使用的繁琐与不稳定，同时其使用也具有一定的门槛。虽然随着API的开放，国内也有很多镜像资源以及免费的平台可以实现与AI的交流，但对于大多数人来说，许多黑心商家利用ChatGPT外接套壳赚钱的现状还是让大家对于ChatGPT望而生畏。对于我个人而言，也是为了让自己能够更加便捷地与ChatGPT沟通进行学习，希望通过python脚本，利用QQ平台搭建机器人接通ChatGPT的API，以实现与ChatGPT更加快捷方便的沟通，并进一步方便更多的人。 整体架构搭建思路如下图所示。 获取API-KEY由于本人的账号没有免费额度，特地从淘宝购入了大额度的api-key（实测可用）以进行进一步的搭建。 Django服务端接口的搭建结合OpenAI官网提供的接入api-key的相关代码样例，完成了这一部分的搭建，通过运行manage.py服务器脚本，实现了在全局代理的前提下利用api-key通过本地8000端口与ChatGPT实现通信。 接入noneBot机器人聊天逻辑借助现成的noneBot机器人聊天逻辑框架，将其接入上述已连接ChatGPT API服务的Django服务器端口实现机器人进一步构建；运行bot.py脚本即可打开聊天机器人终端。 利用go-cqhttp工具连接QQ借助开源的go-cqhttp程序工具，实现QQ账号的登入并接入以上利用noneBot创建的机器人，即可将ChatGPT语言模型顺利接入该QQ账号，并使用其他QQ账号通过该账号与ChatGPT实现沟通。 下图是与我们接入的聊天机器人进行沟通的部分聊天记录。 迭代与优化通过上述流程，基本完成了接入ChatGPT的QQ聊天机器人的架构。在接入完成后，第一时间邀请了部分同学通过与机器人交流进行实际测试，反馈出了如下问题，并在当前的发行版本中予以修正。 该项目代码已在github中开源，并将根据进一步的测试结果不断迭代更新。 仓库地址：Asgard-Tim/ChatGPT-QQBOT: 重庆大学明月科创实验班个性化实践 (github.com) 提问关键词限制问题出于安全性以及防止误操作等考量，在noneBot机器人聊天逻辑设置时，我们特地设置了需要通过在问题前键入关键字“ChatGPT”才能对于机器人进行提问，否则会提示“命令格式错误”；但在实际使用中，我们发现每次都需要进行这样的额外键入无疑给沟通带来了不必要的麻烦，并最终对于机器人聊天逻辑部分__init__.py内的代码进行了修改，删去了额外键入关键词的限制，可以直接对机器人进行提问。 联系上下文问题在测试过程中，部分用户反馈，该机器人无法像正常的人类一样联系聊天过程中的上下文给出回答。针对这一问题，对代码进行修改，储存用于每一次问和答得记录并在下一次提问时一并向服务器发送，从而实现该功能。但是，这样的方式无疑加剧了服务器的处理压力，一旦累积的消息记录过多，会对机器人的回答效率造成很大影响，且对于接入账户的额度消耗较大。目前联系上下文功能已经实装，在消息记录达到一定数量后清空从而保证回答效率，但仍需进一步优化。 漏洞修复：“+”号的识别在实际测试中，部分用户将运算式输入聊天框，希望通过ChatGPT得到正确的计算结果。但由于对于输入信息的编码存在漏洞，导致输入信息中的“+”号无法被识别并传输到服务器端发送给ChatGPT，从而输出了错误的结果。结合跟网页版ChatGPT的沟通学习后，修改了对应部分的代码，成功在noneBot聊天逻辑中改变了输入信息的编码方式，使得“+”号得以保留从而得到正确结果。 0730更新新问题：无法正确识别消息换行之后的左右内容（待修正） 未来规划 机器人持续优化未来打算将机器人推广到更大的测试范围，让更多的朋友能够便捷地用上ChatGPT进行交流学习，因此需要在输入信息处理等方面进行进一步的规范与优化以提高效率。短期内的优化目标是将不同QQ好友的信息分开在不同的服务器端口进行处理与储存，并设置一定的安全防护措施（如用户密码等）。 机器人远程部署要实现QQ机器人的长期在线，目前还需要在本地电脑上运行脚本才能实现整体的构建以及与QQ客户端的连接；为减轻本地内存压力，计划将优化后的机器人放置至远程服务器中运行从而持续稳定地提供接入ChatGPT的聊天服务。 嵌入硬件实体目前的聊天机器人仅仅是建立在QQ客户端上的，而在实际的运用当中ChatGPT可以在更为广泛的人机交互层面得到运用。因此，可以借助ChatGPT提供的现成模型，将聊天机器人接入硬件层面的机器人或产品实体中，从而进一步提升交互性与趣味性，增加附加值。 训练并使用自己的模型事实上，在OpenAI的官方文档中，还给出了根据自身需求投喂数据样本进行训练的方法与对应代码。在未来的产品中，如果我们需要嵌入聊天机器人，可以通过这样的方式训练更加个性化与更具针对性的模型，根据不同的产品需求定制自己的接口与聊天机器人，使其更加灵活自然。","link":"/2023/06/27/chatbot/"},{"title":"小车路径规划","text":"本项目全部代码已同步上传至Github,仓库链接：Asgard-Tim/Path-Planning: 重庆大学明月科创实验班定量工程设计方法课程项目 (github.com) 一、设计要求 在本部分的课程项目中，要求我们运用LD14雷达扫描地图，在MATLAB中进行人工势场添加并对STM32小车进行路径规划，在一规定的场地中让小车避开两个矩形障碍物并以尽可能短的路径最终抵达圆形目标位置。 二、系统方案 2.1 移动底盘分析小车为履带式小车，左右履带分别由一枚直流电机进行驱动，运动模式类似常规双轮小车，通过左右两枚电机转动的差速实现转向。该小车相对来说较为容易进行控制，只需要控制两个驱动轮的速度存在差异，即两轮差速，即可控制机器人实现无滑动摩擦的旋转，也可实现零半径转弯。 图2-1 双轮履带小车外观图 图2-2 两轮差速式机器人运动学分析图 对小车移动底盘的运动学分析（如上图2-2所示）： 小车的速度控制主要是控制 X 轴（前后方向）和 Z 轴（旋转方向）的速度， 以 Vx 和 Vz 来指代，单位分别是 m/s 和弧度/s。X 轴方向以前进记为正，Z 轴方向以右转记为正。车轮速度是使用编码器来计算和得出，读取编码器计数后再转化成车轮的速度。Vz则是通过左右电机转动的差速计算得到的。 图中参数分别代表： 2.2 电机特性分析在本次项目中，我们采用带有减速器与编码器的直流电机驱动小车前进。 直流电机的物理模型图如下图2-3所示。其中，固定部分有磁铁，这里称作主磁极；固定部分还有电刷。转动部分有环形铁心和绕在环形铁心上的绕组。 (其中 2 个小圆圈是为了方便表示该位置上的导体电势或电流的方向而设置的) 它的固定部分（定子）上，装设了一对直流励磁的静止的主磁极 N 和S，在旋转部分（转子）上装设电枢铁心。在电枢铁心上放置了两根导体连成的电枢线圈， 线圈的首端和末端分别连到两个圆弧形的铜片上，此铜片称为换向片。换向片之间 互相绝缘，由换向片构成的整体称为换向器。换向器固定在转轴上，换向片与转轴 之间亦互相绝缘。在换向片上放置着一对固定不动的电刷 B1 和 B2，当电枢旋转时，电枢线圈通过换向片和电刷与外电路接通。在电刷上施加直流电压 U,电枢线圈中的电流流向为：N 极下的有效边中的电流总是一个方向，而 S 极下的有效边中的电流总是另一个方向。这样两个有效边所受的洛伦兹力的方向一致（可以根据左手法则判定），电枢开始转动。具体来说就是，把上图中的+和-分别接到电池的正极和负极，电机即可转动；如果是把上图中的+和-分别接到电池的负极和正极，则电机会反方向转动。电机的转速可以理解为和外接的电压是正相关的（实际是由电枢电流决定）。 总而言之，如果我们可以调节施加在电机上面的直流电压大小，即可实现直流 电机调速，改变施加电机上面直流电压的极性，即可实现电机换向。 图2-3 直流电机的物理模型 在具体的使用过程中，我们需要通过在特定的引脚之间（如本次项目所用电机为1/6引脚）接上一个直流电源，电机即可转动，且改变电压大小即可改变电机转速。接线方式说明如下图2-4所示。 2.3 电机控制策略以及PID特性分析小车电机驱动器芯片使用 AT8236，具有过流保护功能，并可设置电流阈值。驱动芯片只需两个逻辑输入，便可达到调速和正反转的功能，本小车中，每个电机使用两路PWM进行调速（实际上一个普通 IO 和一路 PWM 即可进行正反转 和调速）。 电机的速度使用 13 线霍尔编码器输出 AB 相进行测量，电机减速比为 1:30，使用 STM32 的编码器测量功能，并初始化为脉冲上升沿和下降沿都进行计数，可实现轮子转一圈输出 1560 个计数。 电机调速框图如下图2-5所示。 图2-5 电机调速框图 基于2.1节提到的小车移动地盘的运动学分析，我们可以进一步讨论这些物理量之间的关系，并求出其运动学正逆解公式（如下图2-6），结合PID实现控制。 图2-6 两轮差速式机器人的运动学正逆解公式 下图2-7为PID的控制框图，每个方块代表控制系统的一个组成部分，从图中可看出系统中各组成部分的相互关系和影响，即 PID 调节系统是具有被调参数负反馈的闭环系统。当被控量 Y 受到干扰的影响而升高时，反馈信号将高于给定值 X，经过比较而到放大元件去的偏差信号 e 将为负值，控制器将发出信号而使执行元件动作，其作用方向为负，使被控量下降，这就达到了自动控制的目的。 图2-7中的目标速度一般我们可以通过按键或者开关等方式编程实现改变目标值，测量速度就是通过单片机定时去采集编码器的数据并清零。目标速度和测量速度之间做差这个就是目前系统的偏差。在控制过程中，需要将目标速度、测量速度与偏差三者送入 PID 控制器进行计算输出，然后再经过电机驱动的功率放大控制电机的转动去减小偏差，最终达到目标速度。 图2-7 PID控制框图 对于上述PID控制的基于C语言的实现，我们给出以下代码： 1234567891011121314151617`int Incremental_PI (int Encoder,int Target)` `{` `static float Bias,Pwm,Last_bias;` `Bias=Encoder-Target; //计算偏差` `Pwm+=Velocity_KP*(Bias-Last_bias)+Velocity_KI*Bias;` `//增量式 PI 控制器` `Last_bias=Bias; //保存上一次偏差` `return Pwm; //增量输出` `}` 其中，入口参数为编码器的速度测量值和速度控制的目标值，返回值为电机控制 PWM。第一行是相关内部变量的定义。第二行是求出速度偏差，由测量值减去目标值。第三行使用增量 PI 控制器求出电机 PWM。第四行保存上一次偏差，便于下次调用。最后一行是返回。 2.4 嵌入式控制系统总结分析总体而言，我们基于小车本身的轮距等基本参数编写了一整套嵌入式PID控制流程与系统（基于C语言，面向STM32编程），结合PWM波控制电压，从而控制电机的转速以实现对于车轮速度的反馈调节机制，能够保证小车始终保持相对稳定的速度前进，便于后面进一步规划算法，使小车的运动更加可控。此部分编写的KEIL工程详见附件“PID.zip”。 2.5 传感系统总结分析本次项目所采用的传感器主要为激光雷达，在此我们选用LD14雷达。LD14 主要由激光测距核心，无线传电单元，无线通讯单元，角度测量单元、电机驱动单元和机械外壳组成。LD14测距核心采用三角测量法技术，可进行每秒 2300 次的测距。每次测距时，LD14从一个固定的角度发射出红外激光，激光遇到目标物体后被反射到接收单元。通过激光、目标物体、接收单元形成的三角关系，从而解算出距离。获取到距离数据后，LD14 会融合角度测量单元测量到的角度值组成点云数据，再进行导出。 雷达扫描点云数据形式如下图2-8所示： 图2-8 雷达扫描点云极坐标数据形式（下图2数据为角度（角度制），右侧为距离） 在项目的实践过程中，我们需要通过对STM32单片机进行编程，从激光雷达读取数据并通过串口将处理后的数据传输至电脑中（用特定的软件读取串口输出信息）。STM32中烧录的KEIL工程见附件“Lidar.zip”，接线方式如下图所示。 图2-9 激光雷达与单片机接线方式对应 这里给出KEIL工程中main.c中的主干代码（图2-10），最终会输出数据θ和r,分别代表偏转的角度（AvoidData[i].angle）和距离原点的距离（AvoidData[i].distance）。 图2-10 读取激光雷达数据的主干代码 三、硬件电路设计 主要运用模块电路图如下图3-1所示： 图3-1 主要模块电路图 其中，小车的主控为STM32 F103RCT6芯片，其主控板实物图如下图3-2所示： 图3-2 STM32主控板实物图 由于本次项目需要完成的目标较为单一，仅使用其中少部分接口和器件。 四、软件算法设计 4.1 任务描述在本项目中，我们需要通过激光雷达对于小车所处的地图环境（2m*2m，放置有三个正方体障碍物与一个圆柱体目标物）进行扫描，并对扫描得到的数据结果进行处理。通过一定的算法对于目标物与障碍物进行识别后，我们还需要通过人工势场法进行路径规划，使得小车能够以最优的路径绕开障碍物到达目标物。 本次项目任务分为静态和动态两个部分，其中动态测试过程中会对障碍物的位置进行人为的随机改动。测试过程中，小车的起点位置与目标物的位置始终不变，且可自由选定小车的初始面对方向。 4.2 技术路径和策略通过对于任务描述的分析，我们大致可以将静态情况下的路径规划问题拆解为以下几个部分，并给出相应的处理工具与解决策略： （1） 地图扫描：需要通过对STM32单片机进行编程（利用软件工具KEIL），利用串口通信读取激光雷达扫描所获取的周围地图环境点云的极坐标数据 （2） 处理数据：将串口所得到的数据导入MATLAB中，利用坐标变换将不同点位扫描的极坐标数据统一到同一个笛卡尔坐标系中以便后续处理与识别 （3） 识别物体：在获取扫描后得到的地图后，需要利用RANSAC算法（随机抽样一致算法）识别点云数据中的直线与圆形，并得到相应的障碍物与目标物的二维坐标 （4） 路径规划：在MATLAB中编程，利用得到的出发点、障碍物和目标点各自的坐标建立势场，并用梯度下降法寻找避开障碍物、到达目标点的最优路径 实际上，在动态情况下的路径规划问题中，实现的步骤也与上述大致相同，只是并没有MABLAB等电脑端的辅助软件帮助其进行数据处理与路径规划，需要将这些算法通过对STM32单片机编程集成到小车上，从而实现在测试地图环境随机发生改变的情况下仍然能够按照局部最优的路线避开障碍物到达目标点。 4.3 核心程序逻辑4.3.1 激光雷达极坐标点云数据的处理与变换——得到二维地图在2.5节，我们给出了我们的KEIL工程。通过将其烧入至STM32内，并按照特定接线方式将激光雷达与主控板连接，利用串口通信及相关软件成功在电脑上读取了激光雷达扫描得到的点云极坐标数据（如图2-8右图）。在实际测试时，我们选取了五个坐标点分别放置小车（控制朝向相同）对周围地图环境进行扫描，获得了“data1.txt”等一系列数据文件（详见附件）。 在MATLAB程序的第一部分，我们首先利用importdata函数从数据文本文件中读取相应数据，并将其按列分割为“angle”和“distance”两部分。随后，我们利用MATLAB中自带的坐标变换函数pol2cart将一系列的极坐标数据转换为笛卡尔坐标系下的x-y数据（算法原理如下图4-1）。事实上，由于小车每次扫描的位置均不同，因此还需要将多次扫描的结果结合每次小车放置位置的坐标进行一系列的拼接与变换，才可得到最终的场地二维地图（效果如下图4-2）。 图4-1 利用pol2cart函数进行坐标变换的原理示意图 图4-2 经拼接后得到的场地二维地图 该部分的代码给出如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465`%Step1:处理激光雷达扫描数据，绘制二维坐标系地图``ans=importdata(&quot;data1.txt&quot;);``angle=ans(:,1);``angle=angle.*2.*3.1415926./360;``distance=ans(:,2);``[x,y] = pol2cart(angle,distance);``ans1=importdata(&quot;data2.txt&quot;);``angle1=ans1(:,1);``angle1=angle1.*2.*3.1415926./360;``distance1=ans1(:,2);``[x1,y1] = pol2cart(angle1,distance1);``ans2=importdata(&quot;data3.txt&quot;);``angle2=ans2(:,1);``angle2=angle2.*2.*3.1415926./360;``distance2=ans2(:,2);``[x2,y2] = pol2cart(angle2,distance2);``ans3=importdata(&quot;data4.txt&quot;);``angle3=ans3(:,1);``angle3=angle3.*2.*3.1415926./360;``distance3=ans3(:,2);``[x3,y3] = pol2cart(angle3,distance3);``ans5=importdata(&quot;data5.txt&quot;);``angle5=ans5(:,1);``angle5=angle5.*2.*3.1415926./360;``distance5=ans5(:,2);``[x5,y5] = pol2cart(angle5,distance5);``x4 = [x;x1-100;x2+1850;x3+1400;x5+1500]/100;``y4 = [y;y1+1750;y2+100;y3+1650;y5+1000]/100;``figure(1);``scatter(x4,y4,1);``hold on``axis equal``axis( [ -3, 22, -3, 22 ] )` 4.3.2 利用RANSAC算法识别地图中的直线和圆——获得目标点与障碍物的坐标在成功利用激光雷达的扫描数据建立了二维地图后，我们需要让机器人知道哪里能走哪里不能走，要走向哪里，即明确目标点以及障碍物的具体坐标。在本测试项目中，设定圆柱为目标物而正方体为障碍物，所以问题的关键即为如何从二维地图中识别出圆形以及正方形（本质上为直线的拼接）并获得其坐标。 在之前的课程中，介绍了RANSAC这一算法。随机样本一致性(Random Sample Consensus RANSAC) 是一种迭代方法，用于从包含异常值的观察数据中估计出数学模型参数，因此也可以理解为一种异常值检测方法。RANSAC的一个基本假设是，数据由内点(“inliers”)和外点(“outliers”)组成，其中内点是在一定误差范围内可以通过一些模型参数来解释的数据，外点是不符合模型的数据。RANSAC的另一个假设是，随机选取的样本数据都是内点，存在一个可以估计模型参数的过程，该模型可以最佳地解释或拟合该数据。通过该算法，我们可以有效地从已有的地图（本质上是二维坐标系下的点集数据）中拟合出直线与圆的轮廓，并获取相应图形的对应坐标。 该算法的实现步骤如下： （1） 从原始数据集S中随机选择子集s，s为假设的内点(子集s一般为最小子集，如：直线选取两个点，圆选择三个点) （2） 依据子集s估计模型参数 （3） 遍历数据集S中除子集s外的所有数据，如果数据点在给定误差e以内，则标记为内点，否则标记为外点 （4）所有内点组成一致集，如果一致集中点的个数满足给定阈值T，则用一致集中所有内点重新估计模型参数，然后结束算法 （5）如果一致集中内点个数少于阈值T，则重新选择新的子集s，并重复步骤（1）-（4） （6） 经过K次迭代，选择一个内点数量最多的一致集，用一致集中所有内点重新估计模型参数，然后结束算法 基于上述基本思想与步骤，我们编写了一段MATLAB代码，用于二维坐标地图中直线的识别与拟合。在此基础之上，我们根据算法原理，从点集中随机取出三个点，利用三点成圆获得圆的方程（利用自己编写的函数ThreePoint2Circle）。再对圆的轨迹赋予一个宽度，统计落入这个宽度中的点的数量，对所有的点进行逐个取点，获得最优的圆的方程。值得注意的是，由于待识别的正方形是由多条直边构成，这要求我们需要重复对于该图像进行扫描拟合，且需要在一次拟合之后将该次拟合中涉及的数据点删除以防影响下次拟合。下面将给出这一部分的代码实现以及拟合效果（如图4-3、4-4）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257`%Step2:利用RANSAC算法识别直线和圆``%(1)圆的识别``a = [x4,y4];``% RANSCA参数：``% 迭代次数``iter = 0;``% 查看圆数据的大小``[m,n] = size(a);``% 误差参数``berr = 0.02;``% 拟合参数``bfit = [];``% 内点个数为点数的1/3``t = floor(m/3);``% 开始循环迭代``while iter&lt;100` `% 随机挑选三个点，三个点不重复` `% 拟合圆最少需要三个点，拟合直线最少需要两个` `% ran为索引编号` `ran = randperm(m,3)';` `% b为索引得到的点` `b = a(ran,:);` `% 根据随机得到的三个点，计算圆的半径和圆心` `[r1,p1] = ThreePoint2Circle(b(1,1:2), b(2,1:2), b(3,1:2));` `% 选择除了随机得到的三个点外的其他点` `c = setdiff(a,b,&quot;rows&quot;);` `% 计算每个点到圆心的距离dis` `dis = sqrt(sum((c(:,1:2)-p1).^2,2));` `% 计算 dis和拟合圆的误差` `res = dis - r1;` `% 选择小于误差的点，进入到内点中` `d = c(res&lt;berr,:);` `len = length(d(:,1));` `% 判断内点数量是否满足条件` `if len &gt; t`​ `% 满足条件时，多点拟合圆，这里用平均值计算圆心`​ `p = mean(d);`​ `r = mean(sqrt(sum((d(:,1:2)-p(:,1:2)).^2,2)));`​ `% 多点拟合的圆和随机点拟合的圆的误差`​ `err = sqrt(sum((p-p1).^2))+sqrt((r-r1)^2);`​ `% 如果误差满足条件，则可以结束循环`​ `% 不满足则继续`​ `if err &lt; berr`​ `bfit = [p,r];`​ `berr = err;`​ `break`​ `else`​ `iter = iter+1;`​ `continue`​ `end` `else`​ `iter = iter+1;` `end``end``%绘图``para = [p(1)-r, p(2)-r, 2*r, 2*r];``rectangle('Position', para, 'Curvature', [1 1]);` `%（2）直线的识别``iter = 100;``data1=transpose(x4);``data2=transpose(y4);``data=[data1;data2];``for t=1:10` `number = size(data,2); % 总点数` `bestParameter1=0; bestParameter2=0; % 最佳匹配的参数` `sigma = 1;` `pretotal=0; %符合拟合模型的数据的个数` `for i=1:iter` `%随机选择两个点` `idx = randperm(number,2);` `sample = data(:,idx);` `%拟合直线方程 y=kx+b` `line = zeros(1,3);` `x = sample(:, 1);` `y = sample(:, 2);` `k=(y(1)-y(2))/(x(1)-x(2)); %直线斜率` `b = y(1) - k*x(1);` `line = [k -1 b];` `mask=abs(line*[data; ones(1,size(data,2))]); %求每个数据到拟合直线的距离` `total=sum(mask&lt;sigma); %计算数据距离直线小于一定阈值的数据的个数` `if total&gt;pretotal %找到符合拟合直线数据最多的拟合直线`​ `pretotal=total;`​ `bestline=line; %找到最好的拟合直线` `end` `end``%显示符合最佳拟合的数据` `mask=abs(bestline*[data; ones(1,size(data,2))])&lt;sigma;` `hold on;` `k=1;` `index=[];` `for i=1:length(mask)` `if mask(i)`​ `inliers(1,k) = data(1,i);`​ `k=k+1;`​ `index=[index i];` `end` `end` `%删除完成拟合的点以进行下一次拟合` `for i=1:length(index)` `data(:,index(i))=[];` `for j=1:length(index)`​ `if(index(j)&gt;index(i))`​ `index(j)=index(j)-1;`​ `end` `end` `end` `% 绘制最佳匹配曲线` `bestParameter1 = -bestline(1)/bestline(2);` `bestParameter2 = -bestline(3)/bestline(2);` `xAxis = min(inliers(1,:)):max(inliers(1,:));` `yAxis = bestParameter1*xAxis + bestParameter2;` `plot(xAxis,yAxis,'r-','LineWidth',2);``end``function [R,P0] = ThreePoint2Circle(P1, P2, P3)``%% 求圆心和半径，三个点可以求圆心和半径` `x1 = P1(1); x2 = P2(1); x3 = P3(1);` `y1 = P1(2); y2 = P2(2); y3 = P3(2);` `z1 = x2^2 + y2^2 - x1^2 - y1^2;` `z2 = x3^2 + y3^2 - x1^2 - y1^2;` `z3 = x3^2 + y3^2 - x2^2 - y2^2;` `A = [(x2-x1), (y2-y1); (x3-x1), (y3-y1); (x3-x2), (y3-y2)];` `B = 0.5*[z1; z2; z3];` `P0 = (A'*A)\\A'*B;` `R1 = sqrt( (P0(1) - P1(1))^2 + (P0(2) - P1(2))^2 );` `R2 = sqrt( (P0(1) - P2(1))^2 + (P0(2) - P2(2))^2 );` `R3 = sqrt( (P0(1) - P3(1))^2 + (P0(2) - P3(2))^2 );` `R = (R1 + R2 + R3)/3;` `P0 = P0';``End` 图4-3（上） 对于二维地图中一条直线的拟合（红线为拟合结果） （可以看到拟合效果相对良好） 图4-4（右） 对于给定圆坐标数据的RANSAC拟合（上图为给定的圆，下图为拟合出的圆） （说明该算法实现的有效性） 4.3.3 建立势场并利用梯度下降法确定最优路径（人工势场法）人工势场法引入了物理中斥力场和引力场的思想，把工作环境抽象为一个电磁场，而机器人则是其中的一个电荷，机器人在磁场力的作用下移动。人工势场法会在障碍物周围构建斥力场、在目标点周围构建引力场；这样，机器人便能够在斥力场和引力场的作用下向目标点移动。同时，当障碍物和目标点太近时，机器人很可能会因为刹不住车而出现无法到达目标点等问题，这也就出现了一堆相应的优化算法。 通过利用RANSAC算法对于地图中具有特定形状的边界、障碍物与目标物进行识别，我们成功获得了障碍物与目标点的坐标。在此基础之上，我们基于原型函数（a,b即为障碍物/目标点的x,y坐标）建立势场。通过观察不难发现，在以（a,b）为圆心、半径为1的圆之外的地方该势函数均为正，反之为负。事实上，对于场地内的3个障碍物以及1个目标物而言，所形成的是一个叠加场，由原型函数作用于不同的点叠加而成。在此，我们不妨认为势场为正处具有排斥力而势场为负处具有吸引力，需要吸引小车向目标点走去而花费尽量少的能量。在这样的算法理念基础上，我们需要在代表目标点的原型函数部分加上负号；更进一步的，我们还希望这个吸引力足够大而防止被障碍物阻断，因此在建立势场时，不妨在代表目标点的原型函数前乘上一定的系数以保证其足够强大的吸引力。最终，我们根据地图实际情况，建立了整个势场叠加后的函数方程：F=log(sqrt((x-4.75).^2+(y-12.5).^2))+log(sqrt((x-12).^2+(y-7.6).^2))+log(sqrt((x-11.2).^2+(y-13).^2))-5*log(sqrt((x-16.5).^2+(y-18.5).^2))，并根据该函数绘制了势能图（如图4-5）与等势线图（如图4-6)。 图4-5 势场函数势能图 图4-6 势场函数等势线图 该部分代码如下： 123456789101112131415161718192021`%Step3:通过识别得到的障碍物和目标坐标建立势场``v=-2:1:22;``[x,y]=meshgrid(v);``F=log(sqrt((x-4.75).^2+(y-12.5).^2))+log(sqrt((x-12).^2+(y-7.6).^2))+log(sqrt((x-11.2).^2+(y-13).^2))-5*log(sqrt((x-16.5).^2+(y-18.5).^2));``[px,py]=gradient(F,1,1);``contour(x,y,F);``hold on;``title('人工势场法路径规划');``quiver(x,y,px,py,0);``figure(2);``surf(x,y,-F);` 在建立完势场之后，由于我们需要寻找的是避开障碍物而通往目标点的最优路径，实际上即为所耗费能量最少的路径，我们引入了梯度下降法，通过间隔相同距离的不断迭代，在每一处都寻找能量下降最快的方向（即为梯度方向）前进（在MATLAB中通过调用函数文件path_plan.m与computP.m实现该功能），最终得到了如下图4-7绿色线所示的最优路径。 图4-7 人工势场法路径规划结果（绿色即为规划出的最优路径） 其中，path_plan函数是整个算法过程中的关键，也是梯度下降思想的集中体现，其大致实现思路流程如下： 1）起点、终点 、障碍物、迭代次数、取点半径等参数的设定 2）以起点为中心，作半径为r的圆，从圆上取八个均布的点 3）分别计算八个点的前进“代价”—— 终点对其的引力+所有障碍物对其的斥力 4）取“代价”最小的点的坐标，结合现有起点，计算得到新的起点，然后重复上述内容 5）当发现 一个点距离终点很近 or 迭代的次数计算完 程序停止。 该部分的实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899`%Step4:通过人工势场法确定最优路径``axis([-3 22 -3 22]);``begin=[0;0]%起始点坐标``over=[16.5;18.5];%目标点坐标``figure(1);``hold on;``plot(begin(1),begin(2),'*b','MarkerSize',10);``plot(over(1),over(2),'*b','MarkerSize',10);``obstacle=[4.75,12,11.35;12.75,7.5,12];%障碍物坐标``point= path_plan(begin,over,obstacle);``function [ point ] = path_plan(begin,over,obstacle)``iters=1; %迭代次数``curr=begin;``testR=0.1; %测试8点的圆的半径为0.1``while (norm(curr-over)&gt;0.2) &amp;&amp; (iters&lt;=2000)` `point(:,iters)=curr;``% attr=attractive(curr,over);``% repu=repulsion(curr,obstacle);``%curoutput=computP(curr,over,obstacle);` `%计算当前点附近半径为0.2的8个点的势能，然后让当前点的势能减去8个点的势能取差值最大的，确定这个方向，就是下一步迭代的点` `%先求这八个点的坐标` `for i=1:8 testPoint(:,i)=[testR*sin((i-1)*pi/4)+curr(1);testR*cos((i-1)*pi/4)+curr(2)];`​ `testOut(:,i)=computP(testPoint(:,i),over,obstacle);`​ `%找出来最小的就可以了` `end` `[temp num]=min(testOut);` `%迭代的距离为0.1` `curr=(curr+testPoint(:,num))/2;` `plot(curr(1),curr(2),'og');` `iters=iters+1;``end``end``function [ output ] = computP( curr,over,obstacle )` `k_att=1;``repu=0;``k_rep=100;``Q_star=2;``%计算当前点距离终点的引力``attr=1/2*k_att*(norm(curr-over))^2;``%计算障碍点与当前点的斥力``%设定障碍的斥力作用半径为2``for i=1:size(obstacle,2)` `if norm(curr-obstacle(:,i))&lt;=Q_star`​ `repu=repu+1/2*k_rep*(1/norm(curr-obstacle(:,i))-1/Q_star)^2;` `else`​ `repu=repu+0;` `end``end``output=attr+repu;``end` 4.4 实现的实际效果事实上，尽管RANSAC算法在理论上已经具备足够的拟合精度，但在实际的识别过程中，由于激光雷达扫描获取的数据过多而导致干扰噪点的数量达到了一定规模，以及在算法参数设置上考虑到算力有限等因素而没有采用精确度最高的设置，诸如此类的干扰因素导致在多条直线识别时出现了互相覆盖与识别错误的情况，识别圆形时也并未识别出目标点的圆柱所在处，因此在实际的测试过程中，利用RANSAC算法识别圆与直线以获取目标点和障碍物坐标这一过程并未取得特别良好的效果。为了后面的路径规划算法顺利开展，我们最终采用人工识别的方式，分别给出了起点、障碍物以及目标点的大致坐标，并顺利实现了利用人工势场法进行路径规划的算法，合理规划出了从起点避开障碍物到达目标点停下的最优路径，并通过STM32单片机编程成功驱动了小车按照规划好的路径进行运动，顺利完成开环测试。 五、实验结果及分析 经过几次测试，在进行4至5个位置的扫描之后，通过将数据进行变换与拼接，可以得到一张较为完整的二维地图，再将地图中通过RANSAC算法识别出的特定点位数据读入程序运行，可以得到一条较为合理的最优路径。 事实上，在前面的嵌入式控制系统设计部分，我们计划采用PID方式对于小车与电机进行反馈调节控制，但在实际的测试中，PID的控制方式实现的效果并不尽如人意，无法合理利用MATLAB路径规划所得到的数据结果顺利完成测试。于是我们果断选择了重新使用PWM的方式，依托于MATLAB程序运行规划出的路径对应的相关数据计算所需要的PWM以及延时的时间。最终采用的代码如下图5-1所示（具体KEIL工程内容详见Run.zip附件)。 图5-1 PWM电机驱动部分实现代码 通过调整PWM的方式对小车进行开环运动控制，最终可以较好达到项目要求。（实现效果见下图5-2及视频附件“测试.mp4”） 图5-2 静态路径规划实现效果实地测试 虽然静态路径规划部分完成情况相对较好，但遗憾的是，由于对于C语言编程不是特别熟悉，包括受限于对库的了解、算法的时间复杂度较高、实现繁琐以及对于STM32内部利用效率的不完全开发等因素，最终并没有能够成功完成动态部分的路径规划。事实上，动态情况下的路径规划更符合我们在日常生活中常见的应用场景，不论是扫地机器人还是汽车导航，本身所应对的环境都在时刻发生着改变，因此动态的路径规划问题仍然值得在课程结束之后继续进行深挖和探索。希望在未来的工程实践中，我们能够以更加定量化的思维去分析和思考问题，同时更加熟练的掌握相关的算法设计，提高自己的硬件嵌入式编程能力。 六、个人总结 在路径规划这一阶段的课程中，我在前半段主要负责的是STM32单片机的一些基础开发，对于其基本的开发流程以及GPIO等基本的功能模块有了一定的了解并能进行一些简单的32单片机编程；在后半段，我主要负责整体路径规划项目的思路整理与算法设计，结合课堂上介绍的RANSAC识别算法以及人工势场法规划路径，课下积极结合概念的巩固以及相关资料的查询，阅读了相关的示例代码，并根据算法的整体思路自己动手实现了RANSAC算法对于直线与圆的识别拟合以及在建立的势场中利用梯度下降法实现路径规划的MATLAB程序，积极将自己的算法实现与队友编写的STM32 C语言程序融合在一起，在与队友的充分交流沟通与合作的基础上共同完成了该项目。在死亡之桥的测试项目中，我在一个人调试了单片机程序许久未果后，与队友进行了积极的沟通与合作，也基本确定了由我负责编写MATLAB算法程序给队友的单片机编程提供数据支持的合作模式，对于我们团队的所有人来说都是一次难忘的经历。在利用激光雷达扫描地图的过程中，我们也充分信任彼此，在他们编写好了读取雷达数据的相关程序后，我结合着MATLAB程序的需求对于KEIL代码的输出格式部分进行了一定的修改，在通力合作下最终圆满完成了该项任务。除此之外，也非常感谢整个课程阶段过程中凌睿老师在算法思路方面对我们进行的一系列教学与指导以及助教学长们在答疑时的倾力相助。","link":"/2023/06/25/QEA-Radar-Car/"},{"title":"具有一定扶正能力的船舶设计","text":"本项目定量分析部分Matlab代码已同步上传至Github,仓库链接：Asgard-Tim/QEA-Boat: 重庆大学明月科创实验班定量工程设计方法课程项目 (github.com) 一、项目介绍 在该项目中，我们需要设计制造一艘小船，该小船需要满足以下条件：该艘船的倾覆角度须满足在120°至140°的范围之内，即在倾斜角度到达120°之前都能够回正，同时在超过140°之后不再具有扶正的能力；此外，船体具备一定的载重能力（两罐听装可乐），不会沉没或者有太大（平衡位置甲板与水面夹角超过10°的倾斜）。为了达到以上的指标要求，我们将使用Matlab软件进行相应的定量分析设计，并以木板为材料进行加工制作。具体的呈现详见下文。 二、第一性原理分析 在明确需要达成的指标之后，我们需要使用第一性原理对需要解决的问题进行回归、逐层拨开，回到基本的数学物理公式之中，以便进行较为精确的定量化设计。深入过程见上图。 三、船体设计 3.1设计方向3.1.1第一性原理的实现倾覆角度（120°~140°）实现： 设计灵感来源于鱼漂（鱼漂主要分为漂尾、漂身、漂脚，三部分。漂脚大致分为碳脚、竹脚、钢脚等，漂脚的材质不同，自身的重量就不相同，漂脚越重整支鱼漂的重心就会偏下，使鱼漂入水后翻身站立的时间缩短，也就是我们常说的翻身快。）鱼漂的结构恰好可以很好地解决90°以上倾覆角回正的问题，即“头轻脚重”。通过为船体加装舰岛等提供浮力的模块以及合理调节船体各部分高度来进一步精确化满足倾覆角区间。 载重能力（约700g）实现： 除去船体本身的重量将实现700g左右的载重。船体设计将在船体舰岛中为所载货物预留空间，并且预留出排水体积（即预留最大吃水深度），以满足载重要求。 稳定性实现： 当船舶受到外力倾斜时，其重力的大小位置不发生变化，浮力的大小也不变，但浮力的中心位置会发生偏移。我们知道浮力作用的中心是水下体积的中心，当船舶倾斜时，水下体积形状发生改变，倾斜下沉一侧的水下体积会增加，此时浮力的作用中心会向倾斜的一侧移动，浮力和重力不在同一条直线上，他们形成的力矩和倾斜力矩相反，这就是船舶的复原力矩。只要船舶倾斜，船舶的复原力矩就必然出现，方向永远和船舶的倾斜方向相反，这就是船舶拥有稳性的原因。我们将船舶这种受到外力矩（如风浪等）的作用而发生倾斜，在外力矩消失后自行恢复到原来平衡位置的能力，称为船舶的稳性。 我们对船的剖面演示分析可以发现。当船发生倾斜时，浮心位置改变，我们将浮心所在的垂线于船体中心线交点称为稳心。当稳心在船舶的重心之上时，船舶可以回正。当稳心在重心之下，船舶就发生了倾覆。那么船舶横摇的角度达到多大的时候，我们的船会发生倾覆呢？我们分析研究稳性力臂随着船身倾斜角度变化的曲线。当稳心与重心等高时，也就是这条曲线由正变为负的时候，所对应的船身倾斜角度叫做稳性消失角。当船体的倾斜超过了这个角度，船就会翻。也就是说船舶倾斜在稳性消失角之前，稳心的位置比重心高，稳性力臂为正，复原力矩值也就为正，这时即使船体倾斜，也会回复到船舶原有的平衡位置。当船舶倾斜角度超过了这个稳性消失角，稳心位置就比重心低，稳性力臂比为负，复原力矩值也就为负数，那么这个时候就会发生翻船。这样就解释了船受到外力作用会在海中左右摇摆，随着外力的增加摇摆的更加激烈，船的横摇由于复原力矩的存在，能使其回正，但若超过了稳定消失角这个值，就会发生倾覆。 提高船体稳定性一是降低船体的重心来提高船舶的稳性。例如比赛帆船，通过加中竖龙骨的方法来降低它的重心，使其稳性消失角能够达到150度~170度的角度，接近于永不颠覆的船。另外，增加船宽也可以使船舶获得更高的稳性。例如对安全性要求较高的原油运输船，船体会比较宽，船型比较的矮胖。其他还有多种方式可以抵御船舶倾覆的风险。 动力实现： 动力大致分为驱动和电控两个模块，以及电池，螺旋桨的装配，选取适当控制模块来实现。 3.1.2船体造型与其他功能的实现本次项目设计船舶计划设计类似军舰外形的船体，并且达到船体轻巧，航速较快的目标，在此基础上可以实现节能，造价低廉的非硬性目标。 3.2船体初步设计方案 根据本次项目要求以及船型设计初衷（类军舰）采用了以上减小阻力的第一种设计类型，即通过收窄船体且前尖后宽的方式。 船头借鉴了05式两栖装甲突击车前减阻板的结构，并与上图传统船型结合的联合减租模型。 关于中国05式两栖装甲突击车 新型国产高速两栖突击车首先列装海军陆战队，已经成为海军利器。它不但能在摇摆的海上，精准摧毁敌方阵地工事，而且其强大的威力足以摧毁各型主战坦克。中国05式两栖突击车，操作简单，已没有离合器，具备浮渡精准射击能力。 简介 ZBD-05两栖步兵战车又被称为05式两栖步兵战车，是中华人民共和国研制的”05式两栖装甲车族“一员，装备中国人民解放军海军陆战队和陆军两栖机械化部队的滑水型高速两栖装甲车辆，部分言论称它与美国海军陆战队的”远征战斗车”(Expeditionary Fighting Vehicle, EFV)在概念上相似。 评价 该车外形新颖，车体前部的防浪板是带加强筋的，不但外形宽大而且具有液压伸直调节功能，可以根据海浪的高低和需要的航速自行调节其前倾角度，这就使得整个车体具有了滑行板的功能，在水中行驶时，通过滑行板将水的浮力和速度转化为上抬的力量，类似快艇一样，可以将整个车体短时抬离水面，降低阻力，提高速度。车体前后的防浪板再加上车体两侧打开的侧裙板，可以使得整个车体和水的接触面积大大增加，既增加了该型车在航渡中的稳定性和安全性，还能使得大口径武器如轻型坦克上的105mm火炮具有了在航渡过程中随时可以开火而不致翻沉。在正常陆战使用中，防浪板和后调节板收回车体，还能起到装甲防护的作用。 总结 05式两栖突击车独特巧妙的外形设计是它能快速机动的重要原因。车体前后部的防浪板外形宽大，能根据海浪的高低和需要的航速自行调节前倾角度。突击车在水中行驶时，防浪板将水的浮力转化为向上的力量，再配合车体两侧打开的侧裙板，将突击车短时抬离水面，从而大大降低阻力，提高速度。 舰岛部分以空心提供浮力为主，辅助来进行大角度回调。 驱动控制部分设计为电路模块，包括信号揭发部分，电动机控制部分；驱动模块包括电子调速器，电动机，螺旋桨模块以及锂电池。行进方式采用双桨无舵型，以两个推进器的差速法控制船体行进方向。 ※具体实现以及其他细节后续介绍这里不再给出 四、程序定量设计 4.1 量化指标的数学物理分析基于上述对实际问题的第一性原理分析后，我们不难得出，要使得负有一定载重的船体呈现出满足要求的扶正能力，关键在于对于船体稳定性的量化考察与计算。具体而言，我们可以通过重心、浮心、扶正力矩与稳性消失角等一系列量化参数对于船体的扶正能力进行进一步的定量描述，并根据定量分析结果调整船体设计使其具有相应的扶正能力。 4.1.1 重心重心（Centroids）即为重力中心，本质上是物体在重力场中所受重力作用的等效作用点。在对于船体扶正能力的定量分析中，我们需要通过物体重心与浮心的位置关系判断扶正力矩的正负从而得到稳性消失角以衡量船体的扶正能力。 事实上，由于实验环境处于重力场相对均匀的地表，重心和质心(Center of Mass)在误差允许范围之内可视为重合，因此在定量计算时，我们实际上是将重心等效于质心，通过对于船体质量中心的计算间接得到重力中心的三维坐标。 在上述理论事实的支撑下，我们成功地将问题转化为“如何求取物体质量中心”。不可忽略的一点是，在实际定量计算中，对于物体质量中心的求取首先要将整个物体进行离散化处理，即将物体视作由许多质点组成的质点系，再对这些离散的点进行处理；同时，由于项目中的船体负有载重，离散化的质点系处理过程还便于额外添加船体外壳之外的其他额外质量点（如配重的质心等）。因此，控制物体离散化（本质上是从x,y,z三个方向进行微分）的精度是使得质心坐标结果更为精确的重要一环。在离散化的基础之上，对于N（该项目中N=3）维空间中的质点系而言，在坐标系中有以下质量中心坐标计算公式： 其中X表示某一坐标轴；mi表示物质系统中，某i质点的质量；xi表示物质系统中，某i质点的坐标。 而具体到本项目中所处的三维环境下，又有如下更为细化的公式： 其中，x(y,z)为各坐标轴下质点分布的方程，ρ为船体材料的密度，dA为微分后每一小块的体积。 通过这一公式，就可以得出三维空间中物体离散化后的质点系的质量中心坐标。当离散化程度足够（微分步长足够小）时，在地表实验环境下，这一坐标同时也就是物体重心的坐标。 4.1.2 浮心浮心（Center of Buoyancy）是指浮体或潜体水下部分体积的形心，本质上是浮力的等效作用点。当浮体方位在铅直面内发生偏转时，其水下部分的体积虽保持不变，但其形状却发生变化，因而浮心的位置也相应的移动。在对于船体扶正能力的定量分析中，我们需要通过物体重心与浮心的位置关系判断扶正力矩的正负从而得到稳性消失角以衡量船体的扶正能力。 当物体放入流体中时，由于物体与流体的上下接触面受到流体的压强不等，上小下大，故会产生压强差，进而物体会受到流体竖直向上的压力，即受到流体的浮力。依据阿基米德定律，可得出物体受浮力大小为物体排开那部分流体所受到的重力。自然的，浮心的位置即为被排开流体部分的重心位置。若被排开流体的几何形状是规则的，那么浮心就在被排开的流体原先的几何中心。 事实上，在不同的倾斜角度情况下，物体在水下部分的形状都各不相同，因此随着倾斜角度的改变，浮心也在时刻发生着改变。而在某一固定倾斜角度时，对于浮心的求取本质上即为对于物体排开部分的水的重心求取。在上一节中我们详细阐述了如何计算物体的重心，只是在这里我们需要在不同的倾斜角度下分别求取水下部分的重心，具体计算原理完全一致，在此不过多赘述。但在浮心求取中涉及到的另一个问题是，应该如何确定船体水下部分的船体形状呢？在这里，我们引入水线的概念，即对于船体截面而言，水下部分与水上部分的分界线。上面提到，随着倾斜角度的改变，尽管排开水体部分的形状不尽相同，但提供的浮力大小一致，由阿基米德原理不难得出，即排开水的体积始终不变。因此，我们可以依据这条原理，得到各倾斜角度下水线的方程，与船体截面方程在水线之下的部分共同框定水下部分的形状，从而进行浮心的计算。 4.1.3 扶正力臂（矩）与稳性消失角船的稳性消失角(AVS)是角度θ，当船体的倾斜角度达到该角度后，船体就会倾覆而不再能够自动回倾。利用前两节给出的方法，我们可以得到船体的重心与浮心坐标，它们同时也是重力与浮力作用在船体上的等效作用点。而在这两个力的作用下，会对船体产生一个由重心与浮心之间的距离创建的力矩臂，浮力作用在该臂上以产生扭矩。随着倾斜角度的改变，扭矩的大小与正负也在不断改变，这里不妨规定船体扶正的力矩方向为正。在倾斜角度增大的过程中，力矩臂从正到负，而船体则在力矩臂由正转负的转折点时达到其AVS从而倾覆。当这一浮力产生的扭矩能够使得船体回到稳定平衡的原始位置时，它就是扶正力矩。为此，重心与浮心必须大致满足垂直对齐。如果这两个点稍微偏离对齐状态，则会产生一个扶正扭矩，将两个点推回到对齐状态。两点对齐的下一个可能角度是不稳定的平衡，这意味着如果稍微偏移，系统将无法恢复到其原始状态。当系统稍微偏离不稳定的平衡状态时，所产生的扭矩将改变角度，以使两点变得更加偏离对齐状态。 基于上述对于扶正力矩的定义阐述与分析，我们可以得出以下公式： 式中的GZ为重力作用线与浮力作用线的垂直距离，称为扶正力臂；而MR则为扶正力矩。 扶正力矩与扶正力臂在受力分析图中的呈现如下图所示： 上述分析中提到，稳性消失角仅仅与扶正力矩由正转负的过程有关。通过对于上述式子的观察，不难发现，由于船体扶正或倾覆仅仅取决于扶正力矩的正负，而该计算式中扶正力矩的正负仅仅由扶正力臂的正负所决定，因此基于我们的分析需求，要得到稳性消失角以衡量扶正能力，只需要关注扶正力臂的正负而不关心具体的数值大小，事实上由公式可知扶正力矩只是在扶正力臂的基础上乘上了恒为正的系数（浮力大小）。于是，关键即在于对于坐标系中扶正力臂的求取。具体到坐标系中扶正力臂的计算公式会在后续Matlab程序仿真实现时详细推导与阐述，在此不详细展开。 对于不同的倾斜角度而言，由于淹没部分的形状不同导致浮心位置不同，扶正力臂的大小和正负自然也不同。因此，为了得到稳性消失角，我们可以通过绘制不同倾斜角度下的扶正力臂数值图像，从而得出图像零点处的倾斜角度（横坐标）即为稳性消失角（如下图)。 4.2船体模型构建与仿真模拟4.2.1设计思路基于以上数学物理分析，结合定量分析的需求，我们制定如下设计流程： 具体到实际的设计流程中，我们考虑到如下事实：当船底形状越平，该船的重心越低，船在载重的时候越不容易倾斜，船的平衡性更好。因此，我们基于以上原理，首先通过设计手绘图纸（见附件：切片.docx）的形式确定每一个切片（即船体沿长度方向的横截面）的轮廓形状，然后将切片以草图的形式在Fusion360建模软件中进行绘制，再对各切片草图进行放样操作即可得到船体外壳建模模型；在建模的草图绘制过程中，同时又在y(宽度)方向以一定步长进行采样，得到一系列离散坐标点，从而导入Matlab中进行进一步的仿真定量分析，最终得到符合要求的稳性消失角。 4.2.2基于Fusion 360软件实现船体建模具体实现步骤如下： 将绘制的切片曲线草图依次插入作为画布，并根据草图轮廓（适当修正）利用多点曲线拟合工具得到每一个切片的草图（如下图），各切片之间相隔特定的长度。 在绘制草图曲线的过程中，对于拟合后的放样曲线在宽度方向上以0.5cm为步长进行采样，结合各切片所在的长度坐标可得到船体的点云数据(详见附件our boat.xlsx)，以供后续Matlab仿真处理。 切换至曲面工具，对得到的每一个切片草图的曲线轮廓进行放样操作，得到船体模型大致的表面曲线；再修改选择使用曲面切线，使得曲线更加符合设计草图并更加自然流畅；最后进行封顶，完成船体外形的大致建构。 4.2.3基于Matlab软件构造船体外壳曲面数学模型通过上述利用Fusion360进行的建模过程，我们成功地将切片的草图实体化成了3D模型，并在这一过程中获得了点云数据坐标。接下来，我们将记录在excel表格中的x、y、z点云坐标分别导入Matlab中的mat文件并命名为“X.mat”、“Y.mat”和“Z.mat”存储下来。随后，通过load命令将三个数据文件导入Matlab中的工作区，并利用cftool指令使用曲线拟合器，分别选择X、Y、Z数据，通过多项式对点云数据进行拟合，效果如下图所示。（详情见文件”ourboat.sfit”） 值得注意的是，在点云的获取过程中，我们以船体最下方的点在船体前端的投影作为坐标原点，以船体的长度方向作为x轴，由船头向船尾延伸；船体的宽度方向为y轴，以船的中轴线为分界线，沿x正方向看去左边y值为负，右边y值为正；船底到船顶为z轴正方向。 将所得到的拟合图与建构出的3D模型进行对比，除去比例尺的因素外，外壳形状基本一致，说明模型建构有效，数据与拟合函数可信度高，可以进行下一步仿真。在验证数据有效性的同时，我们也得到了拟合出的曲面函数（如图中右下“结果”框图所示），将其存于函数文件“calculate.m”中，便于后续仿真验证时进行调用。 除此之外，在仿真验证的程序中，我们在导入点集数据之外还需要对船体的各项参数进行定义，并给出微分步长，同时对已有的点集数据进行适当的处理使结果更加合理。 下面给出船体数学模型建立部分的Matlab实现代码： 123456789101112131415161718192021222324252627282930%Step1:船体数学模型建立%导入船体点集数据load('X.mat');load('Y.mat');load('Z.mat');%定义船体参数 单位：cm g%以下参数都基于对于船体实物的测量给出boat.L =39.9; %长boat.W = 17.4; %宽boat.HB = boat.W / 2; %半宽boat.D = 5.4; %深density_water = 1; % g / cm^3boat.mass = 2000; %船体外壳总质量%x为长，y为宽，z为深，做切片（微分）；切片数量为num%dx,dy,dz即为三个方向的微分步长num=100;dy = boat.W/num; dz = boat.D/num; dx = boat.L/num;%构建船体外壳曲面模型mesh.xs = 0:dx:boat.L;mesh.ys = -boat.HB:dy:boat.HB; mesh.zs = 0:dz:boat.D;[mesh.ygrid,mesh.zgrid] = meshgrid(mesh.ys,mesh.zs);[Xi,Yi]=meshgrid(mesh.xs,mesh.ys);Zi=griddata(X,Y,Z, Xi,Yi);%griddata:对二维或三维散点数据插值——增加有效数据量，减少误差surf(Xi,Yi,Zi);shading flat;axis('equal'); 在这里，我们运用了griddata插值函数，对于取样的点云进行了进一步的补充，使得拟合的函数模型曲面更接近于实际情况。所得到的船体曲面模型如下图所示。 至此，我们成功地在Matlab中对我们设计的船体进行了数学函数的拟合，并通过对于函数图像的绘制模拟出船体的外壳模型，同时在程序中对于船体的点云数据以及宏观参数与微分步长都进行了导入与定义，为后续的仿真过程做好准备。 4.2.4船体重心与浮心三维坐标计算及其Matlab实现重心计算：在前面的原理分析部分，我们已经给出物体重心的详细计算方法。 下面给出了Matlab中的实现代码： 123456789101112131415161718192021222324252627282930313233343536373839%Step2:计算船体重心的三维坐标:COM_x=0;%x轴上的重心COM_y=0;%y轴上的重心COM_z=0;%z轴上的重心tnt=0;%有效点个数i=find(isnan(Zi));Zi(i)=0;%去掉NaN点的影响for i=1:num for j=1:num COM_x=COM_x+Xi(i,j); COM_y=COM_y+Yi(i,j); COM_z=COM_z+Zi(i,j); tnt=tnt+1; endend%加入除船壳外的结构，数据均通过实际测量得出%可乐1m1=500;boat.finalmass=boat.mass+m1;x1=10;y1=0;z1=1;%可乐2m2=500;boat.finalmass=boat.finalmass+m2;x2=30;y2=0;z2=1;%桅杆m3=1000;boat.finalmass=boat.finalmass+m3;x3=20;y3=0;z3=8;%最终的重心三维坐标：COM_x, COM_y, COM_zdensity=boat.mass/tnt;COM_x=(COM_x*density+m1*x1+m2*x2+m3*x3)/boat.finalmass;COM_y=(COM_y*density+m1*y1+m2*y2+m3*y3)/boat.finalmass;COM_z=(COM_z*density+m1*z1+m2*z2+m3*z3)/boat.finalmass; 通过运行上述程序，我们可以得到我们设计的船在加上配重与桅杆后的最终重心坐标为： 各倾角下浮心计算：在原理分析部分我们提到，船体的浮心位置会随倾斜角度的改变而不断改变。结合我们在获取稳性消失角时的绘图需求，我们采用循环结构，对从0度到180的所有倾斜角度进行遍历，分别求出各角度下的浮心坐标。 以下是浮心三维坐标计算的Matlab实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243%Step3:计算船体浮心三维坐标%初始化：COB_x,COB_y,COB_z记录每个切片的浮心（2D）COB_x=[];COB_y=[];COB_z=[];MMass=[];%每个浮心点的权重（质量）tot_mass=0;%总质量Y=[];%遍历1-180度的所有theta值for theta=1:1:180 for i=1 :num %对每个x积分 ZZ=[];%记录该X下的Z轴坐标 for j=1 :num+1 %讨论y从-boat.HB到boat.HB t=calculate(i*dx,mesh.ys(1,j)); ZZ=[ZZ t]; end boat.hull = mesh.zgrid &gt; ZZ; %在所计算的Z的值之上的就是船的截面 %不同theta下的水线表示 %确定重力浮力平衡以迭代调整水线 d =water_line(mesh,theta,boat,dx,dy,dz,num);%寻找函数零点 y = mesh.ys; z = -tand(theta).*y+d; if theta&gt;90 &amp;&amp; theta&lt;=180 water = (mesh.zgrid-boat.D/2) &lt; z; elseif theta&lt;=90 &amp;&amp; theta&gt;=0 water = (mesh.zgrid-boat.D/2) &gt; z; end %定义淹没区域 sub_region = flipud(boat.hull)&amp;water;%矩阵交集,求取排水体积;&amp;位与运算（都是1才得1） %计算船体浮心 COB = centerOfMass2(sub_region,mesh); COB_z=[COB_z COB(1,2)]; COB_y=[COB_y COB(1,1)]; COB_x=[COB_x i*dx]; MMass=[MMass matrixSum(sub_region)]; tot_mass=tot_mass+matrixSum(sub_region); end %得出三维浮心坐标 ANS=centerOfMass3(COB_x,COB_y,COB_z,MMass,tot_mass,num);%计算三维浮心 COB_x=ANS(1,1); COB_y=ANS(1,2); COB_z=ANS(1,3); 从而我们可以得到不同倾斜角度theta下的浮心三维坐标。 在上述计算浮心的程序实现中，事实上我们是对于整个船体的浮心进行了整体的求取，具体而言是将船体沿x轴（长度）方向以一定步长微分为num（船体模型建构程序段中有给出定义，是微分的分数）份切片，每一片都分别求取重心的y-z坐标并最终沿x轴方向叠加得到整个船体的浮心。 具体到对于每一个切片的浮心求取，虽然实际情况中是船体在水中倾斜，但为了方便计算，我们不妨处理成船体不动而水线不断改变，当船体的倾斜角度为theta时，水线的斜率应为-tan(theta)；同时在计算时，基于浮力大小不变的原则，即船体淹没部分的体积不变，可以通过函数water_line进行迭代从而得到水线在船体切片的二维y-z坐标系的截距（在数据处理上对于迭代次数与精度进行限制以节约计算时间）。经过上述处理，我们可以得到各倾斜角度theta下各个切片平面中的水线方程。值得注意的是，这里为了使结果更加精确，我们将各点的x,y坐标重新带入了建构模型时所得到的calculate函数从而得到与实际更加接近的z值坐标，并以此来框定各个切片下的函数方程描述。在原理分析部分提到，在某一切片平面中，水线与水线之下的船体函数共同框定了水体淹没面积，对这一部分进行重心的求取即为切片的浮心。 下面给出water_line函数的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839function D_line = water_line(mesh,theta,boat,dx,dy,dz,num) number = 1; i=1; d = -0.02; d_gap = 0.07; density_water = 1000; while number&lt;100 y = mesh.ys; z = -tand(theta).*y+d; if theta&gt;90 &amp;&amp; theta&lt;=180 water = (mesh.zgrid-boat.D/2) &lt; z; elseif theta&lt;=90 &amp;&amp; theta&gt;=0 water = (mesh.zgrid-boat.D/2) &gt; z; end %水线下的水体矩阵 sub_region = flipud(boat.hull)&amp;water; %矩阵交集，求取排水体积 force=sub_region.*density_water*dz*dy*dx; %计算单个微分方块的力 lift= matrixSum(force); %整体浮力 up_force=lift-(boat.finalmass/num); %浮力剩余值 if up_force&lt;0 d=d+d_gap/i; elseif up_force&gt;0 d=d-d_gap/i; else break; end if up_force&gt;-0.01&amp;&amp;up_force&lt;0.01 %判断阈值，水线收敛 break; end i=i*2; %缩短步长 number=number+1;end D_line = d; End 此处同时展示部分功能函数： 12345678910111213141516171819202122232425262728293031323334353637383940function COM = centerOfMass2(masses,mesh) % centerOfMass2: computes center of mass in 2D % masses: matrix of masses % mesh: structure containing ygrid and zgrid % returns: Vector [ycom,zcom] M = matrixSum(masses); ycom = matrixSum(masses .* mesh.ygrid) / M; zcom = matrixSum(masses .* mesh.zgrid) / M; COM = [ycom,zcom];endfunction plotMatrix(A,mesh,cmap) % plotMatrix: plots a matrix using image % A: matrix % mesh: srtruct containing ys and zs % cmap: Colormap colormap(cmap); image(mesh.ys,mesh.zs,flipud(A),'AlphaData',0.5);endfunction M = matrixSum(masses) % matrixSum: returns total of all elements in the matrix % normally sum(m) computes the sums of the columns % selecting m(:) flattens the matrix and computes the sum of all elements % see https://stackoverflow.com/questions/1721987/what-are-the-ways-to-sum-matrix-elements-in-matlab M = sum(masses(:));endfunction ANS=centerOfMass3(XMass,YMass,ZMass,MMass,m,num)x=0;y=0;z=0; for i=1:num x=x+XMass(1,i)*MMass(1,i)/m; y=y+YMass(1,i)*MMass(1,i)/m; z=z+ZMass(1,i)*MMass(1,i)/m; end ANS=[x,y,z];end 4.2.5 船体扶正力臂计算与图像绘制扶正力臂计算原理与公式推导： 在原理分析部分中，我们给出了扶正力矩的定义与扶正力臂的图示，并揭示了只需要计算扶正力臂即可通过判断其正负来获得稳性消失角，但并没有给出具体在坐标系中的计算公式。在这里，将进行计算方法的推导并给出扶正力臂的计算公式。 在上述对于浮心坐标求取的代码实现阐述中，我们提出可以将水中船体的倾斜等效为以船体为参考系下水线的旋转。基于这样的分析思路，我们给出了如下左图所示的示意图，以对于扶正力臂的计算进行进一步的推导。 值得注意的是，尽管图中所表示的仅仅是船体的一个截面，但在实际情况中，若船体在无干扰情况下能稳定在水中平稳漂浮，船体重心与浮心的x坐标在误差允许范围内应可以视为一致，因此在仿真计算中，我们暂时忽略重心与浮心的x坐标而仅仅关心两者的位置关系及这一关系在y-z坐标上的体现。 基于这样的分析，结合上述图示，我们不难得出如上右图所示公式。 另外，所谓扶正力矩必然能够使得船体回正而非倾覆，这就要求力矩的方向应与倾斜角度theta增加的方向相反，因此我们不妨规定这一方向为正方向，在图中第二种情况中显示为船体向右（顺时针方向）倾斜，于是扶正力矩（臂）则以逆时针方向为正。基于这一原理，我们给出了如下方法以判定其正负性，这也是得到最终稳性消失角的关键一环。 在完成了上述推导之后，即可根据推导分析结果设计Matlab程序实现仿真验证。 该部分的程序实现代码如下： 12345678910%Step4:求恢复力臂 k1 = -tand(theta); if ((k1*COB_z+COB_y-COM_y)/k1)-COM_z&lt;0 flag1=1; else flag1=-1; end l = flag1*abs(COB_y+k1*COB_z-k1*COM_z-COM_y)/(k1^2+1)^0.5;%恢复力臂 Y=[Y,l];end 扶正力臂-倾斜角度图像绘制与稳性消失角： 在扶正力臂的求取部分，我们在不同的theta情况下用矩阵Y来存储各角度下的扶正力臂值，以便于绘制θ-l图像，从而根据观察图像得出稳性消失角。 以下为该部分代码实现： 12345%Step5:绘制扶正力臂曲线x=1:1:180;x1=1:1:180;y1=interp1(x,Y,x1,'spline');plot(x1,y1); 最终得到的图像如下图所示。通过观察图像，可以得到我们的船体模型的稳性消失角大致在120-140度之间，满足稳定性要求。 4.2.6误差分析(1)采样点云、拟合曲线与实际船体模型的误差： 由于采样的点云坐标是在对于手绘草图的建模刻画过程中进行读取的，与手绘出的供船体加工的切片草图仍然存在一定的差距，这会带来一定的误差；而在对于点云数据的插值与函数拟合过程中也存在着一定的误差。除此之外，载重的测量误差以及船体在实际加工建造时产生的误差也不可忽略。但由于缺乏一定的工具对于我们建造出的船体实体进行精确的测量与3D模型建构，在数据处理的过程中我们已经对于一些偏差较大的离散点数据进行了纠正或删除处理，使得最终的结果仍然在预期范围之内，并与实际情况相一致。 (2)Matlab仿真时微分步长不足够细分而引起的误差： 在程序仿真设计过程中，我们对于船体从x、y、z三个方向按一定步长分割为若干份，并重点研究沿x轴方向进行切分的各切片以求得船体的重心与浮心坐标。但在实际程序实现的过程中，考虑到运算速度与准确度等多方面因素，各个方向进行分割的份数num不可能做到逼近于现实的无穷大，在上述程序中我们经过测试得到的一个较为合适的num值为100，这导致我们的仿真计算与实际的情况仍然存在一定的误差。但由于采样点的数量也较为有限，num的有限选取也不会对最终的结果造成致命的影响，仍然可以使得船体的稳性消失角最终呈现在可控的目标范围。 五、初代船体制造与实现效果 5.1船型外壳5.1.1结构设计实现为了减轻船体重量，采用了木制板材作为船体材料，通过骨架搭建，外层包裹来实现船模外壳的搭建，过程中主要用到了实木板，白乳胶等材料，加工过程使用绳锯，切割机，打磨机以及电钻等工具。 首先，我们根据最初的船体建模，对模型进行切片处理，以此来获得设计船的肋骨图纸和甲板图纸的必要参数，并根据设计出的肋骨图纸以及甲板图纸加工船体骨架，并进行拼装（详见下图）。 然后利用乳胶，热熔胶和木板，将船体外构型粘贴以达到塑性目的。 5.1.2舰岛设计同样利用模板拼接的方式，构筑舰岛模型。此设计中舰岛的上半部分与下半部分并未粘接，属于分体，用于装载货物使用。 5.2 动力装置 电池：3.5V锂电池 130电机：3.5V 0.7W 双发推力约1.5N 电路板含有电机控制模块（MX1919H实现）与信号接收处理模块。此外设计了对水的感应电路，螺旋桨触水可以遥控发动，离水则发生断路不可发动 螺旋桨部分采用万向结构，这样来减弱偏移对传动的影响。 5.3 防水设计对于船体设计采用了报纸与乳胶混合贴合加固船体的方法，使船体表面硬化并做到初步防水，在彩绘之后涂刷丙烯酸透明防水胶达到更高水平的防水效果。 *船舶防水涂料的应用止水胶防水施工技术。止水胶是一种单组分，无溶剂，遇水膨胀的聚氨酯类无定型膏体，在隧道二次初砌施工缝处设止水胶防水带，以及在钢筋，管线等周围设置止水胶，当接缝中有水渗入时，止水胶的弹性压缩应力和遇水膨胀压力双重作用填塞缝隙，可以有效的防止因接缝不密封出现的渗漏情况，具有较好的密封止水性能，能抗大的水压力。 在舰岛可拆卸部分的设计中，我们采用了轮廓加橡塑胶带的方法，一方面使舱盖固定，另一方面填充缝隙达到防水的效果。 5.4 实现效果在额外载重约700g时，“冲浪者号”吃水过深，并且行进速度大幅降低，全速只有约0.15m/s，而且倾覆角度区间难以满足，于是我们对船体进行了进一步的改进与升级，以达到最初的设计要求。 六、基于定量分析的迭代 6.1 迭代方案思路基于上述的实验效果并结合Matlab建模仿真的结果进行比照，尽管从船型设计上来讲我们所设计的初代船体外形已经达到了额定的稳性消失角要求，具有一定的扶正能力，但在实际的工程测试过程中我们发现，由于船型设计得过小，在装载上配重后整体的吃水深度较大导致船舶在水中航行的稳定性与扶正力矩相关指标的实际表现并不尽如人意；除此之外，在Matlab仿真过程中给出的除船体外壳外的离散质量点的坐标数据也较为模糊，对于稳性消失角模拟的结果造成了一定程度上的印象。通过以上的分析，我们初步设想在迭代过程中尽可能对船体进行再加工，通过延长船体长度的方式扩大相同吃水深度下排开水的体积以提供更大的浮力，从而控制船体满载情况下的吃水深度仍然在可控范围内；同时在仿真模拟的过程中增加对于电力驱动模块中的电机、电池等具有相当质量的组件的坐标导入与运算，并对于各离散质量点的坐标进行精细化处理使其更接近于实际情况，以提高仿真模拟的准确度与有效性。 6.2 迭代方案的定量分析6.2.1 船体外形的修正基于上述的分析结果与初步迭代思路，我们初步定下了延长船体长度的再加工方案，结合对于已有船体的加工现状分析与船体的稳定性考虑，最终决定将船体长度延长至74cm。以下代码给出了对于重新设计的船体的基本参数的定义与设置： 12345678%定义船体参数 单位：cm g%以下参数都基于对于船体实物的测量给出boat.L = 74; %长boat.W = 16.5; %宽boat.HB = boat.W / 2; %半宽boat.D = 7; %深density_water = 1; % g / cm^3boat.mass = 653.8; %船体外壳总质量 除了船体的宏观参数调整之外，相应的，我们还需要在原有的点集数据基础之上对于延长后的部分进行数据的补充，并将新的点云数据集存储在Matlab文件中，再利用cftool曲线拟合器工具获得新的拟合函数表达式并导入函数文件calculate.m中以在后续的仿真模拟中重复调用。下图展示了新点云数据集所拟合出的函数曲面图像以及对应拟合函数的表达式： 在仿真验证的程序中，我们在导入新的点云数据后，为了进一步验证数学模型建构的准确性，仍然需要通过插值函数griddata补充数据并绘制函数曲面图像与fusion 360建模结果进行一定的比对，效果图如下: 6.2.2 离散数量点数据的校准与补充在第一代船的仿真模拟数据中，我们在船体外壳的点云数据之外仅补充了配重与桅杆两部分的质心坐标数据及其质量，而忽略了电控模块其余组件的相关数据，且显然由于电控模块中电池与电机的重量相对于船体整体重量来说并不可忽略不计，所以在本次迭代过程中，在Matlab仿真程序的代码实现中对于这一部分进行了补充，同时对于船体中各零散组件的质心坐标及其质量进行了相对精准的测量与估算，从而提高仿真模拟的准确度，使其更加贴近实际情况。补充调整后船体内的离散质量点的相关数据如下列程序段所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384%加入除船壳外的结构%可乐1m1=356;boat.finalmass=boat.mass+m1;x1=34;y1=0;z1=9.8;%可乐2m2=356;boat.finalmass=boat.finalmass+m2;x2=44;y2=0;z2=9.5;%桅杆m3=116;boat.finalmass=boat.finalmass+m3;x3=39;y3=0;z3=49.5;%上层外壳m4=116.1;boat.finalmass=boat.finalmass+m4;x4=0;y4=39;z4=12.5;%尾部甲板m5=49.4;boat.finalmass=boat.finalmass+m5;x5=64.5;y5=0;z5=6.2;%电池m6=185.1;boat.finalmass=boat.finalmass+m6;x6=12;y6=0;z6=5.5;%电机1m7=190.4;boat.finalmass=boat.finalmass+m7;x7=53;y7=4;z7=3;%电机2m8=191.6;boat.finalmass=boat.finalmass+m8;x8=53;y8=-4;z8=3;%电调1m9=49.4;boat.finalmass=boat.finalmass+m9;x9=20.5;y9=6;z9=7;%电调2m10=49.6;boat.finalmass=boat.finalmass+m10;x10=20.5;y10=-6;z10=7;%船桨1m11=43.5;boat.finalmass=boat.finalmass+m11;x11=73.5;y11=3.8;z11=1;%船桨2m12=40.3;boat.finalmass=boat.finalmass+m12;x12=73.5;y12=-3.8;z12=1;%前端甲板m13=18.2;boat.finalmass=boat.finalmass+m13;x13=20.5;y13=0;z13=6.3;%最终的重心三维坐标density=boat.mass/tnt;COM_x=(COM_x*density+m1*x1+m2*x2+m3*x3+m4*x4+m5*x5+m6*x6+m7*x7+m8*x8+m9*x9+m10*x10+m11*x11+m12*x12+m13*x13)/boat.finalmass;COM_y=(COM_y*density+m1*y1+m2*y2+m3*y3+m4*y4+m5*y5+m6*y6+m7*y7+m8*y8+m9*y9+m10*y10+m11*y11+m12*y12+m13*y13)/boat.finalmass;COM_z=(COM_z*density+m1*z1+m2*z2+m3*z3+m4*z4+m5*z5+m6*z6+m7*z7+m8*z8+m9*z9+m10*z10+m11*z11+m12*z12+m13*z13)/boat.finalmass; 在获得了更加精准的离散质量点的相关数据后，我们可以利用上述程序段的最后部分来计算整个船体在装载了配重与电力驱动模块后的重心在x、y、z轴上的坐标，结果如下图所示： 6.2.3 稳性消失角的最终呈现经过上述结合实际情况后对于点云与离散质量点的数据补充与完善，我们将新的数据导入Matlab程序并再次运行，最终得到了如下图所示的l-θ图像以反映船体倾斜角度与扶正力臂之间的函数关系： 该图也成功体现了改进后的船型设计仍然能够使得稳性消失角维持在120-140度之间，能够满足对于船体稳定性与扶正能力的相关要求，可以进行下一步的迭代加工操作。 七、迭代产品制造过程与实现效果 7.1 迭代产品制造7.1.1 船体再制造为解决原有船体载重后吃水过深的问题，第二代的“刃海级”加长了“冲浪者号”船体长度，本次船体长度在制造前进行了较为周密的运算（各模块重量数据见程序部分），通过对各模块质量的初步掌握，以及配重块和所载重物的估计重量，结合原船型截面面积，计算出额在不改变原有船模外形的前提下，所需加长船身的长度以及大致的吃水情况(船体加长至74cm，空载预估吃水2.87cm，满载预估吃水4.56cm，后经实验实际情况与估计值差距不超过10%) 7.1.2 电控系统改进由于船体整体加大增重以及为解决之前动力不足的问题，更换了另外一套控制系统（功率更大的电机，螺旋桨，电池，电子调速器以及信号接收发遥控系统），改进后的推力更强，满足了设计要求中对动力的需求。 电机参数情况： 实际安装情况： 7.1.3 驱动优化以及节能设计在更换大功率电机之后，电机发热明显增加，为了提高船舶的安全性，可靠性，在迭代过程中，加入了水冷却系统。除此之外为了合理利用船体空间并节约一定能源，在船舶顶部加装了与冷却系统相连的供电装置。 太阳能板与内置电池串联，同时并联水泵与控制板，达到水冷与控制喷水的效果。 额定发电电压：6V 发电最大：150mA 尺寸：60mm*110mm 7.2 迭代产品实现效果7.2.1 实验效果 空载条件下，倾覆角150° 载有饮料的条件下倾覆角大约为130° 7.2.2 微调满足设计要求船舶下水后未调整前倾覆角明显大于140°，于是在船体舰岛舱内加装配重块（仓顶左右两侧各25g），空载倾覆角135°左右，满载倾覆角125°左右。 八、最终成品与总结 8.1 “刃海级” 8.2 项目总结与感悟本次项目历经两次迭代，最后基本实现了项目设计要求，产品还存在需要改进的地方。第一代“冲浪者号”设计中在定量化设计步骤中有疏忽掉配重块的问题，帮助我们发现了我们定量化设计方法的问题所在，总结了第一代的经验之后第二代“刃海级”较为成功地实现了项目设计地要求。 产品的研发设计离不开严格的定量化分析，更离不开多次地迭代更新，在这个过程中我们可以不断学习用到的相关知识，包括电路，控制，材料，结构，力学，软件等等一系列的相关知识，给了我们更开阔的眼界，也锻炼了我们的能力和意志。最重要的是教会了我们定量化分析的思想，为以后项目及产品的开发提供了极大的帮助！","link":"/2023/05/19/boat/"},{"title":"进销存管理系统","text":"本项目全部代码已同步上传至Github,仓库链接：Asgard-Tim/Vendition: 重庆大学明月科创实验班软件设计课程作业 (github.com) 一、需求分析 1.1 进销存管理业务概述随着近年来世界各方面的发展进步和物联网时代的到来及其不断发展，货物销售行业发生了翻天覆地的巨大变革，随着从卖方市场向买方市场的转变，我国的零售行业迅速崛起，并且时时刻刻面临着日益激烈并不断变化的竞争环境。因此，提高进销存管理水平，探索降低成本的方法成为提高企业竞争力的必然选择[1]。 伴随着企业规模的不断扩大和企业效益的进一步发展，原先的管理已经不能跟上企业的发展步伐，更无法满足企业对管理工作快速、准确的要求。在销售业务不断增长的同时，公司日常所需要处理的数据量不断增长，公司内部运转周转的中间传递环节也逐渐增多，进而发展到非常的复杂的经营管理模式，同时，现在复杂多变的市场，人工管理等传统的方法方式在相关方面已无法应对。更为重要的是商品的进销存方面缺乏实时处理的相关分析，管理人员对及时传递资料和命令的需求得无法实现。最后发现如果能够在面对不同种类的货物信息时，能够让管理人员实时掌握销售流程及销售情况，进而支持管理人员对相关商品销售的运营并且可以有效地加速的周转率，从而可以进一步提高行业的服务质量。这时可以组建一个记录、更新、保存数据信息的数据库以建立和支持一个合理高效的软件项目[2]。 具体而言，进销存管理业务的核心是对于商品流动信息的储存与管理，主要涉及到商品品类的新增与删除、进货、商品销售与盘点、平库等相互关联的诸多业务流程。因此，在进销存管理系统中，我们需要让这些业务流程在系统中有所体现，从而达到高效管理的目的。 1.2 功能性需求1.2.1 商品信息管理在进销存管理系统中，需要提供渠道给操作管理人员以录入或删除商品信息，同时对于日常的进货与销售过程予以记录，并在需要的时候对库存中已有的商品种类与数量进行盘点，必要时还需要进行平库操作。这些流程会涉及到公司内的诸多部门，诸如采购部、市场部、财务部等，组织架构的复杂性也对软件系统设计的联动能力与处理效率提出了较高的要求。因此，我们不仅需要通过程序设计实现与实际操作对应的相关功能，对于操作人员在系统中输入的文本信息进行读取与必要的处理以模拟上述诸多对于商品实体的实际操作流程，同时还需要建立与实际仓库所对应的商品的数据库，通过对于所有商品的编号、名称、单价、库存数量与计量单位等具体信息进行存储，并在管理人员进行操作的过程中对库中存储的商品信息进行与实际情况同步的改动，实现更加高效的管理。 1.2.2 系统安全对于公司而言，系统的安全性是软件系统设计过程中一个至关重要的考虑因素，由于系统缺乏维护管理与必要的保护措施所造成的损失与影响将是不可估量且难以弥补的。在进销存管理系统中，系统安全的问题主要可能出现在操作权限与非法输入等方面。基于这样的考虑，软件系统在处理数据时，需要对于非法的输入进行区分并给予用户一定的操作提示；在功能上，需要通过账户密码匹配的机制以对于操作人员的权限进行一定的限制从而保证系统的安全性；在存储数据时，应对于存入的数据在写入文件的同时进行一定的加密操作，防止外部人员盗取或进行修改；同时在用户进行操作时，需要同步保留用户的操作记录，在必要时以供核查。 1.3 非功能性需求1.3.1 性能需求 1.系统必须具备高可用性，能够保证系统长时间连续运行的需求； ​ 2.系统的响应时间应尽可能的短，系统登陆、信息保存等操作响应时间小于1.5秒，信息查询等复杂操作时间小于2秒； ​ 3.数据库容量要大，能够满足商品采购、销售、库存管理等详细信息长时间保存的需求； ​ 4.可供多个用户分时使用该系统平台。 1.3.2 易用性需求 1.系统的相关提示信息一致，如进货、销售、删除、查询等操作功能，应尽可能使人容易理解； ​ 2.有明确的输入限制提示信息； ​ 3.中英文对应正确。 1.3.3 可扩展性需求 在系统底层设计时，需要强化系统的配置和扩展能力，主要体现在以下方面： ​ 1.系统底层支持的可扩展性； ​ 2.系统数据结构可搭建； ​ 3.系统信息展示的可配置性。 二、系统设计 2.1 系统开发方案进销存系统需要在简单快速，并且容易维护的、安全性强的开发环境中进行设计[3]。 2.1.1 系统开发技术事实上，进销存管理的过程，本质上是由操作人员对货物信息进行的一系列操作，而不论是操作人员还是货物，都是系统中的对象，操作人员具有账户和密码等属性，货物则具有编号、名称、数量的属性。基于这样的考量，本进销存管理系统基于命令行界面进行设计，利用面向对象的思想，选用Microsoft Visual Studio Code 作为系统开发工具，后台数据库采用txt格式的文本文件，开发语言选择C++语言。 2.2 技术架构设计系统技术架构上，从上往下分为表示层、业务逻辑层和数据层。系统对每一层定义功能明确的功能接口，同时在层次内实现组件化的接口实现。层次化、模块组件化的实现，使系统具备了最大程度的灵活度，从而能对业务需求的变化作出快速的反应，使系统具有很好的扩展性。 表现层主要是调用业务逻辑层的功能与用户直接进行交互。 业务逻辑层包含了所有业务逻辑的设计与实现，如用户登录、新增商品种类、删除商品种类、商品进货、商品销售、浏览商品信息、显示操作记录、盘点等。 数据层指具体存储系统各种业务数据的数据库系统，在本进销存管理系统中，选用了txt格式的文本文件作为数据库，以便于数据的快速读写。 本进销存管理系统的总体架构如图2.1所示。 图2.1 系统体系架构图 2.3 功能结构与模块设计2.3.1 系统管理该系统包括系统界面初始化、用户注册账户、用户登录等相关功能。系统管理模块主要具体实现以下功能： 1.系统界面初始化 用户进入系统，为用户显示操作功能菜单，提示用户进行相应操作；在用户完成一项操作后，刷新界面并重新初始化当前界面。 2.用户注册账户 若用户第一次使用该系统，需要注册自己的账号并设置密码，不符合规定的密码无效，需要重新注册；完成注册操作后，系统会自动将输入的账号与密码配对并存入数据库中，供登录时进行比对。 3.用户登录 若用户已有账号或已完成注册，可输入自己的账号、密码进行登录操作，若与数据库中的已有条目相一致，则说明该用户具有操作权限，可进入进销存系统内部模块进行下一步操作；若输入的账号与密码不匹配或输入有误，会提示用户重新进行输入。 2.3.2 商品采购、销售与库存管理商品采购、销售与库存管理系统主要包括新增商品种类、删除商品种类、商品进货、商品销售、浏览商品信息、显示操作记录、盘点与平库等相关功能。商品信息管理模块主要具体实现以下功能： 1.新增商品种类 输入需要录入系统的商品的编号、名称、单价、计量单位与库存数量等基本信息，增加商品种类，并同步在数据库中存入该商品的相关信息与操作记录。 2.删除商品种类 输入需要删除的商品种类的编号，即可在系统数据库删除该商品的所有条目信息，并在数据库中留下操作记录；若输入的商品编号无法在数据库中检索到，则该操作无效并给予用户反馈提示。 3.商品进货 对于数据库中已有的商品种类可以进行该操作，否则提示操作失败；输入需要进货的商品种类的编号，界面中会出现数据库中该商品的所有信息，再输入需要进货的数量，若进货的数量有效（为正数），会对应增加该商品的数量并存入数据库中，同时留下操作记录。 4.商品销售 对于数据库中已有的商品种类可以进行该操作，否则提示操作失败；输入需要销售的商品种类的编号，界面中会出现数据库该商品的所有信息，再输入需要销售出去的货物数量，若销售的数量有效（小于等于库存量且为正数），会对应减少该商品的数量并存入数据库中，同时留下操作记录。 5.浏览商品信息 可以将数据库中已有的所有商品的编号、名称、单价、计量单位与库存数量等基本信息以表格的形式展示在界面中以供操作人员进行核对查验。 6.显示操作记录 可以显示改变商品数量的所有操作的操作记录，包括每一次操作的操作类型、操作参数（输入的库存改变量）、操作人员账号和操作时间；其中平库操作进行标红处理。 7.盘点与平库 可以将数据库中已有的所有商品的编号、名称、单价、计量单位与库存数量等基本信息以表格的形式展示在界面中以供操作人员进行核对查验；在盘点完成后，若数据库中的商品数量与实际情况存在出入，在确认原因后可以选择进行平库操作，对于特定商品进行额外的出库或入库操作；平库操作会进行标红处理。 8.数据存储 为了保留已有的操作结果与操作记录，在每一次对于数据库中的商品进行操作时，都会从数据库中重新读取商品信息数据，并在操作完成后将改动之后的商品数据重新存入磁盘的数据库中，并在数据库中保留操作的记录以供日后查验；这也有利于不同操作人员在该系统平台上的协同操作，同时重新启动系统时程序的状态也不会发生改变。 2.4 设计目的与优势2.4.1 设计目的在系统界面与整体功能架构的设计上，对于两个模块均采取了先初始化界面显示操作列表、再根据用户的操作指令给予对应的提示、完成相应操作的模式进行设计，并在各个功能的完成过程中贯穿了对于数据库的读写操作以实时修改，以功能实现为导向，希望帮助操作用户更加高效地实现商品信息的读取与写入。 2.4.2 设计优势1.界面简洁自然，各项功能列表一目了然，方便操作人员迅速完成操作，减少误操作的概率； 2.对于所有输入的位点都进行了规范化处理，保证输入的数据格式都是合乎要求的，同时对于非法的输入操作都给予了反馈警告，便于用户快速上手； 3.设计功能齐全，可以满足大多数情况下商品的采购、销售与库存管理操作； 4.运用数据库实时储存用户信息、商品信息与操作记录，方便必要时进行查询，同时也有利于保存数据，支持多用户对于系统进行操作； 5.用户登录机制与操作记录保存机制为系统的安全性提供了一定的保障。 三、系统实现 本系统的具体框架如下图3.1所示。当成功登录窗口后，用户即进入到主界面中，此时用户可以通过模块选择在自己操作权限范围内的操作，并可在各个功能模块之间进行切换。 图3.1 系统功能流程图 3.1 命令行界面的初始化实现在设计时，我们根据需求，希望系统的界面能够在完成一项指令操作后刷新并重新加载操作功能菜单以使用其他功能。因此，在登录窗口与系统内部商品处理两个模块的界面加载中，采用了相同的实现逻辑以达到这一效果。具体实现逻辑如下图3.2所示。最终实现效果符合预期。 图3.2 命令行界面初始化流程图 3.2 登录界面——用户权限管理实现在登录界面，系统为用户提供了三个选项卡：用户登录、用户注册与退出系统，并分别有与之对应的操作代码。具体实现时，采用了选择分支结构，对于用户输入的功能编号进行检测，并对非法的输入给予反馈，提示需要重新输入正确的功能编号（本系统中所有需要输入操作代码的地方均采用了该流程，后面不再赘述）。 对于文件的读写，在程序中创建了相应的文件操作对象以进行相应的读写操作，并在每一次操作完成后关闭文件并重新打开以重置读写指针，防止影响到后续的操作。（进销存模块的文件读写操作与这里方式相同，后面不再赘述）。 对于用户的个人信息，设计了类user，具有用户名和密码两个私有属性，并设计了一系列公有函数对其进行读写，随后在用户注册与登录环节对该类进行实例化，并对实例化后的对象进行一系列的读写操作以实现功能。（在进销存模块中，对于商品类goods与操作记录类operations也采取了相同的方式进行处理，后面不再赘述）。 若选择“退出系统”选项卡，会提示用户是否确认退出：若确认推出，则立刻自动关闭窗口，反之则重新加载界面。效果图如图3.3。 若选择“用户注册”选项卡，会提示用户输入自己想要设置的用户名与密码（会提示用户用户名和密码只能包含字母和数字；用户名若与库中已有的用户名重复，会提示注册失败；密码还限制了位数不得少于六位，若不足六位也会提示注册失败，需要重新注册）；注册成功后，用户的信息会自动存入用户数据库文件“userinformation.txt”，同时重新加载界面。效果图如图3.4。 若选择“用户登录”选项卡，会提示用户输入用户名和密码，输入完成后与数据库中的对应文件进行匹配，若匹配成功则进入进销存系统模块（在程序编写过程中具体体现为进入函数login），反之则提示输入有误，请重新输入，并重新加载界面。效果图如图3.5。 该模块的详细实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;class user{private: string username; string password;public: void putusername(){cin&gt;&gt;username;} void putpassword(){cin&gt;&gt;password;} string getusername(){return username;} string getpassword(){return password;}};void initialize(){ cout&lt;&lt;&quot;********************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 欢迎您使用进销存系统 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 1.用户登录 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 2.用户注册 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 0.退出系统 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;********************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入您需要执行的功能编号:&quot;;}int main(){ while(true) { fstream userinformation; userinformation.open(&quot;userinformation.txt&quot;,ios::in|ios::app); initialize();//初始化界面 //账号注册与登录模块 string op1; cin&gt;&gt;op1; if(op1==&quot;1&quot;) { //用户登录，先让用户输入账号和密码 user user1; int flagin=0; cout&lt;&lt;&quot;请输入您的用户名:&quot;; user1.putusername(); cout&lt;&lt;&quot;请输入您的用户密码:&quot;; user1.putpassword(); //将用户录入的与文件中保存的账号密码进行比对 string use=user1.getusername()+&quot; &quot;+user1.getpassword(); while(true) { string inform; getline(userinformation,inform); if(inform==&quot;&quot;) break; if(use==inform) { cout&lt;&lt;&quot;亲爱的用户&quot;&lt;&lt;user1.getusername()&lt;&lt;&quot;,欢迎您登录本系统&quot;&lt;&lt;endl; Sleep(1000); system(&quot;cls&quot;); login(user1.getusername());//进入进销存系统 flagin=1; break; } } if(flagin==0) { cout&lt;&lt;&quot;您输入的账号或密码错误,请检查后重新输入&quot;; Sleep(1000); } } else if(op1==&quot;2&quot;) { //用户注册，输入用户名与密码 user user1; cout&lt;&lt;&quot;请输入您的用户名(仅可使用数字与字母):&quot;; user1.putusername(); //判断用户名是否已经存在 int flag=0; while(true) { string name; userinformation&gt;&gt;name; string empty; getline(userinformation,empty); if(name==&quot;&quot;) break; if(user1.getusername()==name) { cout&lt;&lt;&quot;您输入的用户名已经存在,注册失败,请重新输入&quot;&lt;&lt;endl; Sleep(1000); flag=1; break; } } userinformation.close(); userinformation.open(&quot;userinformation.txt&quot;,ios::in|ios::app); if(flag==0) { cout&lt;&lt;&quot;请输入您的用户密码(仅可使用数字或字母,不小于6位):&quot;; user1.putpassword(); //判断用户输入的密码是否符合要求，若符合要求则录入文件 string pass=user1.getpassword(); if(pass.length()&lt;6) { cout&lt;&lt;&quot;您输入的密码小于6位,请重新输入&quot;&lt;&lt;endl; Sleep(1000); } else { cout&lt;&lt;&quot;您已成功注册,请进行登录&quot;&lt;&lt;endl; userinformation&lt;&lt;user1.getusername()&lt;&lt;&quot; &quot;&lt;&lt;user1.getpassword()&lt;&lt;endl; Sleep(1000); } } } else if(op1==&quot;0&quot;) { int fl=0; while(fl==0) { cout&lt;&lt;&quot;您确认要退出该系统吗?(是请按1,否请按0)&quot;; int opp; cin&gt;&gt;opp; if(opp==1) exit(0); else if(opp==0) fl=1; else cout&lt;&lt;&quot;您输入有误,请重新输入&quot;&lt;&lt;endl; } } else { cout&lt;&lt;&quot;您输入了无效的操作代码,请重新输入&quot;; Sleep(1000); } userinformation.close(); system(&quot;cls&quot;); } return 0;} 图3.3 “退出系统”功能效果图 图3.4 “用户注册”功能效果图 图3.5 “用户登录”功能效果图 3.3 商品进销存功能实现进入进销存模块界面，系统为用户提供了八个选项卡：新增商品种类、删除商品种类、商品进货、商品销售、浏览商品信息、显示操作记录、盘点、退出登录，并分别有与之对应的操作代码。 若选择“退出登录”选项卡，会直接退出登录，停顿一秒后回到登录主界面。效果图如图3.6。 若选择“新增商品种类”选项卡，会提示用户输入需要新增种类的商品编号（不得与数据库中已有的商品编号相同，否则会提示重新输入），并依次提示输入商品的名称、单位、价格与库存数量；提示添加成功后，该商品的信息会自动存入商品数据库文件“goodsinformation.txt”，而相应的操作记录（包括操作编号、操作的商品编号、操作的种类、操作的商品数量、操作人的用户名与操作时间等详细信息）会被录入操作数据库文件“operationinformation.txt”(“删除商品种类”、“商品进货”、“商品销售”、“盘点”等操作也会在操作完成后录入该数据库，后面不再赘述)，同时重新加载界面。效果图如图3.7。 若选择“删除商品种类”选项卡，会提示用户输入需要删除的商品编号（必须是库中已有的商品种类，否则会提示重新输入）；提示删除成功后，数据库中该商品的条目信息也会一并删除，同时留下操作记录，并重新加载界面。效果图如图3.8。 若选择“商品进货”选项卡，会提示用户输入需要进货的商品编号（必须是库中已有的商品种类，否则会提示重新输入），并相应显示该商品的详细信息；用户还需要输入进货量（不可以为负数，否则提示重新输入）。提示进货成功后，数据库中该商品的库存量也会相应增加，同时留下操作记录，并重新加载界面。效果图如图3.9。 若选择“商品销售”选项卡，会提示用户输入需要销售的商品编号（必须是库中已有的商品种类，否则会提示重新输入），并相应显示该商品的详细信息；用户还需要输入销售量（不可以为负数或小于库存量，否则提示重新输入）。提示销售成功后，数据库中该商品的库存量也会相应减少，同时留下操作记录，并重新加载界面。效果图如图3.10。 若选择“浏览商品信息”选项卡，将会把数据库中所有货物的详细信息列举出来以供查看。效果图如图3.11。 若选择“显示操作记录”选项卡，将会把数据库中所有操作记录的具体信息列举出来以供查看。其中，平库过程中的出库与入库操作均会被标红。效果图如图3.12。 若选择“盘点”选项卡，将会把数据库中所有货物的详细信息列举出来以供查看，并在下方提示是否需要平库。若选择不需要平库，则会直接重新加载界面；若选择需要平库，则需选择需要出库或者入库（此行会被标红以示警告），出库操作与商品销售类似，而入库操作则与商品进货类似，在此不再重复。效果图如图3.13。 该模块的详细实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;#include&lt;ctime&gt;#include&lt;iomanip&gt;using namespace std;string gettime(){ time_t t=time(NULL); tm *now=localtime(&amp;t); int year=1900+now-&gt;tm_year; int mon=1+now-&gt;tm_mon; int day=now-&gt;tm_mday; int hour=now-&gt;tm_hour; int min=now-&gt;tm_min; int sec=now-&gt;tm_sec; string to_year=to_string( year ); string to_month=to_string( mon ); string to_day=to_string( day ); string to_hour=to_string( hour ); string to_min=to_string( min ); string to_sec=to_string( sec ); return to_year+&quot;-&quot;+to_month+&quot;-&quot;+to_day+&quot; &quot;+to_hour+&quot;:&quot;+to_min+&quot;:&quot;+to_sec;}class goods{private: string no; string name; string count; string price; int num;public: void putno(){cin&gt;&gt;no;} void putname(){cin&gt;&gt;name;} void putcount(){cin&gt;&gt;count;} void putprice(){cin&gt;&gt;price;} void putnum(){cin&gt;&gt;num;} void putnum(int input){num=input;} void putno(string input){no=input;} void putname(string input){name=input;} void putcount(string input){count=input;} void putprice(string input){price=input;} string getno(){return no;} string getname(){return name;} string getcount(){return count;} string getprice(){return price;} int getnum(){return num;}};class operations{private: string no; string kinds; int num; string acount; string date; int flag;public: void putno(string input){no=input;} void putkinds(string input){kinds=input;} void putnum(int input){num=input;} void putacount(string input){acount=input;} void putdate(){date=gettime();} string getno(){return no;} string getkinds(){return kinds;} int getnum(){return num;} string getacount(){return acount;} string getdate(){return date;} int putflag(int input){flag=input;} int getflag(){return flag;}};void systeminitialize(string username){ cout&lt;&lt;&quot;******************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 功能菜单 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 1.新增商品种类 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 2.删除商品种类 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 3.商品进货 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 4.商品销售 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 5.浏览商品信息 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 6.显示操作记录 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 7.盘点 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 0.退出登录 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;******************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;亲爱的用户&quot;&lt;&lt;username&lt;&lt;&quot;,欢迎进入进销存管理平台&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入您需要执行的功能编号:&quot;;}string CharToStr(char * contentChar){ string tempStr; for (int i=0;contentChar[i]!='\\0';i++) { tempStr+=contentChar[i]; } return tempStr;}void DelLineData(char* fileName, int lineNum){ ifstream in; in.open(fileName); string strFileData = &quot;&quot;; int line = 0; char lineData[1024] = {0}; while(in.getline(lineData, sizeof(lineData))) { line++; if (line == lineNum) continue; else { strFileData += CharToStr(lineData); strFileData += &quot;\\n&quot;; } } in.close(); //写入文件 ofstream out; out.open(fileName); out.flush(); out&lt;&lt;strFileData; out.close();}void login(string username){ while(true) { fstream goodsinformation; goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); fstream operationinformation; operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); systeminitialize(username);//初始化界面 //进销存系统内部操作 string op2; cin&gt;&gt;op2; if(op2==&quot;1&quot;) { goods good1; cout&lt;&lt;&quot;请输入商品编号:&quot;; good1.putno(); //检测输入商品的编号，若编号与之前的一致，则需要重新输入 int flag1=0; while(true) { string no; goodsinformation&gt;&gt;no; string empty1; getline(goodsinformation,empty1); if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(good1.getno()==no) { cout&lt;&lt;&quot;您输入的商品种类已经存在,本次录入操作失败,请重新输入&quot;&lt;&lt;endl; Sleep(1000); flag1=1; break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag1==0) { cout&lt;&lt;&quot;请输入商品名称:&quot;; good1.putname(); cout&lt;&lt;&quot;请输入商品单位:&quot;; good1.putcount(); cout&lt;&lt;&quot;请输入商品价格:&quot;; good1.putprice(); cout&lt;&lt;&quot;请输入商品库存数量:&quot;; good1.putnum(); cout&lt;&lt;&quot;添加商品种类成功&quot;&lt;&lt;endl; goodsinformation&lt;&lt;setw(10)&lt;&lt;good1.getno()&lt;&lt;setw(10)&lt;&lt;good1.getname()&lt;&lt;setw(10)&lt;&lt;good1.getcount()&lt;&lt;setw(10)&lt;&lt;good1.getprice()&lt;&lt;setw(10)&lt;&lt;good1.getnum()&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(good1.getno()); operate1.putkinds(&quot;新增商品种类&quot;); operate1.putnum(good1.getnum()); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } } else if(op2==&quot;2&quot;) { cout&lt;&lt;&quot;请输入您需要删除的商品编号:&quot;; string no1; cin&gt;&gt;no1; int flag2=0; int line=1; while(true) { string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { //删除商品信息 DelLineData(&quot;goodsinformation.txt&quot;, line); cout&lt;&lt;&quot;删除商品种类成功&quot;&lt;&lt;endl; flag2=1; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;删除商品种类&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } line++; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,删除商品失败,请检查后再试&quot;&lt;&lt;endl; system(&quot;pause&quot;); } else if(op2==&quot;3&quot;) { cout&lt;&lt;&quot;请输入需要进货的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //显示该商品在系统中的信息 cout&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; cout&lt;&lt;no2&lt;&lt;setw(10)&lt;&lt;name2&lt;&lt;setw(10)&lt;&lt;count2&lt;&lt;setw(10)&lt;&lt;price2&lt;&lt;&quot; &quot;&lt;&lt;setw(10)&lt;&lt;num2&lt;&lt;endl; //进货 cout&lt;&lt;&quot;请输入进货量：&quot;; int num1; cin&gt;&gt;num1; //判断非负 if(num1&lt;0) { cout&lt;&lt;&quot;进货量不能小于零,输入有误,请重新输入&quot;&lt;&lt;endl; break; } good2.putnum(num1+num2); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;进货成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;商品进货&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品进货失败,请检查后再试&quot;&lt;&lt;endl; system(&quot;pause&quot;); } else if(op2==&quot;4&quot;) { cout&lt;&lt;&quot;请输入需要售出的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //显示该商品在系统中的信息 cout&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; cout&lt;&lt;no2&lt;&lt;setw(10)&lt;&lt;name2&lt;&lt;setw(10)&lt;&lt;count2&lt;&lt;setw(10)&lt;&lt;price2&lt;&lt;&quot; &quot;&lt;&lt;setw(10)&lt;&lt;num2&lt;&lt;endl; //进货 cout&lt;&lt;&quot;请输入销售量：&quot;; int num1; cin&gt;&gt;num1; if(num1&lt;0) { cout&lt;&lt;&quot;销售量不能小于零,输入有误,请重新输入&quot;&lt;&lt;endl; break; } int out=num2-num1; if(out&lt;0) { cout&lt;&lt;&quot;库存量不足,无法销售,请核对后重新输入&quot;&lt;&lt;endl; break; } good2.putnum(out); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;商品销售成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;商品销售&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品销售失败,请检查后再试&quot;&lt;&lt;endl; system(&quot;pause&quot;); } else if(op2==&quot;5&quot;) { cout&lt;&lt;setw(10)&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; while(!goodsinformation.eof()) { string informate; getline(goodsinformation,informate); if(goodsinformation.fail()) break; cout&lt;&lt;informate&lt;&lt;endl; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } else if(op2==&quot;6&quot;) { int optime=1; cout&lt;&lt;setw(15)&lt;&lt;&quot;编号&quot;&lt;&lt;setw(15)&lt;&lt;&quot;商品编号&quot;&lt;&lt;setw(15)&lt;&lt;&quot;所作操作&quot;&lt;&lt;setw(15)&lt;&lt;&quot;数量&quot;&lt;&lt;setw(15)&lt;&lt;&quot;操作人账户&quot;&lt;&lt;setw(25)&lt;&lt;&quot;操作时间&quot;&lt;&lt;endl; while(!operationinformation.eof()) { int flag; operationinformation&gt;&gt;flag; string empty; getline(operationinformation,empty); if (flag==0) { string informate; getline(operationinformation,informate); if(operationinformation.fail()) break; cout&lt;&lt;setw(15)&lt;&lt;optime&lt;&lt;informate&lt;&lt;endl; optime++; } else if (flag==1) { string informate; getline(operationinformation,informate); if(operationinformation.fail()) break; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED); cout&lt;&lt;setw(15)&lt;&lt;optime&lt;&lt;informate&lt;&lt;endl; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED |FOREGROUND_GREEN | FOREGROUND_BLUE); optime++; } } operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } else if(op2==&quot;7&quot;) { cout&lt;&lt;setw(10)&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; while(!goodsinformation.eof()) { string informate; getline(goodsinformation,informate); if(goodsinformation.fail()) break; cout&lt;&lt;informate&lt;&lt;endl; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); cout&lt;&lt;&quot;---------------------------------------------&quot;&lt;&lt;endl; int flagx=0; while(flagx==0) { cout&lt;&lt;&quot;是否需要平库?(是请按1,否请按0)&quot;; int op3; cin&gt;&gt;op3; if(op3==1) { int flagy=0; while(flagy==0) { //设置红色字体 SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED); cout &lt;&lt; &quot;您需要出库还是入库?(出库请按1,入库请按0):&quot; ; int op4; cin&gt;&gt;op4; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED |FOREGROUND_GREEN | FOREGROUND_BLUE);//把颜色换回来 if(op4==0) { flagy=1; cout&lt;&lt;&quot;请输入需要入库的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //入库 cout&lt;&lt;&quot;请输入入库量：&quot;; int num1; cin&gt;&gt;num1; //判断非负 if(num1&lt;0) { cout&lt;&lt;&quot;入库量不能小于零,输入有误,请重新输入入库量:&quot;; break; } good2.putnum(num1+num2); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;商品盘点成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;盘点入库&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(1); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品盘点失败,请检查后再试&quot;&lt;&lt;endl; } else if(op4==1) { flagy=1; cout&lt;&lt;&quot;请输入需要出库的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //出库 cout&lt;&lt;&quot;请输入出库量：&quot;; int num1; cin&gt;&gt;num1; if(num1&lt;0) { cout&lt;&lt;&quot;出库量不能小于零,输入有误,请重新输入出库量:&quot;; break; } int out=num2-num1; if(out&lt;0) { cout&lt;&lt;&quot;库存量不足,无法完成出库操作,请核对后重新输入出库量:&quot;; break; } good2.putnum(out); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;商品盘点成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;盘点出库&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(1); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品进货失败,请检查后再试&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;输入有误,请重新输入&quot;&lt;&lt;endl; } flagx=1; } else if(op3==0) flagx=1; else cout&lt;&lt;&quot;输入有误,请重新输入&quot;&lt;&lt;endl; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } else if(op2==&quot;0&quot;) { cout&lt;&lt;&quot;正在为您登出中……&quot;; Sleep(1000); return; } else { cout&lt;&lt;&quot;您输入了无效的操作代码,请重新输入&quot;; Sleep(1000); } goodsinformation.close(); operationinformation.close(); system(&quot;cls&quot;); }} 图3.6 “退出登录”功能效果图 图3.7 “新增商品种类”功能效果图 图3.8 “删除商品种类”功能效果图 图3.9 “商品进货”功能效果图 图3.10 “商品销售”功能效果图 图3.11 “浏览商品信息”功能效果图 图3.12 “显示操作记录”功能效果图 图3.13 “盘点”功能效果图 四、总结 本文首先对进销存管理业务的现状进行归纳，通过分析目前的进销存管理流程，找出存在的问题和原因，对信息化手段给进销存管理带来的好处进行评估，并制订流程以改进管理方案，从系统功能、性能、运行环境等方面提出进销存管理系统的需求，确定开发方案，本着面向对象编程的核心思想，根据数据结构，找到实体间的关系，细化设计思路，并最终依托命令行界面完成了整个进销存管理系统的设计与实现。 根据需要，本进销存管理系统采用三层架构设计，功能模块涵盖了系统管理与商品信息管理两大板块，采用文本文件作为整个系统的数据库，具有实用性、通用性、使用性、扩充性、安全性能高，维护成本低等优点。 在完成了初版的整体设计以及程序实现之后，又对其各项功能进行了多方面的测试，针对其中不足的方面以及小的漏洞进行了进一步的调试、修正、完善与迭代，目前已经能够正常运行。在整个项目的完成过程中，一方面是对于C++编程语言的掌握在实践中进行又一次的巩固加强，另一方面也是对于面向对象这一重要的程序设计思想的深入体会。 总而言之，个人对于本次进销存管理系统项目的完成度是比较满意的，但目前的系统程序仍然存在着许多问题有待于进一步深入研究与学习。一方面是模块化的程度并没有达到预期的效果，整个程序结构仍然稍显冗长。事实上在整个程序设计过程中，受限于不断要对文件进行读写，很难将每一个选项卡单独拆分出来作为独立的函数，同时对于面向对象过程中类的使用仅仅停留在对于其内部私有成员的封装与访问，而并没有涉及到更进一步的针对于特定对象的函数编写与使用 ，希望之后可以进行进一步的迭代与改进。另一方面，虽然在界面设计时本着简洁实用的思想，但很多流程上以及设计上的细节仍然可以进一步深挖改进，这也需要基于一定的实际投放测试并收集反馈来进行；同时受限于时间紧迫，对于QT图形界面无法进行详细的学习以应用在本项目中，希望如果之后有机会可以基于QT界面对于本进销存管理系统进行进一步的重塑与迭代。 参考文献 [1] 郭宁 , 郑小玲.管理信息系统[M].北京 : 人民邮电出版社 , 2009. [2] 刘俊 , 钱瑞明 , 基于 B/S 结构、面向供应链的供销管理系统设计[J] , 微计算机管理 , 2004 ( 1 ) : 42-43 [3] 吴雪海.食品公司进销存系统设计与实现[D].导师：赫枫龄;张雪松.吉林大学,2015.","link":"/2023/05/02/vendition/"},{"title":"寻迹小车","text":"一、绪论 1.1 实验背景1.1.1 问题的情景长期以来，由于我国是人口大国而且工业基础薄弱，因此早期在我国机器人的发展受到一定的限制。然而随着制造业工人的人力成本的不断上升与社会自动化程度的不断提高，我国也开始着重于发展机器人，并且也取得了较大的进步。在 1995 年，我国沈阳自动化所开始研制HT—100A点焊机器人，是我国较早的机器人了，如图1所示；此后，沈阳新松公司研发出了6 kg弧焊机器人，此机器人不仅实用，而且轻便，如图 2 所示；之后，哈尔滨工业大学机器 人研究所也研发出了便携式机器人，此机器人具有 6 自由度，增强了焊接能力，成为在恶劣环境中实现焊接功能的重要设备。总之，在国家“863 计划”与“十一五”计划的指导下，我国机器人的设计取得了飞速发 展，甚至在机器人的某些关键部件的设计已经接近于世界先进水平，并在世界工业机器人领域已经占有一席之地了。 1.1.2 实验的目的目前，机器人的发展趋势非常的迅猛，机器人可以替代人类去从事高危险的工作，减轻了人类的劳动强度。本文通过对机器人的发展史进行简要的介绍，阐明了我国发展机器人的必要性。同时，对于我国的发展而言，我国正处于工业化进程的关键时期，将来的高强度、高危险行业的工人数量将会急剧的下降，机器人将会迎来新的“春天”，所以机器人的发展仍拥有巨大的发展空间。同时，由于我国各机器人的厂商对于机器人的研发能力与金钱投资的不同，在我国的机器人市场上的竞争也会愈演愈烈，最终也将形成我国的机器人研发市场。总之，在未来的几十年里，相信重点发展机器人将会成为社会的发展趋势，不久机器人将会引领未来，加入到我国现代化建设的行列中。小车，也就是轮式机器人，作为以学科交叉、产品创新为特色的明月班同学，切入这个产业不失为优秀的选择，故而选取小车为切入点了解相关知识。 1.2 实验内容1.2.1 使用51单片机控制及其元器件STC89C52控制板芯片、1.5V干电池x4、L298N电机驱动板x1、红外循迹模块、直流电机x2以及搭建材料若干； 1.2.2使用FPGA开发板控制及其元器件Cyclonell EP2C5T144控制板芯片1.5V干电池x4、L298N电机驱动板x1、红外循迹模块、直流电机x2以及搭建材料若干； 二、实现过程 2.1 总体工作原理简释2.1.2 红外循迹模块第一步，位于小车前端的红外模块会释放红外线探测下方是否为黑色区域，并将相应的高低电平信号传递至控制模块（51单片机/FPGA开发板）处理，控制模块随后将发送信息至L298N电机驱动的控制模块，并由此控制左右两轮的转动速度以及转动方向，从而实现对黑线的反应和循迹。 作为电机的驱动模块，该模块对控制小车移动有着重要且直接的作用。 利用红外发射器向地面发射红外线，并用传感器接收由地面反射的红外线。当红外接收模块下方为黑色轨迹时，红外线被黑色轨迹吸收，传感器没有接收到红外线，红外循迹模块输出低电平到单片机。反之，传感器接收到红外线，红外循迹模块输出高电平到单片机。可通过红外循迹模块输出的信号来判断小车是否偏离轨迹。可调电阻可以调节传感器的灵敏度，易于调试。使用红外循迹模块方案也易于实现，红外循迹方案相比于摄像循迹成本更加便宜，软件设计更加简单，设计制作周期短，具备一定可靠性。 对于左电机，共有输入ENA、IN1、IN2，输出OUT1（黑线）、OUT2（红线）、其信号与运动对应如下：（0,X,X）停止、（1,0,0）停止、（1,1,0）正传、（1,0,1）反转、（1,1,1）停止； 对于右电机，共有输入ENB、IN3、IN4，输出OUT3（黑线）、OUT4（红线），其信号与运动对应如下：（0,X,X）停止、（1,0,0）停止、（1,1,0）反传、（1,0,1）正转、（1,1,1）停止。 2.1.3 L298N电机驱动模块 L298N是ST公司的一款电机驱动芯片，也是集成了双H桥，但与上面两个略有不同。电机驱动电压3~48V；可持续工作的输出电流为2A，峰值可达3A。如上图，L298N模块明显有较多的外接元件，这与L298N的内部结构有关。如上图，由于该芯片在H桥上的损耗严重发热较明显（饱和压降大），需要加装散热片，因此在使用上比前两个芯片复杂，体积也相对较大。其各引脚如下图所示。 2.2 使用51单片机部分2.2.1 硬件接线 1为电源输入，与电池盒的输出线相连；2为电源输出，3为驱动板输入，两者需要相连，注意红线为VCC，黑线为GND；4 为单片机IO口引脚，5为驱动板的IN1到 IN4以及ENA和ENB，按照器件上的标注对应连接即可。 6 为与循迹模块的对应接口，按照器件上的标注对应连接即可。 7 和 8 为驱动板与两个电机之间的连线，按照上图所示连接即可。 到这里，基本完成了小车的硬件组装与线路连接，小车要完成循迹进行这些连线就够了，不过在烧录程序到单片机中时还需要 额外的连线，这个将在后面进行说明。 供电上使用四节5号电池。 2.2.2 程序设计首先是如何处理红外模块的探测结果。我们需要先对结果进行编码。我们记没有识别到黑线为0，识别到为1，则我们需要一个算式来囊括左右传感器结果并能对不同情况进行表示。在这里，我们记data2为左边的结果，data3为右边的结果，现给出算式data1=data2*10+data3，data1即检测结果。根据data2、data3不同组合：（1,1）在黑线上；（1,0）略向右偏离；（0,1）略向左偏离；（0,0）完全偏离轨道，分别对应了data1的四个取值，即11、10、1、0，亦即四种情况。相应的，我们需要做出四种反馈，即“前进”、“左转”、“右转”、“停下”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;reg52.h&gt;//51头文件unsigned char pwm\\_val\\_left, pwm\\_val\\_right; //中间变量unsigned char pwm\\_left, pwm\\_right; //定义PWM输出高电平的时间的变量（用户操作PWM的变量）#define PWM\\_DUTY 100 //定义PWM的周期，数值为定时器0溢出周期，假如定时器溢出时间为100us，则PWM周期为10ms。#define PWM\\_HIGH\\_MIN 35 //限制PWM输出的最小占空比#define PWM\\_HIGH\\_MAX PWM\\_DUTY //限制PWM输出的最大占空比/\\*电机驱动IO定义\\*/sbit leftMotorPwm = P1^5; //为1 左电机使能sbit IN1 = P1^4; //为1 左电机正转sbit IN2 = P1^3; //为1 左电机反转sbit IN3 = P1^2; //为1 右电机反转sbit IN4 = P1^1; //为1 右电机正转sbit rightMotorPwm = P1^0; //为1 右电机使能sbit leftSensor = P3^4;//左传感器：为0没有识别到黑线，为1识别到黑线sbit rightSensor = P3^5;//右传感器：为0没有识别到黑线，为1识别到黑线void Timer0\\_Init(void); //定时器初始化void LoadPWM(void);//装入PWM输出值void forward(unsigned char LeftSpeed, unsigned char RightSpeed);//前进void left\\_run(unsigned char LeftSpeed, unsigned char RightSpeed);//左转void right\\_run(unsigned char LeftSpeed, unsigned char RightSpeed);//右转void back(void);//后退修正void Tracking(){//为0 没有识别到黑线 为1识别到黑线char data1, data2 = leftSensor,data3 = rightSensor;data1 = data2\\*10+data3;if(data1 == 11)//在黑线上，前进{//forward(120,120);//前进forward(70,70);//前进}else{if(data1 == 10)//小幅偏右，左转{//left\\_run(80,160);//左转left\\_run(70,70);//左转}if(data1 == 1)//小幅偏左，右转{//right\\_run(160,80);//右转right\\_run(70,70);//右转}if(data1 == 0)//大幅偏左或偏右，已脱离轨道{back();//后退校正}}}/\\*主函数\\*/void main(void){Timer0\\_Init();//定时0初始化while(1){Tracking();}}void forward(unsigned char LeftSpeed,unsigned char RightSpeed){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 1;IN2 = 0;IN3 = 0;IN4 = 1;}void left\\_run(unsigned char LeftSpeed, unsigned char RightSpeed){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 1;IN2 = 0;IN3 = 1;IN4 = 0;}void right\\_run(unsigned char LeftSpeed, unsigned char RightSpeed){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 0;IN2 = 1;IN3 = 0;IN4 = 1;}void back(void){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 0;IN2 = 1;IN3 = 1;IN4 = 0;}/\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\* Timer0初始化\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/void Timer0\\_Init(void){TMOD |= 0x02;//定时器0，8位自动重装模块TH0 = 164;TL0 = 164;//11.0592M晶振，12T溢出时间约等于100微秒TR0 = 1;//启动定时器0ET0 = 1;//允许定时器0中断EA = 1;//总中断允许}/\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\* Timer0中断函数\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/void timer0\\_int (void) interrupt 1{pwm\\_val\\_left++;pwm\\_val\\_right++;if(pwm\\_left &gt; PWM\\_HIGH\\_MAX) pwm\\_left = PWM\\_HIGH\\_MAX; //如果左输出写入大于最大占空比数据，则强制为最大占空比。if(pwm\\_left &lt; PWM\\_HIGH\\_MIN) pwm\\_left = PWM\\_HIGH\\_MIN; //如果左输出写入小于最小占空比数据，则强制为最小占空比。if(pwm\\_right &gt; PWM\\_HIGH\\_MAX) pwm\\_right = PWM\\_HIGH\\_MAX; //如果右输出写入大于最大占空比数据，则强制为最大占空比。if(pwm\\_right &lt; PWM\\_HIGH\\_MIN) pwm\\_right = PWM\\_HIGH\\_MIN; //如果右输出写入小于最小占空比数据，则强制为最小占空比。if(pwm\\_val\\_left&lt;=pwm\\_left) leftMotorPwm = 1; //装载左PWM输出高电平时间else leftMotorPwm = 0; //装载左PWM输出低电平时间if(pwm\\_val\\_left&gt;=PWM\\_DUTY) pwm\\_val\\_left = 0; //如果左对比值大于等于最大占空比数据，则为零if(pwm\\_val\\_right&lt;=pwm\\_right) rightMotorPwm = 1; //装载右PWM输出高电平时间else rightMotorPwm = 0; //装载右PWM输出低电平时间if(pwm\\_val\\_right&gt;=PWM\\_DUTY) pwm\\_val\\_right = 0; //如果右对比值大于等于最大占空比数据，则为零} 2.3 使用FPGA开发板部分2.3.1 硬件接线系统时钟和复位信号必须为PIN17和PIN_90，不过这两个引脚在开发板上已经连接上了，无须手动连接。其它的引脚可以在下表中“FPGA引出I/O”部分选择即可，然后参照之间的51单片机进行连接。 此处附上接线实物图，需要注意的是，FPGA需要独立的接线供电，如充电宝等等。 2.3.2程序设计逻辑上大体与51相同，此处附上代码部分以及引脚的设置图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687LIBRARY ieee;USE ieee.std\\_logic\\_1164.all;ENTITY cartracking ISGENERIC (--时钟为50MHz，为了产生100Hz的PWM波，设置计数值为500000cnt\\_meta : INTEGER := 500000;--对应了停止、前进、左转、右转状态IN4到IN1的输出Back : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;0110&quot;;Forward : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;1001&quot;;Left\\_Go : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;0101&quot;;Right\\_Go : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;1010&quot;);--\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*输入输出端口\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*PORT (sys\\_clk : IN STD\\_LOGIC;sys\\_rst\\_n : IN STD\\_LOGIC;infrared : IN STD\\_LOGIC\\_VECTOR(1 DOWNTO 0);pwm\\_left : OUT STD\\_LOGIC;pwm\\_right : OUT STD\\_LOGIC;in\\_motor : OUT STD\\_LOGIC\\_VECTOR(3 DOWNTO 0));END cartracking;ARCHITECTURE trans OF cartracking ISSIGNAL cnt : INTEGER;SIGNAL duty\\_left : INTEGER;SIGNAL duty\\_right : INTEGER;BEGINPROCESS (sys\\_rst\\_n, infrared)BEGINIF (sys\\_rst\\_n = '0') THENduty\\_right &lt;= 60;duty\\_left &lt;= 60;ELSECASE infrared ISWHEN &quot;00&quot; =&gt;in\\_motor &lt;= Back;--后退WHEN &quot;01&quot; =&gt;in\\_motor &lt;= Right\\_Go;--右转--PWM波的占空比，应设置合适的值来控制小车的转速，为了在仿真时可以对比，特将左右轮设置了不同的占空比。duty\\_left &lt;= 35;duty\\_right &lt;= 55;WHEN &quot;10&quot; =&gt;in\\_motor &lt;= Left\\_Go;--左转duty\\_left &lt;= 55;duty\\_right &lt;= 35;WHEN OTHERS =&gt;in\\_motor &lt;= Forward;--前进duty\\_left &lt;= 50;duty\\_right &lt;= 50;END CASE;END IF;END PROCESS;PROCESS (sys\\_clk, sys\\_rst\\_n)BEGINIF (sys\\_rst\\_n = '0') THENcnt &lt;= 0;ELSIF (sys\\_clk'EVENT AND sys\\_clk = '1') THENIF (cnt = cnt\\_meta) THENcnt &lt;= 0;ELSEcnt &lt;= cnt + 1;END IF;END IF;END PROCESS;PROCESS (sys\\_clk, sys\\_rst\\_n)BEGINIF (sys\\_rst\\_n = '0') THENpwm\\_left &lt;= '0';pwm\\_right &lt;= '0';ELSIF (sys\\_clk'EVENT AND sys\\_clk = '1') THENIF (cnt &gt;= (cnt\\_meta / 100)\\* duty\\_left) THENpwm\\_left &lt;= '0';ELSEpwm\\_left &lt;= '1';END IF;IF (cnt &gt;= (cnt\\_meta / 100) \\* duty\\_right) THENpwm\\_right &lt;= '0';ELSEpwm\\_right &lt;= '1';END IF;END IF;END PROCESS;END trans; 3调试及优化 3.1简单优化由于在测试时需要在保证小车前进速度的同时兼顾其转弯的效率和稳定性，特别是如果直行时转速过快会导致小车在转弯时直接冲出赛道而无法循迹。在原本的设计中，我们将未识别到黑线的反应设置为电机停转而使得小车停止，而这会使得小车无法在冲出赛道后进行自我校正。因此，我们将未识别到黑线时的输出信号由“0000”改为“0110”，即使得左右电机均由原本的停转改为反转，从而实现循迹过程中对于轨道循迹的自我修正。 在 PWM 频率设置的时候， PWM 的频率太低可能导致电机转动不稳定，不 是匀速转动，而 PWM 频率过高可能导致电机反应不过来或者超过电路的上限截止频率。事实上，考虑到转弯过程的稳定性与速度问题，包括与直行过程的速度以及传感器的灵敏度调节配合，我们需要通过实际测试来进一步确定在直行、左转、右转和倒退过程中设定的PWM占空比与转速。具体在调试之后所得到的合适参数已经在上面的代码中有所体现，在此不过多赘述。 3.2调试过程考虑到验收时的重要评判标准是小车循迹一周的时间，且小车本身运动缓慢，我们首先将目光放在了转速的提高上。修改参数大幅提高了轮子的转速后，我们进行了一次实验：结果出乎意料，小车非但没有预想的那样，反而在行进的过程中持续摇摆。分析原因是行进角度不平行于轨道时容易冲出轨道，后续针对此原因，在红外灵敏度以及直行、左转、右转和倒退过程中设定的PWM占空比与转速多次调试与测试。中途红外模块损坏，经过排查确定后更换了新的。此外，我们注意到行进中的不稳定性还来自于万向轮的松散，我们尝试了不限于胶带、缠绳等各种方式加以限制，效果均不理想，虽然直道可以稳定快速行进，转弯却尤为吃力。 最后51的部分取得了第二名的不错成绩。但是FPGA部分却难遂人意。我们一直将注意力放在数据的调试上却忽略了时间的把控，以至于直到最后快结束才仓促进行测试，测试时还发生了接线断开等突发状况。我们本着希望更加灵活的愿望想别的同学借来充电宝供电，没想到这成为了测试失败的最大缘由——充电宝供电严重不足，导致小车行进乏力，但等到我们重新接上电脑供电确认可以正常运行时，却被告知时间已到，不允许再次测试以保证公平。最后无奈接受这个最慢的成绩。 参考文献 [1] 默默无闻小菜鸡. 电机驱动芯片（H桥、直流电机驱动方式）——DRV8833、TB6612、A4950、L298N的详解与比较[EB/OL]. https://blog.csdn.net/qq_44897194/article/details/105524808, 2020-5-11. [2] 周海,叶兵. 机器人的发展现状及应用前景[J]. https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C44YLTlOAiTRKibYlV5Vjs7iAEhECQAQ9aTiC5BjCgn0Rn5ykE3W8_mbbrKtMuQk3r9gP-p4derKJErhs1XrNO9Y&amp;uniplatform=NZKPT, 2017-6-18. 致谢 感谢老师们在本课程中的精心准备与付出。在数电和模电部分得到了曾正教授和袁刚教授的悉心教诲，在后续的项目部分得到了李敏教授和凌睿教授的认真指导，最终得以基本实现预定目标，特此鸣谢！","link":"/2023/03/05/car/"},{"title":"人脸识别项目","text":"本项目全部代码已同步上传至Github,仓库链接：Asgard-Tim/face_recoginition: 重庆大学明月科创实验班线性代数课程项目 (github.com) 使用方法与识别效果如下。","link":"/2023/02/11/facerecognition/"}],"tags":[{"name":"动手学深度学习","slug":"动手学深度学习","link":"/tags/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"单片机","slug":"单片机","link":"/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"路径规划","slug":"路径规划","link":"/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"},{"name":"RANSAC","slug":"RANSAC","link":"/tags/RANSAC/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"数据处理分析","slug":"数据处理分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"},{"name":"可视化","slug":"可视化","link":"/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"定量分析","slug":"定量分析","link":"/tags/%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"船","slug":"船","link":"/tags/%E8%88%B9/"},{"name":"小车","slug":"小车","link":"/tags/%E5%B0%8F%E8%BD%A6/"},{"name":"C51","slug":"C51","link":"/tags/C51/"},{"name":"FPGA","slug":"FPGA","link":"/tags/FPGA/"},{"name":"信号与系统","slug":"信号与系统","link":"/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"name":"傅里叶变换","slug":"傅里叶变换","link":"/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"频谱分析","slug":"频谱分析","link":"/tags/%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/"},{"name":"ChatGPT","slug":"ChatGPT","link":"/tags/ChatGPT/"},{"name":"QQbot","slug":"QQbot","link":"/tags/QQbot/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"图像识别","slug":"图像识别","link":"/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"卷积神经网络","slug":"卷积神经网络","link":"/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"自编码器","slug":"自编码器","link":"/tags/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机视觉","slug":"计算机视觉","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"XJH","slug":"XJH","link":"/tags/XJH/"},{"name":"传热学","slug":"传热学","link":"/tags/%E4%BC%A0%E7%83%AD%E5%AD%A6/"},{"name":"斯特林发动机","slug":"斯特林发动机","link":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%91%E5%8A%A8%E6%9C%BA/"},{"name":"工程热力学","slug":"工程热力学","link":"/tags/%E5%B7%A5%E7%A8%8B%E7%83%AD%E5%8A%9B%E5%AD%A6/"},{"name":"动力学仿真","slug":"动力学仿真","link":"/tags/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F/"}],"categories":[{"name":"动手学深度学习","slug":"动手学深度学习","link":"/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"课程项目","slug":"课程项目","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/"},{"name":"About XJH","slug":"About-XJH","link":"/categories/About-XJH/"},{"name":"定量工程设计方法I","slug":"课程项目/定量工程设计方法I","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95I/"},{"name":"工程原理","slug":"课程项目/工程原理","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"name":"定量工程设计方法II","slug":"课程项目/定量工程设计方法II","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95II/"},{"name":"明慵","slug":"About-XJH/明慵","link":"/categories/About-XJH/%E6%98%8E%E6%85%B5/"},{"name":"个人项目","slug":"个人项目","link":"/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"},{"name":"线性代数","slug":"课程项目/线性代数","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"软件设计","slug":"课程项目/软件设计","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"},{"name":"智能图像处理","slug":"课程项目/智能图像处理","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"明诚","slug":"About-XJH/明诚","link":"/categories/About-XJH/%E6%98%8E%E8%AF%9A/"},{"name":"工程设计","slug":"课程项目/工程设计","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}],"pages":[]}