{"posts":[{"title":"个人简历","text":"教育背景 重庆大学 人工智能（明月班） 本科 2022-至今 成绩： 89.94 / 100 | GPA：3.79 / 4.00 排名：1 / 22 英语水平：CET-4：582 ; CET-6：503 数学课程：数理综合（100）、线性代数（95）、概率论与数理统计（94）、数学物理方法（95） 专业基础课程：软件设计（96）、智能图像处理（99）、定量工程设计方法（91）、工程设计(91)、自动控制原理（90）、工程原理（83）、机器人基础（82） 项目经历 车道线与道路边缘的检测与识别数据集标注（Labelme）与深度学习（Pytorch） 课题组项目 2024年3月–2024年6月 大部分路况在道路边缘并无车道线分隔，但道路边缘具有比一般车道线更高的危险度，目前还没有能够显著识别出道路边缘的车道线识别模型 编写Python脚本读取公开车道线数据集TuSimple并进行转换，同时利用Labelme工具进行补充标注，额外标注出道路边缘 利用Pytorch框架构建基于anchor的CLRnet模型，编写训练与测试代码 基于ZNCC方法的双目视觉点云构建算法优化C++算法实习 中科融合感知智能研究院 2024年7月–2024年8月 阅读相关文献，在OpenCV已有的SGBM方法基础上引入ZNCC（零均值归一化互相关）模板匹配算法，优化双目视觉的视差计算过程 完成双目视觉相机的标定与图像数据采集，并基于视差与相机标定数据生成点云 有效提升了生成点云的速度与精度，单组图片点云生成速度在15ms左右，平均距离误差小于1% 实时修音麦克风Python 学院创新创业项目 2024年11月–2025年1月 利用开源模型实现人声分离与BPM检测，并基于帧检测方法实时修正音调 采用AI大模型技术模拟真实人声，实现局部垫音伴唱，帮助用户提升唱歌体验 针对实际应用场景中的失真等问题进行优化迭代，并将功能实装至硬件产品 专业技能 编程语言: C++, Python（Pytorch/Tensorflow）, Matlab, R 其他技能: 机械建模（SolidWorks/Fusion 360）, 嵌入式开发（C51, STM32F1/F4, Arduino, FPGA）, 机器人操作系统（ROS）, 物理有限元仿真（COMSOL）,机械动力学仿真（Adams）, 移动应用开发（QT）, 网页开发（html/css）， Unity 兴趣爱好：声乐，羽毛球，摄影，音游 竞赛经历 第十五届中国大学生物理学术竞赛（CUPT）组长 校级一等奖 2023年9月–2023年12月 完成Pumping Straw和Droplet Microscope两个赛题 对问题进行物理建模与分析求解，使用COMSOL有限元分析工具对物理过程进行仿真，利用Matlab进行数值计算与物理过程动画演示 设计（制造）实验装置进行定量实验，验证理论分析结果 2024 美国大学生数学建模竞赛编程手 国际级成功参赛 2024年2月 选取E赛题：Sustainability of Property Insurance 建立数学模型帮助保险公司进行承保决策，针对若干小问综合EWM、TOPSIS、CVM、ARIMA、AHP等多种数学模型进行建模 从多篇论文与数据网站获取参考数据，基于Python与Matlab对数据进行处理、分析与建模，解读程序运行结果并给出结论与建议 荣誉奖项 国家奖学金 2024年 校级优秀学生综合奖学金（乙等两次，丙等两次） 2023、2024年 重庆市艺术教育活动先进个人 2024年 校级优秀学生、校级文化艺术先进个人 2023、2024年 第七届大学生艺术展演声乐项目集体合唱本科甲组, 国家级二等奖 2024年6月","link":"/2025/02/22/index/"},{"title":"烟雾扩散问题","text":"1 研究背景简介1.1 研究背景与意义香烟烟雾中含有数千种化学物质，其中包括一氧化碳、尼古丁、苯等多种对人体有害的成分。这些物质在室内封闭环境中容易积聚，对人体健康构成显著威胁，尤其是二手烟和三手烟的危害已引起广泛关注。报告显示，2018年中国不吸烟者的二手烟暴露率为68.1%，其中家庭和工作场所是二手烟暴露的主要场所，这表明室内烟雾污染已成为影响公众健康的重要问题。因此，我们希望通过研究烟雾在室内环境中的扩散规律，为烟雾的控制、空气污染防治或室内空气质量管理提供参考，并帮助优化通风设计或制定健康防护措施。 烟雾的扩散过程受到室内温湿度、气流模式、房间结构及家具布置等多种因素的影响，具有较高的复杂性和随机性。深入研究烟雾扩散的传输机制，可以帮助揭示其污染范围与浓度分布，为优化室内空气质量管理提供理论支持。但在估计和预测吸入暴露风险时，由于与生物伦理学和动物保护相关的潜在限制，涉及人类志愿者和其他用于毒理学研究的哺乳动物替代模型的体内研究存在局限性。出于这样的考虑，我们希望通过理论分析建模与数值模拟的方式，得到烟雾扩散的一般规律，从而为提出可能的防控手段提供理论依据。 通过实验和仿真研究，能够验证不同通风方案对烟雾扩散的控制效果，为改善居住环境提供技术支持；利用数值模拟，可以精确再现不同环境下烟雾的扩散过程，从而更直观地评估各类干预措施的有效性。这种方法不仅降低了研究成本，还能为制定更加科学、精确的室内空气污染防控策略提供强有力的支持。 1.2 研究目标本研究旨在探讨室内封闭环境下烟雾的扩散特性，基于扩散方程等物理原理与数学物理方法对烟雾的扩散情况进行解析求解与数值模拟，重点分析烟雾的流动路径、扩散速率和浓度分布，以优化空气管理和烟雾控制策略。 在具体的研究过程中，我们主要采用特定尺寸的密封容器来模拟室内封闭环境以便于实验开展与现象观察；同时，我们的研究主要关注扩散过程中烟雾的扩散效果、扩散速度以及不同时刻的浓度分布这三个要素，并通过定量计算测量与定性观察现象相结合的方式，得到烟雾扩散浓度空间分布随时间变化的的一般数学物理规律，从而为设计室内烟雾浓度控制系统提供理论依据。 2 理论分析求解2.1 研究对象在实际研究过程中，为方便实验的开展，我们选择了粒径分布在0.1~10微米范围内的植物甘油（丙三醇）气雾作为研究对象，这也是电子烟烟雾的主要成分之一。之所以使用植物甘油气雾来代替香烟烟雾进行研究，主要出于以下考量： 安全性：植物甘油为食品级材料，无健康与环境污染风险 可控性：植物甘油气雾生成过程可控，可进行定量化分析 易获取性：价格低廉，易于获取 可重复性：物质纯度高，化学性质稳定 具体而言，植物甘油气雾具有以下几条显著的理化特性： 无色无臭，有甜味，极易溶于水 密度（25℃）：1.26 g/cm^3 分子量： 92.09 g/mol 主要粒径属于典型气溶胶粒径范围 挥发性极低，以小颗粒悬浮于空气中 在研究过程中进行这样的材料替换，具有如下的合理性： 植物甘油气雾与香烟烟雾的气溶胶形成机制相同（蒸发-冷凝），二者在扩散和湍流行为上具有共性 二者粒径分布相似，具备相似的扩散动力学特征 二者在扩散过程中的视觉效果接近，便于追踪扩散行为 在本研究的理论分析部分，重点关注植物甘油气雾的浓度（即单位体积中该种物质颗粒的质量）ρ(x, y, z, t)这一物理量在研究区域（长为x_0 = 40cm，宽为y_0 = 50cm，高为z_0 = 60cm的长方体规则区域）空间范围内的分布情况及其随时间的变化情况。 2.2 数学物理方程的导出针对烟雾扩散这一常见现象，有现成的实验规律——菲克定律（又称扩散定律）可以直接使用，其基本公式如下： $$\\overrightarrow{q} = - D\\nabla\\rho$$其中： 式中负号代表扩散转移的方向（浓度减小的方向）和浓度梯度（浓度增大的方向）相反； D：扩散系数，与物质的种类以及环境温度有关； ∇ρ：浓度梯度，描述浓度不均匀分布的程度； 扩散流强度，即单位时间通过单位（横截）面积的质量，描述扩散运动的强度： $$\\overrightarrow{q} = \\frac{dm_{g}}{dVdt}$$在本研究中，针对常温环境（25℃）下植物甘油气雾在空气中的扩散系数，可进一步通过Chapman-Enskog方程$$D_{AB} = \\frac{0.00143 \\times T^{1.75} \\times \\sqrt{\\frac{1}{M_{A}} + \\frac{1}{M_{B}}}}{P \\times \\sigma_{AB}^{2} \\times \\Omega_{D}}$$进行估算，代入空气的平均分子量28.97 g/mol和估计的分子直径0.5nm可计算得到此时的扩散系数约为：$$D = 0.0962{cm}^{2}/s$$由于我们的研究区域是一个长方体的三维规则区域，故在研究坐标系的选择上，以长方体区域的底端顶点为原点，长、宽、高延伸方向作为$x、y、z$正方向建立空间直角坐标系，原点在长方体上的对角顶点坐标为$(x_{0},\\ y_{0},z_{0})$。针对三个不同方向，还可以进一步地给出菲克定律的分量形式： $$q_{x} = - D\\frac{\\partial\\rho}{\\partial x},\\ \\ q_{y} = - D\\frac{\\partial\\rho}{\\partial y},\\ \\ q_{z} = - D\\frac{\\partial\\rho}{\\partial z}$$接下来将基于菲克定律和质量守恒定律给出三维扩散方程，即本研究涉及的数学物理方程： 对于空间中任一点(x, y, z)附近的无穷小空间而言：该空间内浓度变化取决于穿过其表面的扩散流。 考虑单位时间内x方向的扩散流： 左表面流入流量$$\\left. \\ q_{x} \\right|{x}dydz$$右表面流出流量$$\\left. \\ q{x} \\right|{x + dx}dydz$$故在单位时间内x方向净流入流量为$$\\left. \\ q{x} \\right|{x}dydz - \\left. \\ q{x} \\right|_{x + dx}dydz$$ 由于取无穷小空间，dx足够小，于是有$$\\frac{\\partial q_{x}}{\\partial x} = \\frac{\\left. \\ q_{x} \\right|{x + dx} - \\left. \\ q{x} \\right|{x}}{dx} 即 \\left. \\ q{x} \\right|{x + dx} - \\left. \\ q{x} \\right|{x} = \\frac{\\partial q{x}}{\\partial x}dx$$代入化简后可以得到单位时间内x方向净流入流量为$$D\\frac{\\partial^{2}\\rho}{\\partial x^{2}}dxdydz$$同理可得：单位时间内y方向净流入流量为$$D\\frac{\\partial^{2}\\rho}{\\partial y^{2}}dxdydz$$单位时间内z方向净流入流量为$$D\\frac{\\partial^{2}\\rho}{\\partial z^{2}}dxdydz$$在本研究中，出于解析求解可行性的考虑，在理论分析部分暂时仅考虑常压下有源无汇的理想场景（即仅在某固定坐标点(x_0, y_0, z_0)处有一恒定扩散源，其强度（单位时间内单位体积产生的气体质量）为F(x,y, z,t)），而在后续数值求解与仿真模拟时才会把负压源视作汇的产生原因从而进一步补充对流的相关条件（对流项）。 在此条件下，基于质量守恒定律，单位时间在该无穷小空间内增加的气体质量等于单位时间内净流入的气体质量与扩散源产生的气体质量，其中扩散源产生的气体质量F(x,y, z,t)仅在(x_0, y_0, z_0)处有恒定值F_0而在其余空间各处均为0。于是列出并化简得到如下三维扩散方程（相比通用控制方程暂时不考虑对流项）： $$\\frac{\\partial\\rho}{\\partial t} - D\\left( \\frac{\\partial^{2}\\rho}{\\partial x^{2}} + \\frac{\\partial^{2}\\rho}{\\partial y^{2}} + \\frac{\\partial^{2}\\rho}{\\partial z^{2}} \\right) = \\rho_{t} - D\\nabla^{2}\\rho = 0, 0 &lt; x &lt; x_{0}, 0 &lt; y &lt; y_{0}, 0 &lt; z &lt; z_{0}$$其中： 浓度的时间增长率（关于时间t的偏导数），即单位时间该无穷小空间内增加的气体质量:$$\\frac{\\partial\\rho}{\\partial t}$$ 扩散系数D仅与物质种类和温度有关，若研究某种特定气体在理想的均匀介质（温度在空间各处保持一致且不随时间变化）条件下的扩散，该系数值为常数；反之则其也应表示为关于空间坐标与时间的函数D(x, y, z, t)（在确定气体类型时仅与温度的分布函数T(x, y, z, t)有关）。 2.3 初始条件与边界条件该问题的初始条件是显然的：研究区域空间内在初始状态（t = 0）没有该种烟雾气体分布，且在某固定点处有一恒定扩散源，始终以恒定的扩散强度（单位时间内单位体积产生的气体质量）产生气体并向区域空间内扩散。将这样的初始条件写成数学表达式的形式： $$\\rho(x,y,\\ z,0) = F_{0}\\delta(x - \\frac{x_{0}}{2})\\delta(y - \\ \\frac{y_{0}}{2})\\delta(z - 0)$$式中F_0表示在固定坐标端点$$\\left( \\frac{x_{0}}{2},\\ \\frac{y_{0}}{2},\\ 0 \\right)$$处的恒定扩散源的扩散强度。结合实验时采用的实验装置，参考其技术文档可知，其值约为5g/cm^3。 关于边界条件，针对我们所研究的扩散问题，通常采用Dirichlet边界条件：$$\\frac{\\partial\\rho}{\\partial n} = 0$$显然这是一个齐次边界条件，也是一个典型的第二类边界条件。为方便后续求解处理，针对我们所建立的空间直角坐标系，可以将其进一步写成分量形式： $$\\left{ \\begin{array}{r}\\left. \\ \\frac{\\partial\\rho}{\\partial x} \\right|{x = 0} = \\left. \\ \\frac{\\partial\\rho}{\\partial x} \\right|{x = x_{0}} = 0 \\\\left. \\ \\frac{\\partial\\rho}{\\partial y} \\right|{y = 0} = \\left. \\ \\frac{\\partial\\rho}{\\partial y} \\right|{y = y_{0}} = 0 \\\\left. \\ \\frac{\\partial\\rho}{\\partial z} \\right|{z = 0} = \\left. \\ \\frac{\\partial\\rho}{\\partial z} \\right|{z = z_{0}} = 0\\end{array} \\right.\\$$ 2.4 数学物理方程求解针对2.2节提出的数学物理方程，可以通过分离变数法，结合2.3节给出的边界条件与初始条件，得到本征值问题的解和本征值的取值，并将多个本征值问题的解依次相乘得到本征解，再对所有可能的本征值求和，即可得到级数解。更进一步的，通过2.3节给出的初始条件，还可以对于级数解中的常数系数进行进一步确定，从而得到该数学物理方程完整的级数解解析表达式。 2.4.1 变量分离对于扩散的烟雾而言，虽然其浓度会在空间中的不同位置随时间而变化，但时间与空间这两者在浓度瞬态变化的过程中实际上可以看作是相互独立的，即浓度随时间变化的速率ρ_t与浓度在空间分布中的变化速率∇ρ无关。 基于这样的假设，可以对烟雾浓度函数ρ(x, y, z, t)做如下的变量分离： $$\\rho(x, y, z, t) = v(x,y,z) \\bullet T(t)$$ 空间部分v(x,y,z)：描述烟雾浓度在三维空间中的分布，可以认为它与时间无关，或者说在某个时刻，密度的空间分布是静态的； 时间部分T(t)：描述烟雾密度随时间的变化，通常假设它是一个仅依赖于时间的函数，反映了扩散过程中气体密度随时间的衰减或增长。 在该式中，自变数x, y, z只出现于v之中，自变数t只出现于T之中，烟雾浓度的一般表示式具有分离变数的形式。 更进一步的，由于在空间中x、y、 z方向上的烟雾浓度变化情况也彼此独立，还可以对于空间部分v(x,y,z)做进一步的变量分离，即： $$v(x,y,z) = X\\left( x) \\bullet Y(y) \\bullet Z(z \\right)$$其中，X(x)为烟雾浓度在空间中x方向的分布情况，Y(y)为烟雾浓度在空间中y方向的分布情况，Z(z)为烟雾浓度在空间中z方向的分布情况。 2.4.2 常微分方程与本征值问题显然三维扩散方程$$\\rho_{t} - D\\nabla^{2}\\rho = 0$$为齐次方程，对于该齐次方程，可以将分离变量后的烟雾浓度代入三维扩散方程中，化简得到如下式子： $$T_{t}(t)v(x,y,z) = DT(t)\\nabla^{2}v(x,y,z)，即\\frac{T_{t}(t)}{DT(t)} = \\frac{\\nabla^{2}v(x,y,z)}{v(x,y,z)} = \\frac{X^{‘’}(x)}{X(x)} = \\frac{Y^{‘’}(y)}{Y(y)} = \\frac{Z^{‘’}(z)}{Z(z)}$$其中，左边均为关于时间t的函数，与坐标位置x, y, z无关；右边则是关于坐标位置x, y, z的函数，与时间t无关。两边相等是显然不可能的，除非两边实际上是同一个常数，不妨将其记为-λ，于是有： $$\\frac{T_{t}}{DT} = \\frac{X^{‘’}}{X} = \\frac{Y^{‘’}}{Y} = \\frac{Z^{‘’}}{Z} = - \\lambda$$将该式关于空间部分X(x)、Y(y)、Z(z)与时间部分T(t)分别分离，可以得到关于X、Y、Z以及关于T的一系列常微分方程： $$\\left{ \\begin{array}{r}T^{‘} + \\lambda DT = 0 \\\\nabla^{2}v + \\lambda v = 0\\end{array} \\right.\\ 即 \\left{ \\begin{array}{r}T^{‘} + \\lambda DT = 0 \\X^{‘’} + \\lambda X = 0 \\Y^{‘’} + \\lambda Y = 0 \\Z^{‘’} + \\lambda Z = 0\\end{array} \\right.\\$$考虑2.3节给出的齐次边界条件即Dirichlet边界条件：边界处$$\\frac{\\partial\\rho}{\\partial n} = 0$$有： $$\\left{ \\begin{array}{r}X^{‘}(0) = X^{‘}\\left( x_{0} \\right) = 0 \\Y^{‘}(0) = Y^{‘}\\left( y_{0} \\right) = 0 \\Z^{‘}(0) = Z^{‘}\\left( z_{0} \\right) = 0\\end{array} \\right.\\$$以上常微分方程与齐次边界条件共同构成了本征值问题。 2.4.3 本征值问题求解首先，对于第一个方程$$\\mathbf{T}^{‘} + \\mathbf{\\lambda DT} = \\mathbf{0}$$而言，该方程为一阶常微分方程，可直接进行求解，结合初始条件$$\\rho(x,y,\\ z,0) = F_{0}\\delta(x - \\frac{x_{0}}{2})\\delta(y - \\ \\frac{y_{0}}{2})\\delta(z - 0)$$可得到： $$\\mathbf{T}\\left( \\mathbf{t} \\right) = \\mathbf{F}_{\\mathbf{0}}(\\mathbf{1} - \\mathbb{e}^{- \\mathbf{\\lambda Dt}})（C为某常数）$$其物理意义上的合理性如下： 初始时刻t = 0：$$T(0) = F_{0}\\left( 1 - \\mathbb{e}^{- 0} \\right) = 0$$即空间内在初始状态下（t = 0）没有该种烟雾气体分布，与初始条件吻合； 稳定时刻t-&gt;∞：$$T(\\infty) = F_{0}\\left( 1 - \\mathbb{e}^{- \\infty} \\right) = F_{0}$$即浓度达到稳定值F_0，与扩散物理过程实际现象一致； 时间项指数因子-λDt决定了扩散速度，其中D为扩散系数，越大扩散越快，λ为空间模态本征值，模态越高衰减越快，这也符合实际物理扩散过程。 而针对后面三个方程，与对应的齐次边界条件形成了三组本征值问题，由于其形式完全一致，下面将以其中一组本征值问题$$\\left{ \\begin{array}{r}X^{‘’} + \\lambda X = 0 \\X^{‘}(0) = X^{‘}\\left( x_{0} \\right) = 0\\end{array} \\right.\\$$为例，利用幂级数法求得其本征解： 选定点x_1 = 0，显然常微分方程$$X^{‘’} + \\lambda X = 0$$的系数函数在该点领域内是解析的，因此该点为方程$$X^{‘’} + \\lambda X = 0$$的常点。针对常点x_1，可以给出X(x)在该点邻域上的泰勒级数形式： $$X(x) = \\sum_{k = 0}^{\\infty}{a_{k}{(x - x_{1})}^{k}}$$将其代入常微分方程可得：$$\\sum_{k = 0}^{\\infty}{\\lbrack(k + 2)(k + 1)a_{k + 2} + \\lambda}a_{k}\\rbrack{(x - x_{1})}^{k} = 0$$于是有：$$(k + 2)(k + 1)a_{k + 2} + {\\lambda a}{k} = 0,\\ k = 0,1,2\\ldots$$可进一步得到系数递推公式：$$a{k + 2} = \\frac{- \\lambda}{(k + 2)(k + 1)}a_{k}$$推得：$$\\left{ \\begin{array}{r}a_{2k} = \\frac{\\lambda^{k}{( - 1)}^{k}}{(2k)!}a_{0} \\a_{2k + 1} = \\frac{\\lambda^{k}{( - 1)}^{k}}{(2k + 1)!}a_{1}\\end{array} \\right.\\ ,\\ k = 1,2,3\\ldots$$因此可得到常微分方程$$X^{‘’} + \\lambda X = 0$$的解： $$X(x) = a_{0}X_{0}(x) + a_{1}X_{1}(x)$$其中： $$X_{0}(x) = 1 + \\frac{- \\lambda}{2!}x^{2} + \\frac{\\lambda^{2}}{4!}x^{4} + \\ldots + \\frac{\\lambda^{k}( - 1)^{k}}{(2k)!}x^{2k} + \\ldots = \\sum_{k = 0}^{\\infty}{\\frac{\\lambda^{k}( - 1)^{k}}{(2k)!}x^{2k}} = \\cos(\\sqrt{\\lambda}x)$$ $$X_{1}(x) = x + \\frac{- \\lambda}{3!}x^{3} + \\frac{\\lambda^{2}}{5!}x^{5} + \\ldots + \\frac{\\lambda^{k}( - 1)^{k}}{(2k + 1)!}x^{2k + 1} + \\ldots = \\sum_{k = 0}^{\\infty}{\\frac{\\lambda^{k}( - 1)^{k}}{(2k + 1)!}x^{2k + 1}} = \\frac{\\sin(\\sqrt{\\lambda}x)}{\\sqrt{\\lambda}}$$ 此时的收敛半径为$$R = \\lim_{n \\rightarrow \\infty}\\left| \\frac{a_{n}}{a_{n + 2}} \\right| = \\lim_{n \\rightarrow \\infty}\\left| \\frac{(n + 2)(n + 1)}{- \\lambda} \\right| = \\infty$$即级数解X_0(x)$和X_1(x)在复数域上始终收敛。X_0(x)仅含x的偶次幂，为偶函数；X_1(x)仅含x的奇次幂，为奇函数。同时，式中含有sqrt（λ）项，这要求λ≥0。 于是有：$$X^{‘}(x) = - a_{0}\\sqrt{\\lambda}\\sin(\\sqrt{\\lambda}x) + a_{1}\\cos(\\sqrt{\\lambda}x)$$将齐次边界条件$$X^{‘}(0) = X^{‘}\\left( x_{0} \\right) = 0$$代入可得: $$\\left{ \\begin{array}{r}a_{1} = 0 \\a_{0}\\sqrt{\\lambda}\\sin(\\sqrt{\\lambda}x_{0}) + a_{1}\\cos(\\sqrt{\\lambda}x_{0}) = 0\\end{array} \\right.\\$$显然有a_1= 0，但对于a_0而言，如果a_0也为0，这样的解是没有意义的；而要使得a_0不为零，就要求$$\\lambda = 0或\\sin\\left( \\sqrt{\\lambda}x_{0} \\right) = 0$$恒成立，这意味着$$\\sqrt{\\lambda}x_{0} = k\\pi$$由于$$x_{0} &gt; 0、\\sqrt{\\lambda} \\geq 0$$于是k的可取值为$$k = 0,1,2,\\ldots$$在这样的条件下，由于x_0与π均为定值，本征值λ则有常数k唯一确定，此时不妨将常数k视为新的本征值。于是可得到该本征值问题的本征解： $$X(x) = a_{0}\\cos\\left( \\sqrt{\\lambda}x \\right) = a_{0x}\\cos\\left( \\frac{k\\pi}{x_{0}}x \\right)，k = 0,1,2,\\ldots$$与此类似的，另外两个本征值问题的本征解为： $$Y(y) = a_{0y}\\cos\\left( \\frac{m\\pi}{y_{0}}y \\right)，m = 0,1,2,\\ldots$$ $$Z(z) = a_{0z}\\cos\\left( \\frac{n\\pi}{z_{0}}z \\right)，n = 0,1,2,\\ldots$$ 值得注意的是，三个本征值问题中出现了三个新的本征值k、m、n，他们分别与时间部分涉及到的本征值λ有定量关系，但是当他们取不同值时，原本征值λ也会有不同的取值，即本质上有三个不同的本征值k、m、n取代了原先的本征值λ。 基于以上本征值问题的解和本征值的取值，可以将其各部分相乘得到本征解，再对本征解按照所有可能的本征值求和，即可得到烟雾浓度的级数解： $$\\rho(x,\\ y,\\ z,\\ t) = \\sum_{k = 0}^{\\infty}{\\sum_{m = 0}^{\\infty}{\\sum_{n = 0}^{\\infty}{a_{0x}a_{0y}a_{0z}F_{0}\\cos\\left( \\frac{k\\pi}{x_{0}}x \\right)\\cos\\left( \\frac{m\\pi}{y_{0}}y \\right)\\cos\\left( \\frac{n\\pi}{z_{0}}z \\right)}}}(1 - \\mathbb{e}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}t})$$由于式中a_0x、a_0y、a_0z、F_0均为常数（可由初始条件$$\\rho(x,y,\\ z,0) = F_{0}\\delta(x - \\frac{x_{0}}{2})\\delta(y - \\ \\frac{y_{0}}{2})\\delta(z - 0)$$进一步确定），不妨将其替换为某一常数$$A = a_{0x}a_{0y}a_{0z}F_{0}$$以便于后续计算，即此时可得到级数解为：$$\\rho(x,\\ y,\\ z,\\ t) = \\sum_{k = 0}^{\\infty}{\\sum_{m = 0}^{\\infty}{\\sum_{n = 0}^{\\infty}{A\\cos\\left( \\frac{k\\pi}{x_{0}}x \\right)\\cos\\left( \\frac{m\\pi}{y_{0}}y \\right)\\cos\\left( \\frac{n\\pi}{z_{0}}z \\right)}}}(1 - \\mathbb{e}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}t})$$ 2.4.4 级数解常数系数的确定需要指出，函数$$\\varnothing_{kmn} = \\cos\\left( \\frac{k\\pi}{x_{0}}x \\right)\\cos\\left( \\frac{m\\pi}{y_{0}}y \\right)\\cos\\left( \\frac{n\\pi}{z_{0}}z \\right)$$是定义在长方体区域$$x \\in \\left\\lbrack 0,x_{0} \\right\\rbrack,\\ \\ y \\in \\left\\lbrack 0,y_{0} \\right\\rbrack,z \\in \\lbrack 0,z_{0}\\rbrack$$上的一组正交基函数，其满足如下正交性与归一化条件： $$\\int_{0}^{z_{0}}{\\int_{0}^{y_{0}}{\\int_{0}^{x_{0}}{\\varnothing_{kmn}\\varnothing_{k^{‘}m^{‘}n^{‘}}dxdydz}}} = \\left{ \\begin{array}{r}x_{0}y_{0}z_{0},\\ (k,m,n) = (k^{‘},m^{‘},n^{‘}) \\0,(k,m,n) \\neq (k^{‘},m^{‘},n^{‘})\\end{array} \\right.\\$$对于级数解$$\\rho(x,\\ y,\\ z,\\ t) = \\sum_{k = 0}^{\\infty}{\\sum_{m = 0}^{\\infty}{\\sum_{n = 0}^{\\infty}{A\\cos\\left( \\frac{k\\pi}{x_{0}}x \\right)\\cos\\left( \\frac{m\\pi}{y_{0}}y \\right)\\cos\\left( \\frac{n\\pi}{z_{0}}z \\right)}}}\\mathbb{e}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}t} = \\sum_{k = 0}^{\\infty}{\\sum_{m = 0}^{\\infty}{\\sum_{n = 0}^{\\infty}{A\\varnothing_{kmn}}}}{(1 - \\mathbb{e}}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}t})$$而言，将两侧同时与Φ_k’m’n’相乘，并在区域内积分： $$\\int_{0}^{z_{0}}{\\int_{0}^{y_{0}}{\\int_{0}^{x_{0}}{\\rho(x,\\ y,\\ z,\\ t)\\varnothing_{k^{‘}m^{‘}n^{‘}}dxdydz}}} = \\int_{0}^{z_{0}}{\\int_{0}^{y_{0}}{\\int_{0}^{x_{0}}{(\\sum_{k = 0}^{\\infty}{\\sum_{m = 0}^{\\infty}{\\sum_{n = 0}^{\\infty}{A\\varnothing_{kmn}}}}\\mathbb{e}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}t})\\varnothing_{k^{‘}m^{‘}n^{‘}}dxdydz}}}$$利用正交性条件，上述式子右边仅保留(k,m,n) = (k’, m’, n’)的项，其余项积分为0： $$\\int_{0}^{z_{0}}{\\int_{0}^{y_{0}}{\\int_{0}^{x_{0}}{\\rho(x,\\ y,\\ z,\\ t)\\varnothing_{kmn}dxdydz}}} = A(1 - \\mathbb{e}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}t})x_{0}y_{0}z_{0}$$代入初始条件$$\\rho(x,y,\\ z,0) = F_{0}\\delta(x - \\frac{x_{0}}{2})\\delta(y - \\ \\frac{y_{0}}{2})\\delta(z - 0)$$即可在t = 0处解出系数$$A = \\frac{\\int_{0}^{z_{0}}{\\int_{0}^{y_{0}}{\\int_{0}^{x_{0}}{\\rho(x,\\ y,\\ z,\\ t)\\varnothing_{kmn}dxdydz}}}}{\\left( 1 - \\mathbb{e}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}t} \\right)x_{0}y_{0}z_{0}}$$由于分子分母在t = 0处均为0，故利用洛必达法则上下对时间$t$求导得： $$\\rho_{t} = T^{‘} = \\mathbb{e}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)Dt}（忽略系数）$$ $$A = \\frac{\\left. \\rho_{t} \\right|{t = 0}\\int{0}^{z_{0}}{\\int_{0}^{y_{0}}{\\int_{0}^{x_{0}}{\\rho(x, y, z, 0)\\varnothing_{kmn}dxdydz}}}}{\\left( {\\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}\\mathbb{e}}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}t} \\right)x_{0}y_{0}z_{0}}= \\frac{F_{0}}{D\\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)\\pi^{2}x_{0}y_{0}z_{0}}\\varnothing_{kmn}\\left( \\frac{x_{0}}{2},\\frac{y_{0}}{2},0 \\right)= \\frac{F_{0}}{D\\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)\\pi^{2}x_{0}y_{0}z_{0}}\\cos\\left( \\frac{k\\pi}{x_{0}}\\frac{x_{0}}{2} \\right)\\cos\\left( \\frac{m\\pi}{y_{0}}\\frac{y_{0}}{2} \\right)\\cos\\left( \\frac{n\\pi}{z_{0}}0 \\right) = \\frac{F_{0}}{D\\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)\\pi^{2}x_{0}y_{0}z_{0}}\\cos\\left( \\frac{k\\pi}{2} \\right)\\cos\\left( \\frac{m\\pi}{2} \\right)，其值随k,m,n的变化而变化$$ 最后，将其代入2.4.3节解得的级数解，可以最终得到植物甘油气雾浓度的解析表达式为： $$\\rho(x,\\ y,\\ z,\\ t) = \\frac{F_{0}}{Dx_{0}y_{0}z_{0}}\\sum_{k = 0}^{\\infty}{\\sum_{m = 0}^{\\infty}{\\sum_{n = 0}^{\\infty}{\\frac{1}{\\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)\\pi^{2}}\\cos\\left( \\frac{k\\pi}{2} \\right)\\cos\\left( \\frac{m\\pi}{2} \\right)\\cos\\left( \\frac{k\\pi}{x_{0}}x \\right)\\cos\\left( \\frac{m\\pi}{y_{0}}y \\right)\\cos\\left( \\frac{n\\pi}{z_{0}}z \\right)}}}(1 - \\mathbb{e}^{- \\left( \\frac{k^{2}}{x_{0}^{2}} + \\frac{m^{2}}{y_{0}^{2}} + \\frac{n^{2}}{z_{0}^{2}} \\right)D\\pi^{2}t})$$ 2.5 基于MATLAB的级数解可视化基于上述求解过程得到的烟雾浓度解析表达式，编写了对应的MATLAB程序，将不同时刻烟雾浓度在空间内各点处的分布情况进行计算与可视化。值得注意的是，由于级数解本质是无限项求和，而在MATLAB程序实际计算中需要指定求和项数，在此综合考虑计算精度与算力需求，选取$k,m,n$三个本征值各10项进行计算与可视化；除此之外，为与实际实验相对应，计算的扩散时间设置为30秒，同时为直观观察扩散过程中烟雾浓度随时间的变化，设置计算步长为1秒。 代入相应的数值并运行程序可以得到如下的可视化结果（代码详见附件1）： 可以看到，随着时间的推移，烟雾的可见范围越来越大（设定可见浓度为0.3mg/cm^3），且浓度从扩散中心点向四周呈递减趋势，这与我们的生活经验高度一致；在扩散时间为0s（即扩散未开始）时，空间区域内烟雾浓度均为零，这也与我们设定的初始条件相一致。以上事实初步验证了理论推导结果的正确性。 除此之外，为与后续的实验过程相对应，还记录了特定测量点(x_0/2, 0, z_0)处的烟雾浓度随时间的变化情况，并根据换算公式$$ppm = \\frac{C \\times 10^{6}}{\\rho}$$将原有的气雾质量浓度C（单位：g/cm^3）换算为体积比ppm（百万分之一），得到的结果如下： 可以看到，由于该处离扩散中心点较远，此处烟雾浓度大概在扩散时间20s后达到基本稳定，稳定时的烟雾浓度值约为380ppm。 3 数值仿真模拟3.1 数值分析方法：有限元法由于严格的解析求解对于方程的复杂度以及初始条件与边界条件等都具有一定的要求，第2章所涉及到的理论分析也仅仅是围绕简化后的烟雾扩散问题展开。相比于真实的场景，这样的理论分析忽略了很多现实环境中的复杂变量（比如对流）。为使得我们的研究更具有实用价值，我们需要对于更加泛化的数学物理模型，采用数值求解的方法去模拟真实的扩散情况。 在这一部分，我们主要考虑到，2.3节提到的初始条件中烟雾源处视为单点并采用δ函数进行数学表示的做法过于理想化。与实验相对应的，我们采用的烟雾发生器的烟雾出口也不仅仅是一个单点，而是一个半径约为0.6cm的圆面。因此，我们希望通过有限元这一数值求解方法，对于初始条件迭代后的问题进行数值模拟分析。 图3.1 烟雾发生器烟雾出口孔径测量 基于有限元法的基本思想，我们主要按照如下的方法步骤进行数值分析： 首先进行区域剖分，将长方体研究区域Ω划分为有限个小单元，用于构建离散有限元模型。在划分单元时，采用长方体网格剖分方式，将区域划分为n_x * n_y * n_z个小立方体。每个小立方体单元有8个顶点，因此共有N = (n_x+1) * (n_y+1) * (n_z+1)个节点。对这些节点按列优先顺序进行编号，依次为1、2、…、N，同时对于各单元按体积分块顺序编号，编号为1、2、…、E。 接下来需要选择合适的单元基函数以表示单元内的浓度分布。在此我们选取基函数Φ_ i(x,y,z)近似表示浓度：$$\\rho(x,\\ y,\\ z,\\ t) \\approx \\sum_{i = 1}^{N}{c_{i}(t)\\phi_{i}(x,y,z)}（c_{i}(t)表示节点i处的浓度值）$$并采用线性插值基函数（梯形单元），即单元内任意一点的浓度由8个顶点的浓度值线性插值（符号根据顶点位置的坐标取正或负）：$$\\phi_{i}(x,y,z) = \\frac{1}{8}(1 \\pm x)(1 \\pm y)(1 \\pm z),\\ i = 1,2,\\ldots,8$$值得注意的是，在单元内，基函数在对应节点取值为1，其余节点取值为0，同时基函数也满足局部支撑性，即在单元外为零。 基于划分好的单元和选取的单元基函数，可以写出对应的单元积分表达式。通过对单元内的质量矩阵、刚度矩阵和源项向量进行积分，单元积分表达式应使得方程余量最小、本质边界条件余量最小、自然边界条件余量最小。将扩散方程乘以任意测试函数Φ_j(x,y,z)后，对区域Ω积分即可得到单元积分表达式： $$\\int_{\\Omega}^{}{\\phi_{j}\\frac{\\partial\\rho}{\\partial t}\\mathbb{d}\\Omega} = D\\int_{\\Omega}^{}{\\phi_{j}\\nabla^{2}\\rho\\mathbb{d}\\Omega} + \\int_{\\Omega}^{}{\\phi_{j}F\\mathbb{d}\\Omega}$$该表达式中共有三项： 时间导数项（差分离散）：$$\\int_{\\Omega}^{}{\\phi_{j}\\frac{\\partial\\rho}{\\partial t}\\mathbb{d}\\Omega} \\approx \\int_{\\Omega}^{}{\\phi_{j}\\frac{\\rho^{n + 1} - \\rho^{n}}{\\mathrm{\\Delta}t}\\mathbb{d}\\Omega}$$ 空间扩散项：通过分部积分，将扩散项转化为： $$\\int_{\\Omega}^{}{\\phi_{j}\\nabla^{2}\\rho\\mathbb{d}\\Omega} = - \\int_{\\Omega}^{}{\\nabla\\phi_{j}\\nabla\\rho d\\Omega} + \\int_{\\partial\\Omega}^{}{\\phi_{j}\\nabla\\rho \\bullet \\overrightarrow{n}dS}$$ 在齐次边界条件下，边界项为0。 离散形式：代入插值函数近似： $$\\int_{\\Omega}^{}{\\phi_{j}\\frac{\\rho^{n + 1} - \\rho^{n}}{\\mathrm{\\Delta}t}\\mathbb{d}\\Omega} = D\\int_{\\Omega}^{}{\\nabla\\phi_{j}\\nabla(\\sum_{i = 1}^{N}{C_{i}^{n + 1}\\phi_{i}})\\mathbb{d}\\Omega} + \\int_{\\Omega}^{}{\\phi_{j}F\\mathbb{d}\\Omega}$$ 基于列出的单元积分表达式，可以对各个单元进行分析，计算其对应的质量矩阵、刚度矩阵与源项向量，从而建立有限元方程。将离散化方程写为矩阵形式： $$M\\frac{c^{n + 1} - c^{n}}{\\Delta t} + Kc^{n + 1} = F$$其中： 质量矩阵：$$M_{\\mathbb{i}j} = \\int_{\\Omega}^{}{\\phi_{i}\\phi_{j}d\\Omega}$$ 刚度矩阵：$$K_{\\mathbb{i}j} = D\\int_{\\Omega}^{}{\\nabla\\phi_{i}\\nabla\\phi_{j}d\\Omega}$$ 源项向量：$$F_{\\mathbb{i}} = \\int_{\\Omega}^{}{F\\phi_{i}d\\Omega}$$ 进而可以将单元积分表达式更新为有限元方程： $$(M + \\Delta tk)c^{n + 1} = Mc^{n} + \\Delta tF$$将每个单元映射到标准立方体单元（边长为2，中心为原点），可以根据基函数梯度$$\\nabla\\phi_{i} = (\\frac{\\partial\\phi_{i}}{\\partial x},\\ \\frac{\\partial\\phi_{i}}{\\partial y},\\ \\frac{\\partial\\phi_{i}}{\\partial z})$$在这些标准单元上使用高斯积分进行质量矩阵和刚度矩阵的计算： $$M_{\\mathbb{i}j}^{(e)} = \\int_{\\Omega_{e}}^{}{\\phi_{i}\\phi_{j}d\\Omega}$$ $$K_{\\mathbb{i}j}^{(e)} = D\\int_{\\Omega_{e}}^{}{\\nabla\\phi_{i}\\nabla\\phi_{j}d\\Omega}$$ 将源项向量$$F_{\\mathbb{i}}^{(e)} = \\int_{\\Omega_{e}}^{}{F\\phi_{i}d\\Omega}$$离散化为节点的平均值后，也可以通过插值基函数对其进行积分。 完成单元分析后，可以将单元矩阵的局部节点编号1、2、…、8映射到总体矩阵的全局节点编号，并在每个单元中将其局部质量矩阵M^e、刚度矩阵K^e和源项向量F^e加入到总体矩阵M、K和向量F中，进行总体合成。 在对于总体有限元方程进行求解之前，还需要在总体矩阵方程中施加边界条件。在此我们采用消行修正法：对于齐次边界条件，将其带入总体有限元方程，并将边界上的节点浓度固定置零，同时修改总体矩阵对应行列为单位矩阵，右端项置零；对于非齐次边界条件（即初始条件），在边界节点区域（以扩散源中心（x_0/2, y_0/2, 0）为圆心，半径为0.6cm的圆面）中给定固定浓度值F_0，并对应调整右端向量F（已在单元积分中满足）：$$F_{i} \\Leftarrow F_{i} - k_{ij}F_{0}$$最后，对于总体有限元线性方程 $$(M + \\Delta tk)c^{n + 1} = Mc^{n} + \\Delta tF$$可以采用迭代方法进行求解： 初始条件：$$c^{0} = 0$$ 时间步进：对于每个时间步，首先计算右端向量$$Mc^{n} + \\Delta tF$$再采用稀疏矩阵求解器计算下一步的浓度$$c^{n + 1}$$ 迭代终止：当时间达到设定终止时间T时，终止求解过程。 3.2 基于Python的有限元数值仿真基于3.1节提出的有限元分析方法，利用Python中的MeshPy依赖库进行网格生成，并编写对应Python代码进行有限元数值仿真的计算与可视化。出于程序运行的稳定性等方面考虑，数值计算时仅选取原长方体区域的四分之一（高度不变，长宽各取一半，坐标原点即为扩散源中心）作为扩散区域。 运行程序（代码详见附录2），得到以下数值仿真结果： 可以看到，有限元仿真Python程序的运行结果能够较好地反映扩散过程中烟雾浓度分布的变化情况，基本与理论分析可视化中展现的趋势一致，在此不再赘述。相较于理论分析的可视化结果而言，有限元仿真的结果更加精细也更加丰富，特别是在截面的浓度分布上，很好地反映了扩散过程的基本特点，但在空间中的浓度分布可能受到了边界条件的过分影响，导致其明显呈现沿容器边缘扩散的趋势，而在容器内部的扩散范围较为有限。 3.3 基于COMSOL仿真软件的有限元数值仿真尽管对于初始条件进行了一定的修正，但上述的有限元数值模拟仍然缺乏对于对流项的考虑，这可能是导致其结果受边界条件影响较大的原因之一。除此之外，上述的理论分析与数值计算也仅仅对于烟雾扩散过程中的浓度分布变化进行计算与模拟，而缺乏了烟雾扩散速度方面的计算分析，这也受到了解析求解方法的限制。因此，我们希望借助成熟的商业有限元仿真软件COMSOL进行更进一步的数值仿真，以分别模拟常压扩散与负压吸附两种情况下的植物甘油气雾颗粒扩散情况，并得到常压扩散情况下的扩散速度场与压力分布情况，帮助我们进一步完善烟雾扩散的基本模型。 为更加真实地反映实际扩散过程中的复杂物理环境，我们需要在COMSOL软件中指定相应的物理场模型： 湍流模型：帮助模拟湍流流动对气体扩散过程的影响，增加流体混合、热量传递和物质扩散等过程的复杂性； RANS模型：通过对Navier-Stokes方程进行时间平均，简化了直接求解瞬时湍流方程的复杂度，计算成本相对较低，同时可以较为准确地描述气体扩散过程中湍流对流场的影响，尤其是在稳态流动情况下； 低雷诺数k-ω模型：采用湍动能（k）和湍流频率（ω）作为主要变量，能够较好地捕捉近壁区和低雷诺数流动特性，在复杂的流动区域中能更好地描述气体的湍流行为，提供更准确的边界层模拟，从而提高气体扩散的模拟精度。 除此之外，我们还需要使用温度场模型来模拟扩散过程中粒子的运动情况。对于烟雾产生端，采用650~750K的的随机梯度划分以达到不同速度的效果。 为了模拟出烟雾粒子扩散过程中的运动状态，我们还需要模拟出颗粒的流动。由于实际实验中采用的植物甘油气雾本质上是一种固体烟雾颗粒，所以在仿真中，我们选取遵循一阶牛顿规则的粒子，并给予每个颗粒一定的质量（与植物甘油气雾的理化性质相一致，设置其密度为1.26g/cm^3）。 处于仿真计算的复杂度与运行时间考虑，我们仅在x = x_0/2处的垂直截面区域内（50cm*60cm）进行仿真，并设置仿真时间为6秒、时间步长为0.1秒、网格单元大小为1cm。同时与实验环境保持一致，温度设置为25℃（298.15K）。 考虑到需要对于常压扩散与负压吸附两种情形分别进行仿真，还需要对于仿真边界（壁）进行一定的设置： 常压扩散：将各边设置为壁，壁条件设置为满散射； 负压吸附：将上边界设置为出口，边界条件设置为静压力（-0.02MPa） 完成了以上的所有设置流程，可以点击”计算”运行有限元仿真，仿真结果如下所示： 可以看到，通过COMSOL软件进行有限元数值仿真，可以有效划分三角网格并准确模拟出常压扩散情况下的扩散速度场及其强度分布情况，同时仿真得到的粒子运动轨迹大体趋势也与先前的解析求解与有限元数值计算较为吻合。仿真结果成功验证了先前理论模型推导的有效性，并在扩散速度方面进行了有力补充。 4 实验现象验证4.1 预实验：常压封闭环境下的水雾扩散在进行理论模型的推导与演算前，为更准确地把握初始条件、边界条件以及部分环境因素的设置，并对于烟雾扩散的具体现象进行初步了解，我们首先基于手头已有的实验材料进行了定性观察的预实验。在预实验中，我们使用香薰机作为烟雾发生装置，但由于装置限制，仅采用纯净水作为烟雾发生原料以产生水雾，通过观察水雾扩散现象来初步把握扩散过程的基本特征。 {width=”1.466816491688539in”height=”1.9565212160979877in”} 基于以上预实验装置，搭建如下的实验装置场景： 启动香薰机，开始产生水雾，并通过长方体容器底部开孔向容器内部区域空间进行烟雾扩散。设置扩散时间为10分钟，拍摄视频记录扩散实验现象。 可以看到，随着扩散时间的推移，容器内聚集的水雾越来越多，且越靠近底部、越靠近扩散源中心，水雾的浓度也就越高（从现象来看，可以认为水雾团越密集的地方浓度越高），且当扩散时间达到一定程度时，容器内的水雾逐渐达到饱和，开始向容器底部沉降，并在容器底部呈聚集态势。 预实验的定性观察帮助我们对于烟雾扩散的基本现象有了宏观上的认知，并通过实物实验的方式让我们对于研究对象以及研究区域有了更加具象的认识，这对于我们后续理论模型推导与数值计算仿真的有序推进打下了良好的基础。但定性实验只能帮助我们认识现象，要对于理论模型的研究成果进行更加严谨的实证评估，还需要进行定量化的实验与测量。 4.2 正式实验：常压封闭环境下的植物甘油气雾扩散在完成了理论模型的推导以及解析求解与数值仿真计算之后，我们还希望通过实际定量实验的测量结果来验证理论模型的合理性。为进行定量化实验，我们将预实验中的部分实验装置进行了替换，以严格定量控制烟雾的产生过程并实时测量特定测量点位处的烟雾浓度，从而与理论计算与仿真结果进行比照。 对于烟雾发生器而言，为达到定量产生植物甘油气雾的效果，选取了Selens手持烟雾发生器作为新的实验器材，该款烟雾发生器可以产生固定强度的植物甘油气雾，查阅其产品技术文档可知，其固定产生烟雾的强度约为F_0 ≈ 5g/cm^3（与先前理论推导采用相同符号）；同时为定量测量定点(x_0/2,0,z_0)处（与2.5节一致）的烟雾浓度，选取了MQ-2烟雾浓度传感器进行测量，通过STM32F1开发板对传感器进行供电，同时将数据传输至PC端并实时在屏幕上显示测量到的烟雾浓度值（单位：ppm，与g/cm^3的换算关系在2.5节已提及）。 需要注意的是，由于该款传感器读取烟雾浓度的过程是渐变而非突变，因此在使用前需要一定的预热（初始化）时间，且初始化完成后，在还未开始烟雾扩散实验时，读取到的烟雾浓度也并不为零，因此在后续数据处理时还需要移除对应的偏移量，实测平均偏移量在180ppm左右。 基于以上实验装置，搭建如下的实验装置场景： 对于该款手持烟雾发生器而言，需要手动长按开关才可持续发生烟雾，且该产品具有安全保护机制，最多只能连续产生30s的植物甘油气雾。启动装置后即开始进行烟雾扩散实验，烟雾通过长方体容器底部开孔向容器内部区域空间不断进行扩散。拍摄视频记录扩散实验现象与扩散过程中屏幕上显示的烟雾浓度的实时变化数值及曲线。 可以发现，随着扩散时间的增加，容器内聚集的植物甘油气雾也越来越多，且扩散的过程与理论解析求解可视化以及有限元数值仿真展示的烟雾扩散趋势基本一致。同时，在常压状态下，相较于水雾扩散而言，容器内聚集的植物甘油气雾在停止发生一段时间后仍然没有明显消散，这是由于植物甘油独特的理化性质所导致的，也比水雾扩散实验的结果更加接近香烟烟雾扩散的实际情况。 将烟雾传感器读取到的烟雾浓度数值实时传输到PC端保存，利用MATLAB进行可视化并与理论解析求解计算的定点测量结果进行比照，结果如下： 可以看到，通过烟雾传感器测量得到的烟雾浓度同样在20s左右达到基本稳定，且两者达到稳定后的浓度数值基本接近（在5%的误差允许范围内，约为380ppm），这说明我们的理论模型能够较好地解释实验测量结果；但比较而言，相比起实际测量的数据，理论求解得到的浓度在达到稳定前均高于实际测量结果，这一方面可能由于理论计算时进行了部分近似假设造成了偏差，另一方面也可能是实际测量时在传感器测量与数据读取传输过程中产生了一定的延迟。 通过理论求解计算结果与实验测量观察结果的比照可以发现，我们建立的理论模型对于烟雾扩散情况的模拟效果无论从现象（可视化效果）上还是从浓度数值上都能对于实际的烟雾扩散现象进行较好的模拟，这充分证明了我们理论解析求解模型研究的有效性。 4.3 正式实验：封闭环境中负压作用下的植物甘油气雾扩散在正式实验阶段，除了在常压条件下进行烟雾扩散实验以验证烟雾扩散理论模型的准确性之外，为了后续进一步地提出可能的烟雾吸附方案并验证其有效性，我们还在负压环境下进行了对应的植物甘油气雾扩散实验，为后续开发提供参考。 在负压源的选取上，我们采用了涵道风机来营造负压环境。该款涵道风机可以通过旋钮调节产生不同档位强度的负压，通过查阅该产品技术文档可知，我们在实验时次啊用的最低档位负压值为P_0≈-0.02MPa，在通过COMSOL有限元仿真对于负压环境下的烟雾扩散进行数值模拟时也采用了相同的参数。其余的实验装置保持不变。 基于常压实验中搭建好的实验装置，在原烟雾发生处的开口对侧开出一个相同大小（半径3cm）的圆孔，并将涵道风机进风口对准该圆孔，完成负压吸附环境下植物甘油气雾扩散实验环境的搭建： 通过STM32F1开发板驱动涵道风机（供电）并通过旋钮将其调至最低档位，并采用与常压环境下实验相同的实验步骤与实验条件，拍摄视频记录扩散实验现象与扩散过程中屏幕上显示的烟雾浓度的实时变化数值及曲线。 可以发现，随着扩散时间的增加，容器内聚集的植物甘油气雾越来越多，但没有像常压状态下一样出现大量烟雾的堆积与沉降现象，且整体扩散方向受负压源牵引作用明显，这点与COMSOL有限元仿真得到的烟雾粒子运动轨迹基本一致；同时可以注意到，同样是在停止烟雾发生30秒后（期间持续进行负压吸附），在负压吸附的持续作用下容器内聚集的植物甘油气雾迅速地被排出容器外，而不像常压环境下的扩散那样会长时间堆积在容器内难以消散，这也充分验证了负压吸附这一解决方案的可行性与有效性，为后续的开发应用提供了良好的实验基础。 将烟雾传感器读取到的烟雾浓度数值实时传输到PC端保存，利用MATLAB进行可视化并与理论解析求解计算的定点测量结果进行比照，结果如下： 可以看到，相较于常压环境中的烟雾扩散，在负压作用下测量点处的植物甘油气雾浓度达到基本稳定的速度明显变快（大概在10s左右），且稳定后测得的烟雾浓度数值（100ppm左右）相较于常压下的稳定测量结果（380ppm左右）有明显下降，这样的数值结果在实验现象的基础上更进一步地验证了负压吸附这一解决方案的可行性与有效性，同时为后续的开发应用提供了良好的实验数据基础。 5 研究结论应用5.1 研究结论基于以上对于植物甘油气雾扩散问题在解析求解、数值模拟以及实验测量方面的深入研究，针对1.2节提出的研究目标，可以给出如下三点主要的研究结论： 在扩散过程中不同时刻的浓度分布方面，针对常压下密闭环境中的烟雾扩散现象，通过理论计算得到了不同时刻空间内各点处的浓度分布，并结合实验测试结果，印证了理论分析的高精度，在20s后空间内浓度分布基本稳定； 在扩散过程中烟雾的扩散速度方面，通过COMSOL有限元仿真软件对常压下密闭环境中的烟雾扩散进行数值模拟，得到扩散处于基本稳定状态下空间截面内速度场的分布，为分析浓度分布变化趋势提供参考； 在扩散过程中的烟雾扩散效果与除烟效果方面，将常压下和负压吸附下的COMSOL有限元仿真结果与实际实验现象进行对照，可以发现理论分析、数值求解以及实际实验三者的扩散现象结果基本一致，且在引入负压对流后，稳定后的烟雾浓度整体较常压时明显降低，且在烟雾发生停止后能够迅速清除残余的烟雾，具有良好的除烟效果。 除此之外，在这三点研究结论的基础上，我们还通过理论、仿真与实验的有机结合，得到了植物甘油气雾扩散的一般规律与数学物理模型，可以通过该理论模型对于实际的烟雾扩散情况进行定量化的数值模拟分析，从而对于烟雾扩散过程进行更精准的把控与必要的干预管理，并通过多种手段对该理论模型的有效性进行了充分验证，这也为我们后续应用产品的开发打下了良好的理论与实验基础。 5.2 研究成果应用：室内烟雾浓度控制系统基于数值分析结果与研究结论，我们开发了一套简易的闭环控制系统作为原型样机，通过实时检测监测点处的烟雾浓度，实现对于风机吸附功率的灵活动态调控，以优化用户体验。 在该系统的开发方面，采用STM32F1开发板作为系统主控，通过ADC实时读取MQ-2传感器返回的烟雾浓度数值，并通过PID闭环控制实时调控给涵道风机供电的PWM占空比，从而实现对于风机吸附功率的实施调控。 通过运行该闭环控制系统并测试其烟雾浓度控制效果，可以发现该系统对于烟雾有着较高的灵敏度，并在检测到高浓度烟雾后能够迅速调动涵道电机作出反应，快速吸附容器内的植物甘油气雾并始终维持空间内的烟雾浓度低于150ppm，说明样机能够初步满足用户的基本除烟需求。 6 课程收获感悟通过本次数学物理方法课程的学习，以及烟雾扩散课程项目的开展，我们通过在实际项目中运用课程中学习到的理论知识，在扩散过程中烟雾浓度分布的定量化求解过程中，对于数学物理方程的导出、边界与初始条件的确定以及基于变量分离与本征值方法求解级数解的过程有了更加深刻的认识与理解，同时通过课程中介绍的数值求解有限元方法对于更加泛化的情况进行了数值模拟与讨论。在解析与数值求解的理论分析基础上，我们还利用成熟的COMSOL有限元仿真软件对于烟雾扩散的粒子运动轨迹以及速度场分布进行数值仿真以作为对我们理论模型的补充，并通过定量化的实验测量进一步验证了理论模型的有效性，为我们后续进行实际的产品开发与应用提供了良好的理论与实验基础。 在本次课程项目报告的最后，再次感谢老师的耐心指导以及提出的宝贵意见，也希望我们能够将数学物理方法教给我们的定量化分析思维带入到未来的项目研究与学习工作中，对我们未来的项目开展与人生成长起到帮助。 参考文献[1] Gao, Naiping and Jianlei Niu. “Modeling particle dispersion and deposition in indoor environments.” Atmospheric Environment (Oxford, England : 1994) 41 (2007): 3862 - 3876. [2] Hoegg U. R. (1972). Cigarette smoke in closed spaces. Environmental health perspectives, 2, 117–128. [3] Kuga K, Ito K, Yoo S-J, et al. First- and second-hand smoke dispersion analysis from e-cigarettes using a computer-simulated person with a respiratory tract model. Indoor and Built Environment. 2018;27(7):898-916. [4] Holmberg, S., &amp; Li, Y. (1998). Modelling of the Indoor Environment – Particle Dispersion and Deposition. Indoor Air, 8, 113-122. [5] Al-sarraf, A.A., Yassin, M.F. &amp; Bouhamra, W. Experimental and computational study of particulate matter of secondhand smoke in indoor environment. Int. J. Environ. Sci. Technol. 12, 73–86 (2015). [6] 陈占秀,陈冠益,王艳,等.丙三醇与1,6-己二醇混合物降温凝固过程的分子动力学模拟[J].化工学报,2013,64(07):2316-2321. [7] 沈玉峰,孟强龙.基于物理模型的烟雾扩散模拟[J].电子技术,2011,38(03):61-63. [8] 李强,普小云.用毛细管成像法测量液相扩散系数——等折射率薄层测量方法[J].物理学报,2013,62(09):185-191. [9] 杜青青.室内烟雾扩散模拟技术研究与实现[D].北京工业大学,2018. [10] 梁昆淼编.数学物理方法[M].北京：高等教育出版社,1978:593页. 附录1 MATLAB解析求解可视化代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596% 参数定义x0 = 40; % 长方体的长度y0 = 50; % 长方体的宽度z0 = 60; % 长方体的高度F0 = 0.5; % 源项强度 g/cm3D = 0.0962; % 扩散系数x_s = x0 / 2; % 点源的 x 坐标y_s = y0 / 2; % 点源的 y 坐标z_s = 0; % 点源的 z 坐标t_max = 30 * 40; % 最大时间num_time_steps = 31; % 时间步数num_terms = 10; % 级数项数% 创建空间网格x = linspace(0, x0, 50);y = linspace(0, y0, 50);z = linspace(0, z0, 50);[X, Y, Z] = meshgrid(x, y, z);time_steps = linspace(0, t_max, num_time_steps); % 时间步长rho = zeros(length(x), length(y), length(z), num_time_steps); % 计算解的函数% 测量点坐标 (x0/2, 0, z0)x_measure = x0 / 2;y_measure = 0;z_measure = z0;rho_measure = zeros(1, num_time_steps); % 初始化存储测量点浓度的数组for t_idx = 1:num_time_steps t = time_steps(t_idx); % 当前时间 % 级数求解 sum_term = 0; for l = 1:num_terms for m = 1:num_terms for n = 1:num_terms % 计算级数各项 lambda = (l^2 * pi^2 / x0^2) + (m^2 * pi^2 / y0^2) + (n^2 * pi^2 / z0^2); term = cos(l * pi * X / x0) .* cos(m * pi * Y / y0) .* cos(n * pi * Z / z0) .* ... cos(l * pi * x_s / x0) .* cos(m * pi * y_s / y0) .* cos(n * pi * z_s / z0) .* ... (1 - exp(-D * lambda * t)) ./ lambda; sum_term = sum_term + term; end end end rho(:, :, :, t_idx) = (F0 / (x0 * y0 * z0 * D)) * sum_term; % 乘上源强度项和常数因子 % 计算测量点处的浓度 rho_measure(t_idx) = interp3(X, Y, Z, rho(:, :, :, t_idx), x_measure, y_measure, z_measure); rho_measure(t_idx) = rho_measure(t_idx) * 10^6 / 1.26; % 单位换算：g/cm^3 -&gt; ppm disp(t_idx)endtime_steps = time_steps / 40;% 创建视频对象video_file = 'fog_diffusion.avi'; v = VideoWriter(video_file);v.FrameRate = 5; % 设置帧率open(v); % 打开视频文件% 绘制动态可视化figure;for t_select = 1:num_time_steps % 遍历时间步 value = rho(:, :, :, t_select); % 筛选出非零值及其对应的坐标 non_zero_indices = value &gt;= 0.0003; % 设定阈值：可见浓度0.3mg/cm3 X_nonzero = X(non_zero_indices); Y_nonzero = Y(non_zero_indices); Z_nonzero = Z(non_zero_indices); Value_nonzero = value(non_zero_indices); % 绘制非零值的散点图 scatter3(X_nonzero, Y_nonzero, Z_nonzero, 20, Value_nonzero, 'filled'); % 绘制散点图 colormap jet; % 设置颜色图 colorbar; % 显示颜色条 xlabel('x'); ylabel('y'); zlabel('z'); title(['3D Scatter Plot of Values at t = ' num2str(time_steps(t_select))]); grid on; view(3); % 设置三维视角 % 固定坐标轴长度 axis([0, x0, 0, y0, 0, z0]); % 设置 x, y, z 的范围 % 将当前帧保存到视频 frame = getframe(gcf); writeVideo(v, frame);endclose(v); % 关闭视频文件% 绘制测量点浓度随时间的变化figure;plot(time_steps, rho_measure, '-o', 'LineWidth', 2);xlabel('Time (s)');ylabel('\\rho at (x0/2, 0, z0) (ppm)');title('Concentration at Measurement Point over Time');grid on;disp(['视频已保存为: ', video_file]);% 将测量点浓度数据保存到txt文件output_file = 'rho_measurement_data.txt';fileID = fopen(output_file, 'w');fprintf(fileID, 'Time(s)\\tConcentration(ppm)\\n'); % 表头for i = 1:length(time_steps) fprintf(fileID, '%.2f\\t%.6f\\n', time_steps(i), rho_measure(i));endfclose(fileID);disp(['测量点数据已保存为: ', output_file]); 2 Python有限元仿真代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import numpy as npfrom scipy.sparse import lil_matrixfrom scipy.sparse.linalg import spsolveimport matplotlib.pyplot as pltfrom matplotlib.colors import Normalizeimport matplotlib.animation as animation# 网格生成函数def generate_mesh(x0, y0, z0, nx, ny, nz): from meshpy.tet import MeshInfo, build points = [(0, 0, 0), (x0, 0, 0), (x0, y0, 0), (0, y0, 0),(0, 0, z0), (x0, 0, z0), (x0, y0, z0), (0, y0, z0)] facets = [[0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4], [1, 2, 6, 5], [2, 3, 7, 6], [3, 0, 4, 7]] mesh_info = MeshInfo() mesh_info.set_points(points) mesh_info.set_facets(facets) mesh = build(mesh_info, max_volume=(x0/nx) * (y0/ny) * (z0/nz)) return mesh# 全局矩阵组装def assemble_global_matrices(mesh, D): num_nodes = len(mesh.points) M_global = lil_matrix((num_nodes, num_nodes)) K_global = lil_matrix((num_nodes, num_nodes)) for element in mesh.elements: node_ids = element vertices = np.array([mesh.points[i] for i in node_ids]) B, volume = compute_B_matrix(vertices) K_element = D * volume * (B.T @ B) M_element = volume * np.eye(4) for i in range(4): for j in range(4): M_global[node_ids[i], node_ids[j]] += M_element[i, j] K_global[node_ids[i], node_ids[j]] += K_element[i, j] boundary_indices = find_boundary_nodes(mesh) apply_boundary_conditions(M_global, K_global, boundary_indices) return M_global, K_globaldef compute_B_matrix(vertices): A = np.ones((4, 4)) A[:, 1:] = vertices volume = abs(np.linalg.det(A)) / 6.0 B = np.zeros((3, 4)) for i in range(4): sub_matrix = np.delete(A, i, axis=0) coeffs = np.linalg.det(sub_matrix[:, 1:]) B[:, i] = coeffs B /= (6 * volume) return B, volumedef find_boundary_nodes(mesh): boundary_indices = set() for facet in mesh.facets: boundary_indices.update(facet) return list(boundary_indices)def apply_boundary_conditions(M_global, K_global, boundary_indices): for idx in boundary_indices: M_global[idx, :] = 0 M_global[:, idx] = 0 K_global[idx, :] = 0 M_global[idx, idx] = 1 K_global[idx, idx] = 1# 时间步进求解def solve_diffusion(mesh, M_global, K_global, F0, D, t_max, num_time_steps): num_nodes = len(mesh.points) rho = np.zeros((num_nodes, num_time_steps)) dt = t_max / (num_time_steps - 1) center = np.array([x0/2, y0/2, 0]) radius = 0.6 for t_idx in range(1, num_time_steps): A = M_global + dt * K_global F = F0 * np.ones(num_nodes) for idx, point in enumerate(mesh.points): if np.linalg.norm(point - center) &lt; radius: F[idx] += F0 b = M_global @ rho[:, t_idx-1] + dt * F rho[:, t_idx] = spsolve(A, b) return rho# 可视化与动画def create_animation(mesh, rho, time_steps, output_file): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') points = np.array(mesh.points) def update_plot(frame_idx): ax.clear() rho_t = rho[:, frame_idx] norm = Normalize(vmin=0.005, vmax=0.01) ax.scatter(points[:, 0], points[:, 1], points[:, 2], c=rho_t, cmap='jet', norm=norm, s=10) ax.set_title(f&quot;Concentration at t = {time_steps[frame_idx]:.2f}&quot;) ax.set_xlim(0, x0) ax.set_ylim(0, y0) ax.set_zlim(0, z0) ani = animation.FuncAnimation(fig, update_plot, frames=len(time_steps), interval=500) ani.save(output_file, writer='ffmpeg', fps=5)plt.show()# 主程序if __name__ == &quot;__main__&quot;: # 参数 x0, y0, z0 = 20, 25, 60 nx, ny, nz = 10, 10, 10 D = 0.0962 F0 = 0.5 t_max = 30 num_time_steps = 31 mesh = generate_mesh(x0, y0, z0, nx, ny, nz) # 网格生成 M_global, K_global = assemble_global_matrices(mesh, D) # 矩阵组装 # 求解 time_steps = np.linspace(0, t_max, num_time_steps) rho = solve_diffusion(mesh, M_global, K_global, F0, D, t_max, num_time_steps) create_animation(mesh, rho, time_steps, &quot;diffusion_animation.mp4&quot;) # 生成动画","link":"/2025/01/11/smoke/"},{"title":"基于自编码器和卷积网络的肺炎图像识别","text":"1 项目背景与研究意义1.1 项目背景肺炎作为一种常见的呼吸系统疾病，对人类健康构成了长期威胁，特别是随着COVID-19新冠肺炎疫情的全球爆发，其公共健康影响更为显著。COVID-19肺炎具有传播速度快、感染范围广、诊断难度大的特点，对全球医疗系统和社会经济产生了深远影响。特别是在疫情高峰期，医疗资源的短缺和诊断效率的瓶颈，进一步突显了快速、准确诊断工具的重要性。 传统肺炎诊断方法主要依赖医生对胸部X光片或CT图像的人工分析，既耗时又容易受到经验和疲劳的影响，尤其在COVID-19疫情期间，大量影像数据的涌现使得人工诊断难以满足需求。与此同时，COVID-19的影像表现与其他类型肺炎的重叠性增加了诊断的复杂性，这进一步加剧了对智能化诊断系统的需求。 随着人工智能技术的快速发展，深度学习为医疗影像分析带来了全新的解决方案。卷积神经网络（Convolutional Neural Network, CNN）凭借其强大的图像特征提取能力，在自动化诊断中展现了巨大潜力。同时，由于不同医疗机构的CT扫描设备性能差异显著，特别是在医疗资源较为匮乏的地区，CT影像常常受到设备老化、分辨率低或操作不规范等因素的影响，图像质量参差不齐，这不仅增加了诊断的复杂性，还对自动化系统的鲁棒性提出了更高要求；而自编码器（Autoencoder）作为一种有效的降噪工具，为医疗影像数据预处理提供了重要支持。通过自编码器的引入，可以有效消除图像中的噪声干扰，减少不同设备间的成像差异，为后续的分类和识别模型提供高质量的输入数据。因此，本项目提出结合自编码器和卷积神经网络的深度学习框架，开发一套针对肺炎（包括COVID-19）CT影像识别的智能诊断系统。 1.2 研究意义本项目以新型冠状病毒肺炎为切入点，面向未来医学智能化需求，开发的诊断系统不仅能够应对当下疫情挑战，还具有推广至其他医学影像诊断场景的潜力，从而为全球公共健康事业的发展提供有力支持。 面向新冠肺炎疫情期间大规模肺部影像数据的快速诊断需求，本系统依托深度学习技术，有效提升了诊断效率，为疫情防控和患者管理提供重要的技术支持。通过先进的模型算法，系统能够精准识别肺部CT影像中的病变特征，减少人为误差，确保诊断结果的准确性和一致性，大幅降低不同医疗机构和医生之间的诊断差异，避免误诊和漏诊风险，从而更好地保障患者安全。 针对基层医院或偏远地区医疗资源匮乏的现状，本系统可作为一种可靠的辅助诊断工具，为医生提供科学的决策支持，帮助缓解诊断能力不足带来的压力。其高效的处理能力不仅提高了基层医疗服务水平，也为疫情防控的全面推进提供了技术保障，为应对紧急医疗需求的地区解决实际困难。 此外，本系统在高效处理和分析海量肺部CT影像数据的基础上，还为研究新冠肺炎的病理特征及流行规律提供了宝贵的数据支持。这些分析结果可进一步应用于疫情传播趋势预测和公共卫生政策制定，为疫情防控策略的科学性和有效性奠定了坚实基础。 同时，本系统也为患者病情的动态管理提供了重要帮助。通过智能分析新冠肺炎影像特征的变化趋势，系统能够为临床医生提供精确的病情评估建议，有助于及时调整治疗方案。这种基于影像数据的技术支持，不仅提高了患者管理的科学性和有效性，还为医疗资源的合理分配提供了重要依据，进一步推动了疫情防控工作的高效开展。 2 数据集获取与预处理2.1 数据集介绍本项目使用的肺部X-光片数据集从Kaggle网站（链接：https://www.kaggle.com/datasets/alsaniipe/chest-x-ray-image）获取，共分为三类标签：新冠肺炎COVID19、正常NORMAL和普通肺炎PNEUMONIA，该数据集已经事先划分好了训练集与测试集。此外，为测试模型对于不同质量CT影像的识别精度，还对测试集中的部分图像使用高斯噪声进行扰动，以模拟实际CT扫描的成像质量差异。 数据分布如下表所示： 表2.1：数据集数据分布情况 COVID19 NORMAL PNEUMONIA Train 460 1266 3418 Test 116 317 855 Noisy_Test 26 20 20 2.2 编程环境搭建本项目中所有的代码编写与运行均是在配备NVIDIA GeForce RTX 3060显卡、16GB运行内存、12th Gen Inter(R) Core(TM) i7-12700@2.10GHz处理器与Microsoft Windows 11操作系统的工作站上使用Python编程语言完成的。 软件环境方面，采用Conda进行环境管理，在控制台中通过命令”conda create -n covid python=3.12”创建虚拟环境，并在激活环境后使用pip install命令依次安装所需的各种依赖库；全部安装并测试完成后，通过命令”pip freeze &gt;requirements.txt”将虚拟环境中安装的所有依赖库及对应版本写入文件requirements.txt，后续移植时可在新的运行环境中运行命令”pip install -r requirements.txt”完成环境的一键配置。 值得注意的是，在PyTorch（包括torch、torchvision与torchaudio库）安装时需要根据自己电脑使用的CUDA版本（使用CPU则直接在命令行中使用pip install安装即可）在PyTorch官网中找到对应的安装命令进行安装。我使用的CUDA版本为12.6，安装命令的选取如下图所示： 下面对于项目中使用到的主要依赖库进行简要介绍： 其中，plt用于绘图，nn中包含了用于构建神经网络的隐藏层（全连接层、卷积层等），F中包含了各种激活函数（ReLu、Sigmoid等），DataLoader用于在训练时加载数据，datasets和transforms用于读取和处理数据集，tqdm用于进度条可视化，torchmetrics用于模型精度的测试，torchviz和torchsummary用于以图形与文字的方式描述模型架构概况。 2.3 图像数据读取torch对于一些常用的数据集做了封装，可以直接调用，例如datasets.MNIST()。但此处我们使用的是本地的图片数据，可以使用ImageFolder将一个文件夹下的图片读取成数据集并完成数据增强工作。在读取完数据集后，还需要定义DataLoader用于加载数据为可分批次（batch）读取的迭代器以供后续使用。为使得代码更加简洁，将上述的数据读取与加载过程为封装在getDataLoader函数中，并在主函数中通过指定不同的目录加载训练集、测试集或是含噪声测试集。 可以看到，其中构建了数据增强器transform，在读取数据时进行相应处理： Grayscale: 指以灰度图的形式读取。 Resize: 由于图像尺寸各不相同，在训练前需将它们重塑成相同尺寸256*256。 ToTensor: 将图片格式转换成张量形式，torch的计算以张量的形式进行。 除此之外，在构建数据加载器时需要指定一个批次（batch）中的图片数据数量batch_size，在模型训练时训练批次大小TRAIN_BATCH_SIZE也是会影响最终模型性能的重要超参数之一。在训练过程中，设定TRAIN_BATCH_SIZE为32，而在测试过程中，为提高测试效率，将TEST_BATCH_SIZE设置为66并对函数进行对应修改。 2.4 叠加噪声函数不论是构建噪声测试集，还是在利用无噪声的训练集进行训练时，都需要手动添加噪声，故编写add_noise函数，默认的噪声强度为0.5，并在添加噪声后进行归一化以确保图像值位于[0,1]范围内。 3 模型构建与网络训练3.1 整体模型框架整体模型框架由两个核心部分组成，分别是用于去噪的数据预处理模块和负责分类的卷积神经网络（CNN）。去噪模块采用自编码器（Autoencoder）的架构，专注于从输入数据中去除噪声，以提升后续分类的准确性；分类模块基于卷积神经网络，其强大的特征提取和模式识别能力使其成为分类任务的理想选择。 两个模块相辅相成，通过有效的数据处理和特征提取，确保模型能够在噪声干扰较大的环境中实现高精度分类。噪声数据首先经过自编码器处理，生成质量优化的特征表示，然后被CNN接收并完成分类任务。这一整体框架设计非常适合肺炎图像识别任务，通过结合去噪和分类两大模块的优势，模型不仅能够有效提高数据质量，还能充分挖掘数据中的有用特征，从而能够在复杂的医学影像处理中表现出卓越的鲁棒性和准确性，满足肺炎诊断的实际需求。 3.2 自编码器自编码器模型用于处理输入数据中的噪声问题，提升后续分类的准确性。其核心思想是通过编码器将输入数据压缩至低维潜在表示（latent representation），再由解码器将其还原至去噪后的重构数据，从而实现降噪效果。 3.2.1 网络结构设计 自编码器网络结构由编码器encoder与解码器decoder组成： 编码器由两层卷积（Conv2d）和两次池化（MaxPool2d）操作组成，用于提取特征； 解码器通过两次反卷积（ConvTranspose2d）和两次上采样（UpsamplingNearest2d）逐步恢复图像尺寸到原始大小； 最后使用Sigmoid激活函数将输出值限制在[0,1]区间。 模型定义代码如下： 模型继承自nn.Module类，在__init__()函数中定义模型的结构，在forward()函数中定义模型的前向传播过程。 通过调用torchviz和torchsummary库，可以输出该模型结构的基本信息： 3.2.2 模型训练基本的训练流程集成在函数train_autoencoder_process中，如下图所示： 其中指定优化器optimizer为Adam，损失函数为均方误差MSE，并使用超参数：训练轮数Epochs=50、学习率lr=0.001。每轮（Epoch）训练中均需要以多个batch的形式遍历训练集中的所有数据，并在每个batch后对模型进行更新，具体而言每次更新均需执行如下操作： 从加载器中获取输入数据 使用add_noise函数对干净图像加噪 将加噪后图像输入自编码器模型并计算模型输出 根据模型输出和标签计算损失Loss 清空梯度 反向传播 更新模型 值得注意的是，由于用于训练的图像数据没有噪声，因此训练时首先需要对输入的图像进行加噪处理，再输入自编码器模型进行训练。 训练过程中还利用tqdm进度条函数对训练进程进行可视化，并在每轮训练完成后打印出当轮训练过程中模型的平均损失： 在训练过程中，将每轮训练的平均损失存储在列表中，并在训练结束后将平均损失的变化过程以图像形式呈现： 可以看到，经过多轮训练，模型的损失函数值在不断减小且逐渐趋近于0，这意味着该自编码器的模型训练过程是收敛的，模型具有较稳定的工作性能。 3.3 卷积神经网络卷积神经网络负责从图像中提取多层次的空间特征，通过逐步减少图像尺寸和增加特征通道来捕捉关键信息，从而实现去噪后肺部CT图像的分类功能。CNN以其强大的特征提取能力，能够有效处理图像的局部依赖性和空间不变性，高效处理结构化数据（如图像、时序数据）。模型简单且高效，具有较强的泛化能力，适合处理小规模数据集的图像分类问题。 3.3.1 网络结构设计 卷积神经网络结构（如上图，通过NN-SVG工具绘制）由两层卷积层（Conv2d）和池化层（MaxPool2d）组成，激活函数均选用ReLU，逐步提取特征并将输入图像的尺寸从原始大小减小到64×64。卷积后的特征图展平后通过三个全连接层（Linear），分别将特征维度从32×64×64降至128，再降至32，最后输出3个类别（Covid19、Normal、Pneumonia）的预测结果。 模型定义代码如下： 模型继承自nn.Module类，在__init__()函数中定义模型的结构，在forward()函数中定义模型的前向传播过程。 通过调用torchviz和torchsummary库，可以输出该模型结构的基本信息： 3.3.2 模型训练基本的训练流程集成在函数train_cnn_process中，如下图所示： 其中指定优化器optimizer为Adam，损失函数为交叉熵损失CrossEntropy，并使用超参数：训练轮数Epochs=50、学习率lr=0.001。每轮（Epoch）训练中均需要以多个batch的形式遍历训练集中的所有数据，并在每个batch后对模型进行更新，具体而言每次更新均需执行如下操作： 从加载器中获取输入数据 使用add_noise函数对干净图像加噪 将加噪后图像输入训练好的自编码器模型trained_autoencoder_model 将经过自编码器去噪后的图像输入CNN模型并计算模型输出 根据模型输出和标签计算损失Loss 清空梯度 反向传播 更新模型 值得注意的是，由于用于训练的图像数据没有噪声，为与实际的输入情况一致，首先需要对输入的图像进行加噪处理，再利用训练好的自编码器模型进行降噪（为了不在更新CNN的同时更新自编码器，这一步不需要产生梯度），才能输入CNN分类模型进行训练。 训练过程中还利用tqdm进度条函数对训练进程进行可视化，并在每轮训练完成后打印出当轮训练过程中模型的平均损失与在训练集上的测试精度： 在训练过程中，将每轮训练的平均损失与模型在训练集上的测试精度存储在列表中，并在训练结束后将两者的变化过程以图像形式呈现： 可以看到，经过多轮训练，模型的损失函数值在不断减小且逐渐趋近于0，这意味着该自编码器的模型训练过程是收敛的，模型具有较稳定的工作性能；同时随着训练轮数增加，模型在训练集上的精度也逐渐增高（波动上升），在模型训练完成时，卷积神经网络在训练集上的分类精度已经可以达到99.59%（一度达到99.90%），接近百分之百，说明模型的分类能力较好。 4 模型测试及应用4.1 自编码器降噪效果在自编码器模型的训练过程中，每隔10轮对模型参数进行了一次存档；在测试过程中，分别使用训练轮数为10、20、30、40、50的自编码器模型对于加噪后的模型进行降噪处理，效果如下图所示： 通过对比不同训练轮数的自编码器模型降噪效果可以发现，随着训练轮数的增加，自编码器模型的降噪效果在逐渐提升，但在Epoch到达30之后，训练带来的降噪效果提升就不如先前显著了。尽管由于较大的噪声强度（0.5）导致降噪后的图像仍然比较模糊，但通过肉眼还是能粗略观察处肺部骨骼的轮廓等特征，后续实验也证明了卷积神经网络确实可以从这样清晰度的图像中提取相应的特征来进行分类，该自编码器模型的设计有效。 4.2 卷积神经网络分类精度在卷积神经网络的分类精度上，训练过程中已经实时对于每一轮训练后的模型在训练集上进行了精度测试（3.2.2节中已有提及），而在测试集上，可以编写与训练过程类似的代码利用torchmetrics库对模型分类精度进行测试，只是不会更新模型，代码如下： 可以看到，由于我们的测试集分为含噪声和不含噪声两类，因此编写了不同的函数对模型分类精度进行测试。两个函数的主要差别就在于，由于含噪声测试集是已经加噪的图片（噪声与手动通过add_noise函数添加的不同），因此在含噪声测试集的测试代码中不必再次手动添加噪声，而是直接将图像输入自编码器降噪后再输入CNN分类模型中进行分类；而对于不含噪声的测试集而言，为模拟与训练集同样的处理流程，会先进行手动加噪再通过自编码器降噪之后才输入CNN分类模型中进行分类。 运行测试代码后，得到模型在含噪测试集上的分类精度为96.97%，在不含噪声的测试集上的分类精度为94.57%，在两个测试集上的分类精度水平均较高，说明该模型具有良好的分类效果。 4.3 模型应用：基于CT影像的肺炎诊断Web服务通过对比多组超参数的模型降噪与分类效果，最终选定如下的超参数： 训练轮数Epochs=50； 学习率LR=0.001； 训练批次大小Train_Batch_Size=32。 选定参数后，将整体代码抽离为model.py（包含模型定义类代码），run.py（服务端代码）和train.py（训练函数），并将模型部署到实际应用中，使用Flask作为服务端，以Web形式用户提供操作接口以上传图片进行诊断。由于主要功能是提供接口，故网页只做了很简易的一个index.html，给用户提供上传图片的按钮，并在用户上传有噪声的CT影像后返回诊断结果及去噪后的图像。除此之外，还将挂载在本地端口上的Web通过内网穿透映射到公网，以供实时访问。 网页初始界面如下图所示： 接下来分别测试当输入COVID19、NORMAL和PNEUMONIA三个组别的图片，模型能否正确判断： 可以发现，模型在大多数情况下可以正确识别图像来源，但也会出现错误识别的情况，这和Test 集上的Accuracy相符合；此外，在测试时还注意到，模型识别结果偶尔会出现不稳定的现象，即输入同一张图像有时识别为某一类别，有时又会识别为另一类别，这是由模型内部部分随机参数导致的，这也反映了模型在一些模棱两可的情况下（两类别概率接近）做出判断时的不稳定性。在实际应用中，为尽可能减少误诊对于患者带来的各方面影响，还需要采取更多优化措施提升模型性能，并对模型在模棱两可的情况下做出的判断进行合理的限制。 5 总结与展望本项目全部代码（不包含数据集）已上传至Github仓库，仓库URL地址：https://github.com/Asgard-Tim/Pneumonia-Image-Recognition 5.1 项目总结本项目基于深度学习技术，结合自编码器和卷积神经网络，开发了一套智能诊断系统，用于快速、高效地识别肺部的CT影像并判断该患者是否患有肺炎（包括COVID-19）。自编码器模块有效去除了噪声，提升了图像质量，而卷积神经网络以其强大的特征提取能力，实现了高精度的分类。本项目在数据预处理、模型设计、网络训练及测试等环节中均采用了创新性的技术方案，最终实现了在含噪声测试集上96.97%和在无噪声测试集上94.57%的分类精度，表现出了较高的鲁棒性和实用价值。同时，系统已通过Flask框架部署为Web服务，能够实时接收CT影像并给出诊断结果，为疫情期间大规模影像数据的快速诊断及基层医疗资源匮乏地区的医疗支持提供了重要的技术保障。 5.2 课程收获与反思本次选修《智能图像处理》这门课程确实让我学到了很多东西，其实自己之前也自己看过一些机器学习方面的内容，有一定的知识基础与环境搭建经验，但由于各方面原因总是没有系统性的去学习计算机视觉的相关知识，也缺乏足够的实战代码与项目经验。通过这门课程的学习，很大程度上锻炼了我Python的代码能力，也在Coding的过程中不断熟悉OpenCV、Pytorch等库的使用，更在实践的过程中不断加深对于各种算法模型（AlexNet、ResNet、YOLO等）的理解。 本次项目让我完整地经历了从数据集获取、论文调研及算法代码实现，再到代码调试与模型训练测试，最终将模型应用到实际系统中的全过程，在项目实现的过程中收获了很多课程教学与实验中涉及不到的东西，包括数据集的收集、模型的选择以及作为一个完整项目的代码实现等等多个方面，这也是我第一次使用GPU资源去进行。虽然由于时间等条件的限制，在模型选择上并没有进行深入的调研与充分的对比试验，只是基于自己已知的一些知识对于架构较为简单的自编码器模型与卷积神经网络进行了复现与设计，最终模型的分类精度还有一定的提升空间，但是这也为我后续的自主学习打下了一个良好的基础，希望未来我能在计算机视觉方面有更加深入的学习与探索，也感谢老师的耐心指导与悉心教学。 参考文献[1] Nosa-Omoruyi M, Oghenekaro L U. AutoEncoder Convolutional Neural Network for Pneumonia Detection[J]. arXiv preprint arXiv:2409.02142, 2024. [2] Ratiphaphongthon W, Panup W, Wangkeeree R. An improved technique for pneumonia infected patients image recognition based on combination algorithm of smooth generalized pinball SVM and variational autoencoders[J]. IEEE Access, 2022, 10: 107431-107445. [3] Gayathri J L, Abraham B, Sujarani M S, et al. A computer-aided diagnosis system for the classification of COVID-19 and non-COVID-19 pneumonia on chest X-ray images by integrating CNN with sparse autoencoder and feed forward neural network[J]. Computers in biology and medicine, 2022, 141: 105134. [4] García-Ordás M T, Benítez-Andrades J A, García-Rodríguez I, et al. Detecting respiratory pathologies using convolutional neural networks and variational autoencoders for unbalancing data[J]. Sensors, 2020,20(4): 1214. [5] Xia Y. Enhanced Pneumonia Detection in Chest X-Rays Based on Integrated Denoising Autoencoders and Convolutional Neural Networks[J]. [6] El-Shafai W, El-Nabi S A, El-Rabaie E S M, et al. Efficient Deep-Learning-Based Autoencoder Denoising Approach for Medical Image Diagnosis[J]. Computers, Materials &amp; Continua, 2022, 70(3). [7] Rana N, Marwaha H. Auto encoder-guided Feature Extraction for Pneumonia Identification from Chest X-ray Images[C]//E3S Web of Conferences. EDP Sciences, 2024, 556: 01011. [8] Ankayarkanni B, Sangeetha P. An Autoencoder-BiLSTM framework for classifying multiple types of lung diseases from CXR images[J]. Multimedia Tools and Applications, 2024: 1-30. [9] 孙敬,丁嘉伟,冯光辉.一种基于自编码器降维的神经卷积网络入侵检测模型[J/OL].电信科学,1-7[2025-01-05]. [10] 张淙越,杨晓玲.基于卷积神经网络的新冠肺炎CT图像识别系统[J].电脑与信息技术,2022,30(03):12-14+40.","link":"/2025/01/05/graph/"},{"title":"心电信号采集与处理","text":"1 实验需求分析1.1 项目背景介绍心电信号（Electrocardiogram, ECG）是反映心脏活动电生理变化的重要生物电信号，其特征包括心率、节律、波形等参数，能够直观反映心脏健康状况，在临床医学、健康监测和疾病预防中具有不可替代的作用。通过心电信号的测量与分析，可以检测心律失常、心肌缺血、心脏传导阻滞等异常，为心脏疾病的诊断和治疗提供关键支持；借助便携式和可穿戴设备，实时心电监测已成为健康管理的重要手段，为心血管疾病高危人群提供预警，有助于降低发病率和致死率。此外，心电信号还是生物医学研究的重要工具，为心血管药物开发、人工心脏研究等领域提供了基础数据。在当前人口老龄化加剧和心血管疾病高发的背景下，心电信号测量与分析技术显得尤为重要。本项目旨在开发高精度的心电信号采集系统，结合课程中介绍的数字信号处理等专业知识，为心脏健康提供更加便捷和智能的监测方案，推动精准医疗与个性化健康管理的发展。 1.2 心电信号特征与设计需求心脏内部产生的一系列非常协调的电刺激脉冲，使得心脏肌肉细胞有节奏的舒张和收缩，这些信号传递到人体表面的不同部位形成不同的电位差。通过仪器设备可以从体表检测到这些微弱的电位差信号，称之为心电信号。换言之，心电信号即为人体心脏细胞细胞膜产生的电势差。在医学上，医生往往需要通过心率与幅值等参数来初步判断患者的健康状况，因此实现高精度的心率与幅值测量是本项目中设计的心电信号采集与处理系统的核心功能。 正常的心电信号频率范围为0.05Hz－100Hz，其能量集中在低频段，其中99％的能量集中在0Hz－35Hz。在其采集过程中容易受到各种干扰，主要分为三种： 工频和工频的谐波频率干扰，工频频率在我国为50Hz； 肌颤噪声和采样电路参考电压引入的电源纹波等高频噪声，频率通常在100Hz以上； 呼吸基线漂移和采样引入的直流分量，频率一般分布在0-0.7Hz。 以上的各种干扰会对心电信号采集结果产生较大的影响，使得采集到的心电信号中出现许多杂波与噪声，这是我们所不希望看到的。因此，为提高心电信号的测量精度，需要设计相应的滤波器对传感器采集到的信号进行滤波，从而减小信号中的噪声震荡，提高心率与幅值测量的准确程度。特别的，由于参考电压受环境温度变化会产生一定的温漂，以及人的呼吸活动和电极滑动也导致基线漂移。这些干扰的频率很低，通常在几Hz以内，但和心电信号的有效频谱非常接近，因此需要过渡带较窄的IIR直流陷波器来消除干扰。 基于心电信号的以上特性，对于该心电信号采集与处理系统，提出如下的技术指标需求： 0频处的缓变直流衰减不低于30dB； 降噪滤波器以35Hz为3dB通带截止频率，过渡带不超过10Hz，阻带衰减不低于40dB； 心率估算误差不超过10%。 2 实现方案论证2.1 系统框架设计本项目的核心目标是实现心电信号的采集与滤波以及心率测量，同时需要在屏幕上绘制时域波形与频谱图。具体而言，细分的功能如下： 实现ADS1292获取心电信号原始数据，并通过串口传输至PC电脑； 实现PC电脑中通过MATLAB对原始数据进行时域和频域分析； 实现PC电脑中通过MATLAB对原始数据进行降噪和提取心率； 实现STM32单片机中对原始数据进行降噪和提取心率； TFT屏幕中绘制心电信号曲线和显示心率数值。 为实现以上功能，采用如下的系统设计流程： 调试ADS1292R_PowerOnInit函数中的ADS1292芯片读取，通过读取芯片device_id验证硬件功能正常且连接正确； 在中断驱动下，读取ADS1292的原始数据，并存储在单片机的存储器中； 把原始数据传输到PC； 在PC中分析原始数据的时域和频域； 在PC中设计滤波器对原始数据进行处理，并提取心率等； 把PC中的滤波器移植到单片机中； 在单片机中把心电波形和心率等数据显示到TFT屏幕。 根据如上设计流程，结合目前提供的材料，设计了如下图所示的心电信号采集与分析系统： 系统的工作流程如下： 首先，STM32控制器向心电传感器发送采集指令，传感器随后采集来自人体或模拟信号源的心电信号，并将数据反馈至控制器； 接着，控制器将采集到的数据传输至PC端，供进一步分析处理； 然后，根据PC端的分析结果，控制器会调整参数并优化心电信号处理； 最终，处理后的结果将在TFT屏幕上实时显示，供用户查看。 可以看到，该系统主要涉及到STM32主控芯片、ADS1292R传感器、TFT显示屏、心电信号模拟器以及PC端分析软件MATLAB等关键组件。接下来将对于本项目涉及的各硬件组件进行介绍。 2.2 STM32主控芯片本项目选用的微控制器STM32F407ZG是系统的核心控制单元，负责协调各个模块的工作。其不仅负责信号的采集，还管理信号传输、滤波器应用、以及与TFT屏幕的显示操作。其强大的处理能力和灵活的控制方式使其成为整个系统的”大脑”。该控制器目前搭载在”正点原子”探索者STM32F407开发板V3上，负责完成系统的信号采集、处理与传输任务。 该单片机具备高性能的ARM Cortex-M4内核，主频高达168MHz，同时集成了丰富的外设接口，包括多个ADC通道、DMA（直接存储器访问）、定时器以及USART串口等，为心电信号的实时采集、处理与传输提供了强有力的硬件支持。它通过SPI协议与ADS1292传感器进行数据交换，采集来自人体或模拟信号源的心电信号，并进行初步处理。 2.3 心电信号模拟器在实验的过程中，无法总是以人体作为心电信号源，因此在缺乏人体数据的情况下，本项目采用SKX-2000心电信号模拟仪作为测试时的模拟信号源。它能够生成不同类型的心电波形，广泛用于测试系统性能和验证心电信号采集、处理的稳定性。此设备对确保系统在实际使用前达到预期的性能标准至关重要。 在本项目中，主要使用到的是正常的心电波形与标准的心率信号，可以通过操作该模拟仪控制其产生心电信号的心率以及幅度。在连接方面，如图2.3所示，采用三导联接法，RA连接右手（红色），LA连接左手（黄色），LL连接左脚（绿色）；通过3.5耳机动态导联线，将模拟仪产生的心电信号输入ADS1292S传感器中以供进一步采集。 2.3 信号采集传感器：ADS1292RADS1292R作为一款多通道同步采样的24位模数转换器（ADC），被广泛应用于生物电势测量领域，其独特的设计集成了可编程增益放大器、内部基准源和板载振荡器，确保了心电信号的精准采集。在本系统中，ADS1292R作为信号采集模块的核心组件，负责从心电电极捕获原始心电信号。这些信号随后通过SPI接口传输至STM32微控制器，供后续处理和分析。 该模块共有12个输出引脚（传感器模块右侧)，各引脚接口功能说明如下： GND：接供电电源地； CLK：提供给ADS1292R工作的外部时钟，由于本项目采用内部时钟，故该引脚无需连接； GPIO1、GPIO2：本项目中未使用，无需连接 SPI_SCK：接入由STM32单片机提供的SPI时钟信号； SPI_MISO：向STM32单片机发送SPI数据输入信号； SPI_MOSI：接收STM32单片机发出的数据输出信号； SPI_CS0：接入STM32单片机GPIO，为ADS1292R提供片选选中信号； ADS_DRDY：向STM32单片机发送外部中断输入，告知单片机可以通过SPI接收采集信号； ADS_START：接入STM32单片机GPIO，为ADS1292R提供开始采集信号； ADS_PWDN：接入STM32单片机GPIO，为ADS1292R提供复位信号RESET； +5V：接供电电源+5V（由STM32输出）。 除此之外，由于选用的STM32单片机只允许接收0~3.3V的输出电压，故单片机通过SPI通信接收的信号电压必须限制在该范围内，因此需要将ADS1292R传感器模块中间的VDD与3.3V引脚通过跳线帽相连以实现电压转换（与图2.5中左图的连接方式相反）。 2.4 SPI通信读取采集数据在本系统中，传感器将数字化后的原始心电信号数据通过SPI接口传输到STM32微控制器。SPI通信具有高速度、全双工传输的优势，非常适合用于实时性要求较高的应用场景。SPI接口确保了心电信号数据的快速、稳定传输，保证了信号的实时处理和准确性。通过SPI，ADS1292R和STM32微控制器能够高效地交换数据，从而提升系统的整体性能和响应速度。 SPI通信采用主从结构，其中STM32微控制器作为主设备，ADS1292R作为从设备。具体来说，SPI通信包括四个主要信号线：时钟信号（SCK）、主输出从输入（MOSI）、主输入从输出（MISO）和片选信号（CS）。时钟信号由STM32微控制器提供，用于同步数据传输。数据通过MOSI线从ADS1292R传输到STM32微控制器，而传感器通过MISO线将必要的反馈信息传回STM32。 为了提高系统的响应速度和处理效率，在单片机端选择了基于中断驱动的数据采集机制。当ADS1292R传感器完成一组心电数据的采集后，通过中断信号通知STM32F407进行数据读取和处理。这种机制有效减少了CPU的空闲时间，提高了系统的整体效率。 在单片机程序工程中，通过调用驱动库文件中的ADS1292_Read_Data函数，可以实现单片机与ADS1292R的数据交互以进行实时数据监测，并通过函数ADS1292_Send_CMD将信号数据通过UART串口以115200的波特率传输至PC端并保存。在此过程中，原始信号数据被保存为.dat格式的文件，后续将通过MATLAB读取和显示这些信号数据，并针对这些数据进行滤波器等模块的设计，对信号进行进一步验证与调试。 3 理论推导与MATLAB计算PC端分析软件（本项目中使用MATLAB）用于对采集到的原始心电信号进行深入分析。为验证滤波器对心电信号的作用和效果，可以先在MATLAB上设计算法对心电信号进行一系列处理，包括数据读取、绘制原始数据时域波形、分析原始数据的频谱、设计数字直流陷波器、设计FIR数字低通滤波器、分析并比较滤波前后数据的频谱以及估算心率。通过这些分析，系统能够设计出合适的滤波器以去除噪声并提取出心率等重要参数，为后续移植到单片机上提供理论验证。 3.1 原始心电信号数据的读取与频谱分析为了研究信号特征和评估处理效果，首先需要导入心电信号数据并进行基本分析。当心电信号传入单片机后，根据ADS1292R的数据手册，还需在单片机中对数据进行解码处理。在2.4节中，直接存入.dat文件的是未经过解码的原始数据，而图2.11展示的则是经过解码转换后的波形数据可视化结果（由单片机内部程序完成解码转换，将在4.2节中详细展开）。 本章中的MATLAB分析均基于未解码的.dat文件，因此要想获得真实的波形数据（电压值），需要先根据以下规则对数据进行解码（4.2中的解码基于同样的原理，后续不再赘述）： 由于原始数据格式是24bits的二进制补码（7FFFFF对应的模拟信号是2.4V。800000对应的模拟信号是-2.4V），若考虑保留高16bits，需要注意此时为补码，同时也要考虑到16bits相比于24bits相当于右移了8位。所以此时7FFF的数值对应模拟信号相当于2.4V，8000对应模拟信号-2.4V。 基于这样的规则，可以在MATLAB编写对应的接收数据代码，从文件中读取数据（注意把负数的二进制补码转换为原码），其中Off可以为0或1（因为MATLAB接收的起始数据可能是16bits的高8位或者低8位，用off作为偏移调整，这样组合的数据才不会出现错位）；同时通过plot函数绘制出原始心电信号的时域波形，并使用快速傅里叶变换（FFT）分析信号频谱，绘制出频谱图。 从频谱图（上右图）中可以明显观察到信号中的低频基线漂移和工频干扰（与1.2节中的分析基本一致），这些成分需要通过滤波器加以去除。 3.2 IIR数字直流陷波器设计与滤波效果工程中使用高精度传感器采集动态信号，采集的原始数据会因为环境变化、量化字长和参考电压等因素，包含较强的缓变直流分量，如果不予以消除，会导致在降噪等处理中出现运算饱和溢出。由于在采集心电信号时，人的呼吸活动和电极滑动会导致基线漂移，而这些干扰的频率又与心电信号的有效频谱非常接近，因此需要设计窄带IIR直流陷波器来消除该干扰。 直流陷波器的传递函数Η(z)为：$$Η(z) = \\frac{z - 1}{z - a}$$该数字系统的极点为z = a，零点为z=1，其中参数a决定了陷波器的过渡带宽和衰减性能，为接近1的正实数。因为零点对应的幅角ω = 0，所以数字系统在零频处的增益显著衰减（如图3.5所示），其衰减的程度与过渡带的宽度和极点a的数值有关：a越大衰减变小，同时过渡带变窄，反之则衰减增大和过渡带增宽。通过实验调整，选择a=0.992可在基线漂移和信号完整性之间取得平衡。 可以看到，在加入了直流陷波器进行滤波后，0频处的基线漂移基本被消除，说明该滤波器的设计有效并起到了很好的效果。 3.3 FIR数字低通滤波器设计与滤波效果根据阻带衰减不低于40dB且过渡带不超过10Hz的要求，利用MATLAB中自带的filterDesigner滤波器设计工具对于FIR数字低通滤波器进行设计。在该滤波器中，采用固定窗口，通过对当前点及其前160个点的加权求和来计算输出（指定滤波器阶数为160）。 在固定窗口的选择上，由于不同窗函数的阻带最小衰减各不相同，过渡带应与对应窗函数的”精确过渡带宽”相等。以下是常用窗函数的对比表： 表3.1 不同窗函数的阻带最小衰减 窗函数 第一旁瓣衰减A/dB 近似过渡带宽Bw 精确过渡带宽 旁瓣峰值衰减/(dB * oct^(- 1)) 矩形窗 -13 4π/N 1.8π/N 21 汉宁窗 -31 8π/N 6.2π/N 44 海明窗 -41 8π/N 6.6π/N 53 布莱克曼窗 -57 12π/N 11π/N 74 凯泽窗(β = 7.865) -57 10π/N 80 在实际设计中，选择Chebyshev（切比雪夫）窗，其主要特点为：在给定窗口长度的情况下，能够提供最小的主瓣宽度。因此，通过选用Chebyshev窗，在频域上最小化主瓣的振幅波动，以实现滤波器的设计。 除此之外，设计时还指定采样频率为500Hz，阻带频率设计为35Hz，确定好参数后可在filterDesigner工具中导出为MATLAB函数： 在主程序中调用生成的滤波器函数构造一个FIR数字低通滤波器实例，并利用filter函数对于直流陷波后的波形数据进行FIR滤波并通过plot函数绘制滤波后的频谱，代码与结果如下所示： 可以看到，在加入了数字低通滤波器进行滤波后，50Hz处的工频干扰完全被消除，说明该滤波器的设计有效并起到了很好的效果。 3.4 滤波结果综合分析通过IIR和FIR滤波器的级联处理，最终获得了较为清晰的心电信号波形（如图3.9所示）。此过程有效去除了干扰，为后续心率计算和信号分析提供了可靠的基础。 为了更直观地展示信号处理过程的效果，对心电信号在各个处理阶段的频谱进行了对比分析。图3.10中显示了原始心电信号以及经过直流陷波器和FIR低通滤波器联合处理后的信号频谱图。 从原始心电信号频谱可以看出，信号中存在显著的工频干扰（约50Hz）和低频基线漂移（频率较低）。此外，信号还包含较多高频噪声，影响了心电信号的质量。经过直流陷波器处理后，低频基线漂移明显被抑制，低频成分显著减少但同时工频干扰和高频噪声依然存在，但其幅值未发生明显变化，表明直流陷波器主要对低频干扰起到作用；在应用FIR低通滤波器后，信号中50Hz附近的工频干扰被有效抑制，同时高频噪声也显著减弱。 最终处理后的频谱显示出清晰的心电信号主频成分（低于30Hz），为后续的R波检测与心率计算提供了可靠的基础。 3.5 心率计算在对原始心电信号完成滤波处理后，可进一步估算心率这一关键生理参数。心率的计算基于心电信号中的R波峰值检测，通过分析相邻R波之间的R-R间期推算心率值。R波的检测是心率估算的关键环节。在此实验中，采用MATLAB函数findpeaks来检测心电信号中的峰值。为提高检测精度，将滤波后的信号进行缩放，并设置峰值检测的阈值为信号均值加一倍标准差。 检测到R波位置后，可通过计算相邻峰值位置之间的时间间隔（R-R间期）来估算心率。使用diff函数计算相邻R波的时间间隔并计算R-R间期的平均值，并根据如下公式计算出心率： $$心率 = \\frac{60}{平均R - R间期}$$ 最终得出结果为60.29bpm，对比实际信号发生仪60bmp的心率，可以较为准确地估算心率，其结果符合误差小于10%的预期。 4 STM32程序设计与参数选择项目代码已推送至Github远程仓库：Asgard-Tim/ECG_Final_Project 4.1 单片机程序架构设计为实现2.1节所提出的基本功能，除了要采集心电数据并对其进行滤波、显示时域波形外，还需要对滤波后的波形进行频谱分析并显示。为了更高效地完成这一过程，系统引入了快速傅里叶变换（FFT）算法，用于将时域信号转化为频域信号，便于分析信号的频谱特性。然而，由于FFT计算量较大，尤其是在较高采样率下，需要处理大量的点，因此为了加快运行速度，程序采用了FreeRTOS实时操作系统，分别对信号滤波和频谱分析进行任务划分和并行处理。 在系统的实现中，FreeRTOS将任务分为信号采集与滤波任务ECG和FFT计算任务。如上图所示，信号采集任务负责从ADS1292R中读取原始心电信号，并完成IIR和FIR滤波的处理，将滤波后的数据存储到循环缓冲区中，通过中断驱动的方式与传感器交互，确保数据的实时性和可靠性；而FFT计算任务则专注于对缓冲区中的数据进行频谱分析，每当缓冲区填满指定数量的数据点时，FFT计算任务将被启动，这虽然会导致实际运行时FFT频谱更新会产生一定的延时，但这样的设计将使得整个系统的工作更加稳定可控。 通过引入FreeRTOS，系统充分利用了单片机的多任务并行能力，使信号滤波和频谱分析的运行效率大幅提升，同时保证了心电信号处理的实时性。滤波和频谱分析的结合，不仅提高了信号的可用性，还为后续的心率计算和心电异常检测提供了更加丰富和可靠的数据支持。 4.2 采集原始数据解码通过SPI接口，STM32微控制器不断与ADS1292R传感器进行交互，读取其输出的24位数字信号数据。基于3.1节提到的价码规则，将读取到的数据经过必要的解码和处理后，可将其转换为实际的电压值，并进一步用于实时显示与分析。其核心代码如下所示： 在具体实现中，通过将ADS1292R的24位原始数据解码为32位有符号整数，消除了符号位可能引起的误差。随后，将解码后的信号根据增益和参考电压转换为实际的电压值。这一过程中，左导联和右导联的连接状态也会被实时检测，以确保数据采集的可靠性。如果导联连接异常（如电极松动），系统会发出提示并暂停后续的采集。 4.3 处理算法移植：滤波器经过STM32接收心电信号后，系统根据PC端设计好的滤波器方案对原始信号进行双重滤波处理，先通过IIR滤波器消除直流分量，然后利用FIR滤波器进一步去除高频噪声，从而得到更为清晰的心电信号。经过IIR和FIR滤波后的信号显著改善，直流漂移、工频干扰以及高频噪声均被有效抑制，这一改进不仅提高了信号的可分析性，也为后续的特征提取与心率计算打下了坚实基础。 滤波后，处理得到的心电信号被传输至PC端，并通过可视化工具显示其改进的波形。如下图所示，信号的基线漂移已完全消除，高频噪声也显著减弱。滤波后的心电信号为后续的心率估算和其他心电特征分析提供了高质量的数据输入，从而提升了系统的整体性能和实用性。 4.3.1 IIR数字直流陷波器在IIR滤波阶段，STM32程序参考了PC端的滤波器设计，实现了高效的实时滤波。IIR滤波器的核心算法通过递归关系计算当前输出值，其中参数a=0.992控制直流分量的衰减程度。算法以较少的存储空间完成了对信号直流漂移的有效抑制，使用上一输入与上一输出值的递归关系更新当前输出值，从而达到实时滤波的目的。 4.3.2 FIR数字低通滤波器经过IIR滤波后，信号中的直流分量被有效去除，但仍可能含有工频干扰和其他高频噪声。因此，信号会进一步通过FIR滤波器进行处理。FIR滤波器利用一个固定长度的滑动队列实现，其滤波系数矩阵B由MATLAB中的filterDesigner工具生成并导出到C代码中。该滤波运算采用定点方式，在初始化时需要将滤波器系数乘以66536（如图4.5中右图所示），再取整保存为16bits整数。该部分的核心算法是，通过遍历队列数据与滤波器系数进行逐项乘积累加，实现对信号的精准滤波。代码设计充分考虑了队列操作的效率，通过队列循环的方式减少内存消耗并保证实时性。 4.4 处理算法移植：心率与幅值计算系统的心跳检测功能基于心电信号的峰谷变化，通过heartbeat_check函数实现对R波峰值的实时检测。该函数采用简单高效的阈值法，以波峰和波谷之间的差值判断是否发生心跳事件。函数的核心逻辑包括记录当前波形的上升和下降趋势，以及动态调整波峰（up_value）和波谷（down_value）的值。 具体来说，当检测到波形从下降趋势转为上升趋势，且波峰与波谷的差值超过设定的阈值（经过调试设置为0.55较为合适），即判定为一次心跳事件。此时，波峰和波谷会重新初始化，为下一次心跳检测做好准备。如果当前波形变化幅度未达到阈值，则认为是噪声或非心跳波形，函数返回0。 在实际应用中，该函数与DWT模块配合使用，每次心跳事件发生时记录时间戳，通过计算相邻两次事件的时间间隔（R-R间期）估算心率。高精度的DWT计数器和简洁的心跳检测算法相结合，使得系统能够在保证实时性的同时，准确识别心跳并计算心率。 为衡量心率信号的幅值范围，编写函数 Cal_PeakToPeak 以计算一组浮点数数据的峰峰值，即数据中的最大值与最小值之间的差值，用以反映数据的动态范围或振幅。函数通过接收一个浮点数数组 samples 和数组中的元素个数 sample_count 作为输入，首先将数组的第一个元素初始化为当前的最大值和最小值，然后从第二个元素开始逐一遍历整个数组。在遍历过程中，函数逐步更新最大值 max 和最小值 min，确保能够捕获数据中的真实极值。遍历完成后，函数通过计算 max - min 得到峰峰值，并将结果作为返回值。整个过程采用单次遍历的方法，计算效率较高，适合处理较大规模的采样数据。 4.5 TFT屏幕绘制采集波形TFT屏幕是系统的重要输出模块，负责实时显示处理后的心电波形和心率数据。通过高分辨率和快速刷新率，TFT屏幕能够清晰呈现心电信号的变化，供用户随时监控自己的心脏健康状况。它不仅显示心电波形，还提供当前的心率和可能的异常信号提示，帮助用户及时发现问题。 对于已经滤波后的心电信号，在移植并调用原有LCD驱动库的基础上，编写了drawCurve函数实现实时的波形显示。该函数根据输入的心电信号数值，将其映射到屏幕的像素坐标，并绘制出连续的曲线。 可以看到，对于滤波后的心电信号值，除了基本的指定区域绘制波形外，为避免波形超出屏幕边界，还对计算得到的y坐标进行上下限约束，使其始终位于屏幕的有效显示区域内：如果y坐标超过屏幕范围，则自动截断至边界位置；当x坐标超出屏幕宽度时，程序清空屏幕并从起始位置重新开始绘制新的波形。通过这种循环显示方式，确保波形在屏幕上以滚动形式连续更新，为实时心电信号的监测提供直观的显示效果。 4.6 频谱分析及其TFT屏幕绘制在频谱FFT计算的具体实现中，程序使用CMSIS-DSP库提供的高效FFT算法，首先将心电信号数据打包为复数输入，其中实部为滤波后的心电数据，虚部置为零。随后调用arm_cfft_radix4_f32函数完成快速傅里叶变换，并通过arm_cmplx_mag_f32函数计算复数频谱的幅值。计算结果存储在FFT输出缓冲区中，用于后续的频谱绘制。 对于频域波形，系统通过FFT算法计算心电信号的频率分量，并将其可视化为频谱图。频谱图的x轴代表频率，y轴代表频率分量的幅值，能够直观反映心电信号的频率特性。频域波形的可视化主要依赖Draw_Spectrum函数： 由于屏幕高度有限，为避免绘图时坐标溢出，函数将FFT输出的幅值限制在合理范围内（0到150，其余位置留给时域波形）。当幅值超过上限或低于下限时，进行截断处理。每个频率分量对应一条垂直线，从屏幕底部开始绘制到计算得到的y坐标。 5 程序测试方法5.1 ADS1292R驱动移植及引脚配置首先，在通过STM32CubeMX创建工程时，需要配置单片机的时钟速率，SPI接口，中断以及UART串口通信等。为实现与ADS1292R传感器的数据传输，选用SPI1并对引脚进行如下配置： 其中与ADS1292R传感器通信的SPI接口配置为主模式，时钟极性为CPOL=LOW，时钟相位为CPHA=2EDGE，数据帧格式为8位，通信速率依据传感器要求设置在8MHz以下，此处设置为656.25Kbit/s。 此外，还需要根据ADS1292R库文件中的说明，对UART通信进行设置，其中波特率设置为115200，8位数据位，1位停止位，无校验。 完成引脚配置后就可以进行初始代码生成。在生成的初始代码工程中，引入ADS1292R的相关库文件（ADS1292R.c与ADS1292R.h），根据对应的配置代码将STM32F407开发板与ADS1292R传感器模块进行连线： 连线完成后，要通过SPI接口实现与ADS1292R的数据交互，还需要在主程序中完成相应的初始化，即调用ADS1292R驱动库中的相关函数，由单片机向ADS1292R发送相应的命令以启动数据采集，并配置工作模式、采样速率、增益等参数。根据ADS1292R数据手册及项目要求，以下是对ADS1292R的主要配置过程： 首先，将ADS1292R的CONFIG2寄存器配置为0xA3，以启用内部参考电压。内部参考电压的稳定性对于后续心电信号的准确采集至关重要，因此在配置完成后需通过DWT_Delay_ms(10)添加延时，确保内部参考电压稳定。随后，将CONFIG1寄存器设置为0x02，配置心电采集的采样速率为500SPS（Samples Per Second），这一速率能够兼顾信号的时域分辨率和数据量。 接下来，对通道1和通道2进行配置。其中，通道1的CH1SET寄存器设置为0x00，表示通道1工作于正常采集模式，且未启用测试信号输入。通道2的CH2SET寄存器配置为0x05，用于指定通道2采集来自内部测试信号的方波，方便在调试阶段验证系统的采集和传输功能。 此外，为了进一步优化信号的质量，对右腿驱动（RLD）电极进行了配置，通过将RLD_SENS寄存器设置为0x2C，使右腿驱动电极同时连接到通道1和通道2，增强了共模信号的抑制能力。在呼吸阻抗测量相关功能中，将RESP1和RESP2寄存器分别配置为0x02和0x03，根据手册要求开启适当的工作模式。 通过上述配置，ADS1292R可以稳定运行于双通道心电采集模式，通道1用于实时采集患者的心电信号，通道2可用于采集ADS1292R传感器的测试信号以验证该传感器模块是否被正常驱动。 5.2 ADS1292R驱动移植验证：读取传感器设备ID事实上，在ADS1292_PowerOnInit函数中，图5.5所示初始化代码之前还有一段代码： 可以看到，要实现5.1节中对于ADS1292R传感器模块的正确驱动，就必须要顺利运行该段代码，其中调用了ADS1292_ReadDeviceID这一函数并设置了判断条件，若读取到的设备ID不为83（ADS1292）或115（ADS1292R）则会一直循环读取ID而不进行后续的初始化，以确保读取的心电信号不会出现无效数据且采集数据符合预期格式。由于本次项目使用的传感器芯片为ADS1292R，故成功读取到并在串口助手中打印的device_id为115，这也证明驱动库文件的移植是正确的且能正常驱动该传感器模块。 5.3 ADS1292R驱动移植验证：测试信号采集及其TFT屏幕绘制在ADS1292R的芯片数据手册中，给出了其内置测试信号的相关参数： 可以看到，当PGA增益倍数设置为1时，芯片将输出测试方波信号，通过MATLAB读取并解码原始数据，得到（含直流）范围在-20到8；而去除直流后，该方波动态范围为-14到14。由于参考电压为2.4V（16bits），此时14/32768*2400mv约等于1mv，说明此时方波动态范围转换为电压是正负1mv，和数据手册说明一致。方波测试信号的成功读取也进一步验证了ADS1292R驱动库移植的正确性且能正常驱动该传感器模块。 图5.8：MATLAB读取测试方波结果 6 实验数据记录与分析演示视频链接：https://www.bilibili.com/video/BV1HWCkYzETe/ 6.1 测试信号采集在测试ADS1292的内部方波信号时，设置PGA增益为1，测试结果显示方波波形良好，基本无误差。系统能够准确读取方波信号的峰峰值和幅度值，其效果如图所示： 此外，系统新增了按键功能，按压KEY_0即可实现在显示测试信号波形与显示心电信号波形间切换。 6.2 模拟器心电信号采集在实际运行中，drawCurve函数结合系统滤波模块的输出数据和心跳检测结果，将心电信号时域与频域的动态变化以实时曲线的形式绘制在屏幕上。同时，在屏幕上显示心率、波幅等关键参数，进一步增强了系统的直观性和信息量。其效果如下图所示： 经过测试，测算出的心率值与心电模拟仪中给出的心率值误差不超过3 BPM（每分钟心跳数），满足系统设计需求；但此时滤波器的滤波效果有点过度，也可能是显示的波形幅度调整的不好，导致最终显示的波形丢失了过多的有用信息。 6.3 模拟器心率信号采集将模拟器调至2档（心率档），产生的心率信号默认为75BPM，此时时域与频域波形的显示效果如下： 可以看到，此时测得的心率基本准确，与心电模拟仪中给出的心率值误差不超过3 BPM，满足系统设计需求，且频谱图也有较明显的尖峰且噪声较少；此时滤波器的滤波效果虽然也有点过度了，但效果明显由于6.2节中对于心电信号的测量，有明显的波峰。 心跳检测功能的设计不仅能够适应动态变化的心电信号，还通过灵活的阈值调整提高了对不同信号幅度的适应性。将模拟器调至8档，以调整产生心率信号的幅值（心率BPM仍为75），采集与显示效果如下： 可以看到，随着心率信号幅值的成倍变化，测量出的波形幅值也在成倍变化，且频谱较为干净，这说明该心电信号采集系统对于不同的信号幅度具有较高的灵敏性，但未对测量的幅值数值进行对应电压的换算导致结果并不直观；同时由于测量心率程序中对于检测跳变幅度的阈值设置较小，导致此时当幅值明显增大时，震荡信号的跳变幅度也随之增加，导致心率测量出现一定程度的偏差。 6.4 人体心电信号采集与测量未接入人体心电信号时，采集到信号的时域波形与频谱如下： 对于人体心电信号检测，由于心电电极对接触状态的敏感性，最佳效果仅在涂抹酒精并佩戴三分钟内获得，因此系统仅能在心电电极贴附于人体的短时间内实现精确检测 在实际测试时，邀请室友将电极片分别贴于手腕和脚部，并分别与数据线连接，此时系统采集到的心电波形如下所示（详细测试过程在演示视频中）： 从图中可以看出，检测人体心电信号时，波形与心电信号模拟仪的输出相比仅存在轻微差别，整体表现良好，但仍然存在滤波过度的问题。 除了将电极贴于手腕和脚部进行测试外，系统还测试了将电极贴在左右锁骨中线第一肋间和胸骨左缘第四肋间的位置。测试结果显示，这些位置的信号稳定性优于手脚部位，并且能够维持更长时间的良好效果。 7 实验结果总结和心得体会7.1 实验结果在本项目中，基于 STM32F407ZG 主控芯片和 ADS1292R 传感器模块，成功实现了人体心电信号的采集与分析功能。针对心电信号易受工频干扰和低频基线漂移影响的问题，设计并实现了 IIR 数字直流陷波器 和 FIR 数字低通滤波器，有效消除了干扰并获得了较为清晰的心电波形。 在开发过程中，利用心电信号模拟仪对单片机程序进行了调试，使系统能够稳定采集和显示心电波形。尽管滤波器在MATLAB仿真中效果良好，但移植到单片机工程中后，出现了滤波过度的问题。初步分析认为，这可能与信号采样频率、显示波形的幅度比例调节以及滤波算法的具体实现有关，仍需进一步优化。然而，系统总体性能令人满意，其采集效果、频域分析结果、心电峰峰值及心率测算结果均较为准确。 此外，系统还实现了对 ADS1292R模块自带测试方波信号的读取、显示以及峰峰值测量功能，基本满足了所有的设计需求。最终也成功采集并显示了实际人体心电信号的时域波形与频谱。 7.2 心得体会通过本次项目的实践，我对数字信号的采集与处理以及滤波器的设计与实现有了更加深刻的理解。这不仅加深了我对数字信号处理理论知识的掌握，还让我在理论与实践的结合中得以进一步巩固相关技能。在单片机的编程实践与调试过程中，我对STM32尤其是F4系列开发板的硬件和软件开发有了更深入的认识，这大大提升了我的开发效率和调试能力。 本项目也是我首次尝试使用 FreeRTOS操作系统搭建整个工程框架。在此过程中，我学习并掌握了实时操作系统的基本原理和任务调度机制，初步理解了如何优化系统资源管理，成功地将操作系统的使用融入到嵌入式项目开发中。这一尝试不仅丰富了我的开发经验，也让我更好地认识到实时操作系统在复杂工程中的价值。 尽管最终心电信号的显示结果并未完全达到预期，但我从问题中发现了自身在信号采集频率、滤波算法实现以及系统显示优化方面的不足，并明确了未来改进的方向。整个项目开发的过程充满了挑战，同时也伴随着大量的收获。我深刻体会到硬件开发与数字信号处理是一个不断探索和优化的过程，而这次项目实践无疑为我在这些领域的技能提升打下了坚实基础。 此外，本次项目还培养了我独立分析和解决问题的能力。从模块功能的实现到整体工程的构建，我逐步熟悉了完整的开发流程，对系统的设计、调试和优化有了更加系统化的认识。我相信，这些经验和能力将在今后的学习和工作中发挥重要作用，为更高层次的开发任务奠定基础。 参考资料[1] 朱冰莲,方敏编著.数字信号处理[M].电子工业出版社,2014:276. [2] 程佩青编著.数字信号处理教程[M].清华大学出版社,2015:524. [3] 任勇,曾浩编著.单片机原理及应用[M].清华大学出版社,2023. [4] 德州仪器. ADS1292 数据手册 [5] 任勇. CQU_S12XDEV开发板原理图 微电子与通信工程学院 [6] 任勇. ADS1292-心电信号采集原理图及接口说明-RY","link":"/2024/12/31/ecg/"},{"title":"基于直流电源调控的自动调光控制设计","text":"摘要本项目围绕直流电源调控的自动调光控制系统展开研究与设计，系统性地探讨了Buck变换器的基本原理、建模方法、性能分析及其实验验证过程。在硬件设计方面，基于STM32处理器，选择了高性能的元器件并通过合理的电路拓扑实现高效的能量转换；在软件控制算法方面，采用PID闭环控制，并结合自动控制原理中的经典控制理论，利用PSIM与MWorks等仿真与科学计算工具，对控制系统的时域响应、频域特性和稳定性进行了详尽分析，进而通过参数优化与校正环节设计显著提升了系统的响应速度和稳态性能，同时也验证了闭环控制系统在动态性能、抗干扰能力和输出精度方面的显著优势。此外，通过实验测量与仿真结果对比，探讨了电路寄生参数对系统性能的影响，为后续优化提供了理论依据。在基于光敏电阻的自动调光功能模块中，结合蓝牙通信接口实现了系统的智能化控制，同时对于自动调光系统进行外观设计，赋予产品更多的人文关怀与实用价值；在光伏板最大功率点跟踪（MPPT）功能模块中，根据MPPT的原理与基本思想设计了相应的控制算法，并在实验中成功控制光伏板输出功率，使其约等于负载消耗功率，完成了不同光照强度下最大功率点的跟踪。最后，对于该自动控制系统的设计成果及其在实际应用中的可行性与局限性进行总结，并对未来可能的优化方向和工程实现前景提出了展望。 关键词：Buck变换器；PID闭环控制；自动调光；光伏MPPT 1 课程涉及理论基础和STM32简介1.1 自动控制原理简介在科学技术飞速发展的今天，自动控制技术和理论已经成为现代社会不可缺少的组成部分。自动控制技术的应用不仅使生产过程实现自动化，从而提高了劳动生产率和产品质量，降低了生产成本，提高了经济效益，改善了劳动条件，使人们从繁重的体力劳动和单调重复的脑力劳动中解放出来；而且在人类征服大自然、探索新能源、发展空间技术和创造人类社会文明等方面都具有十分重要的意义。 自动控制理论是研究关于自动控制系统组成、分析和综合的一般性理论，是研究自动控制共同规律的技术科学。自动控制是在人不直接参与的情况下，利用外加的自动控制设备或装置（控制装置或控制器），使机器、设备或生产过程（统称为被控对象）的某个工作状态或参数（被控量）自动地按照预定的规律运行，使机器的动作、设备的运转、生产过程的状态能够自动地在一定的精度范围内按照给定的规律变化。学习和研究自动控制理论是为了探索自动控制系统中变量的运动规律和改变这种运动规律的可能性和途径，为建立高性能的自动控制系统提供必要的理论依据。 1.2 本项目所涉及的经典控制理论内容 本项目从经典控制理论的基本原理与概念出发，以Buck变换器这一单输入-单输出的线性系统作为研究对象，利用微分方程、Laplace变换与传递函数等数学工具建立系统的数学模型，并基于时域分析、频域分析以及根轨迹法等多种分析方法对于系统的稳定性与响应特性进行详细分析，从而针对特定的性能指标进行对应的校正设计，通过引入PID控制器并调控其参数以改变系统的频率特性从而满足给定的各项性能指标，使得整个闭环控制系统能够兼具稳定性、快速性与准确性。 1.3 STM32处理器介绍控制核心是控制系统中的重要组成部分，用于计算、解析各种数据，并执行相应的控制算法。芯片选型的设计直接决定了控制板的性能和功能。STM32是由意法半导体公司（ST）推出的基于Arm Cortex-M处理器内核的32位微控制器，专为要求高性能、低成本、低功耗的嵌入式应用设计，集实时功能、数字信号处理、低功耗/低电压操作、连接性等特性于一身，同时还保持了集成度高和易于开发的特点，基于行业标准内核，提供了大量工具和软件选项以支持工程开发，非常适用于小型项目或端到端平台。 本项目选用的处理器STM32F103C8T6作为中等容量高性能系列MCU，集成了工作频率为72MHz的高性能Arm Cortex-M3 32位RISC内核、高速嵌入式存储器（高达128KB的Flash存储器和20KB的SRAM存储器），以及大量连接至2条APB总线的增强型I/O与外设，具有36引脚至100引脚等6种不同的封装类型。所有器件均提供2个12位ADC、3个16位通用定时器、2个PWM定时器以及标准和高级通信接口：多达2个I2C和SPI、3个USART、1个USB和1个CAN。器件的工作电压为2.0V至3.6V。该处理器的工作温度范围为-40℃到+85℃，可扩展至-40℃到+105摄氏度。这些特性使得该处理器成为各种应用的理想之选，也能很好满足本项目对于控制器的性能需求。 1.4 本章小结本章主要介绍了本课程相关的自动控制理论基础，针对本项目涉及到的经典控制理论框架进行了简要概述，同时对于本项目所选用的控制核心——STM32处理器进行简单介绍，重点分析了我们采用的STM32F103C8T6处理器的性能特性并给出选型原因。这为本课程项目提供了整体框架，并从理论上对后续项目的具体实施给出了方向性的指引。 2 直流Buck变换器设计与调试2.1 Buck变换器拓扑原理分析Buck（降压式）变换器是一种输出电压≤输入电压的非隔离直流DC-DC变换器，其中输入电流为脉冲式的，而输出电流为连续的低纹波直流电压。Buck变换器实现的稳态输入输出关系为：$$U_{0} = DU_{in}$$Buck变换器的主电路由开关管Q，二极管D，输出滤波电感L和输出滤波电容C构成。 可以看到，在能量缓冲变换电路中，主要由如下三个部分组成： 电感L与电容C实质上构成了一个二阶低通滤波器，通过滤除开关频率交流分量而仅保留其直流分量，得到平直的输出电压U0； 脉冲宽度调制（Pulse Width Modulation，PWM）产生方波电压控制开关管Q的导通； 二极管D为电感电流提供续流回路。 Buck变换器主电路整体的工作逻辑如下： 当开关管Q驱动为高电平时，开关管导通，储能电感L被充磁，流经电感的电流线性增加，同时给电容C充电，给负载R提供能量； 当开关管Q驱动为低电平时，开关管关断，储能电感L通过续流二极管D放电，电感电流线性减少，输出电压靠输出滤波电容C放电以及减小的电感电流维持。 事实上，对于该电能变换器，可以通过更改个别元器件的种类、接入方式与顺序，实现搭建具有不同功能的电能变换电路，即Buck变换器的拓扑原理。下面列举几种常见的拓扑电路： 升压变换器： 降压同步整流变换：采用互补工作模式，可减小损耗 H桥DC-AC逆变器：开关管部分串联构成双极性交流电压源 闭环PWM控制：可以在原有Buck电路基础上增加闭环环路，通过PWM调配开关管Q的导通与否，从而实现对于输出电压的控制，使系统能够更加”稳”、”快”、”准”地得到期望的输出。目前的控制器选择主流为PID控制器，根据不同的指标又可将闭环控制系统分为不同类别：若根据控制对象分类，则可分为电压控制与电流控制；若根据接收调控信息的时间先后分类，又可分为反馈控制与前馈控制；根据其他的分类标准，还可分为线性/非线性控制、平均/纹波控制、模拟/数字控制……在此不一一列举。 2.2 Buck变换器元器件参数选择在Buck变换主电路中，对电路参数进行如下设定： 输入电压$$U_{in} = 15V$$ 输出电压$$U_{o} = 8V$$ 占空比$$d = 50%$$ 电源转换电压：12V、15V、5V、5V（隔离） 电感$$L = 100\\mu F$$ 电容$$C = 660\\mu F$$ 工作频率$$f = 25kHz$$ 首先，为满足电源转换与单片机供电的需求，需要在电源直接引入Buck电路前先接入电源模块，涉及到的元器件及相关参数如下： URB2412YMD-10WR3电源模块：降压模块，将电源提供的输入电压（最大35V，本实验中为15V）转换为12V输出，提供0.83A的电流； CW7805线性稳压器：将12V输入电压转换为稳定的5V输出电压，并将输出电流转换成1A，分输入、输出与接地三端，主要用于使线性的输出电压稳定； A1215S-2WR3电源模块：升压模块，将12V输入转换为±15V，适合供给双电源运放电路，本实验中主要用于为采样电路（滤波器）供电； IB1205S-2W电源模块：降压模块，将12V输入转换为5V，通常用于低功耗电路的供电，本实验中主要用于光耦（与驱动）电路的供电。 其次，在Buck变换主电路中，为满足设定元件参数，选取如下元器件： 贴片MOS管NCE0130KA：VDS=100V，VGS=10V 贴片电感：色环直插型，100uH 贴片铝电解电容：330uF，±20%，耐压50V，两个并联达到设定660uF 电流传感器CC6920SO-5A：初级电流测量范围-5A~5A，供电电压5V 电压传感器LV25-NP：初级电流测量范围10-500V，供电电压±15V 其中，电容与电感均采用贴片形式的原因主要有以下几点： 【1】 体积小且便于贴装，适合电路的高集成度需求； 【2】 贴片元件引线较短，寄生电感和电容较小，可提高电路的高频性能； 【3】 贴片元件的散热性能通常较好，有助于提高电路的可靠性； 【4】 贴片元件可以有效减小电磁干扰，提高电路的稳定性。 除此之外，由于本实验采用的主控STM32输出能力有限，无法直接驱动管子开关，因此还需要采用光耦和驱动电路为管子提供驱动信号，涉及到的元器件及相关参数如下： IR21844S驱动：栅极驱动供电范围10-20V 光耦-逻辑输出6N135：5V供电，光耦隔离 运算放大器AD823ARZ：最大输入偏置电流25pA，低失真−108dBc 2.3 Buck变换器实物设计与调试在Buck变换主电路设计时，选择不对Buck变换器的电路部分进行拓扑，而在闭环PWM控制电路中采用平均电压模式进行控制。本项目采用的实验电路板主要包括Buck电路基本器件、开关管驱动、辅助电源以及采样电路（信号调理电路），实验时将元器件焊接至电路板上并分别调试各模块功能。 2.3.1 主电路设计与调试 该电路是一个典型的降压型 DC-DC 转换器，其工作原理是通过开关管 Q3 的高速开关动作，将输入电压V_IN转换为期望的输出电压V_OUT。当开关管Q3导通时，输入电压通过 L2、L3和负载形成电流回路，电感存储能量，同时为负载供电；当 Q3关断时，续流二极管 D4 提供电流通路，电感释放能量维持负载电流的连续性。控制器 U6根据反馈电压（通过分压电阻 R8 反馈的V_OUT）与参考电压之间的误差，实时调节 Q3的导通时间（占空比），从而实现输出电压的稳定调节。两级电感 L2 和 L3以及滤波电容 C9、C15进一步平滑输出电流和电压，减少高频纹波，确保输出电压的稳定性和低噪声特性。 经过调试，Buck降压模块主电路可正常实现功能，在参考输入方波幅值为8V、占空比为50%的情况下能够输出占空比为50%、幅值在8V左右（实际约为8.5V）的方波。 2.3.2 控制电路供电设计与调试 如图所示为STM32主控芯片供电电路（电源模块）以及单片机内部所使用的接口引脚图，同时将大部分未使用的引脚通过排针引出以供后续拓展功能开发。 在STM32主控芯片供电电路中，包含两个级联的线性稳压器，用于将高电压逐级稳压到所需的5V 和 3.3V。上半部分采用 CJ7805稳压器，将输入电压V_IN转换为稳定的5V输出，通过输入电容C2和C1滤波降低输入纹波，稳压器通过内部反馈电路调节输入电压，使输出稳定在5V，同时通过输出电容C3滤除高频噪声，进一步平滑输出电压。下半部分采用AMS1117-3.3 稳压器，将上一级提供的 5V 电压进一步稳压为3.3V，通过输入滤波电容 C5和 C6减少输入噪声，并通过输出滤波电容C4提高输出电压的稳定性。整个电路通过分级稳压设计，既提高了稳压效率，又能为负载提供低噪声、高稳定性的5V和3.3V电压，适用于嵌入式系统和低功耗数字电路的电源需求。 调试流程：取下单片机核心板—&gt;接入负载100欧姆—&gt;单片机输出PWM—&gt;观测PA8端口波形—&gt;观测驱动芯片输出端口波形—&gt;上主电24V—&gt;检测辅助电源输出电压—&gt;检测输出电压—&gt;根据占空比计算输出电压是否正常—&gt;完成 经调试，该部分模块可正常工作，为STM32主控芯片提供稳定的5V电压： 2.3.3 驱动电路设计与调试 如图所示，驱动电路为已有的STM32输出提供了合适的电压和电流驱动功率器件，而如果直接使用STM32输出驱动，可能会超出其输出能力或不能实现良好的电气隔离，导致驱动失败或损坏器件，输出信号不稳定。使用光耦和驱动电路则可以更好地实现电气隔离，从而防止高压或大电流对控制电路的干扰或损坏，保护STM32免受高电压或大电流的影响，提高系统工作可靠性。 调试时，先切断仿真器供电，将单片机供电切换为主电路辅助电源供电；单片机烧录输出电压控制程序后，接入后端负载，再上主电，观测输出电压。经调试，驱动电路可正常工作。 2.3.4 电压和电流采样调理滤波设计与调试 该电路是一个基于运算放大器的电压比较和分压检测电路，主要功能是将输入电压V_OUT通过电阻分压后与基准电压比较，并输出相应的信号V_S。该电路可用于电压监测或过压保护等场景，通过调整R1 和 R2 的比例，可以设置分压电压，从而灵活设定输入电压的触发阈值。 具体工作原理如下：输入电压$V_{OUT}$经由电阻R1和R2分压后，产生一个分压电压，该电压送入运算放大器U5的反相输入端（引脚2）。运算放大器的非反相输入端（引脚 3）通过稳压二极管 D2提供一个固定的基准电压（3.3V）。当分压后的电压低于基准电压时，运算放大器输出高电平；当分压电压高于基准电压时，运算放大器输出低电平。电容C7和C16用于滤除输入和输出的高频噪声，保证比较过程的稳定性。 调试时，使用仿真器给单片机供电，以调试PWM波形输出是否正常；烧录开环测试程序之后，使用示波器或者上位机观测电路板PA8端口是否正常输出PWM波形。经调试，可对输入信号正确采样并输出对应波形，说明采样模块正常工作： 2.4 本章小结本章主要介绍了直流Buck变换器的基本工作原理及其拓扑变换，并根据选定的主控芯片STM32F103C8T6以及设定的电路参数进行了基本元器件的选型与电路原理图及PCB电路板的设计，确定电路主要包括Buck降压变换主电路、控制电路供电辅助电源模块、驱动电路以及采样电路（信号调理电路）四个模块；在焊接时对各个模块依次进行焊接与调试，保证各模块均可以正常工作，以便于后续闭环控制实现时STM32主控控制模块与代码的设计与测试。 3 直流Buck变换器建模3.1 Buck变换器闭环控制原理分析Buck变换器闭环控制系统主要由以下几个部分组成： 误差放大器：将参考电压V_ref与实际输出电压V_OUT比较，生成误差信号； 补偿网络：对误差信号进行处理（例如，PI或PID控制），以提高系统稳定性和动态性能； PWM调制器：将补偿后的控制信号转换为开关元件的占空比D; 采样电路：对输出电压 V_OUT进行实时采样。 整个闭环控制系统的工作过程如下： 输出电压采样：通过分压电路对输出电压V_OUT进行采样，得到反馈电压V_fb; 误差检测：误差放大器将参考电压V_ref与反馈电压V_fb比较，产生误差信号$$e(t) = V_{ref} - V_{fb}$$ 误差调节：误差信号经过补偿网络调节，生成调节信号V_ctrl，此信号决定PWM占空比； PWM调制：调制器根据调节信号V_ctrl生成控制信号D，驱动开关元件； 电感电流调节：开关元件的导通时间决定电感电流的充电时间，从而控制输出电压。 从系统传递函数的角度考虑，根据系统框图与元件特性，可计算其开环传递函数与特征方程： （1）G_c(s)为PI环节， PI调节器为：$$\\left{ \\begin{aligned} &amp; \\dot{x} = K_{I}v \\ &amp; y = K_{p}v + x\\end{aligned} \\right.$$可得PI环节传递函数G_c(s)： $$G_{c}(s) = K_{p} + K_{I}\\frac{1}{s} = \\frac{K_{p}(\\tau s + 1)}{\\tau s}，\\tau = \\frac{K_{p}}{K_{I}}$$（2）PWM脉宽调制环节：由大信号关系$$v_{con}(dT) = v_{ramp}(dT) = V_{M}\\frac{dT}{T} = dV_{M}$$做微分可得小信号的线性关系$$\\mathrm{\\Delta}v_{con} = \\mathrm{\\Delta}dV_{M}$$从而实现传递函数的线性化： $$G_{pwm} = \\frac{\\mathrm{\\Delta}d}{\\mathrm{\\Delta}v_{con}} = 1/V_{M}$$（3）PWM脉宽控制开关电路：由大信号关系$$v_{D} = dv_{g}$$做全微分可得小信号线性关系$$\\mathrm{\\Delta}v_{D} = \\mathrm{\\Delta}dV_{g} + \\mathrm{\\Delta}v_{g}D$$零初始条件下，对应的工作点为$$V_{g} = V_{in}，\\mathrm{\\Delta}v_{g} = 0$$于是有传递函数：$$G_{vg} = \\frac{\\mathrm{\\Delta}v_{D}}{\\mathrm{\\Delta}d} = V_{g}$$（4）RLC并联二阶输出滤波器：由电路图与元件特性可得各元件间电流电压关系： $$\\left{ \\begin{array}{r}u_{0} = Ri_{2} \\u_{L} = L\\frac{di}{dt} \\i_{1} = C\\frac{du_{0}}{dt} \\i = i_{1} + i_{2} \\u_{D} = u_{L} + u_{0}\\end{array} \\right.$$从而可得该滤波器对应的微分方程：$$u_{D} = LC{u_{0}}^{‘’} + \\frac{L}{R}{u_{0}}^{‘} + u_{0}$$对两边同时进行拉普拉斯变换，化简整理后可得二阶滤波器的传递函数G_vd(s)： $$G_{vd}(s) = \\frac{U_{0}(s)}{U_{D}(s)}V_{in} = \\frac{\\frac{1}{LC}}{s^{2} + \\frac{1}{RC}s + \\frac{1}{LC}}V_{in}$$又因输出信号v_0直接接入PI控制器，故$$H(s) = 1$$综上所述：有开环传递函数： $$T(s) = G_{c}(s)G_{pwm}G_{\\text{vd}}H(s) = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{\\frac{1}{LC}}{s^{2} + \\frac{1}{RC}s + \\frac{1}{LC}}V_{in} = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{V_{in}}{LCs^{2} + \\frac{L}{R}s + 1}$$进而可以得到系统的特征方程$$T(s) + 1 = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{V_{g}}{LCs^{2} + \\frac{L}{R}s + 1} + 1 = 0$$化简后可得：$$\\Delta(s) = V_{g}K_{p}(\\tau s + 1) + \\tau sV_{M}\\left( LCs^{2} + \\frac{L}{R}s + 1 \\right) = \\tau V_{M}LCs^{3} + \\tau V_{M}\\frac{L}{R}s^{2} + (V_{g}K_{p} + V_{M})\\tau s + V_{g}K_{p} = 0$$ 3.2 Buck变换器PSIM仿真（开环+闭环）利用PSIM软件进行电路仿真，根据实际电路结构搭建仿真电路图，并将电路各元件实际参数代入（PI控制器参数：K_p = 0.1，tao = 0.004）： 运行仿真程序，可得到输出电压的仿真结果： 对比开环与闭环控制系统的输出电压仿真结果可以发现，尽管两个系统都能在短时间内达到稳定的输出电压，但显然闭环控制系统到达稳态的速度更快且震荡更小，稳定后的电压也更接近参考电压8V（约为7.95V）。这说明闭环控制系统具有更快的响应速度与更好的稳定性和准确性。 3.3 输出电压纹波计算（仿真+实验） 首先进行Buck变换器的开环控制实验，并通过示波器观察其输出电压的纹波波形。可以看到，输出波形峰值$$V_{omax} = 88mV$$谷值$$V_{omin} = - 76mV$$则波形的震荡幅度为$$\\Delta V_{o} = V_{omax} - V_{omin} = 164mV$$随后利用PSIM软件进行电路仿真，根据实际电路结构搭建仿真电路图，并将电路各元件实际参数代入： 可得到输出电压纹波的仿真结果： 可以看到，输出电压信号的震荡波形与实际电路示波器显示的纹波形状一致且震荡幅度大致相同。 3.4 电容寄生电阻计算（仿真+实验）在Buck变换器开环控制实验中，通过万用表测量得到输入电压V_i= 15.304V，输出电压均值V_o = 7.537V： 除了给定的元件参数之外，为对直流Buck变换器进行精确建模，考虑到电容的寄生参数可能对系统有较大影响，故特别计算其寄生电阻阻值ESR： 结合$$U_{esr} = \\Delta I_{L}*ESR$$一式，考虑到电流因流过电容的寄生电阻而产生的压降U_esr应不大于（实际一般处理为等于）波形的震荡幅度，即：$$U_{esr} \\leq \\Delta V_{o}$$可以得到在同步Buck电路中（V_d = 0）电容寄生电阻阻值ESR的计算公式： $$ESR \\leq \\frac{\\Delta V_{o}fLV_{i}}{V_{o}\\left( V_{i} - V_{o} \\right)}$$结合Buck变换器开环控制实验结果，代入参数$$\\Delta V_{o} = 164mV，L = 100\\mu F，f = 25kHz，V_{i} = 15.304V，V_{o} = 7.537V$$可以计算得出该电路中实际的电容寄生电阻阻值$$ESR \\approx 107.185m\\Omega$$这里计算的是接入单个电容的寄生电阻阻值，在实际电路中使用了两个330μF的电容等效替代原设计电路中的660μF电容，为使仿真尽可能接近实际，采取了与实际电路相同的结构，因此需要把寄生电阻同样进行等效，根据电阻并联的等效电阻计算可以得到两个330μF电容的寄生电阻值均为$$2ESR \\approx 214.371m\\Omega$$利用PSIM软件进行电路仿真，根据实际电路结构搭建仿真电路图，并将计算出的寄生电阻结果代入仿真电路中： 得到的输出电压仿真结果如下图所示： 可以看到，仿真结果中输出电压的均值约为7.65V，与实际的测量结果$$V_{o} = 7.537V$$较为接近；同时输出电压信号的震荡波形也与实际电路示波器显示的纹波形状一致且震荡幅度大致相同。这也印证了寄生电阻的计算以及电路建模与仿真的正确性。 3.5 本章小结本章主要介绍了直流Buck控制器及其闭环控制系统的建模过程，通过分析Buck电路中的元件特性及闭环控制的各个环节，实现控制系统的数学建模，得到系统的开环传递函数与特征方程；同时结合Buck控制器开环控制实验的实际测量结果，关注到电容寄生电阻对于系统输出的重要影响，并通过输出电压纹波的相关特性对其进行计算，搭建PSIM电路仿真模型观察修正前后的仿真结果，发现引入寄生电阻后的仿真结果与实际实验波形输出基本一致从而说明考虑寄生电阻的必要性。除此之外，还分别搭建了Buck变换器的开环与闭环控制系统PSIM仿真电路并对比输出电压仿真结果，可以发现闭环控制系统具有更好的动态响应性能，其稳定性、快速性与准确性均优于开环控制系统。 4 直流Buck变换器控制性能分析4.1 直流Buck变换器劳斯稳定判据分析基于3.1节得到的开环传递函数与系统特征方程，可利用劳斯判据给出系统稳定的PI控制器比例系数K_p临界条件： 根据系统特征方程可给出如下劳斯表： 根据劳斯判据，要使得系统稳定，需同时满足如下条件： $$\\left{ \\begin{array}{r}\\ \\tau V_{M}LC &gt; 0 \\\\tau V_{M}\\frac{L}{R} &gt; 0 \\\\left( V_{in}K_{p} + V_{M} \\right)\\tau - V_{in}K_{p}RC &gt; 0 \\{\\ \\ V}{in}K{p} &gt; 0\\end{array} \\right.\\$$这是关于PI控制器比例系数K_p的不等式组，可解得其边界条件为： $$0 &lt; K_{p} &lt; \\frac{V_{M}\\tau}{V_{in}(RC - \\tau)}$$若选定控制环路的时间常数$$\\tau = 0.004$$$三角载波幅值$$V_{M} = 0.5V$$则可代入数值解得：比例系数K_p的稳定边界为$$\\frac{V_{M}\\tau}{V_{in}(RC - \\tau)} \\approx 0.0513$$而在实际情况下，需要考虑电容的寄生电阻$$ESR \\approx 107.185m\\Omega$$这意味着需要对3.1节建立的数学模型进行修正。显然电路结构中除二阶滤波器外的其他环节没有发生改变，针对考虑电容寄生电阻ESR的RLC并联二阶输出滤波器，由电路图与元件特性可得各元件间电流电压关系： $$\\left{ \\begin{array}{r}u_{0} = Ri_{2} \\u_{L} = L\\frac{di}{dt} \\i_{1} = C\\frac{du_{C}}{dt} \\i = i_{1} + i_{2} \\u_{0} = u_{C} + ESRi_{1} \\u_{D} = u_{L} + u_{0}\\end{array} \\right.\\$$从而可得该滤波器对应的微分方程，对两边同时进行拉普拉斯变换，化简整理后可得二阶滤波器的传递函数G_vd(s)： $$G_{vd}(s) = \\frac{U_{0}(s)}{U_{D}(s)}V_{in} = \\frac{\\frac{1}{LC} + \\frac{ESR}{L}s}{(1 + \\frac{ESR}{R})s^{2} + (\\frac{1}{RC} + \\frac{ESR}{L})s + \\frac{1}{LC}}V_{in}$$其他环节保持不变，于是有开环传递函数：$$T(s) = G_{c}(s)G_{pwm}G_{\\text{vd}}H(s) = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{\\frac{1}{LC} + \\frac{ESR}{L}s}{\\left( 1 + \\frac{ESR}{R} \\right)s^{2} + \\left( \\frac{1}{RC} + \\frac{ESR}{L} \\right)s + \\frac{1}{LC}}V_{in} \\approx \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{1 + C \\bullet ESRs}{LCs^{2} + \\frac{L}{R}s + 1}V_{in}$$因此近似后系统的特征方程$$T(s) + 1 = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{(1 + C \\bullet ESRs)V_{in}}{LCs^{2} + \\frac{L}{R}s + 1} + 1 = 0$$化简后可得： $$\\Delta(s) = {(1 + C \\bullet ESRs)V}{in}K{p}(\\tau s + 1) + \\tau sV_{M}\\left( LCs^{2} + \\frac{L}{R}s + 1 \\right) = V_{M}LC\\tau s^{3} + (V_{M}\\frac{L}{R} + C \\bullet ESR \\bullet V_{in}K_{p})\\tau s^{2} + (V_{in}K_{p}\\tau + V_{M}\\tau + C \\bullet ESR \\bullet V_{in}K_{p})s + V_{in}K_{p} = 0$$接下来利用劳斯判据给出系统稳定的PI控制器比例系数K_p临界条件： 根据系统特征方程可给出如下劳斯表： 根据劳斯判据，要使得系统稳定，需同时满足如下条件： $$\\left{ \\begin{array}{r}\\ \\tau V_{M}LC &gt; 0 \\\\tau V_{M}\\frac{L}{R} &gt; 0 \\V_{in}K_{p}\\tau + V_{M}\\tau + C \\bullet ESR \\bullet V_{in}K_{p} - \\frac{V_{M}LCV_{in}K_{p}}{V_{M}\\frac{L}{R} + C \\bullet ESR \\bullet V_{in}K_{p}} &gt; 0 \\{\\ \\ V}{in}K{p} &gt; 0\\end{array} \\right.\\$$这是关于PI控制器比例系数K_p的不等式组，其中第1、2、4个不等式均指向K_p &gt; 0，而第三个不等式是一个关于K_p的一元二次不等式，代入电路元件参数可解得$$K_{p} &lt; - 0.0232或K_{p} &gt; - 0.0067$$因此可得到K_p的稳定边界为：$$K_{p} &gt; 0$$即该情况下系统始终稳定。 4.2 直流Buck变换器系统根轨迹分析（手绘+MWorks绘制）基于3.1节得到的开环传递函数，代入数值可得： $$T(s) = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{V_{in}}{LCs^{2} + \\frac{L}{R}s + 1} = \\frac{30K_{p}(s + 250)}{s(6.6*10^{- 8}s^{2} + 10^{- 5}s + 1)}$$根据该开环传递函数可知，该系统： 具有1个零点：$$z_{1} = 250$$具有3个极点：$$p_{0} = 0，p_{1} + p_{2} = \\frac{5}{33}*10^{3} \\approx 151.5，p_{1} = \\frac{5}{66}*10^{3} + a_i，p_{1} + p_{2} = \\frac{5}{66}*10^{3} - a_i$$故有3条根轨迹，1条止于开环零点，2条止于无穷远； 根轨迹的渐近线与实轴的夹角$$\\varphi_{a} = \\pm \\frac{2k + 1}{2}\\pi(k = 0,1,2\\ldots) = \\pm 90{^\\circ}、180{^\\circ}$$渐近线与实轴交点的坐标值$$ \\delta_{a} = \\frac{\\sum_{}^{}\\left( - p_{i} \\right) - \\sum_{}^{}\\left( - z_{i} \\right)}{2} = \\frac{- \\frac{5}{33}*10^{3} + 250}{2} \\approx 49.24$$ 基于以上结果，可手绘根轨迹草图如下： 编写如下MWorks代码： 1234using TyControlSystemss=tf('s');G=(s+250)/(s*(6.6*10^(-8)*s*s+10^(-5)*s+1));rlocus(G); 运行该段代码，得到MWorks绘制的根轨迹图如下： 根轨迹本质上反映的随着比例系数K_p的变化，特征方程根的变化情况；当两个共轭根恰好位于虚轴上时，此时对应的比例系数K_p（可将此时特征根带回特征方程求出）即为其稳定的边界值（大于该值不稳定，小于该值稳定）。 编写如下MWorks程序，寻找根轨迹与虚轴的交点并带回特征方程，求出比例系数K_p稳定边界值： 123456789101112131415161718192021222324% 找寻与虚轴交点k = linspace(0, 10, 1000); % 增加点数，1000个点[r, k]=rlocus(G,k);real_part = real(r);imag_part = imag(r);% 查找实部接近零的索引tolerance = 1e-1; % 设定阈值idx = find(abs(real_part) &lt; tolerance); % 找到所有交点的索引intersections = r(idx); % 交点的复数值% 求解临界kps = intersections(2);% 系统参数tao = 0.004;vm = 0.5;l = 10^(-4);c = 6.6*10^(-4);vin = 15;r = 10;syms kp; % 定义符号变量eq = tao*vm*l*c*s*s*s + tao*vm*l*s*s/r + vin*kp*tao*s + vm*tao*s + vin*kp == 0;solutions = solve(eq, kp); % 求解real_solutions = real(solutions); % 取实部decimal_solutions = double(real_solutions); % 转换为小数disp(decimal_solutions); % 显示结果 运行上述MWorks代码，得到的比例系数K_p稳定边界值结果为：0.0514，这与先前依据劳斯判据得到的结果$$\\frac{V_{M}\\tau}{V_{in}(RC - \\tau)} \\approx 0.0513$$大致一致。 而在实际情况下，需要考虑电容的寄生电阻；基于4.1节修正后的开环传递函数，代入数值可得： $$T(s) \\approx \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{1 + C \\bullet ESRs}{LCs^{2} + \\frac{L}{R}s + 1}V_{in} \\approx \\frac{30K_{p}(s + 250)(1 + 7.0710^{- 5}s)}{s(6.610^{- 8}s^{2} + 10^{- 5}s + 1)}$$根据该开环传递函数可知，该系统： 具有2个零点：$$z_{1} = 250，z_{2} \\approx 1.41*10^{5}$$具有3个极点：$$p_{0} = 0，p_{1} + p_{2} = \\frac{5}{33}*10^{3} \\approx 151.5，p_{1} = \\frac{5}{66}*10^{3} + bi，p_{1} + p_{2} = \\frac{5}{66}*10^{3} - bi$$故有3条根轨迹，2条止于开环零点，2条止于无穷远； 根轨迹的渐近线与实轴的夹角$$\\varphi_{a} = \\pm (2k + 1)\\pi(k = 0,1,2\\ldots) = 180{^\\circ}$$基于以上结果，可手绘根轨迹草图如下： 编写MWorks代码如下： 123456using TyControlSystemss=tf('s');c = 6.6*10^(-4);esr = 0.107185;G=(s+250)*(1+c*esr*s)/(s*(6.6*10^(-8)*s*s+10^(-5)*s+1));rlocus(G); 运行该段代码，得到MWorks绘制的根轨迹图如下： 可以看到，在考虑电容寄生电阻的情况下，根轨迹完全位于虚轴左侧，这意味着无论比例系数K_p（&gt;0）如何变化，系统特征方程的根均位于虚轴左侧，即此情况下系统始终稳定，这与先前依据劳斯判据得到的结果也是一致的。这样的结果也充分说明，寄生电阻的加入使得系统的稳定性提高。 4.3 直流Buck变换器奈奎斯特稳定判据分析在不考虑寄生电阻的情况下，基于3.1节得到的开环传递函数，取负载电阻R = 2欧姆，代入PI控制器参数：$$K_{p} = 0.05、\\tau = 1\\text{/}5000$$与三角载波幅值$$V_{M} = 3V$$可得： $$T(s) = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{V_{in}}{LCs^{2} + \\frac{L}{R}s + 1} = \\frac{0.05 \\times \\left( \\frac{1}{5000}s + 1 \\right)}{\\frac{1}{5000}s} \\cdot \\frac{1}{3} \\cdot \\frac{15 \\times 10^{8}}{6.6s^{2} + 5000s + 10^{8}} = \\frac{2.5 \\times 10^{7}(s + 5000)}{s(6.6s^{2} + 5000s + 10^{8})}$$根据该开环传递函数，编写MWorks代码如下： 123using TyControlSystemsH = tf([2.5*10^7 2.5*10^7*5000],[6.6 5000 10^8 0]);nyquist(H); 运行该段代码，得到MWorks绘制的奈氏图如下： 观察奈氏图图像可得：正穿越次数N+=1，负穿越次数N- =1 又由系统开环传递函数可知：系统开环右极点数P=0 故由奈奎斯特稳定判据可知：该闭环系统稳定。 4.4 直流Buck变换器系统波特图分析（MWorks绘制）与4.3节使用相同参数，即开环传递函数可写为： $$T(s) = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{V_{in}}{LCs^{2} + \\frac{L}{R}s + 1} = \\frac{2.5 \\times 10^{7}(s + 5000)}{s(6.6s^{2} + 5000s + 10^{8})}$$根据该开环传递函数，编写如下MWorks代码绘制波特图： 1234using TyControlSystemss=tf('s');G=2.5*10^7*(s+5000)/(s*(6.6*s^2+5000*s+10^8));bode(G); 运行该段代码，得到MWorks绘制的波特图如下： 从图中可读出：剪切频率$$\\omega_{c}≈1.49*10^{3}rad/s$$相位裕度$$γ≈102{^\\circ}$$根据对数频率特性稳定判据可知：当相位裕度γ与增益裕度Lg同时大于零时，闭环系统稳定；而对于最小相位系统，相位裕度γ&gt;0与增益裕度Lg&gt;0是同时发生或同时不发生的，因此只需通过相位裕度γ即可判定闭环系统稳定情况。显然此时相位裕度大于零，表明闭环系统稳定，且稳定性较好（相位裕度较大）。 4.5 直流Buck变换器闭环负载稳定边界计算及仿真验证基于2.2节中的电路元件参数以及输入电压恒为15V的客观事实，在给定PI控制器参数:$$K_{p} = 0.1、\\tau = 0.004$$与三角载波幅值$$V_{M} = 0.5V$$的情况下，若不考虑电容寄生电阻，根据4.1节劳斯判据化简后的结果：$$RCV_{g}K_{p} \\leq (\\tau V_{M} + V_{g}K_{p}\\tau)$$可推得系统处于稳定状态的电阻值范围应为：$$R \\leq \\frac{\\tau}{C}\\left( \\frac{V_{M}}{V_{g}K_{p}} + 1 \\right) \\approx 8.08\\Omega$$即直流Buck变换器闭环系统的负载电阻稳定边界约为8.1Ω。 为进一步通过仿真验证计算结果，建立PSIM仿真电路图如下： 取负载电阻值R = 5Ω（小于临界值）时： 取负载电阻值R = 8.1欧姆（约等于临界值）时： 取负载电阻值R=10Ω（大于临界值）时： 通过对比三组仿真结果可以发现：取不同的负载电阻值并不会影响系统的响应速度与响应瞬时超调量，而是影响输出电压趋于稳定后的纹波波形： 当负载电阻值小于临界值时，稳定后的输出电压会有较大的震荡（负载越小，震荡幅度越大），但该震荡上没有纹波，系统处于稳定状态； 当负载电阻接近临界值（实际临界值略小于8.1Ω）时，稳定后输出电压的震荡幅度减小，但开始出现纹波，系统处于临界稳定状态； 当负载电阻大于临界值时，稳定后输出电压的震荡幅度进一步减小，但纹波幅度有所增大，系统处于不稳定状态。 4.6 考虑寄生参数直流Buck变换器波特图分析（MWorks绘制）在实际情况下，为实现对直流Buck变换器闭环控制系统更加精准的建模，需要考虑电容的寄生电阻，基于4.1节修正后的开环传递函数（取未近似结果）： $$T(s) = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{\\frac{1}{LC} + \\frac{ESR}{L}s}{\\left( 1 + \\frac{ESR}{R} \\right)s^{2} + \\left( \\frac{1}{RC} + \\frac{ESR}{L} \\right)s + \\frac{1}{LC}}V_{in}$$取PI控制器参数:$$K_{p} = 1、\\tau = 0.01$$三角载波幅值$$V_{M} = 2V$$负载电阻$$R = 2\\Omega$$代入电路各元件参数与3.4节测算得到的寄生电阻$$ESR \\approx 107.185m\\Omega$$编写如下MWorks程序绘制波特图： 123456789101112using TyControlSystemss=tf('s');vm=2;r=2;esr=0.107185;c=6.6\\*10\\^(-4);l=10\\^(-4);vg=15;kp=1;tao=0.01;G=kp\\*(tao\\*s+1)\\*(esr\\*c\\*s+1)\\*vg/(tao\\*s\\*vm\\*(l\\*c\\*(1+esr/r)\\*s\\*s+(l/r+esr\\*c)\\*s+1));bode(G); 运行该段代码后绘制出的波特图如下： 从图中可读出：剪切频率$$\\omega_{c}≈1.29*10^{4}rad/s$$相位裕度$$γ≈50{^\\circ}$$根据对数频率特性稳定判据可知，此时相位裕度γ&gt;0，表明闭环系统稳定。 4.7 PSIM仿真扫频波特图取与4.6节相同的参数，利用PSIM搭建扫频电路进行仿真得到波特图： 从图中可读出：剪切频率$$\\omega_{c} \\approx 1997Hz \\approx 1.25*10^{4}rad/s$$相位裕度$$γ≈50{^\\circ}$$扫频仿真结果与MWorks根据系统开环传递函数绘制的波特图基本一致。 若在仿真电路图中加入锁存器与零阶保持器： 图4.19：考虑寄生电阻——加入锁存器与零阶保持器后PSIM扫频仿真结果 从图中可读出：剪切频率$$\\omega_{c}≈1997Hz$$相位裕度$$γ≈18{^\\circ}$$可以发现，在仿真中加入锁存器与零阶保持器后，剪切频率基本未发生改变，图线也大致与MWorks通过传递函数得到的波特图相同，但相位裕度有所降低，系统仍然保持稳定。 4.8 本章小结本章主要对于直流Buck变换器闭环控制系统的控制性能进行了详细的分析，特别是针对系统的稳定性问题，从系统的开环传递函数入手，对于考虑电容寄生电阻与否的两种不同情况，在时域上利用劳斯稳定判据与根轨迹法，讨论在负载电阻R与PI控制器时间常数τ给定的情况下，PI控制器比例系数K_p的稳定边界；在频域上依据奈奎斯特稳定判据（基于奈奎斯特图）与对数频率特性稳定判据（基于波特图，由MWorks绘制与PSIM扫频仿真得到，两者结果高度吻合），通过系统相位裕度γ判断闭环系统稳定性，同时在PI控制器参数给定的情况下讨论负载电阻R的稳定边界，并搭建PSIM仿真电路对不同负载电阻下闭环系统的稳定性进行验证，仿真结果与理论推导结论基本一致。 5 直流Buck变换器闭环控制实验5.1 KEIL5软件环境安装及创建Keil 5是一款集成开发环境（IDE），它以其强大的功能和丰富的特性，在嵌入式系统开发领域占据了重要的地位。在本项目中，需要借助该IDE编写主控代码并烧录至STM32芯片中，使其能够在闭环控制系统中正常发挥控制作用。 下载助教在课程群内上传的安装程序压缩包并解压，文件夹内包含如下文件： 双击安装程序”MDK524a.EXE”，一路点击”NEXT&gt;&gt;“（注意勾选同意许可证条款与指定软件安装位置）即可完成Keil5软件安装；软件安装完成后会自动运行，关闭后需要重新以管理员身份运行Keil5（右键-&gt;以管理员身份运行），随后进入keygen_new2032文件夹，双击运行破解程序”keygen_new2032.exe”，输入Keil5软件内”File-&gt;Licence Management…”里的CID并选择ARM，点击”Generate”并将生成的序列号复制到Keil5软件内”File-&gt;Licence Management…”下方的LIC一栏，点击”ADD LIC”即可完成破解。 除此之外，针对本项目选用的STM32F103C8T6芯片，还需要安装相关芯片库：双击”支持包”文件夹中的”Keil.STM32F1xx_DFP.2.2.0.pack”文件并点击”NEXT&gt;&gt;“即可完成安装。 完成软件环境的安装后，需要进入Keil5软件，点击上侧菜单栏中”Project-&gt;New μVision Project”新建工程，随后会进入到芯片设备的选择环节，选择芯片”STM32F103C8”并点击”OK”，在弹出的Manage Run-Time Environment对话框中再次点击”OK”即可完成工程创建。 当然事实上这样建立的工程仍然无法正常使用，还需要引入一系列启动文件与库函数文件等，具体流程在此不详细赘述，可以参考博客：如何在keil中建立一个STM32F10x完整工程。至此Keil5的软件环境安装及工程创建过程已经全部完成，再额外导入一些系统辅助函数文件（如”Delay.c”等），即可在”main.c”文件中进行闭环控制程序的编写了。 5.2 ADC采样及PWM生成原理ADC（Analog-to-Digital Converter），即模拟到数字转换器，主要用于将连续传输的模拟信号转换为数字信号，便于数字系统（如中央处理器CPU、微控制器MCU等）对传输信息进行快速处理和分析。 采样是指ADC在一定时间间隔内对连续变化的模拟信号进行取样，得到一系列离散的样本点，实现在有限采样率条件下，无失真还原信号波形信息。采样率决定了每秒采集的样本量，通常单位为Hz；其必须满足奈奎斯特采样定理（大于信号最高频率的两倍），否则会产生混叠。 由于数字信号本身不具有实际意义，仅仅表示一个相对大小，故任何一个模数转换器都需要一个参考模拟量作为转换的标准，比较常见的参考标准为最大的可转换信号大小，而输出的数字量则表示输入信号相对于参考信号的大小。在STM32单片机中，ADC为12位，即单片机读取的ADC值应在0~4095范围内，这样的ADC值与0~3.3V的输入电压值之间存在线性对应关系（若输入电压范围超出0~3.3V，则需要在输入ADC引脚前加入电阻分压和放大器等外围电路，在2.3.4小节中有详细介绍该部分采样电路）。 PWM（Pulse Width Modulation），即脉冲宽度调制，是一种通过调节脉冲信号的宽度（即占空比，高电平持续时间占整个周期的比例）来控制输出信号平均值的方法。在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量。简单而言，PWM可以视为一种DA（数字-&gt;模拟）转换，通过产生PWM波形这一数字信号等效地实现了模拟信号的输出。 PWM实现的原理是：通过锯齿波/三角波(载波)所需要合成的波形（调制波）进行比较，然后确定PWM所需要输出的极性，锯齿波从比较器的反相端端输入，当大于参考电压时输出与锯齿波相反的极性，而当锯齿波从比较器同相端输入，当大于参考电压时输出与锯齿波相同极性。 在Keil工程中，基于以上PWM生成原理编写函数文件”PWM.c”，其中包含了生成PWM波形所需的全部函数。实际运行时，PWM波形是通过定时器的计数和输出比较模块的配合生成的，其具体过程如下： （1）计数器计数：TIM2定时器按照内部时钟驱动，从0计数到ARR（2999），然后重新清零，重复循环。 （2）比较与输出：定时器每次计数到CCR（1500）时，切换PWM输出的电平状态：从计数开始到计数器值为CCR时，输出高电平；从计数器值为CCR到ARR，输出低电平。 （3）占空比：由CCR与ARR的比值决定。程序中初始设定CCR=1500，ARR=2999，故可计算得出占空比为$$\\frac{CCR}{ARR + 1} = 50%$$同时在主程序的控制过程中还可通过函数PWM_SetCompare1动态设置CCR值，从而实时改变占空比，进而影响输出的等效电压值。 5.3 基本PI控制理论及程序PI控制器是比例-积分控制器的一种，其核心是通过调节控制变量（输出电压），使系统输出接近目标值，是在控制工程中技术成熟、理论完善、应用最为广泛的一种控制策略。 对于PI控制器而言，其控制量的计算公式为：$$u(t) = K_{P} \\cdot \\mathbb{e}(t) + K_{I}\\int\\mathbb{e}(t)\\mathbb{d}t$$其中： （1）e(t)：当前时刻系统输出电压与参考电压之间的误差值； （2）K_P：比例增益系数，用于快速响应； （3）K_I：积分增益系数，用于消除稳态误差； （4）u(t)：待控制变量——系统输出电压。 写成微分方程形式则为：$$\\left{ \\begin{aligned} &amp; \\dot{x} = K_{I}v \\ &amp; y = K_{p}v + x\\end{aligned} \\right.$$根据传递函数定义，其传递函数可表示为： $$G_{c}(s) = K_{p} + K_{I}\\frac{1}{s} = \\frac{K_{p}(\\tau s + 1)}{\\tau s}$$其中积分时间常数$$\\tau = \\frac{K_{p}}{K_{I}}$$PI控制器具有以下特点： 从时域上看，只要存在偏差，积分就会不停对偏差积累，因此稳态时误差一定为零； 比例与积分动作都是对过去控制误差进行操作，不对未来控制误差进行预测，限制了控制性能； PI调节将比例调节的快速反应与积分调节消除静差的特点结合，主要用于改善控制系统的稳态性能。 在Keil工程中的主函数文件”main.c”中，其main函数在进行了PWM、ADC与串口等必要的初始化后，在while循环中反复运行update_voltage_reference与control_buck两个函数，其中前者主要是进行参考电压的动态更新，而后者中则包含了PI控制的主要逻辑，部分核心代码如下： 1234error = voltage_ref \\* 2500 \\* 1000 / 1050 / 20000 - voltage_fb;integral += error;control_signal = KP \\* error + KI \\* integral;last_error = error; 该段代码主要按照如下流程实现PI控制： 误差计算：error$$e(t) = V_{ref} - V_{fb}$$ 其中V_ref（voltage_ref）为函数update_voltage_reference中设定的目标电压，而V_fb（voltage_fb）为系统输出并反馈至控制器的实际电压。 积分计算：$$integral = \\int\\mathbb{e}(t)\\mathbb{d}t$$为累加误差，用于消除系统的稳态误差（输出电压voltage_fb与参考电压voltage_ref的差值error）。 PI控制量：control_signal$$u(t) = K_{P} \\cdot \\mathbb{e}(t) + K_{I}\\int\\mathbb{e}(t)\\mathbb{d}t$$为最终控制信号，用于调节PWM占空比。 除此之外，为防止占空比超出合理范围，还对控制信号control_signal进行约束： 1234if (control_signal \\&gt; 0.8) control_signal = 0.8;else if (control_signal \\&lt; 0.2) control_signal = 0.2; 除了PI控制的核心逻辑外，在主控函数control_buck中还实现了其他功能： 模拟信号采集得到系统输出并反馈至控制器的实际电压V_fb（voltage_fb）： 12voltage_fb = (float)AD_GetValue()\\*3.3/4096;trueVoltage = voltage_fb \\* 1050 \\* 20000 / 2500 / 1000; 根据PI控制结果，实时更新PWM占空比： 123duty_cycle = control_signal \\* PWM_PERIOD;i = (int)duty_cycle;PWM_SetCompare1(i); 通过串口发送调试信息，用于监控采样值和控制效果： 1Serial_Printf(\\&quot;%d,%.2f\\\\r\\\\n\\&quot;, sample_index, trueVoltage); 5.4 闭环PI稳压调控输出（8V、10V）5.3节中对于主控函数control_buck进行了详细的解析，整个闭环PI调控过程都由此函数完成，在此不重复赘述；而对于函数update_voltage_reference而言，该函数实现了电压的切换： 1234567891011121314void update_voltage_reference(void){ time_counter += 40; // 每次调用增加计时器值 if (time_counter \\&gt;= 10000) // 达到10秒{ time_counter = 0; // 重置计时器 if (voltage_state == 0){ voltage_ref = 10.0; // 切换到10V voltage_state = 1; // 更新状态 } else{ voltage_ref = 8.0; // 切换到8V voltage_state = 0; // 更新状态 } }} 可以看到，该函数每隔10秒就对于目标电压voltage_ref进行一次切换，由10V切换为8V，再由8V切换回10V，循环往复。该函数主要用于模拟动态负载或参考值变化的情景，以测试控制器再目标电压变化时的响应性能。 事实上，在main函数中，在进行各项初始化（PWM、ADC、串口等）后，while循环中只有参考电压切换函数update_voltage_reference与PI主控函数control_buck反复作用，也正是这两个函数使得该直流Buck变换器闭环控制PI系统能够交替稳压输出8V或10V的电压。 5.5 闭环参考电压8V-10V连续跳变实验与分析（仿真+实验）在直流Buck变换器闭环PI控制系统参考电压8V-10V连续跳变实验时，重点对于输出电压分别为8V与10V的两种情况下单片机的PWM输出波形进行测试，通过观察其占空比反映其输出电压情况： 先使用仿真器给单片机供电，以调试PWM波形输出是否正常； 将上述闭环控制程序放入Keil工程中，成功编译后烧录至单片机内，将单片机（最小系统板）插入电路板上预留的引脚接口处并上电测试，使用示波器或者上位机观测电路板PA8端口输出PWM波形的占空比。 可以看到，在参考电压设置为8V时，单片机输出的PWM占空比明显小于参考电压为10V时的结果。 为进一步观察参考电压连续跳变时的动态响应过程，进行了对应的PSIM电路仿真（仿真参数：kp=0.12，τ_i=1/5000，R=2Ω），其中跳变效果通过在直流参考电压后接入一个周期方波信号实现，跳变周期为0.1s： 可以看到，跳变瞬间系统的动态响应较快（约为0.01s）且输出电压稳定后震荡幅度较小，说明该参数下系统具有较好的动态响应性能。 5.6 本章小结本章主要介绍了对于直流Buck变换器PI闭环控制的整体实验流程，从STM32单片机编程环境的搭建，到根据PWM生成原理编写PWM的初始化函数及占空比实时调控函数，再到根据PI控制的基础理论编写对应的主控代码，在参考电压连续跳变（8V-10V）的情况下调控闭环PI的稳压输出，最后将代码烧录进行实际实验，测试单片机的PWM输出调控情况，并通过仿真观察参考电压连续跳变时的动态响应情况。通过该闭环控制实验，充分证明了PI闭环控制系统对于直流Buck变换器具有良好的控制效果。 6 复合PI控制直流Buck变换器6.1 PI+超前校正（复合PI）分析设计为提高PI闭环控制系统暂态响应速度，可以在原有的控制系统中加入一些其参数可以根据需要而改变的控制器，即对于系统进行校正，从而使整个系统的频率特性发生变化。本项目中针对直流Buck变换器的PI闭环控制系统，采用PI+串联超前校正的复合PI控制器，以进一步提升系统性能指标。 串联超前校正的核心思想是，将补偿中心ω_ m设计为期望剪切频率ω_ c处，从而提升剪切频率(补偿中心)所对应相位，并利用补偿处增益放大(+20)来改善剪切频率处斜率。具体的设计流程如下： 根据静态性能指标，确定开环增益K 为确定校正环节的设计方向，根据所确定的开环增益，画出系统固有部分G_s(s)的波特图，并计算其剪切频率ω_ c1与相位裕度γ_ 0； 根据要求的相位裕度γ，确定$$\\varphi_{m} = \\mathrm{\\Delta}\\varphi = \\gamma - \\gamma_{0} + \\varepsilon，\\varepsilon =5° - 25°$$若$$\\varphi_{m} &lt; 60{^\\circ}$$说明可采用串联超前校正，即$$\\varepsilon \\approx \\varphi（\\omega_{c1}）-\\varphi（\\omega_{c2}），\\omega_{c1}为原穿越频率，\\omega_{c2}为校正后穿越频率$$ 由φ_m确定α：$$$\\alpha = \\frac{1 + \\sin\\varphi_{m}}{1 - \\sin\\varphi_{m}} &gt; 1$$ 令校正后剪切频率$$\\omega_{c2} = \\omega_{m} = \\frac{1}{T\\sqrt{\\alpha}}$$ 画出校正后系统的波特图，并验算相位裕度是否满足要求：若满足要求，则需要在原有PI控制器前增加环节$$G_{c}(s) = \\frac{\\alpha Ts + 1}{Ts + 1}$$若不满足要求，需增大ε的值，从第（3）步重新开始计算。 对于比例积分PI控制器，一般采用如下的超前校正方式： 图6.3：PI控制器超前校正电路原理图 针对直流Buck变换器的PI闭环控制系统，给定PI控制器参数:$$K_{p} = 0.8、\\tau = 1/5000$$负载电阻$$R = 2\\Omega$$与三角载波幅值$$V_{M} = 1V$$根据3.1节给出的系统开环传递函数（不考虑电容寄生电阻）：$$T(s) = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{V_{in}}{LCs^{2} + \\frac{L}{R}s + 1}$$在MWorks中编写如下代码绘制校正前的波特图： 1234567891011using TyControlSystemss=tf('s');vm=1;r=2;c=10^(-4);l=10^(-4);vg=20;kp=0.8;tao=1/5000;G=kp*(tao*s+1)*vg/(tao*s*vm*(l*c*s*s+(l/r)*s+1));bode(G); 绘制出校正前的波特图： 从图中可读出：校正前系统的剪切频率$$\\omega_{c1}≈4.20*10^{4}rad/s$$相位裕度$$\\gamma_{0}≈0{^\\circ}$$此时系统处于临界稳定状态。 为使得校正后的相位裕度$$\\gamma &gt; 30{^\\circ}$$可确定需增加的相位裕度$$\\varphi_{m} = \\mathrm{\\Delta}\\varphi = \\gamma - \\gamma_{0} + \\varepsilon = 30{^\\circ} - 0{^\\circ} + 15.5{^\\circ} = 45.5{^\\circ} &lt; 60{^\\circ}$$满足超前校正要求，进而可以确定 $$\\alpha = \\frac{1 + \\sin\\varphi_{m}}{1 - \\sin\\varphi_{m}} \\approx 6$$又因为系统周期$$T = \\frac{1}{70000}s$$从而可以确定增加的超前校正环节的开环传递函数为： $$H(s) = \\frac{\\frac{6}{70000}s + 1}{\\frac{1}{70000}s + 1}$$这意味着校正后整个闭环控制系统的传递函数变为$$T^{‘}(s) = T(s)H(s)$$可在上述MWorks代码的基础上增加下列代码以实现对于校正后闭环控制系统波特图的绘制： 123H=(6*s/70000+1)/(s/70000+1);G1=G*H;bode(G1); 绘制出校正后的波特图： 从图中可读出：校正后系统的剪切频率$$\\omega_{c2}≈8.71*10^{4}rad/s$$相位裕度$$\\gamma≈31{^\\circ} &gt; 30{^\\circ}$$相位裕度较校正前有明显提升且满足系统对品质指标的要求，校正正确。 6.2 复合PI控制PSIM仿真（校正前后参考电压变化时输出电压分析）首先通过PSIM扫频仿真对先前波特图的MWorks绘制结果进行验证： 从图中可读出：校正前系统的剪切频率$$\\omega_{c1}≈6554Hz$$相位裕度$$\\gamma_{0}≈0{^\\circ}$$校正后系统的剪切频率$$\\omega_{c2}≈14126Hz$$相位裕度$$\\gamma≈35{^\\circ}$$与MWorks绘制的波特图结果基本一致。 为反映超前校正的引入对于系统暂态响应速度的提升效果，搭建PSIM仿真电路，分析校正前后参考电压跳变瞬间的输出电压响应情况： 对比校正前后参考电压跳变瞬间的输出电压暂态响应PSIM仿真结果，可以发现：校正前系统暂态响应时间约为0.034s，而加入超前校正环节后系统暂态响应时间为0.0006s，较校正前有显著缩短，说明超前校正的引入有效提升了系统的动态响应特性（快速性）。 6.3 PI+微分环节D（PID）分析设计除增加串联超前校正环节设计外，还可以通过在原有PI控制器基础上加入微分环节D实现PID闭环控制来提升系统的稳定性与暂态响应速度。事实上，在PID控制器的三个环节中，比例环节P主要负责动态性能的提升，积分环节I主要负责稳态精度的提升，而引入微分环节D则可进一步改善系统的稳定裕度以提升系统稳定性。 与PI控制器类似，通过对PID控制器的微分方程组进行拉普拉斯变换，可以得到其传递函数为：$$G_{c}(s) = \\frac{K_{p}(\\tau_{i}s + 1)}{\\tau_{i}s} + \\tau_{d}s$$其中τ_ i为积分时间常数，而τ_ d为微分时间常数。 接下来将通过MWorks绘制波特图，配合PSIM的扫频仿真结果，从相位裕度的角度来反映微分环节D的引入对于系统稳定性的提升： 对于PI控制器，给定控制器参数:$$K_{p} = 0.12、\\tau = 1/5000$$负载电阻$$R = 2\\Omega$$与三角载波幅值$$V_{M} = 1V$$根据3.1节给出的系统开环传递函数（不考虑电容寄生电阻）：$$T(s) = \\frac{K_{p}(\\tau s + 1)}{\\tau s}\\frac{1}{V_{M}}\\frac{V_{in}}{LCs^{2} + \\frac{L}{R}s + 1}$$$在MWorks中编写如下代码绘制波特图： 123456789101112using TyControlSystemss=tf('s');vm=1;r=2;esr=0.107185;c=6.6*10^(-4);l=10^(-4);vg=15;kp=0.12;tao=1/5000;G=kp*(tao*s+1)\\*(esr*c*s+1)*vg/(tao*s*vm*(l*c*(1+esr/r)*s*s+(l/r+esr*c)*s+1));bode(G); 同时在PSIM中搭建扫频仿真电路，通过扫频仿真结果验证MWorks绘制波特图的正确性： 从图中可读出：PI闭环控制系统剪切频率$$\\omega_{c}≈6.78*10^{3}rad/s \\approx 1105Hz$$相位裕度$$\\gamma$≈$10{^\\circ}$$且MWorks绘制波特图与PSIM扫频仿真结果基本一致。 对于加入微分环节D后的PID控制器，给定控制器参数:$$K_{p} = 0.12、\\tau_{i} = 1/5000、\\tau_{d} = 0.00001$$负载电阻$$R = 2\\Omega$$与三角载波幅值$$V_{M} = 1V$$根据3.1节给出的系统开环传递函数（不考虑电容寄生电阻）并将其中PI控制器的传递函数替换为PID控制器的传递函数，可得到PID闭环控制系统的开环传递函数：$$T(s) = (\\frac{K_{p}(\\tau_{i}s + 1)}{\\tau_{i}s} + \\tau_{d}s)\\frac{1}{V_{M}}\\frac{V_{in}}{LCs^{2} + \\frac{L}{R}s + 1}$$在MWorks中编写如下代码绘制波特图： 12345678910111213using TyControlSystemss=tf('s');vm=1;r=2;esr=0.107185;c=6.6*10^(-4);l=10^(-4);vg=15;kp=0.12;tao=1/5000;taod=0.00001;G=(kp*(tao*s+1)+taod*tao*s*s)*(esr*c*s+1)*vg/(tao*s*vm*(l*c*(1+esr/r)*s*s+(l/r+esr*c)*s+1));bode(G); 同时在PSIM中搭建扫频仿真电路，通过扫频仿真结果验证MWorks绘制波特图的正确性： 从图中可读出：PID闭环控制系统剪切频率$$\\omega_{c}≈6.78*10^{3}rad/s \\approx 1026Hz$$相位裕度$$\\gamma≈36{^\\circ}$$且MWorks绘制波特图与PSIM扫频仿真结果基本一致。 通过对比PI和PID控制下的波特图与扫频结果可以发现，相比于PI控制器，PID控制下的直流Buck变换器闭环系统具有更高的相位裕度，这意味着在加入微分环节D之后，系统具有更好的稳定性。 6.4 PID控制PSIM仿真（校正前后R变化时输出电压分析）为反映微分环节D的引入对于系统稳定性与响应速度的提升效果，搭建PSIM仿真电路，分析PI与PID控制器在负载电阻R不同时输出电压响应情况： 对比PI与PID控制器在负载电阻R不同时的输出电压暂态响应PSIM仿真结果，可以发现：当负载电阻R=2Ω时，在原有的PI控制器闭环控制下，系统的暂态响应时间约为0.008s，而加入微分环节D后，系统在PID控制器的闭环控制下暂态响应时间为0.004s，这意味着在加入微分环节D后，系统的动态响应特性得到一定提升（响应时间缩短50%）；除此之外，在相同的控制器作用下，随着负载电阻阻值由2Ω增大到5Ω，系统的输出电压在稳定后的振荡幅度明显减，但此时暂态响应时间也明显增加（增加近两倍）。 6.5 本章小结本章主要介绍了基于PI控制器的校正设计，对于直流Buck变换器的闭环控制而言，分别采用在原有控制系统上增加超前校正环节与微分环节D的两种校正方式实现复合PI控制，通过MWorks绘制波特图与PSIM扫频仿真，反映校正环节的引入对于相位裕度即系统稳定性的提升效果，并结合PSIM电路仿真的输出电压结果，观察校正环节的引入对于系统暂态响应速度即动态响应特性的提升效果。仿真实验结果表明，对于PI控制器的校正设计（超前校正/引入微分环节形成PID控制）在提升系统稳定性与动态响应快速性方面取得了良好的效果。 7 基于直流电源调控的自动调光控制设计该系统的主要功能是将灯的电压通过直流Buck变换器完成闭环PID控制，将输出电压控制在0-15V范围内。系统主要包含电量控制与亮度控制两个部分，其中电量控制由STM32数字控制器通过电压控制信号调节Buck变换器输出电压；亮度控制则通过光敏传感器感知外界光强，并将反馈信号传递给STM32，实现对LED灯源亮度的动态调整，从而形成电压与亮度的双闭环调节系统。 基于该架构，系统设计的基本流程如下： 搭建Buck电路控制系统，用于调控LED灯源； 使用开发工具Keil5编写STM32控制程序，实现PWM信号生成和调节； 将光敏传感器的输出连接到STM32的ADC（模数转换器）端口； 设计闭环控制系统并编写主控程序，实现根据光照强度自动调节PWM占空比，从而控制LED灯光的亮度； 调试系统，过程中实时监测电路工作状态，确保电路安全稳定运行且光照强度变化时LED灯亮度能够迅速进行响应调整； 对系统功能进行测试与优化，验证系统的响应速度和调光精度。 除此之外，在系统基本功能的设计实现基础上，还进行了基于无线通信的远程控制这一拓展功能设计，将调光系统与蓝牙无线通信模块结合，实现通过手机应用对LED灯进行调光控制，增加系统的便携性和灵活性。 接下来将分模块具体阐述自动调光控制系统各功能设计的详细过程。 7.1 默认电压值设置在系统上电之后，输出电压默认设置为9V。之所以选择9V作为默认值，是因为这一电压能够在不消耗过多能量的情况下提供足够的亮度，同时避免由于过高或过低电压对系统性能的影响。 具体来说，9V的默认值具有以下几个优点： （1）能耗平衡：相较于较低电压（5V），9V能够提供更高的亮度输出，同时不会像满电压（15V）那样带来显著的能量消耗，适合作为常规环境下的起始亮度。 （2）避免电压冲击：在系统刚启动时，设定较高的默认电压可能会导致电流冲击，影响电源和负载的寿命。9V作为中间值，有效降低了这种风险。 （3）用户体验优化：默认电压为9V时，灯光亮度适中，避免了开机过亮或过暗对用户造成的不适，同时为后续手动或自动调节提供了便利。 （4）环境适应性：在普通家庭或办公室环境下，9V的亮度通常能满足基本照明需求，而无需立即调整，增强了系统的即用性。 此外，9V的默认值通过主程序固化设置，确保每次系统启动时都能快速恢复到该默认电压值。这一设置不仅提高了系统的稳定性，还为后续用户操作提供了可靠的初始状态。设计中对默认电压的选择经过多次实验验证，综合考虑了实际照明需求和电源性能，最终确定了这一合理数值。 7.2 蓝牙接口通信控制在本系统中，蓝牙模块被用作与手机或其他移动设备的通信桥梁，用户可通过蓝牙实现对灯光的远程控制，增强系统的操作便利性和用户体验。蓝牙模块选用低功耗蓝牙（Bluetooth Low Energy, BLE）技术，保证了通信的可靠性和功耗优化。具体而言，蓝牙通信具有以下优点： 便捷性：用户可通过手机远程调节灯光，无需物理接触，尤其适合家庭场景。 可扩展性：蓝牙接口支持更多功能指令的扩展，如灯光模式切换等。 低成本实现：蓝牙模块硬件成本低，结合STM32可轻松实现稳定通信。 以下是蓝牙接口通信功能的详细设计： 硬件接口设计 蓝牙模块选型：选用HC-05蓝牙模块，该模块具有支持串行通信（UART）功能，能与STM32单片机直接连接；模块通过UART接口与STM32的USART1通道连接，波特率设置为9600bps以平衡数据传输速率与稳定性。 引脚连接：蓝牙模块的TX和RX引脚分别连接STM32的RX和TX引脚，模块的VCC和GND引脚分别接单片机供电端和地线，保证模块稳定供电。 软件功能设计 蓝牙通信通过STM32主程序实现对蓝牙模块接收指令的解析和响应。指令的解析流程大致是这样的：主程序中设定一个蓝牙接收缓冲区，用于存储用户发送的指令；当蓝牙模块接收到数据时，触发中断，将数据写入缓冲区；程序定时轮询缓冲区，并根据指令类型解析执行以下指令以实现功能，包括灯的开关、亮度百分比调整，以及环境光自动调节的触发： “on”/“off”指令：通过电压直接跳转的方式实现即时开关 “on”：将输出电压设定为最大值15V，点亮灯光； “off”：将输出电压设定为最小值0V，关闭灯光。 亮度调整指令：接收一个0-100的整数，表示灯光亮度为15V的百分比。程序计算目标电压时依据公式：$$V_{target} = \\frac{百分比指令}{100} \\times 15$$调用PWM控制函数调整Buck变换器的输出电压至目标值，实现实时亮度调节。 “LL”指令：触发光敏传感器，启动环境光度自动调节模式（详见7.3节）。 通信协议设计 蓝牙通信基于简单的ASCII协议，用户可通过手机APP或终端工具发送指令。每条指令均以换行符\\n结尾，便于解析。以下是通信协议的具体格式： “on\\n”：开启灯光。 “off\\n”：关闭灯光。 “50\\n”：将亮度设置为50%。 “LL\\n”：启动环境光度自动调节模式。 通过蓝牙接口通信，系统不仅支持手动调节灯光，还为后续的智能化功能扩展奠定了基础。 7.3 基于光敏传感器的调光功能本系统采用光敏传感器对环境光强进行实时检测，并基于检测值动态调整灯光的亮度，提供适应不同场景的自动调光功能。通过光敏传感器实现调光，既可以减少用户手动调整灯光的频率，还可以自动优化输出电压，适用多种场景需求。通过闭环控制机制，确保灯光的输出电压与环境光强度的变化相匹配，为用户提供更舒适、高效的照明体验。以下为光敏传感器调光功能的详细设计与实现过程： 硬件接口设计 光敏传感器选型：选用光敏电阻模块，输出光强的模拟信号值。传感器将环境光强信号转换为电压信号，供STM32单片机的ADC模块读取。 传感器连接方式：光敏传感器的模拟输出端（AO口）连接到STM32单片机的PA5引脚，PA5被配置为ADC输入通道。供电引脚（VCC）连接单片机的3.3V供电，地线（GND）连接系统地，保证传感器的稳定工作。 软件功能设计 数据采集与转换：STM32通过ADC模块以一定采样频率读取光敏传感器的模拟信号，模拟值范围为0到4095，对应电压范围为0到3.3V；可通过公式$$V_{target} = \\frac{ADC值}{4095} \\times 15$$将光强模拟值映射为输出电压目标值，该线性映射关系保证了灯光亮度的平滑过渡，避免突然变化对用户产生视觉不适。 调光逻辑与策略：当ADC值低于预设阈值（如1024）时，认为环境光较暗，此时系统逐步增加输出电压，以提高灯光亮度补偿环境光；当ADC值高于预设阈值（如3072）时，认为环境光较亮，此时系统逐步降低输出电压，以避免浪费电能或造成视觉不适；当光强处于中等范围时（ADC值1024到3072），输出电压以线性比例动态调节，保持环境与灯光亮度的适应性平衡。 PID闭环控制：根据光敏电阻值计算目标电压，并作为参考值输入PID控制器；PID控制器实时计算实际输出电压与目标电压之间的误差，并调整PWM信号占空比控制Buck变换器，确保输出电压快速稳定地收敛到目标值。 状态反馈与异常处理：当光敏传感器信号异常（如ADC值恒定不变或超出有效范围）时，系统进入保护模式，将输出电压设定为安全值9V，并通过蓝牙模块通知用户；传感器数据每次读取后均存储在缓冲区中，并定期更新，避免因单次采样噪声造成调光不稳定。 为进一步验证调光功能的灵敏度，需要测试光敏传感器在不同光强条件下的响应时间和精度，确保其采集的光强信号与实际环境光强相符。经过调试，光敏电阻灵敏度较高，但光敏电阻的朝向会对空间中同一点的光敏传感有不同的值。解决方式为固定光敏电阻朝向位置，使其主要接收来自上方的环境光。除此之外，还需要验证在自动调光模式下，灯光亮度调整是否与环境光变化相匹配。经过我们的实验，该灯泡在8V电压以下不会发光，且为了保护电路和用户，我们将最高输出电压15V通过程序限制在12V，于是我们将光亮百分比线性映射公式修改为：$$V_{target} = \\frac{百分比指令}{100} \\times 4 + 8$$从而使得亮度百分比更符合实际；由于百分比电压现在被限制在8-12V，光敏需要更多的外边界，从原先0-15V电压的计算，改为5-15V电压的线性映射，光敏电阻映射公式也需要对应修改为：$$V_{target} = \\frac{ADC值}{4095} \\times 10 + 5$$此时由于光敏电阻在一般的环境光下位于1024-3072而并不会趋于极端值，且程序有保护设计，故一定可以限制输出电压在8-12V范围内。 为进一步优化用户的使用体验，还开展了用户测试实验为产品优化提供参考。实验记录了光敏传感器自动调光时用户的视觉体验，并通过调整PID参数和映射公式提高舒适性。通过光敏传感器的引入，本系统实现了基于环境光强的自动调光功能，显著提升了灯光控制的智能化水平与用户体验。 7.4 闭环PID控制原理闭环PID控制是本系统的核心功能之一，负责根据目标输出电压值和实际输出电压值的误差，动态调节PWM信号，从而控制Buck变换器的输出电压，实现稳定、精准的调光效果。通过PID控制算法，可以使Buck变换器的输出电压始终接近目标值，无论输入电压波动、负载变化，还是环境光强条件改变，都能够保持系统的高稳定性和快速响应性。 PID控制算法主要由三部分组成：比例（P）、积分（I）、微分（D），可通过公式$$u(t) = K_{p}e(t) + K_{i}\\int_{0}^{t}{e(\\tau)d\\tau} + K_{d}\\frac{de(t)}{dt}$$计算其控制输出，其中u(t)为控制信号（用于调节PWM占空比）；e(t)为当前误差值，定义为目标值与实际值之差，即$$e(t) = V_{target} - V_{actual}$$K_p,K_i,K_d分别为比例、积分、微分的调节系数，分别控制系统的响应速度、稳态误差消除能力和动态性能。 通过调节K_p,K_i,K_d三个参数，可以调整控制器的性能，从而实现系统响应特性的优化，提升系统控制效果。具体而言，三个参数对于响应输出的影响如下： 比例（P）参数K_p：比例项主要控制误差对输出的直接影响，增大K_p会使系统响应更迅速，但过大可能引起震荡。本系统初始设置$$K_{p} = 0.1$$通过实验验证实现了较平滑的响应。 积分（I）参数K_i：积分项通过累积误差消除稳态误差，确保输出精度。由于积分过大会导致超调或积分饱和，本系统设置$$K_{i} = 0.01$$ 微分（D）参数K_d：微分项对误差变化率进行调节，用于改善动态性能并抑制震荡。为避免过分灵敏的微分效应引入噪声，D参数设置为较小值$$K_{d} = 0.01$$ 在本项目的自动调光系统中，PID控制器的控制流程主要分为如下几个步骤： 误差计算：STM32单片机实时采集目标电压值 V_target 和实际输出电压值 V_actual，计算误差：$$e(t) = V_{target} - V_{actual}$$ 控制信号计算：根据误差值，通过PID公式计算控制信号u(t)，调整PWM信号的占空比：$$u(t) = K_{p}e(t) + K_{i}\\sum_{k = 0}^{t}{e(k)\\mathrm{\\Delta}t} + K_{d}\\frac{e(t) - e(t - 1)}{\\mathrm{\\Delta}t}$$其中Δt为控制周期；∑e(k)Δt为误差累积值；(e(t)-e(t-1))/Δt为误差变化率。 PWM调节：将计算得到的u(t)映射为PWM信号的占空比，直接控制Buck变换器的输出电压。占空比范围为10%至80%，对应输出电压范围为0V至15V。 反馈调整：系统持续监测实际输出电压，更新误差值并重复上述步骤，形成闭环控制。 在基于STM32单片机编写程序具体实现PID控制器算法时，还需要特别注意以下两点： 采样频率：ADC采样频率需要设置为与main函数主循环频率同步，以保证控制系统对输入误差的快速响应。同时PID计算周期也应同步于ADC采样，以避免数据滞后影响调节效果。 保护机制：若误差值持续过大（如超出安全范围），系统触发保护模式，因此实际实现时将PWM占空比最小设为10%，最大设为80%。 在实际调试验证时，主要对于控制系统的动态性能与抗干扰能力进行了测试与优化，以进一步提升自动调光功能的灵敏性与稳定性，从而优化用户体验： 动态性能测试：在快速切换目标电压值时，观察系统的响应时间和稳定性，确保输出电压能够迅速收敛到目标值。在负载变化的情况下，验证系统能否保持输出电压的稳定。 抗干扰能力测试：模拟输入电压波动和环境光强突变，测试系统的鲁棒性和PID调节效果。 最终经过多次调试与不断优化，该闭环PID控制系统实现了以下目标： 高精度输出：在误差范围内快速稳定输出目标电压。 快速响应：对目标值或负载变化的响应时间快，满足实际调光需求。 稳定性强：在输入波动、负载变化和环境干扰下，系统保持良好的稳定性。 7.5 外观设计制作为了使本系统不仅具有实用性，还能满足美观性和设计感的需求，我们对外观部分进行了重新设计和制作。本节详细介绍了外观设计的灵感来源、制作过程以及技术实现中的注意事项。 本系统的外观设计灵感来源于游戏《无畏契约》（Valorant）中的角色”尚博勒”（Chamber）的道具”摄像头”。这一设计概念契合科技感与现代感的视觉效果，适合科技爱好者的审美需求，同时其独特的造型也为灯具的装饰性增色。我们力求将其视觉元素融入本项目，打造一款既具功能性又有极高辨识度的灯具设备。同时在外壳设计时也结合了灯泡的散热需求，保证了灯具长时间工作时的安全性和稳定性。设计中注重可拆卸性，用户可以方便地调整灯泡朝向和光照亮度。 详细的制作过程如下： 原型拆解 我们首先将旧灯具的灯罩部分锯下来，仅保留其内部核心组件，包括灯泡、散热装置、电路板和连接线。为确保灯具正常运行，对保留的灯泡和电路板进行功能检测，确认其性能稳定，并清理了原型中多余的固定结构，为后续的外壳重新设计预留空间。 3D建模与设计 使用Fusion 360软件，根据”尚博勒摄像头”的设计特点，建模了一个以球体和多面体造型的外壳结构。模拟摄像头的结构，在灯具上设计了圆形凹陷部分，提升灯具的科技感。外壳设计了散热格栅，与灯具散热需求相结合；外壳底部设计了支撑脚架，便于放置和移动。摄像头部分设计轨道凹槽，可旋转控制摄像头方向。 材料选择与加工 外壳部分采用轻质耐用的 PLA 材料，利用3D打印技术制作。打印分为两个部分：上半部分为灯具主壳，下半部分为安装支架，组装后固定。3D打印完成后，外壳表面进行手工打磨并喷涂金色亚光涂料，灯罩边缘则涂上金属漆，营造高科技感。 组件安装与调试 将灯泡、电路板、散热器嵌入3D打印外壳中，通过卡扣、限位固定，确保结构稳固。为避免外壳对散热产生影响，在装配后对设备进行长时间运行测试，确保温度稳定在安全范围内。重新调整灯光的投射方向和亮度，使其与设计的外壳结构匹配，确保在不同环境下具备良好的照明效果。 为进一步提升用户体验，后续将持续对产品进行深度优化，包括添加更多灯光模式（如动态光效或多色渐变）以进一步增强装饰性和互动性，或引入语音控制功能并将其与蓝牙通信相结合以提升智能化体验。 7.6 本章小结本章介绍了基于直流电源调控的自动调光控制设计，通过蓝牙模块完成手动输出电压控制，通过光敏传感器进行环境光度自动调节，最终通过Buck变换器闭环PID控制完成灯的电压和光亮度稳定。 8 基于直流电源调控的光伏MPPT控制设计8.1 设计背景与系统架构光伏发电是当前清洁能源的主流之一，最大功率点跟踪（Maximum Power Point Tracking, MPPT）是光伏系统中提高效率的关键技术。由于光伏板的输出功率受到光照强度影响，不同的光照强度下最大功率点对应的输出电压不同，需要不断通过改变输出电压来寻找最大功率点（MPP）。因此，希望通过搭建一个基于直流电源调控的光伏MPPT控制系统，结合STM32单片机和Buck变换器实现光伏阵列的最大功率点跟踪，从而使得系统维持在最大功率工作，减少不必要的能量损失，有效储存其他能量转化成的电能。 在该系统中，外界光照被太阳能电池板转化为电能，经功率变换电路处理后向负载供电。STM32微控制器实时采集电池板电压、电流等参数，运行MPPT算法，生成控制信号优化功率变换电路的工作状态，确保太阳能电池板始终在最大功率点运行，提高能源利用效率。 8.2 实验原理光伏板的输出功率会受到环境条件（如光照、温度）影响，这一点无法改变，但是输出功率同时也受到工作电流、电压的因素影响，因此可以通过调节负载电压，使光伏系统的功率维持在最大值，即工作在最大功率点（实现输入侧阻抗匹配）。在本课程使用的Buck变换器中，可以根据STM32输出PWM波的占空比来控制输出的电压，同时由于电路中在不断采集输出电压，从而可以通过设计相应的控制算法算法实现对于输出电压的精确闭环控制。 为了找到最大功率点，可采用扰动观察法（Perturb and Observe, P&amp;O）算法。通过降低与增加占空比来调节输出电压，由于电阻一定，可以通过计算算出变化后的功率，同时将其与变化前的功率进行比较，若功率增大，则沿当前方向继续调整占空比；否则反向调整。在每次调整占空比后，计算功率并记录趋势，从而找到最大功率点。在本项目中，采用改进的扰动观察法，通过记录功率变化并自动调整占空比，从而快速收敛到最大功率点。 8.3 代码逻辑在Keil5中编写的STM32主控代码主要分为如下4个主要的功能模块： 系统初始化：初始化系统时钟与ADC、PWM模块，为数据采集及控制做好准备。 1234SystemInit(); // 初始化系统时钟PWM_Init(); // 初始化PWM模块AD_Init(); // 初始化ADC模块_enable_irq(); // 开启全局中断 PWM控制模块：通过实时调控PWM输出占空比实现Buck变换器输出电压的改变，从而影响光伏阵列的工作点。值得注意的是，需要调整PWM输出频率与Buck变换器相适应，同时确保输出占空比范围在0~1范围内。 123TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; // 配置为PWM模式1TIM_OCInitStructure.TIM_Pulse = 0; // 设置初始占空比为0TIM_SetCompare1(TIM2, (uint16_t)(dutyCycle * PWM_PERIOD)); // 调整PWM占空比 ADC采样模块：将光伏阵列输出的电压信号通过ADC采样转换为数字信号并读取，再通过与电阻的计算得出电流值，以用于功率计算。值得注意的是，ADC通道需与光伏阵列信号对应，同时为确保采样精度还需事先对ADC模块进行校准。 MPPT算法实现：根据扰动观察法原理，通过电流与电压相乘得到当前输出功率，与上个点的功率相比较，若大于上个点的功率，则继续增大占空比，增加输出电压，从而增加输出功率，若小于，则减小占空比，并在每次调整占空比后再次计算输出功率。循环往复进行上述流程，同时记录功率变化趋势及对应占空比，以寻找最大功率点。值得注意的是，程序中设置的步长STEP_SIZE值应适中，过大会导致振荡，而过小则会影响跟踪的速度，同时还应避免控制过程中PWM波形的占空比超出0~1范围。 在主循环main函数中编写总控代码对上述代码逻辑进行整合，每次循环都会测量电压与电流从而得到功率，再通过进行扰动观察法寻找最大功率点。 8.4 实验现象实验时，将Buck变换器、STM32开发板与光伏阵列进行连接，并确保采样与控制电路正常工作。将代码烧录到STM32开发板，并通过调整光照强度，观察功率点变化及最大功率点跟踪效果。接下来需要进行逐步调试： 使用示波器观察PWM信号及Buck变换器输出电压，验证占空比调节是否正常，并使用万用表验证电压、电流采样值是否准确； 可以看到，此时PWM输出占空比为50%，占空比调节正常；光伏板输出电压为5.1V，电流为0.025A，输入功率约为0.1275W。 通过调整光照强度，观察功率点变化及最大功率点跟踪效果。 可以看到，此时所接负载为200Ω，输出电压为4.5V，输出功率约为0.12W。考虑功率损耗，光伏板输出功率约等于负载消耗功率，完成了对该光照强度下最大功率点（MPP）的准确寻找。 随后又对于该控制系统的动态跟踪性能进行进一步的测试，可以观察到，当外界环境的光照强度改变时，控制系统能快速做出响应并使光伏板输出功率达到最大（约为负载消耗功率），说明控制系统对于最大功率点的实时跟踪性能良好。 8.5 本章小结本章主要介绍了基于直流电源调控的光伏板最大功率点追踪（MPPT）控制系统的设计，设计时主要采用递归算法，每次通过扰动当前功将率与变换前功率作比较，若大，则继续增加占空比，若小，则减少占空比，以此类推，不断循环，从而找到最大功率点。每次变化占空比的步长与延时时间影响找到最大功率点的效率，需要调试找到最佳的相应效率。同时，在步长固定的情况下，通过自适应步长控制算法也可以更有效率的寻找最大功率。通过动态追踪，显著提高了光伏发电效率。 9 总结与展望9.1 课程小结《自动控制原理》课程作为一门项目制课程，重点围绕经典控制相关理论知识及应用实践，有效地将理论教学与设计实践结合起来。通过课程的理论学习与项目实践，我们在实践操作中对于经典控制理论的知识有了更加深刻的理解，建立了”控制”工程观与系统性分析思维，也锻炼了自己将理论应用于工程实践的能力，以及对于控制工程问题的分析与解决能力。 该项目制课程主要分为两个项目板块： 控制基础实践项目为”直流电源控制分析与系统设计”，以直流电源这一经典工程案例串联起经典控制理论知识各版块，涵盖控制系统建模（微分方程与传递函数）、时域分析、根轨迹分析、频域分析，频域校正与PID控制等，从理论分析、仿真、实验三维度强化同一理论知识点的学习，完成直流电源控制系统的分析设计以及调试。这一部分项目在理论课程学习的同时穿插完成，主要涉及到经典控制理论的学习，并将其应用到实际的Buck变换器PI闭环控制系统中、结合实际电路参数完成的PSIM电路仿真与相应的MWorks分析计算。 综合应用实践项目为”基于电源的综合应用系统”，以直流电源驱动系统应用为综合实践项目，运用传感、闭环控制、先进控制等硬件与算法，完成基于直流电源控制的LED自动调光与光伏最大功率跟踪（MPPT）等项目实践。这一部分项目主要以实验方式开展，最终本小组顺利完成实验与设计内容并进行课程项目汇报。 回顾这门课程一路走来，从课程引入与理论教学，到实际实验调试与项目设计，再到最终的项目测试与汇报，我们在理论与实践的结合中扎实掌握了经典控制理论的相关知识，并锻炼了自己的电路设计分析与实践能力。我们能取得如此的进步与成就离不开两位老师与四位助教的辛勤付出，在此再次向各位老师与助教们送上最真诚的感谢，也衷心祝愿这门课程在未来能建设得越来越好。 9.2 课程收获及建议通过《自动控制原理》这门课程的学习，我了解到了许多经典控制理论的相关知识：从系统的数学建模入手，微分方程与传递函数是描述一个控制系统性能的基本工具；为调整系统参数以提高控制系统的稳定性，可从时域与频域两个角度分别进行分析，时域上可以使用劳斯判据进行系统稳定性的判定并根据根轨迹找到系统的临界稳定状态，频域上可以使用奈奎斯特稳定判据或依据Bode图对系统稳定性进行分析；基于频率特性，还可以从频域校正环节的设计层面调节系统的动态响应特性。理论学习之余，课程紧密穿插了相应的仿真与电路调试实验，理论与实践的结合使得我对于这些枯燥的理论知识有了更加生动而深刻的理解。 在课程项目中，我主要负责对于闭环控制系统的理论分析、仿真验证与参数调试，以及课程项目报告绝大部分的撰写。令我印象最深刻的是，在理论部分对系统进行频率特性分析时，使用MWorks根据系统开环传递函数绘制Bode图，得到了穿越频率与相位裕度；而在根据实际电路结构在PSIM中搭建了相应的扫频电路之后，当看到运行扫频仿真得到的结果与MWorks绘制的Bode图几乎完全一致时，我深刻体会到了理论的有效性，这代表理论的分析确实可以真实地指导实际控制系统的设计，在后续项目设计与调试时也充分利用了这一点，有效提高了设计与调试的效率。最终我们也顺利完成了基于直流电源调控的自动调光与MPPT控制系统的设计与实现，并将自动调光系统实例化为一个具有实际应用意义的产品。相信在这门课程中学到的知识与技能能够为我们未来的硬件产品开发中起到重要的作用。 最后感谢两位老师耐心的教学与指导以及四位助教的辛苦付出，特别是几位助教，耐心地回答我们的问题、批改我们的作业并协助我们进行硬件实物的调试，为我们的项目实践提供了丰富的参考资料，帮助我们快速上手项目。在此提出一点小小的建议，这次项目中在电路焊接方面浪费了许多时间，希望未来的课程项目设计能够在各个实现细节上更加完善，在设计与测试时考虑的更加全面；同时希望在理论课程中穿插的各种仿真作业能够与实际的控制系统结合的更加紧密，完善一些逻辑不严谨的地方（如提供的报告框架中，是否考虑电容寄生电阻这点体现的略显混乱）。但总的来说，这门课程确实是已有项目制课程中的精品，也希望能够在未来建设得越来越好。 参考文献[1] 胡寿松主编.自动控制原理[M].科学出版社,2019:a670. [2] 卢京潮主编.自动控制原理习题解答[M].清华大学出版社,2013:195. [3] 王天威编著.控制之美[M].清华大学出版社,2022. [4] 李昆.智能技术在室内LED照明系统中的应用研究[J].光源与照明,2024,(10):51-53. [5] 郑盛梅.恒照度自动调光台灯的设计[J].光源与照明,2023,(01):69-71. [6] 侯耀华,陈萍,於崇干.直流电源系统高级功能在无人值班变电站的应用[J].供用电,2015,(02):19-24. [7] 许桂敏,解皓月,张子泉,等.基于Simulink的光伏电池特性及MPPT算法仿真研究[J].智能建筑电气技术,2024,18(06):36-39+60. [8] 王青苗.PLC模糊PID控制系统在隧道照明节能控制中的应用[J].微型电脑应用,2024,40(06):114-118+122. [9] 陈礼俊,兰志勇.单片机控制的双调控高压直流电源[J].现代电子技术,2017,40(12):165-168. [10] 樊战亭,万欣,王超.太阳能电池板自动追光控制系统设计[J].咸阳师范学院学报,2024,39(06):12-16. [11] Gene F. Franklin, J. David Powell, Abbas Emami-Naeini, et al. Feedback control of dynamic systems[M].Publishing House of Electronics Industry,2013:14,590. [12] Karl Johan Astrom, Richard M. Murray.自动控制多学科视角[M].人民邮电出版社,2010:310. 附录1 STM32闭环PI控制程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &quot;stm32f10x.h&quot; // Device header#include &quot;Delay.h&quot;#include &quot;OLED.h&quot;#include &quot;PWM.h&quot;#include &quot;AD.h&quot;#include &quot;Serial.h&quot;// 定义全局变量#define PWM_FREQUENCY 10000 // PWM频率#define MAX_PWM_VALUE 1000 // PWM最大值#define PWM_PERIOD 3000 // PWM周期为1000个计数单位#define KP 0.1 // 比例增益#define KI 0.01 // 积分增益#define KD 0.01float voltage_ref = 10; // 设定的输出电压 float voltage_fb = 0.0; // 反馈的实际输出电压float duty_cycle = 0.0; // 占空比float error = 0.0; // 误差float integral = 0.0; // 积分项float control_signal = 0.0; // 控制信号float last_error = 0.0; // 上一次的误差float derivative = 0.0; // 微分项int sample_index = 0; // 样本计数器float trueVoltage=0.0; // 实际输出电压值float VREF;uint32_t time_counter = 0; // 用于记录时间的计数器uint8_t voltage_state = 0; // 0 表示电压为8V，1 表示电压为10Vuint16_t ADValue;float Voltage;float i;void control_buck(void){ voltage_fb = (float)AD_GetValue()*3.3/4096; //读取ADC的值 trueVoltage = voltage_fb*1050*20000/2500/1000; // 计算实际电压 (根据外部电路参数) error = voltage_ref*2500*1000/1050/20000 - voltage_fb; // 计算误差 integral += error; // 积分计算 derivative = error - last_error; // 微分计算 control_signal = KP * error + KI * integral + KD * derivative; // PID控制输出 if (control_signal &gt; 0.8) control_signal = 0.8; else if (control_signal &lt; 0.2) control_signal = 0.2; duty_cycle = control_signal * PWM_PERIOD; // 更新占空比 i = (int)duty_cycle; PWM_SetCompare1(i);}int main(void){ OLED_Init(); PWM_Init(); AD_Init(); Delay_ms(10); NVIC_Configuration(); Serial_Init(); // 初始化串口 while (1){ control_buck(); }} 2 自动调光程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &quot;stm32f10x.h&quot; // Device header#include &quot;Delay.h&quot;#include &quot;OLED.h&quot;#include &quot;PWM.h&quot;#include &quot;AD.h&quot;#include &quot;Serial.h&quot;#include &quot;HC05.h&quot;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;// 定义全局变量#define PWM_FREQUENCY 10000 // PWM频率#define MAX_PWM_VALUE 1000 // PWM最大值#define PWM_PERIOD 3000 // PWM周期为1000个计数单位#define KP 0.1 // 比例增益#define KI 0.01 // 积分增益#define KD 0.01float Light_Intensity = 0.0; // 光敏实际模拟量float voltage_ref = 5 * 1.38; // 设定的输出电压 float voltage_fb = 0.0; // 反馈的实际输出电压float duty_cycle = 0.0; // 占空比float error = 0.0; // 误差float integral = 0.0; // 积分项float control_signal = 0.0; // 控制信号float last_error = 0.0; // 上一次的误差float derivative = 0.0; // 微分项//int sample_index = 0; // 样本计数器float trueVoltage=0.0; // 实际输出电压值float VREF;uint32_t time_counter = 0; // 用于记录时间的计数器uint8_t voltage_state = 0; // 0 表示电压为8V，1 表示电压为10Vuint16_t ADValue;float Voltage;float i;uint8_t RxSTA = 1;char RxData[100] = &quot;N&quot;;void control_buck(void){ voltage_fb = (float)AD_GetValue(ADC_Channel_4)*3.3/4096; //读取ADC的值 trueVoltage = voltage_fb*1050*20000/2500/1000; // 计算实际电压 (根据外部电路参数) error = voltage_ref*2500*1000/1050/20000 - voltage_fb; // 计算误差 integral += error; // 积分计算 derivative = error - last_error; // 微分计算 control_signal = KP * error + KI * integral + KD * derivative; // PID控制输出 if (control_signal &gt; 0.8) control_signal = 0.8; else if (control_signal &lt; 0) control_signal = 0; duty_cycle = control_signal * PWM_PERIOD; // 更新占空比 i = (int)duty_cycle; PWM_SetCompare1(i);}int main(void){ OLED_Init(); PWM_Init(); AD_Init(); Delay_ms(10); NVIC_Configuration(); // NVIC初始化 Serial_Init(); // 初始化串口 HC05_Init(); while (1){ // 蓝牙读取开关 HC05_GetData(RxData); if (RxSTA == 0){ if (strcmp(RxData, &quot;LL&quot;) == 0){ RxSTA = 1; while(1){ // 读取光敏模拟输入量 Light_Intensity = (float)AD_GetValue(ADC_Channel_5); voltage_ref = (Light_Intensity * 2 / 3500 + 8) * 1.38; control_buck(); HC05_GetData(RxData); if (RxSTA == 0) break; } } else if (strcmp(RxData, &quot;on&quot;) == 0) voltage_ref = 10 * 1.38; else if (strcmp(RxData, &quot;off&quot;) == 0) voltage_ref = 5 * 1.38; else{ int num = atoi(RxData); if (num &gt;= 0 &amp;&amp; num &lt;= 100) voltage_ref = ((float)num / 100 * 2 + 8) * 1.38; else if (num &gt; 100) voltage_ref = 10 * 1.38; else voltage_ref = 5 * 1.38; } memset(RxData, 0, sizeof(RxData)); strcpy(RxData, &quot;N&quot;); RxSTA = 1; } control_buck(); // 控制输出电压 }}","link":"/2024/12/22/control/"},{"title":"厨余垃圾处理器","text":"以下为课程项目设计产品“厨余垃圾处理器”的结题汇报PPT。","link":"/2024/12/16/rubbish/"},{"title":"基于STM32F407实现的信号发生与采集分析系统","text":"演示视频已上传至Bilibili视频平台：https://www.bilibili.com/video/BV1wUiRYxE8z 一、系统功能与整体架构设计系统实现功能（1）单片机在按键控制下，产生1kHz的正弦波或方波； （2）单片机能够采集波形，并且显示； （3）单片机能够分析采集波形的频谱，并且显示频谱与基波频率。 整体架构设计图 系统主页与按键对应功能简介 每次启动系统都会默认直接进入该主页面： （1）蓝色部分的文字为系统名称与作者姓名，这会在后续的每个功能页面中都有显示； （2）黑色部分的文字为各按键对应的功能介绍。 正如主页的功能介绍栏所示： （1）按下KEY0：PA4引脚开始持续输出1kHz的正弦波信号，并在屏幕上实时显示从PA5引脚采集到的输入信号波形； （2）按下KEY1：PA4引脚开始持续输出1kHz的方波信号，并在屏幕上实时显示从PA5引脚采集到的输入信号波形； （3）按下KEY2：在屏幕上实时显示从PA5引脚采集到的输入信号的频谱分析结果（幅值谱，频率范围为0~1000Hz）； （3）按下KEY3（KEY_UP）：在屏幕上实时显示从PA5引脚采集到的输入信号的频谱分析结果（幅值谱，频率范围为0~8000Hz）。 二、各部分功能实现1、1kHz正弦波与方波的产生模块功能架构设计 在实际单片机编程实现时，导入并调用DSP库加速信号数组（正弦波）的计算，并通过时钟TIM6（分频）控制DMA的数据搬运过程，并设置DAC数模转换将搬运后的信号数字数据在PA4引脚以模拟信号形式输出。 模块功能实现依据为使用单片机产生指定频率的波形，需要根据上述架构设置对应的参数，基本的设置逻辑如下： （1）首先，这里使用定时器TIM6来控制DMA搬移数据的过程，在CubeMX中已预先设置其时钟频率为84MHz； （2）在生成信号数组时，C语言程序中设定数组长度为1024（与后续采集一致，为4的整数次幂以便于进行快速傅里叶变换FFT）； （3）事实上，对于信号数组长度N、定时器频率fT与信号基波频率f而言存在如下关系式：f = fT / N，这意味着以输出基波频率f = 1kH的信号为例，经过时钟分频后的定时器频率fT是可以直接确定的，进而可以确定分频倍数（时钟频率/分频后定时器频率）。 经过计算，当分频倍数设置为82时（实际单片机控制程序中为两次分频，取第一次分频倍数为41、第二次分频倍数为2即二分频），输出的信号基波频率f约为1000（由于数组长度为1024，在分频倍数必须取整的情况下，基波频率无法精准等于1000Hz，实际约为1000.38Hz）。 在MATLAB中，可以编写简单的测试程序模拟这一过程： 12345678TIM6_Frequency = 84000000; %DAC_DMA时钟TIM6频率DAC_DMA_Divide1 = 41; %DAC_DMA时钟一次分频DAC_DMA_Divide2 = 2; %DAC_DMA时钟二次分频DAC_DMA_Frequency = TIM6_Frequency / (DAC_DMA_Divide1 * DAC_DMA_Divide2); %分频后时钟频率N = 1024; %数组长度与采样点数f = DAC_DMA_Frequency / N; %产生信号频率（期望值1000） 模块功能实现效果启动系统后按压按键KEY_0启动正弦波生成，将示波器的通道正极与信号输出引脚PA4连接，示波器的通道负极与单片机的地GND连接，可在示波器上显示出如下波形： 可以看到输出的波形形状为标准的正弦波，输出电平范围为03.3V（对应生成的正弦信号数组振幅为2048、偏置为2047即数据点范围位于04095），均值为1.6V，且周期约为1kHz（示波器显示1.00045kHz；一个周期大致占据五格、每格代表200us即一个周期为1ms）。 按压按键KEY_1切换为生成方波，可在示波器上显示出如下波形： 可以看到输出的波形形状为标准的方波（占空比50%），输出低电平为0V、高电平为3.3V（对应生成的方波信号数组前一半值为0、后一半值为4095），均值为1.6V，且周期约为1kHz（示波器显示1.00043kHz；一个周期大致占据五格、每格代表200us即一个周期为1ms）。 2、波形信号的采集与显示模块功能架构设计 在实际单片机编程实现时，通过定时器控制从PA5引脚读入模拟信号，通过ADC模数转换为数字数组并通过DMA搬运将其存入长度为1024（为4的整数次幂以便于进行快速傅里叶变换FFT）的数组中，存满一次数组即中断一次DMA搬运并将该数组数据（即采集波形）显示在显示屏上，短暂延迟（控制屏幕刷新速度合适）后进行新一轮的信号采集、搬运与波形显示。 模块功能实现依据为使用单片机采集信号数据并以合适的形式将波形显示在显示屏上，需要根据上述架构设置对应的参数，基本的设置逻辑如下： （1）首先，控制ADC1的定时器在CubeMX中已预先设置其时钟频率为84MHz，但根据相关手册与文档，硬件上对于分频后的ADC实际频率有限制，不能高于30MHz，在这样的条件下一般取四分频（仅分频一次，以对应结构体参数hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4实现），即分频后定时器频率为21MHz； （2）其次，根据相关手册与文档，完成一次采样至少会花费12个时钟周期，为调控实际采样频率通常还可以设置额外的时钟周期（库函数限制只能为特定的几个值），即实际的采样频率Fs应为：分频后定时器频率（21MHz）/一次采样花费的时钟周期数（12+额外设置的时钟周期）； （3）事实上，要想控制屏幕上显示的波形不过于松散/密集，需要控制一次采样（填满数组，DMA中断）内包含的信号周期数量，这可以通过将信号产生的定时器频率fT除以采样频率Fs得到； （4）另一方面还需要注意为使得采集到的波形没有失真（频域混叠）现象，要求采样频率Fs与待采集波形频率f满足：Fs≥2f。 经过计算与测试，当额外设置的时钟周期设置为112时（sConfig.SamplingTime = ADC_SAMPLETIME_112CYCLES），一次采样中包含（屏幕上显示）的信号周期约为6，这样的显示效果较为合理；同时此时的采样频率Fs约为42683Hz，远大于待采集波形频率f = 1000Hz的两倍，不会发生频谱混叠。 在MATLAB中，可以编写简单的测试程序模拟这一过程（以正弦信号为例）： 123456789101112131415161718192021222324ADC_Timer_Frequency = 84000000; %ADC时钟频率%硬件限制：要求ADC实际时钟频率不能超过30MHzADC_Divide = 4; %取四分频，分完后达到21MHz满足要求ADC_Frequency = ADC_Timer_Frequency / ADC_Divide; %分频后ADC时钟频率%完成一次采样需要多个时钟周期Collect1 = 12; %固定消耗12次循环，无法更改Collect2 = 112; %可设置额外消耗循环数以调整采样频率Fs = ADC_Frequency / (Collect1 + Collect2); %ADC采样频率Cycle = DAC_DMA_Frequency / Fs; %一次采样采出多少个周期A = 2047; %幅值B = 2048; %直流偏置分量t = 0 : 1 / Fs : (N - 1) / Fs;x = A * sin(2 * pi * f * t) + B;% 绘制原始信号figure;subplot(2,1,1);plot(t, x);title('正弦波信号');xlabel('时间 (秒)');ylabel('幅值'); 运行该MATLAB程序，绘制出一次采样采集到的波形如下图所示： 模块功能实现效果启动系统后按压按键KEY_0启动正弦波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，屏幕上显示采集波形效果如下： 按压按键KEY_1切换为生成方波信号并采集，屏幕上显示采集波形效果如下： 图上的横坐标单位为ms；可以看到屏幕上显示的即为6个周期的信号波形，这与MATLAB的模拟计算结果是完全一致的，且波形无失真。 3、采集波形信号的频谱分析模块功能实现依据在频谱分析与频谱图显示方面，有如下要点需要注意： （1）首先，频谱分析依赖于对于信号的傅里叶变换，在数字信号层面对于离散的数据点则需要采用离散傅里叶变换，但这样的变换计算速度往往很感人，因此需要利用其快速算法，即快速傅里叶变换FFT，MATLAB可直接调用fft函数实现，单片机编程中在DSP库中也有相应的函数可以实现完全相同的过程，但要求信号数组的长度应为4的整数次幂，故先前均选取1024作为发生与采集信号的数组长度； （2）其次，经过FFT变换后会得到一个长度相同（1024）的新数组，其中每一个数字的下标index对应的实际频率应为index*Fs/1024，这意味着如果直接将整个FFT变换结果数组作为频谱图显示到屏幕上，横坐标的跨度实际上为Fs≈42683Hz，为使得频谱图更加直观，需要限制绘制频谱图的频率范围，并对应控制绘制数组中的部分数据； （3）事实上，FFT变换结果的数组中各数值并不是期望的对应频率的幅值，还需要除以数组长度1024（单片机程序中对于起始点只需要除以一半的数组长度即512）才可得到正确的幅值。 由于涉及到信号的基波频率检测以及方波的频谱分析，在KEY_2和KEY_UP按键分别设置了频谱频率范围为01000Hz与08000Hz两种模式。在MATLAB中，可以编写简单的测试程序模拟频谱分析过程并在0~8000Hz的频段上展示频谱： 123456789f_range = linspace(0, Fs, N);%频域横坐标，注意奈奎斯特采样定理，最大原信号最大频率不超过采样频率的一半xk = fft(x) / N; %用fft得出离散傅里叶变换% 计算并绘制频谱subplot(2,1,2);plot(f_range(1:50),abs(xk(1:50)));%画双侧频谱幅度图title('正弦波频谱');xlabel('频率 (Hz)');ylabel('幅度'); 运行该MATLAB程序，绘制出一次采样采集到的波形如下图所示（以正弦信号为例）： 可以看到该信号具有直流分量（频率为0）以及1000Hz除的正弦分量，两者幅值均为2048（与产生波形时的一致）。 除此之外，在单片机编程中，为寻找并在屏幕上打印出信号的基波频率，还需要在显示频率波形的同时完成对于除直流分量外最高幅值对应频率的计算（数组返回最大值对应下表，算法较简单在此省略实现过程）。 模块功能实现效果启动系统后按压按键KEY_0启动1000Hz正弦波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，并按压按键KEY_2可启动短频段0~1000Hz的频谱显示如下： 按压按键KEY_UP可启动长频段0~8000Hz的频谱显示如下： 可以看到此时只有直流分量和1000Hz的正弦分量两个尖峰，与MATLAB模拟计算结果一致。 按压按键KEY_1，切换为1000Hz方波波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，并按压按键KEY_2可启动短频段0~1000Hz的频谱显示如下： 按压按键KEY_UP可启动长频段0~8000Hz的频谱显示如下： 可以看到此时在01000Hz频段只有直流分量和1000Hz的正弦分量两个尖峰，但在08000Hz频段，由于方波实质上是不同频率的正弦信号的叠加，所以频谱会在基波的奇数倍（1、3、5……）处也有尖峰，但尖峰的幅值会远小于基波1000Hz处，且倍数越大幅值越小，这使得按照先前的算法也能识别出基波频率约为1000Hz。 4、补充测试由于还需要对于基波频率在0~1000Hz范围内的任意输入信号进行频谱分析，经过调试后，当输入信号频率为200Hz时，为使得显示波形合理，将ADC环节设置的额外时钟周期由112调整至480，结果如下所示： 200Hz正弦波： 时域： 频域： 短频段（0~1000Hz）： 长频段（0~8000Hz）： 200Hz方波： 时域： 频域： 短频段（0~1000Hz）： 长频段（0~8000Hz）： 在ADC环节额外时钟周期设置为480的情况下，可以计算得出，对于频率为1000Hz的信号，一次采样（即屏幕内显示）包含21个周期（正好为整数），结果如下所示： 1000Hz正弦波： 时域： 频域： 长频段（0~8000Hz）： 1000Hz方波： 时域： 频域： 长频段（0~8000Hz）： 可以看到此时虽然时域上波形显示更加狭窄密集，但是频域上尖峰的变化过程也有了迅速的提升，且测得的基波频率也更加精准。 三、总结通过本次项目实践，不仅在实验中进一步加深了对于数字信号的产生、采集与频谱分析处理过程的理解，特别是通过期望发生信号频率去计算定时器分频系数、采样频率的计算过程以及FFT计算与频谱图像绘制的过程；而且也增加了对于STM32F407单片机开发的实战经验，在巩固了引脚GPIO与时钟配置相关内容的同时，又对于DMA内存搬运及其中断以及DAC数模转换输出与ADC模数转换输入等功能模块有了更深刻的认识，包括定时器对于这些过程的调控也涉及到相关频率的计算，所有模块的配置之间都有着密切的联系。","link":"/2024/12/05/document/"},{"title":"机器学习分类算法项目","text":"摘要本项目围绕机器学习分类算法展开， 以支持向量机（support vector machine，SVM）为主要研究对象，探究其分类性能、模型改进与优化算法。SVM和Logistic回归模型都可以用于解决二分类问题，但模型设计的思路不同，因此希望能够比较两者在分类性能上的差异。项目过程中代码完全基于R语言实现，主要以二维样本数据为研究对象，生成模拟数据并基于经典硬间隔SVM模型和Logistic回归模型分别进行建模与训练，在测试集上对模型进行验证，最终比较两者的分类效果差异。实验结果表明，当样本数据本身区分度不明显时，两种分类模型效果均较差，但Logistic模型明显优于经典硬间隔SVM；当样本数据本身具有明显的差异性时，两种分类模型效果均较好，SVM略优于Logistic。此外，还对改进后的SVM模型（核函数由线性函数更换为高斯核函数）进行性能测试，发现其在区分度不明显的数据集上显著优于经典硬间隔SVM，说明其显著提升了其在非线性可分数据上的分类效果；但在区分度较明显的数据集上分类效果反而略逊于经典SVM模型。最后，对两篇有关SVM改进模型的文献进行了阅读与调研，总结了软间隔SVM模型在正则项和损失项拓展方面的研究进展，并介绍了柔性套索惩罚和快速截断Huber损失等改进方法。 关键词: 机器学习分类算法、二分类、支持向量机（SVM）、Logistic回归、硬间隔、软间隔、高斯核函数、改进的SVM模型、柔性套索惩罚、快速截断Huber损失、R语言 项目概述问题背景人工智能的概念是在1956年首次被提出，其目标旨在希望通过计算机模拟人的思维能力或智能行为，从而让计算机能够像人类一样进行思考。目前，人工智能已经在机器翻译、智能控制、图像识别、语音识别、游戏博弈等领域得到广泛的应用。 机器学习作为人工智能的一个发展方向，起源于20世纪50年代的感知机数学模型，其目标是使得机器能够像人类一样具有学习能力。机器学习的基本过程主要是基于样本数据（客体）去训练/学习某个模型或决策函数（主体）。一般而言，正则化框架下的机器学习过程主要由学习机、损失项和正则项（惩罚项）三个部分构成，最终通过学习得到模型。 支持向量机(support vector machine，SVM)最早由Cortes和Vapnik二人于1995年为解决二分类问题而提出[^1]。作为经典的机器学习模型之一，SVM有坚实的统计理论基础，算法实现容易，且决策函数具有很强的几何含义。由于其在模式识别等数据分析问题中的优越表现，SVM如今已成为最经典的判别分析方法之一。与SVM相类似，广义线性回归统计模型中的Logistic回归模型同样也可用于解决二分类问题。本质上来说，两种方法都注重研究一组协变量X_1, …, X_p是如何影响二元的响应变量Y的，在用途上具有极大的相似性，因而希望研究并比较两者分类效果的差异性。 除此之外，SVM作为一种经典且基础的机器学习算法，在漫长的发展历程中也经历了多次迭代，有多种多样的改进版本。最基本的版本为硬间隔SVM，但由于实际的样本数据很可能不满足线性可分的理想情况，又发展出了采用不同求解算法的软间隔SVM模型以及基于核函数升维思想实现的非线性SVM，基于软间隔SVM模型又集中在模型损失项与正则项两个方面进行了理论上的拓展。这样的发展是永无止境的，在此希望对过去的部分研究改进成果进行理论总结与代码实现，以更好地了解SVM模型的发展现状。 项目任务在本次项目中，需要随机生成模拟数据，并在该样本数据基础上分别利用经典SVM模型与Logistic模型进行统计建模，同时对比两者的分类效果；此外还需要总结并实现部分改进版本的SVM算法，分析其预测效果。具体而言可细分为如下任务： 任务1:随机生成200条模拟数据并将其分为训练数据集与测试数据集，利用训练数据集分别基于经典硬间隔SVM模型与Logistic广义线性回归模型建立统计模型，实现样本数据的分类且在测试数据集上进行验证，比较两者的分类效果差异。 任务2:代码实现某一种改进版本的SVM模型，简单测试其性能并将其分类结果与经典版本进行对比。 任务3:查阅SVM模型改进相关的文献，基于正则化框架对于文献中涉及的模型（学习机、损失项、正则项）、创新点与求解算法进行重述与总结。 项目过程本项目代码部分完全基于R语言实现，主要涉及样本模拟数据的生成，以及SVM（经典与改进版本）与Logistic回归模型的建立、训练与测试。 模拟数据生成本项目中涉及到的样本数据完全由模拟方法生成。具体而言，不论是SVM还是Logistic回归模型，其目的都是为了研究一系列协变量对于一个二元的响应变量的影响。为方便起见，选择采用协变量的维度为二维，即二元响应变量Y只由两个变量X_1, X_2决定。在生成数据时，为了较好地区分出两类数据，分别在正态总体下以均值为0和均值为1生成两组模拟数据（同一条数据中的两个变量X_1, X_2来自同一均值的总体），并分别打上分类标签（即对应Y的取值为）0或1： 123456789101112set.seed(123) #设置随机种子，固定每次运行程序生成的随机数，使结果可重复n &lt;- 200 # 每个类别的数据点数# 生成类别0的数据x1 &lt;- matrix(rnorm(n * 2, mean = 0), ncol = 2)y1 &lt;- rep(0, n)# 生成类别1的数据x2 &lt;- matrix(rnorm(n * 2, mean = 1), ncol = 2)y2 &lt;- rep(1, n)# 合并数据x &lt;- rbind(x1, x2)y &lt;- c(y1, y2) 绘制样本点对应的散点图，初步观察其分类情况： 12345678910111213141516171819# 加载 ggplot2 包library(ggplot2)# 创建数据框data &lt;- data.frame(x1 = x[, 1], x2 = x[, 2], y = factor(y))# 设置点的大小和透明度p &lt;- ggplot(data, aes(x = x1, y = x2, color = y)) +geom_point(size = 3, alpha = 0.7) + # 调整点的大小和透明度scale_color_manual(values = c(&quot;blue&quot;, &quot;red&quot;)) +labs(x = &quot;x1&quot;, y = &quot;x2&quot;, color = &quot;Class&quot;) +theme_minimal()# 调整背景和边界线p + theme(panel.background = element_rect(fill = &quot;white&quot;, color = &quot;black&quot;),panel.border = element_rect(color = &quot;black&quot;, fill = NA),axis.line = element_line(color = &quot;black&quot;))ggsave(&quot;2.png&quot;, plot = p, width = 6, height = 6, units = &quot;in&quot;, dpi = 300) 观察上左图可知，由于基于正态总体生成模拟数据时仅制定了均值而未指定方差（默认为1），导致令均值为0和1的情况下两类数据没有办法明显的区分开来，这样的分类效果显然是不好的。经过调试，当设置两类数据均值分别为0和5时，数据点呈现良好的区分性（如上右图所示）。 为便于后续的模型训练，还需要将样本模拟数据分成训练集与测试集两部分，根据经验，较为合适的数据集数量比例为7：3，即样本数据中的70%为训练集，另外30%为测试集用于验证。 12345678910# 将数据分为训练集和测试集train_index &lt;- sample(1:(2 * n), 0.7 * 2 * n)x_train &lt;- x[train_index, ]y_train &lt;- y[train_index]x_test &lt;- x[-train_index, ]y_test &lt;- y[-train_index]# 合并 train_data &lt;- cbind(x_train, y_train)test_data &lt;- cbind(x_test, y_test) 在此对部分训练集数据进行罗列： 12#观察数据集head(train_data,10) x.1 x.2 y 1 5.8641525 2.78936689 1 2 -1.9666172 -0.72306597 0 3 0.8215811 -0.57438869 0 4 -1.2512714 0.84573154 0 5 1.3686023 0.09049665 0 6 -0.2153805 2.41677335 0 7 6.0466288 5.10719041 1 8 1.0057385 0.68430943 0 9 4.6738561 3.67224452 1 10 -0.4727914 -1.28471572 0 基于经典硬间隔SVM模型的建模硬间隔支持向量机是一种基于线性可分数据集的分类模型。线性可分，意味着可用一条直线将两类数据分开。显然这样的直线有无穷多条，但对应直线的上下移动又因分类要求的限制而存在极限位置。因此，硬间隔支持向量机所要解决的关键问题就是，如何从无穷多条直线（对应无穷多个分类器）中选择最优？ 实际上，具有”最大间隔”的分类器就是SVM要寻找的最优解，而最优解对应的两侧虚线（上下极限状态）所穿过的样本点，就是SVM中的支持样本点，称为&quot;支持向量&quot;。SVM中寻找最优分类器的问题，本质上是一个优化问题。对于一般的优化问题，往往有3个基本要素需要重点关注： 目标函数:希望优化的目标指标； 优化对象:期望通过改变哪些因素（协变量）使目标函数达到最优； 约束条件:优化对象一般需要满足一些特定的约束条件。 假定$${ {({x_i}^T,y_i)} }_{i=1}^n$$表示一个二分类数据集，其中第i个样本x_i ∈ R^p，样本对应的标签y_i ∈ {-1,+1}, i=1, …, n。对于优化对象x_i而言，可以根据解析几何的基本知识构造其分类器（超平面）的一般表达式： $$w_1x_1+\\cdots+w_px_p+b=w^Tx+b=0$$其中$$w={(w_1,\\cdots,w_p)}^T$$为该超平面的法向量，b为超平面的截距。 显然，SVM中的优化对象就是上述分类器，或者说超平面中的参数w, b。在本项目的模拟数据中，令样本协变量维度p=2，此时分类器为R^3上的平面。 在线性SVM算法中，目标函数显然就是”分类间隔”，即目标是最大化“分类间隔”W=2d (如下图所示)。其中d表示“支持向量”到最优分类器的距离，最大化W等价于最大化d。 最后是约束条件的确定。首先要考虑的就是，如何判断超平面是否将样本点正确分类？此外，目标函数本质上是求距离d的最大值，要确定约束条件，还必须要找到哪些是”支持向量”。总而言之，对于目标函数d的取值范围受到的限制和约束条件的确定，关键问题是如何将其数学化。 以上述平面上的分类问题为例：对任意一点x_i，其到最优分类直线的距离为$$d_i=\\frac{|w^Tx_i+b|}{||w||}$$一方面，如果此时最优分类直线确实实现了分类目标，则所有样本点(y_i =1 or -1)必定都要满足约束(d 为最优距离)：$$d_i=\\frac{|w^Tx_i+b|}{||w||}\\geq d \\Leftrightarrow \\begin{cases} \\frac{w^Tx_i+b}{||w||}\\geq d,\\ y_i=1\\ \\ \\frac{w^Tx_i+b}{||w||}\\le-d,\\ y_i=-1 \\end{cases} \\Leftrightarrow \\ y_i\\bullet\\frac{w^Tx_i+b}{||w||}\\geq d\\ \\Leftrightarrow \\frac{1}{||w||d}\\bullet y_i(w^Tx_i+b)\\geq1$$注意到:$$w^Tx+b=0与\\frac{1}{||w||d}\\bullet(w^Tx+b)=0$$本质上代表同一个超平面，因此上述约束条件可以等价改写为：$$y_i(w^Tx_i+b)\\geq1$$另一方面，注意到”支持向量”都是位于最优分类超平面上，即若点(x_i, y_i)为”支持向量”，则必有：$$w^Tx_i+b=1$$于是最大化目标函数(“支持向量”到最优分类超平面的间隔)，等价于最大化：$$\\frac{1}{||w||}$$也等价于最小化：$$\\frac{1}{2}{||w||}^2$$综上所述，硬间隔SVM的基本数学模型可以描述为如下不等式约束的二次型函数的约束优化问题：$$\\begin{cases} \\mathop{min}\\limits_{w,b}{ {\\frac{1}{2}||w||}^{2} }\\ st:\\ y_i(w^Tx_i+b)\\geq1,\\ i=1,\\cdots,n \\\\end{cases}$$该优化问题由于受不等式约束，因此求解过程中还需要考察拉格朗日对偶问题和KKT条件。基于不等式约束的凸优化问题，可以基于拉格朗日对偶问题和KKT条件，然后利用SMO算法求解,得到最优w*, b*，从而可构造最优分类超平面：$${(w^\\ast)}^Tx+b^\\ast=0$$对待分类的样本点x，根据以下决策函数来进行分类判别$$f(x)=sgn({(w^\\ast)}^Tx+b^\\ast)$$即当$${(w^\\ast)}^Tx+b^\\ast&gt;0$$时返回0，否则返回1。 基于以上理论， 可实现经典硬间隔SVM模型建构。在R语言中，e1071程序包内的svm()函数是对于经典硬间隔SVM模型的封装实现，其基本用法如下： 12# 训练 SVM 模型model &lt;- svm(formula,data,labels,scale=TRUE/FALSE,kernel,gamma=g,degree=d,cost=C,epsilon=0.1,na.action=na.omit/na.fail) 其中： formula:拟合公式，以R公式的形式指定输出变量和输入变量，其格式一般为：输出变量名 输入变量名； data:训练数据集（各协变量），通常是一个数据框或矩阵； labels:标签数据（二元响应变量），通常是一个因子向量，用于指定那些将被用来训练模型的采样数据; scale:逻辑向量，指定特征数据是否需要标准化(默认标准化为均值0，方差1)，默认为True; kernel:核函数类型， 常用的有&quot;linear&quot;、&quot;polynomial&quot;、&quot;radial&quot; (RBF) 和 &quot;sigmoid&quot;; gamma:用于指定多项式核以及径向基核中的参数，默认gamma是线性核中的常数项，等于1/p(p为特征空间中的维度); degree:用于指定多项式核中的阶数d; cost:惩罚参数，用于控制误分类的惩罚程度; epsilon:用于指定支持向量回归中的带，默认值为0.1; na.action:用于指定当样本数据中存在无效的空数据时系统应该进行的处理，默认值na.omit表明程序会忽略那些数据缺失的样本；另外一个可选的赋值是na.fail，它指示系统在遇到空数据时给出一条错误信息。 硬间隔支持向量机（Hard-Margin SVM）是支持向量机的一种特殊情况，适用于数据完全线性可分的情况。它通过最大化间隔来找到一个分离超平面，使得所有数据点都在间隔之外且没有误分类点。为实现经典的硬间隔SVM模型，可以将svm()函数的参数如下设置： 1234# 训练硬间隔SVM模型library(e1071) # 需要先导入e1071库cost_value &lt;- 1e5 # 设置 cost 为一个非常大的值，从而确保没有误分类svm_model &lt;- svm(x_train,y_train, type = &quot;C-classification&quot;, kernel = &quot;linear&quot;, cost = cost_value, scale = FALSE) 可以通过summary()方法查看训练出的模型的信息： 1234567891011121314summary(svm_model) Call:svm.default(x = x_train, y = y_train, scale = FALSE, type = &quot;C-classification&quot;,kernel = &quot;linear&quot;, cost = cost_value)Parameters:SVM-Type: C-classification #模型类别SVM-Kernel: linear #模型使用的核函数cost: 1e+05 #模型确定的约束违反成本Number of Support Vectors: 2 ( 1 1 ) #模型找到的支持向量数量，两类各有一个Number of Classes: 2Levels: 0 1 #模型中分类的目标类别 至此已经基于训练集数据完成了经典硬间隔SVM模型的建立与训练过程。 基于Logistic回归模型的建模与SVM模型类似，Logistic回归模型也旨在研究协变量X_1, …, X_p是如何影响响应变量y的。但不同的是，Logistic作为广义线性回归模型的一种，本质上还是基于”回归”的基本思想，在多元线性回归的基础上进行调整从而能够处理离散的二元数据。 假定对二元响应变量y有n次观测：$$\\ y_i \\sim B(1,\\mu_i),\\ i=1,\\cdots,n$$显然其均值方差分别为：$${E(y}i)=\\mu_i;\\ Var(y_i)=\\mu_i(1-\\mu_i)$$同时，对协变量X_1, …, X_p也有n次观测，且记其线性组合分别为：$$\\eta_i=\\beta_0+x{i1}\\beta_1+\\cdots+x_{ip}\\beta_p=x_i^T\\beta,\\ i=1,\\cdots,n$$其中：$$x_i={(1,x_{i1},\\cdots,x_{ip})}^T, \\beta={(\\beta_0,\\beta_1,\\cdots,\\beta_p)}^T$$在多元线性回归的过程中，由于响应变量y连续，因此可以直接令其均值E(y)等于协变量与未知参数的线性组合η；但对于二元（取值仅存在0或1两种情况）的响应变量而言，这样简单粗暴的处理方式显然是不合适的，需要在原来的方法上做推广，即”广义”的线性回归模型：既然无法直接令两者相等，不妨寻找一个链接函数，将多元线性回归中值域为R的协变量线性组合$$\\eta_i=x_i^T\\beta$$映射到μ_i ∈ (0*,* 1)区间上，从而便于分类过程的实现。 具体而言，在建立广义线性回归模型的过程中，需要在多元线性回归的基础上选取合适的链接函数g(•)把y_i的期望µ_i = E(y)和协变量的线性组合η _i = x_i^T * β联系起来，使得g(µ _i) = η _i。这样的链接函数应该具有良好的性质（如光滑等），才便于后续计算。 针对二元响应变量的分类过程，常用的连接函数为Logistic链接函数：$$g(x)=ln{\\frac{x}{1-x}},\\ x\\in(0,1)$$基于Logistic链接函数构造的广义线性回归模型即为Logistic回归模型，其基本内容如下：$$\\begin{cases} y_i \\sim B(1,\\mu_i), i=1,\\cdots,n \\ g(\\mu_i)=\\mu_i=x_i^T\\beta \\end{cases}$$事实上，基于给定的样本数据（训练集数据），训练模型的过程即为对未知参数向量β进行极大似然估计的过程，但与线性模型不同的是，该模型中极大似然估计并没有显式解，因此需要基于特定的算法进行数值求解，一般采用Newton-Raphson迭代算法，这里不详细展开求解过程。 在R语言中，Logistic模型的训练由基本包中自带的glm()函数实现，其基本用法如下： 12# 训练广义线性模型model &lt;- glm(formula, data = mydata, family = family(link = &quot;link_function&quot;)) 其中： formula:表示响应变量与解释变量的关系公式，如y ∼ x1 + x2； data:所用的数据集（需要为数据框格式来识别特征和标签）； family:表示所拟合的GLM模型类型，包括（但不限于）高斯、二项分布、泊松分布等; link:表示链接函数，常见的有&quot;identity&quot;、”logit”、&quot;log&quot;等。 为实现广义回归模型中的Logistic回归模型，可按照如下方式进行调用： 12345# 将训练数据转换为数据框train_data &lt;- data.frame(x = x_train, y = as.factor(y_train))# 训练Logistic回归模型logistic_model &lt;- glm(y ~ ., data = train_data, family = binomial) 同样采用summary()方法查看训练模型的信息： 123456789101112131415161718192021summary(logistic_model)Call: # 调用信息, 说明模型使用了二元逻辑回归和所有特征。glm(formula = y ~ ., family = binomial, data = train_data)Coefficients: # 估计值、标准误差、z值和p值的表格。(Intercept) -169.33 32205.14 -0.005 0.996# 截距项的估计值、标准误差、z值和p值。x.1 15.32 5873.78 0.003 0.998# 第一个特征x.1的估计值、标准误差、z值和p值。x.2 63.10 13139.18 0.005 0.996# 第二个特征x.2的估计值、标准误差、z值和p值。(Dispersion parameter for binomial family taken to be 1)# 二项分布的离散参数被设定为1。Null deviance: 3.8815e+02 on 279 degrees of freedom# 零偏差：模型中只有截距时的偏差, 279个自由度。Residual deviance: 6.1211e-08 on 277 degrees of freedom# 残差偏差：模型拟合后的偏差, 277个自由度。AIC: 6 # AIC 值（信息准则）, 用于模型选择。Number of Fisher Scoring iterations: 25 # Fisher评分算法的迭代次数。 至此已经基于训练集数据完成了Logistic回归模型的建立与训练过程。 二者分类效果的比较前文在生成模拟数据的过程中提到，若生成时设置的正态总体均值差异不同，其聚集效果也会不同，在默认方差为1的情况下，设置均值为0和1的数据点区分不明显，而设置均值为0和5的数据点区分明显。在模型效果测试中，为保证模型聚合等多方面因素，分别选用均值为0和1（数据点区分不明显），以及均值为0和2.8的数据（数据点区分明显）进行模型训练与性能测试。 首先是选用均值为0和1的数据，即标签为0的数据应聚集在点(0, 0)附近，标签为1的数据应聚集在点(1, 1)附近。将训练好的模型应用于测试集上并计算其分类准确率，同时绘制其分类结果与分类器效果图像： 12345678910# 使用SVM模型进行预测svm_predictions &lt;- predict(svm_model, x_test)# 计算SVM模型的分类准确率svm_accuracy &lt;- sum(svm_predictions == y_test) / length(y_test)# 使用Logistic回归模型进行预测logistic_probabilities &lt;- predict(logistic_model, newdata = data.frame(x = x_test), type = &quot;response&quot;)logistic_predictions &lt;- ifelse(logistic_probabilities &gt; 0.5, 1, 0)# 计算Logistic回归模型的分类准确率logistic_accuracy &lt;- sum(logistic_predictions == y_test) / length(y_test) 运行程序，得到该情况下SVM模型的分类准确率为0.525，Logistic回归模型的分类准确率为0.767。结合观察图像可知，此时对于区分不明显的数据，两个模型的分类效果都较差（90%以下），但Logistic回归模型在数据区分不明显的情况下分类性能要明显优于经典硬间隔SVM模型。 然后选用均值为0和2.8的数据，即标签为0的数据应聚集在点(0, 0)附近，标签为1的数据应聚集在点(2*.8, 2.*8)附近。将训练好的模型应用于测试集上并计算其分类准确率，同时绘制其分类结果与分类器效果图像： 运行程序，得到该情况下SVM模型的分类准确率为0.967，Logistic回归模型的分类准确率为0.950。结合观察图像可知，此时对于区分较明显的数据，两个模型的分类效果都较好（90%以上），但经典硬间隔SVM模型在数据区分较明显的情况下分类性能会略优于Logistic回归模型，但总体而言差异并不是很大。 改进后SVM模型的性能测试上述内容中用到的经典硬间隔SVM模型实际上对于数据有着较高的要求，其实现依赖于样本数据为线性可分这一假设条件，但现实中的实际数据往往很难满足这一点，这也是其缺陷所在。针对不是线性可分的数据，Cortes和Vapnik采用了一种非常巧妙的方式进行改进，即借助函数映射，将低维数据映射到高维空间中，使得在低维空间原来不能线性可分的数据，在高维空间变得线性可分，且可以证明这样的映射始终存在。 具体而言，构造升维函数：$$K(x,z)=\\varphi(x)\\bullet\\varphi(z)$$并构造相应的非线性SVM：$$\\begin{cases} \\mathop{min}\\limits_{w,\\ b,\\ \\delta_i} { {\\frac{1}{2}||w||}^2} \\ st:\\ y_i(w^TK(x_i,z)+b)\\geq1,\\ \\ i=1,\\cdots,n \\end{cases}$$相应的最优分类超平面为：$${(w^\\ast)}^TK(x_i,z)+b^\\ast=0$$这里选择高斯函数(径向基函数RBF)作为核函数，将每一个样本点映射到一个无穷维的特征空间从而实现降维，构造改进的SVM模型：$$K(x, x’) = \\exp\\left(-\\gamma | x - x’ |^2\\right)$$高斯核函数实现的功能是：先将原始的数据点(x, y)映射为新的样本(x′, y′)，再将新的特征向量点乘(x′, y′)，返回其点乘结果。其主要目的是找到更有利分类任务的新的空间，本质是在衡量样本和样本之间的”相似度”，在一个刻画”相似度”的空间中，让同类样本更好的聚在一起，进而线性可分。 在R语言中，要实现高斯核函数，仅需将调用的svm()函数中的参数进行改变： 12# 训练改进后的非线性SVM模型svm_model_modify &lt;- svm(x_train,y_train, type = &quot;C-classification&quot;, kernel = &quot;radial&quot;, gamma = 2, cost = 1, scale = FALSE) 其中核函数类型的参数kernel由原先的线性函数”linear”更换为高斯核函数”radial”，并对核函数中的参数gamma以及控制误分类的惩罚参数cost进行了相应调整。 在样本数据区分不明显（即总体均值设置为0和1）的情况下，运行程序，得到改进后的非线性SVM模型的分类准确率为0.767，与Logistic回归模型在该样本下的分类准确率一致，较原先经典硬间隔SVM的预测准确率0.525有显著提升。改进后模型的分类效果如下图所示。 在样本数据区分较明显（即总体均值设置为0和2.8）的情况下，运行程序，得到改进后的非线性SVM模型的分类准确率为0.958，虽然仍优于Logistic回归模型在该样本下的分类效果，但较原先经典硬间隔SVM的预测准确率0.967有略微下降。尽管如此，改进后的模型分类准确率仍然在0.95以上，具有良好的分类效果。改进后模型的分类效果如下图所示。 文献调研硬间距SVM要求构建的分类超平面完全正确的分类所有训练数据，但由于实际样本被假设成线性可分的条件太强，为避免过拟合，更多时候需要考虑软间距（soft-margin）SVM模型。 所谓软间距，就是允许一些点不满足线性可分的约束条件，即：$$y_i\\left(w^Tx_i+b\\right)&lt;1$$当然，为保证拟合模型仍然为一种SVM方法的”本性”，我们希望这样的点不能太多，因此要对违反约束的样本点(x_i, y_i)施加一定的非负惩罚（松弛变量）δ_i：$$\\delta_i=max{0, 1-y_i\\left(w^Tx_i+b\\right)}= \\begin{cases} 0, y_i\\left(w^Tx_i+b\\right)\\geq1\\ \\ 1-y_i\\left(w^Tx_i+b\\right),\\ y_i\\left(w^Tx_i+b\\right)&lt;1 \\end{cases}$$这样就可以得到软间隔SVM的基本数学模型：$$\\begin{cases} \\mathop{min}\\limits_{w,\\ b,\\ \\delta_i} { {\\frac{1}{2}||w||}^2+c\\sum_{i=1}^{n}\\delta_i} \\ st:\\ y_i(w^Tx_i+b)+\\delta_i\\geq1,\\ \\delta_i\\geq0,\\ i=1,\\cdots,n \\end{cases}$$值得注意的是，每一个样本都有一个对应的松弛变量，表征该样本不满足约束的程度；c&gt;0为惩罚参数，其值越大，对分类的惩罚越大。跟硬间隔SVM一样，先用拉格朗日乘子法得到拉格朗日函数，再求其对偶问题。 在正则化的框架下，软间隔SVM的基本数学模型结构还可改写为：$$\\mathop{min}\\limits_{w,\\ b,\\ \\delta_i} { {\\frac{1}{2}||w||}^2+c\\sum_{i=1}^{n}\\delta_i}$$其中学习机、损失项、正则化项分别定义为： 学习机：$$f\\left(w\\right)=w^Tx+b$$ 损失项：$$c\\sum_{i=1}^{n}\\delta_i$$ 正则项：$$\\frac{1}{2}w^Tw={\\frac{1}{2}||w||}^2$$ 基于软间隔SVM模型，理论上的拓展主要集中在模型损失项与正则项两个方面，针对这两个方面，接下来将分别选取一篇文献，对其改进模型、求解算法与创新点进行简单的书面总结。 正则项拓展：柔性套索惩罚[^2]模型重述柔性套索（Pliable lasso）是一种新的互动模型，由Robert Tibshirani和Jerome Friedman于2018年提出。该模型是原始套索问题的扩展，允许套索回归模型接受修改变量、预测因子和结果。原始的套索（Lasso）问题本质上是将1-范数作为正则项，而柔性套索是在此基础上的改进。1-范数支持向量机的缺点之一是，在一些输入高度相关的情况下，并且所有输入都与输出相关，1-范数惩罚最终会挑选出少数输入，并将其余的减少到零，这意味着”群体选择”将是对1范数支持向量机的挑战。 柔性套索惩罚允许估计协变量X的主要影响以及协变量与一组修饰符Z之间的相互作用影响，以处理相互作用效应。为了处理变量选择并帮助选择相关变量组，引入修正变量Z，并将柔性套索作为正则项（惩罚项），得到具有柔性套索惩罚的SVM目标函数：$$\\min_{\\beta, h} \\left( \\frac{1}{n} \\sum_{i=1}^n (1 - y_i (\\beta_0 + x_i^T \\beta))+^2 + \\lambda_1 \\left( \\sum{j=1}^p |\\beta_j|1 + \\sum{j=1}^p |h_j|_1 \\right) + \\frac{\\lambda_2}{2} \\left( |\\beta|2^2 + \\sum{j=1}^p |h_j|_2^2 \\right) \\right)$$其中，学习机、损失项和正则化项（惩罚项）定义如下： 学习机：$$y = \\beta_0 + Z h_0 + \\sum_{j=1}^p X_j (\\beta_j + Z h_j) + \\epsilon_i$$ 损失项：损失平方和（hinge函数）$$\\frac{1}{n} \\sum_{i=1}^n (1 - y_i (\\beta_0 + x_i^T \\beta))^2$$ 正则项：柔性套索惩罚$$\\lambda_1 \\left( \\sum_{j=1}^p |\\beta_j|1 + \\sum{j=1}^p |h_j|_1 \\right) + \\frac{\\lambda_2}{2} \\left( |\\beta|2^2 + \\sum{j=1}^p |h_j|_2^2 \\right)$$ 求解算法与创新点在目标函数优化的求解过程中， 主要使用块方向坐标下降过程（the block-wise coordinate descent procedure）优化目标函数： 本篇文章在过去已有模型的基础上再次进行了改进，创造性地把柔性套索（优化后的1-范数）作为惩罚项（正则项）引入软间隔SVM模型中，创新点有如下几条： 可调套索惩罚的应用：将可调套索惩罚应用于支持向量机，能够有效估计协变量与修饰变量之间的交互作用。 交互项排除机制：通过可调套索，能够在相应主效应为零时自动排除交互项，提高模型的解释性和简洁性。 平方铰链损失结合块坐标下降算法:使用该组合优化目标函数，在模拟和实际数据（结肠癌和前列腺癌数据集）上验证了方法的有效性。 损失项拓展：快速截断Huber损失[^3]模型重述支持向量机作为一种有用的分类工具，在许多领域得到了广泛的应用。然而，在非常大的样本数据集上，它可能会导致计算上的不可行性。为了解决这一问题，该文章提出了一种新颖的带有截断Huber损失的稀疏鲁棒支持向量机模型，即L_th-SVM，其基本数学模型如下：$$\\min_{w \\in \\mathbb{R}^n, b \\in \\mathbb{R}} \\frac{1}{2} |w|^2 + \\gamma \\sum_{i=1}^m \\ell_{th}(1 - y_i(\\langle w, x_i \\rangle + b))$$也可写作：$$\\min_{w \\in \\mathbb{R}^n, b \\in \\mathbb{R}} \\frac{1}{2} |w|^2 + \\gamma \\sum_{i=1}^m \\ell_{th}(h)$$其中，学习机、损失项和正则化项（惩罚项）定义如下： 学习机：$$h:= \\mathbf{1} - \\mathcal{G}\\mathbf{w} - b\\mathbf{y} \\in \\mathbb{R}^{m},其中\\begin{aligned} \\mathcal{G} &amp;:= \\left[ \\begin{array}{cccc} y_{1}x_{1} &amp; y_{2}x_{2} &amp; \\cdots &amp; y_{m}x_{m} \\end{array} \\right]^{\\top} \\in \\mathbb{R}^{m \\times n} \\end{aligned}$$ 损失项：快速截断Huber损失（Truncated Huber Loss）：$$\\ell_{\\text{th}}(t) = \\begin{cases} 1, &amp; \\text{if } t &gt; 1 + \\frac{\\delta}{2}, \\ t - \\frac{\\delta}{2}, &amp; \\text{if } t \\in \\left[\\delta, 1 + \\frac{\\delta}{2}\\right], \\ \\frac{t^2}{2\\delta}, &amp; \\text{if } t \\in [0, \\delta), \\ 0, &amp; \\text{if } t &lt; 0.\\end{cases}$$ 正则项：L2正则化$$\\frac{1}{2}w^Tw={\\frac{1}{2}||w||}^2$$ 求解算法与创新点针对L_th-SVM问题，文章提出了一种新颖高效的乘子与工作集交替方向的方法L_th-ADMM)，证明了L_th-ADMM产生的序列是L_th-SVM的局部最小值，并且在工作集很小的情况下具有较低的计算复杂度。大量的数值实验表明，L_th-ADMM能够提供更高的预测精度，提供更少的支持向量，并且运行速度快，特别是在大规模数据集设置中。其求解算法大致如下： 本文的创新点主要包括以下几个方面： 截断Huber损失函数的提出：提出了一种新的截断Huber损失函数，该函数能够在保持稀疏性的同时，增加对异常值的鲁棒性。与现有的hinge损失、huberized pinball损失和Huber损失相比，截断Huber损失函数在稀疏性和鲁棒性方面表现出更优的性能。 稀疏鲁棒SVM模型的构建：基于截断Huber损失函数，构建了新的稀疏鲁棒支持向量机模型（Lth-SVM）。该模型不仅继承了SVM分类能力强、理论框架完善等优点，还通过引入截断Huber损失函数提高了模型的稀疏性和鲁棒性，使其在处理大规模分类问题时更加有效。 一阶最优性条件的建立：为L_th-SVM模型建立了基于新引入的P-稳定点的一阶必要和充分条件，定义了L_th支持向量和工作集。这些条件为算法设计提供了理论基础，同时也证明了所有L_th-SVM支持向量仅占整个训练集的一小部分，这为后续开发高效算法提供了可能。 L_th-ADMM求解算法的设计：提出了一种具有工作集的新型交替方向乘子法（L_th-ADMM）来求解L_th-SVM。该算法通过引入工作集策略，显著降低了每次迭代中的计算复杂度，使得算法在处理大规模数据集时能够快速收敛。同时，理论证明表明，该算法生成的序列能够收敛到L_th-SVM的一个局部极小值。 参考文献[^1]: Cortes C, Vapnik V. Support-vector networks[J]. Machine learning, 1995, 20(3): 273-297.[^2]: Asenso, T. Q., Wang, P., &amp; Zhang, H. (2022). Pliable lasso for the support vec- tor machine. Communications in Statistics - Simulation and Computation, 53(2), 786–798.[^3]: Huajun Wang, Yuanhai Shao, Fast truncated Huber loss SVM for large scale clas- sification, Knowledge-Based Systems, Volume 260, 2023.","link":"/2024/06/29/project2/"},{"title":"产品质量管理项目","text":"摘要本项目的核心任务是通过统计过程控制（SPC）方法，对某工厂生产的滚珠直径数据进行产品质量管理，评估产品工艺水平及其生产过程是否受控。统计过程控制作为一种基于概率统计的过程控制方法，自1924年由Shewhart博士提出控制图以来，已广泛应用于现代制造过程的质量控制中。本项目基于Matlab软件开发，对于收集到的数据，通过描述性统计分析、正态性检验、总体均值检验、工序能力指数计算与绘制均值控制图和方差控制图等多种方式，对数据进行全面分析，最终评估工艺水平及生产过程的受控状态。具体而言，首先，在数据收集过程中，结合实际数据与模拟数据，得到25组产品质量样本数据（每组至少5个样本）；随后，通过描述性统计分析方法对数据进行宏观的认知，根据均值、方差、极差、直方图等指标对数据进行初步分析；接着又利用假设检验的方法，分别通过Pearson卡方检验与t检验等方法验证数据是否符合正态分布，并对其总体均值进行检验。基于对于正态总体及其均值、方差的检验合理性，最终计算并评估了数据的工序能力指数，同时绘制了均值控制图和方差控制图，以直观反映生产过程中的数据波动情况。通过多种方法的综合分析，最终得出了工厂生产的滚珠直径的工艺水平评价和生产过程的受控状态判断。 关键词: 产品质量管理、统计过程控制（SPC）、假设检验、Shewhart控制图、Matlab 项目概述问题背景现代产品质量管理主要有两个核心目标：第一，评价产品的工艺水平如何，即产品质量如何；第二，评价产品的生产过程是否受控，即产品可靠性如何。从现代质量控制的角度看，一方面要求产品质量好，另一方面还要求可靠性高。 统计过程控制(Statistical Process Control, SPC)是一种基于概率统计的过程控制方法。1924年美国贝尔实验室的Shewhart博士提出控制图，标志着产品统计质量控制的正式起点。作为现代质量管理的重要方法，SPC广泛应用于现代制造过程的质量控制。20实际80年代，国际上半导体制造过程已经普遍采用SPC技术提升产品合格率和可靠性。比如Motorola公司提出并在美国通用电器公司等广泛应用的6σ管理，其主要技术基础就是SPC理论。 生产过程是否处于统计受控状态，取决于生产过程是否存在异常因素导致产品质量的起伏变化。产品加工结果是否满足加工规范要求，反应的是工艺水平的高低；而工艺是否受控，反应的是生产过程是否存在异常因素。 项目任务在本次项目中，需要收集批量产品质量数据，利用SPC方法对其进行管理，分析整体工艺水平并判断生产过程是否处于统计受控状态，具体而言可细分为如下任务： 任务 1:收集或生成25组以上的数据，每组至少5个样本。 任务2:根据均值，方差，极差，直方图等指标，对数据进行描述性统计分析。 任务 3:对数据进行正态性检验与总体的均值检验。 任务 4:计算数据工序能力指数并对其进行评估。 任务 5:描绘均值控制图和方差控制图。 任务 6:得出结论：工艺水平如何；生产过程是否处于统计受控状态。 项目过程本项目完全基于Matlab代码实现SPC方法进行产品质量管理。 数据收集本项目中的数据收集采用实际数据与模拟数据结合的方式，其中实际数据以书本7.4节的例题7.4.4[^1]为主要来源，在此基础上利用生成的模拟数据对其进行扩充，最终得到25组产品质量样本数据，每组中含有5个数据。 具体而言，本项目的问题情境为对工厂生产的滚珠直径（单位：$mm$）进行产品质量管理。书本上的例题提供了50个直径数据，将其作为扩充生成模拟数据的源数据source_data，即： 12345678910source_data=[15.0,15.8,15.2,15.1,15.9, 14.7,14.8,15.5,15.6,15.3, 15.0,15.6,15.7,15.8,14.5, 15.1,15.3,14.9,14.9,15.2, 15.9,15.0,15.3,15.6,15.1, 14.9,14.2,14.6,15.8,15.2, 15.2,15.0,14.9,14.8,15.1, 15.5,15.5,15.1,15.1,15.0, 15.3,14.7,14.5,15.5,15.0, 14.7,14.6,14.2,14.2,14.5]; 设置扩充后的数据组数num_groups以及各组样本数据个数samples_per_groups： 12num_groups = 25;samples_per_group = 5; 两者相乘得到样本数据总数num_data_points： 1num_data_points = num_groups * samples_per_group; 要对原始数据进行扩充，首先需要复制原始数据并添加随机扰动： 12replicated_data = repmat(source_data, 1, ceil(num_data_points / length(source_data)));perturbed_data = replicated_data(1:num_data_points) + 0.05 * randn(1, num_data_points); 接着使用插值生成更多数据点，并保留一位小数： 1234x = 1:length(perturbed_data);xi = linspace(1, length(perturbed_data), num_data_points);interpolated_data = interp1(x, perturbed_data, xi, 'spline');interpolated_data = round(interpolated_data, 1); 最后将生成的模拟数据点重新组织为25组，每组5个数据，得到完整样本数据： 12expanded_data = reshape(interpolated_data, samples_per_group, num_groups)';data = expanded_data; 最终的样本数据如下表所示： 1 2 3 4 5 1 15.0000 14.6000 15.0000 15.1000 16.0000 2 14.9000 15.2000 15.5000 15.2000 14.7000 3 15.7000 14.7000 15.6000 15.2000 15.0000 4 14.2000 15.1000 15.5000 14.7000 14.6000 5 15.2000 15.5000 15.7000 14.9000 15.3000 6 14.7000 14.9000 15.1000 14.4000 14.3000 7 15.1000 15.6000 15.8000 14.8000 15.6000 8 15.9000 14.8000 15.1000 15.5000 14.3000 9 16.0000 15.3000 14.6000 15.3000 15.1000 10 15.2000 15.1000 15.1000 14.9000 14.6000 11 15.0000 14.8000 14.9000 15.1000 15.9000 12 14.9000 15.3000 15.5000 15.2000 14.7000 13 15.8000 14.8000 15.6000 15.3000 14.9000 14 14.1000 15.1000 15.4000 14.7000 14.6000 15 15.2000 15.5000 15.7000 14.9000 15.3000 16 14.6000 14.9000 15.0000 14.5000 14.3000 17 15.2000 15.6000 15.8000 14.9000 15.6000 18 15.8000 14.8000 15.1000 15.5000 14.2000 19 15.9000 15.3000 14.5000 15.2000 15.1000 20 15.2000 15.1000 15.0000 15.0000 14.5000 21 15.0000 14.7000 15.0000 15.1000 16.0000 22 14.9000 15.1000 15.6000 15.3000 14.6000 23 15.7000 14.9000 15.6000 15.4000 14.9000 24 14.2000 15.0000 15.5000 14.8000 14.7000 25 15.2000 15.4000 15.6000 14.9000 15.2000 其中每行表示一组数据，共25组，每组中有5个数据。 描述性统计分析描述性统计量主要有以下几种： 均值 (Mean): 计算每组数据的平均值，反映该组数据的中心位置。 方差 (Variance): 度量数据分散程度，数值越大表示数据的波动越大。 标准差 (Standard Deviation): 方差的平方根，同样反映数据的分散程度，但单位与数据相同。 极差 (Range): 最大值与最小值的差，表示数据的跨度。 利用Matlab软件中自带的库函数，可以分别实现对于各组数据均值、方差、标准差与极差等统计量的计算： 1234means = mean(data, 2); variances = var(data, 0, 2); ranges = range(data, 2); stds = std(data, 0, 2); 各组均值 各组方差 各组标准差 各组极差 1 15.14 0.268 0.51769 1.4 2 15.1 0.095 0.30822 0.8 3 15.24 0.173 0.41593 1 4 14.82 0.247 0.49699 1.3 5 15.32 0.092 0.30332 0.8 6 14.68 0.112 0.33466 0.8 7 15.38 0.172 0.41473 1 8 15.12 0.382 0.61806 1.6 9 15.26 0.253 0.50299 1.4 10 14.98 0.057 0.23875 0.6 11 15.14 0.193 0.43932 1.1 12 15.12 0.102 0.31937 0.8 13 15.28 0.187 0.43243 1 14 14.78 0.247 0.49699 1.3 15 15.32 0.092 0.30332 0.8 16 14.66 0.083 0.2881 0.7 17 15.42 0.132 0.36332 0.9 18 15.08 0.387 0.62209 1.6 19 15.2 0.25 0.5 1.4 20 14.96 0.073 0.27019 0.7 21 15.16 0.243 0.49295 1.3 22 15.1 0.145 0.38079 1 23 15.3 0.145 0.38079 0.8 24 14.84 0.223 0.47223 1.3 25 15.26 0.068 0.26077 0.7 以及计算总体数据的均值、方差、标准差与极差： 1234overall_mean = mean(data(:)); overall_variance = var(data(:)); overall_range = range(data(:)); overall_std = std(data(:)); 总体均值 15.1064 总体方差 0.18657 总体标准差 0.43194 总体极差 1.9 值得注意的是，Matlab中计算方差的函数 var(A) 默认会按照 N-1（N是观测值数量，即上文中的num_data_points）实现归一化，从而可以作为对于总体分布的方差的无偏估计。上述得到的均为修正后的样本方差。 通过对于上述四个描述性统计量的样本观测结果进行初步分析，可以得到如下结论： 滚珠直径的总体平均值约为15.1mm，可作为后续总体均值检验的检验目标。 各组数据的方差均在0.5以内，总体方差与标准差也较低，说明生产过程中数据波动较小，产品质量稳定性较高。 数据极差范围适中，总体极差不超过2，处于合理区间。 除此之外，还可以通过绘制频数分布直方图的方式对于样本数据进行描述性统计分析： 1h = histogram(data); 观察图表可知，数据的频数分布大致呈”两边少，中间多”的趋势，推测其总体大致服从正态分布，需要进行进一步检验。 数据正态性检验要验证总体是否服从正态分布，需要采用Pearson卡方检验方法，对总体的分布类型进行检验。 Matlab软件中，有相应的函数chi2gof可通过Pearson卡方检验来验证总体分布类型是否为正态分布： 1[result, p_chi2] = chi2gof(data(:)); chi2gof函数是使用Pearson卡方检验返回原假设的检验决策，其原假设假定样本数据来自正态分布的总体，备择假设是样本数据不来自正态分布的总体。默认情况（仅将样本数据data输入chi2gof函数）下，检验的显著性水平为δ=0.05，且默认检验总体是否服从正态分布；通过增加函数的输入参数可以对显著性水平和检验的分布类型进行更改，在此不再赘述。 返回的参数result为正态性检验的结果，若result=0，说明无法拒绝原假设，即可认为样本数据来自正态分布的总体；若result=1，则拒绝原假设，认为数据不来自正态分布的总体。另一返回参数p_chi2则为该检验的p值，当其大于显著性水平δ时不拒绝原假设。 通过对样本数据进行正态性检验，可认为数据来自正态分布的总体，正态性检验的p值为0.37005。 从原理出发，也可根据假设检验的基本方法流程对总体的分布类型进行检验： 首先，提出原假设与备择假设： H_0：总体服从正态分布，即$$F(x) = \\phi(\\frac{x-\\mu}{\\sigma})$$ H_1：总体不服从正态分布，即$$F(x) \\neq \\phi(\\frac{x-\\mu}{\\sigma})$$ 其中F(x)为总体的分布，μ和σ为正态分布的均值与方差（均为未知参数）。 接着，根据假设的提出给出对应的拒绝域形式：$$R_0 = \\left{ T&gt;c \\right}$$其中T为构造的统计量： $$T=\\sum_{i=1}^{r}\\frac{ {(n_i-n{p}_i)}^2}{np_i}$$若将对总体X所有可能的取值范围分割成$r个两两不交的部分，则式中： n_i：统计样本中实际落入第i个部分的个数（实际频数）； n：样本数据总数，即上文代码中的num_data_points； p_i：任一样本落入第$i$个部分的概率。 显然，当原假设$$H_0: F(x) = \\phi(\\frac{x-\\mu}{\\sigma})$$成立时，理论频数n*p_i应与实际频数n_i较为接近，这也是拒绝域形式的确定依据。 可以注意到，Pearson卡方统计量$$T=\\sum_{i=1}^{r}\\frac{ { {(n_i-np}_i)}^2}{np_i}$$服从如下的大样本分布： $$\\hat{T}=\\sum_{i=1}^{r}\\frac { { {(n_i-n\\hat{p}}_i)}^2}{n{\\hat{p} }_i}\\rightarrow X^2(r-1-s)$$其中： s表示待估未知参数的个数，显然本项目中s=2； hat(p)_i为任一样本落入第i部分的概率p_i的估计值，这是由于假定的分布类型中含有未知参数，因此需要先根据样本数据对未知参数进行极大似然估计，再代入得到概率的估计值。 然后，需要计算犯第一类错误的概率$$\\alpha=P \\left{H_1|H_0\\right} = \\left{T&gt;c|\\F(x)=F_0(x)\\right}$$并根据α = δ = 0.05求得拒绝域中未知参数c的临界值criticalValue = 11.0705： 123456deta=0.05;mu_MLE = overall_mean;sigma2_MLE = overall_variance*(num_data_points-1)/num_data_points; sigma_MLE = sqrt(sigma2_MLE);dimension=numBins-1-2;criticalValue = chi2inv(1 - deta, dimension); 事实上，上文中提到Matlab软件中的var(A)函数默认按照N-1实现归一化，而正态分布方差的极大似然估计应为未修正的样本方差，故特此进行更正；同时，在2.2节的描述性统计分析过程中，涉及到频数直方图的绘制时已经对数据完成了分组，可直接通过读取上述的图表属性获取分组数numBins（对应上文中r）、各组频数binCounts（对应上文中实际频数n_i与各分组边界binEdges（可用于计算p_i））： 123numBins = h.NumBins;binCounts = h.Values;binEdges = h.BinEdges; 最后，通过样本数据计算出对应卡方统计量T的观测kafang = 2.6897： 123456789kafang=0;p_hat(1)= normcdf(binEdges(2), mu_MLE, sigma_MLE);for i=2:numBins-1 p_hat(i)= normcdf(binEdges(i+1), mu_MLE, sigma_MLE)-normcdf(binEdges(i), mu_MLE, sigma_MLE);endp_hat(numBins)= 1-normcdf(binEdges(numBins), mu_MLE, sigma_MLE);for i=1:numBins kafang=kafang+(binCounts(i)-num_data_points*p_hat(i))^2 / (num_data_points*p_hat(i));end 由于kafang&lt;criticalValue，即不位于拒绝域内，因此无法拒绝原假设H_0，即可以认为数据确实来自正态分布的总体，与直接调用Matlab内置库函数的结果一致。 总体均值检验通过Pearson卡方检验，已经可以认为在显著性水平δ=0.05的情况下，总体近似服从正态分布。进一步地，还希望对该正态总体的均值参数μ进行假设检验。在2.2节的描述性统计分析过程中，已经计算得到样本的总体均值（实际上也是正态分布参数μ的无偏估计与最大似然估计）μ_0 约为15.1(mm)，因此接下来的假设检验过程就将其作为检验对象： 1miu0=15.1; 在正态总体的均值检验过程中，主要采取t检验的方法，即认为正态总体的另一参数σ未知。这样的检验方法的合理性是显然的，此时需要构造服从t分布的统计量以进行t检验。 在Matlab软件中，对于t检验仍然有相对应的库函数ttest()可以调用： 1[result1, ttest_p_value] = ttest(data(:),miu0); 函数ttest(data(:),miu0)使用单样本t检验返回原假设的检验决策，其原假设假定数据data来自均值等于输入参数miu0且方差未知的正态分布，而备择假设是总体分布的均值不等于miu0。如果该检验在默认为5%的显著性水平上拒绝原假设，则函数的返回值result1为1，即认为正态总体的均值不为miu0，否则为0；而另一返回值ttest_p_value则为该检验的p值，当其大于显著性水平时不拒绝原假设，即可认为正态总体的均值等于miu0。 运行代码可得：正态总体均值检验p值ttest_p_value=0.8687，可认为正态总体的均值约为μ_0=15.1。 同样的，这样的假设检验过程也可以基于一般的统计方法实现： 首先，提出原假设与备择假设： H_0：正态总体的均值为15.1，即μ=μ_0=15.1； H_1：正态总体的均值不为15.1，即μ ≠ μ_0。 接着，根据假设的提出给出对应的拒绝域形式：$$R_0 = \\left{ (x_1, x_2,…,x_n)^T :|\\bar{x}-\\mu_0| &gt;c \\right}$$该拒绝域形式的构造是具有合理性的，因为显然可证明样本均值bar{x}是对于正态总体参数μ的无偏估计，若原假设H_0成立，则说明bar{x}应与设定检验值μ_0较为接近，反之可得其拒绝域应描述为bar{x}与μ _0相距较远的情形，基于这样的原理也可构造其他形式的拒绝域，这里只是给出一种可能性。 然后，需要计算犯第一类错误的概率$$\\alpha=P \\left{H_1|H_0\\right} = \\left{\\bar{x}-\\mu_0| &gt;c|\\mu=\\mu_0\\right}$$并根据α = δ = 0.05求得拒绝域中未知参数c的临界值tcriticalValue = 0.0765： 1234deta=0.05;dimension=num_data_points-1;s=sqrt(var(data(:)));tCriticalValue = tinv(1 - deta/2, dimension)*s/sqrt(num_data_points); 上述计算操作的依据是，在对第一类错误发生概率α的计算过程中，可以根据抽样分布定理构造出对应的t统计量$$\\frac{\\bar{x}-\\mu_0}{s/\\sqrt{n}} \\sim t(n-1)$$从而查表进行计算求解得到临界值$$c=\\frac{t_{1-\\frac{\\delta}{2}}(n-1)*s}{\\sqrt{n}}$$其中s为样本数据的标准差（修正后），n为样本容量num_data_points。 最后，前文已经计算出样本均值为bar{x}，若将其与待检验值μ_0之间的距离|bar{x}-μ _0|定义为参数d，则在判定是否处于拒绝域中时只需要比较d与临界值tcriticalValue即可： 1d=abs(overall_mean-miu0); 计算得到d=0.0064，小于临界值tcriticalValue = 0.0765，即不位于拒绝域内，因此无法拒绝原假设，可认为正态总体的均值μ约为15.1。这同样与直接调用Matlab内置函数的结果相一致。事实上，只要μ_0在样本均值bar{x}=15.1064上下tcriticalValue = 0.0765的区间范围内，都可在显著性水平δ=0.05的情况下认为是正态总体的均值μ。 数据工序能力指数的计算与评估在2.3节和2.4节中，通过假设检验的方法已经分别证明在显著性水平平δ=0.05的情况下，可以认为总体近似服从正态分布，且正态总体的均值μ约为15.1mm。基于类似的方法，不难得到正态总体的标准差σ约等于样本数据的标准差（修正）s=0.4319。基于这样的假设并通过假设检验验证其合理性之后，可以对于产品的生产质量利用数据工序能力指数等指标进行评估。 在工业生产中，为了综合表示工艺水平满足工艺参数规范要求的程度，通常借助于工序能力指数 (Process Capability index, Cp or Cpk) 来描述生产线是否具有较高的工艺水平能否生产出质量好的产品。潜在工序能力指数Cp的定义为： $$Cp=\\frac{T_U-T_L}{6\\sigma}$$其中T_U，T_L分别表示工艺参数规范的上限和下限。在本项目的问题背景之下，一般认为滚珠直径在14mm-16mm都可视为合理；但值得注意的是，在此定义中，隐含要求工艺参数分布中心μ与工艺规范要求的中心值T_0=(T_U+T_L)/2相重合。由2.4节的均值检验过程可知，μ约为15.1且上下限14和16的均值15不在可以通过假设检验的区间范围内，因此在此先进行近似处理，假定T_U=16.1，T_L=14.1，则可以计算出此时的潜在工序能力指数Cp=0.7717： 12345Tu=16.1;Tl=14.1;spec_limits = [Tl, Tu]; sigma = std(data(:)); cp = (spec_limits(2) - spec_limits(1)) / (6 * sigma); 而事实上，在原设定T_U=16，T_L=14的条件下，由于规范中心T_0=(T_U+T_L)/2与参数分布中心μ不重合，上述的近似处理并不能很准确在的反映其工序能力，此时则需要采用实际工序能力指数Cpk来度量工艺水平的高低： $$Cpk=\\frac{T_U-T_L}{6\\sigma}(1-K)$$其中K用于度量工艺参数分布均值μ对规范中心T_0的相对偏离度，即： $$K=\\frac { {|\\mu-T}_0|} { {(T}_U-T_L)/2}$$ 123456Tu=16;Tl=14;spec_limits = [Tl, Tu]; T0=(spec_limits(2) + spec_limits(1)) / 2;k=abs(overall_mean-T0)*2/(spec_limits(2) - spec_limits(1));cpk=(spec_limits(2) - spec_limits(1)) *(1-k)/ (6 * sigma); 计算得到：相对偏离度K=0.1064，实际工序能力指数Cpk=0.6896。其中相对偏离度K&lt;1，说明均值未偏离到规范范围外，表明工艺加工结果合适，且实际工序能力指数Cpk&gt;0，表明该工序具有一定的生产能力，但并未达到国际上的普遍要求Cpk&gt;1.5，说明生产水平还存在相当大的提升空间。 除此之外，还可以计算单侧规范下的实际工序能力指数C_PU和C_PL: 若工艺参数只有上规范T_U的要求，则实际工序能力指数C_PU定义为：$$C_{PU}=\\frac{T_U-\\mu}{3\\sigma}$$若工艺参数只有下规范T_L的要求，则实际工序能力指数C_PL定义为：$$C_{PL}=\\frac { {\\mu-T}_L}{3\\sigma}$$ 12cpu = (spec_limits(2) - mean(data(:))) / (3 * sigma);cpl = (mean(data(:)) - spec_limits(1)) / (3 * sigma); 计算得到：实际工序能力指数C_PU=0.6896、C_PL=0.8538，也并未达到国际一般标准。 均值控制图与方差控制图Shewhart控制图是实施SPC过程中判断生产过程是否处于统计受控状态的基本工具，其中使用最为广泛的为均值控制图和方差（标准差）控制图。通过连续采集工艺参数数据，可以利用Shewhart控制图来定量分析和度量生产线的运行过程处于统计受控状态。 均值控制图在均值控制图中，包含有三条水平线，分别是： **UCL(Upper Control Limit)**：表示上控制限； **LCL(Lower Control Limit)**：表示下控制限； **CL(Center Line)/Avg(Average)**：表示中心线。 对于各批次的样本数据，用折线连接每批次的均值，从而得到反映不同批次数据均值波动情况的折线图。 对于服从正态分布总体N(μ, σ^2)的工艺参数而言，其取值落在(μ ± 3σ)区间范围内的概率为99.73%，因此可以采用如下的3σ准则来确定均值控制图的中心线以及上下控制限： $$UCL=\\mu+3\\sigma$$ $$CL=\\mu$$ $$LCL=\\mu-3\\sigma$$ * 我国标准”GB/T 4091常规控制图(2001版)”规定采用上述法则来计算控制限。 基于以上法则，可绘制均值控制图如下： 12345678910miu_hat=overall_mean;sigma_hat=overall_variance;figure;plot(means, 'o-');CL= miu_hat;UCL=miu_hat+3*sigma_hat;LCL=miu_hat-3*sigma_hatyline(CL, 'r-', 'CL');yline(UCL, 'r--', 'UCL');yline(LCL, 'r--', 'LCL'); 但在实际生产实践中，并不是所有的产品工艺指标都会近似服从正态分布。因此，在实际操作中，均值控制限常用如下公式估算： $$UCL=\\hat{\\mu}+A_s\\bullet \\hat{s}$$ $$CL=\\hat{\\mu}$$ $$LCL=\\hat{\\mu}-A_s\\bullet \\hat{s}$$ 其中，若采集工艺参数样本数据组数k=25，各批次数据数量n=5，令x_ij表示第i批次的第j个数据，bar{x_i}表示组内均值；则可用μ表示个各批次所有数据的样本均值，hat{s}表示各个批次数据标准偏差的算数平均值，即： $${\\bar{x}}i=\\frac{1}{n}\\sum{j=1}^{n}x_{ij}$$ $$\\hat{s}=\\frac{1}{k}\\sum_{i=1}^{k}{\\hat{s}}_i$$ $$\\hat{\\mu}=\\frac{1}{k}\\sum_{i=1}^{k}{\\bar{x}}i=\\frac{1}{kn}\\sum{i=1}^{k}\\sum_{j=1}^{n}x_{ij}$$ $${\\hat{s}}i=\\sqrt{\\frac{1}{n-1}\\sum{j=1}^{n}{ {(x}_{ij}-{\\bar{x} }_i)}^2}$$ 又查表[^2]可得：当每批次样本数据数n=5时，有A_s=1.427。 于是绘制出实际均值控制图： 123456789101112131415161718figure;plot(means, 'o-');xi=mean(data, 2);for i=1:num_groups sum=0; for j=1:samples_per_group sum=sum+((data(i,j)-xi(i))^2); end si_hat(i)=sqrt(sum/(num_groups-1));ends_hat=mean(si_hat);As=1.427;CL= miu_hat;UCL=miu_hat+s_hat*As;LCL=miu_hat-s_hat*As;yline(CL, 'r-', 'CL');yline(UCL, 'r--', 'UCL');yline(LCL, 'r--', 'LCL'); 方差控制图方差控制图的结构与均值控制图非常类似，也是由中心线以及上下控制限构成。只是图中的数据点描述的每批次数据的标准偏差，因此可用于定量判断不同批次数据的标准偏差(数据的波动性)在变化中是否存在”异常因素”。 类似于均值控制图，在实际操作中，常用如下公式估算其中心线以及上下控制限： $$UCL=B_U\\bullet\\ \\hat{s}$$ $$CL=\\hat{s}$$ $$LCL=B_L\\bullet\\hat{s}$$ 其中B_U、B_L为依赖于每批次样本数据数n的常数参数，查表[^2]可得：当每批次样本数据数n=5时，有B_U=2.089、B_L=0。 据此可绘制出对应的方差控制图： 1234567891011Bu=2.089;Bl=0;figure;plot(variances, 'o-');hold on;UCL=(Bu*s_hat);CL=(s_hat);LCL=(Bl*s_hat);yline(CL, 'r-', 'CL');yline(UCL, 'r--', 'UCL');yline(LCL, 'r--', 'LCL'); 产品质量分析结论为根据Shewhart控制图判断产品生产过程是否受控，可对于均值控制图与方差控制图分别采用如下八条常见规则（规则均不能触碰，否则视为不受控），以识别产品生产过程是否仅受到随机因素影响： 规则 1:控制图上有一个点(对应某个批次数据)位于控制限以外； 规则 2:连续9个点落在中心线同一侧； 规则 3:连续6个点递增或者递减； 规则 4:连续14个点交替上下； 规则 5:连续3个点中有2个点落在中心线同侧的B区以外； 规则 6:连续5个点中有4个点落在中心线同侧的C区以外； 规则 7:连续15个点落在中心线两侧的C区； 规则 8:连续8个点落在中心线两侧且无一点在C区以内。 其中，A、B、C分区如下图^^[@2]^^所示，C区为以CL控制限为对称轴的中心区域，B、A两区向两侧延伸至上下控制限UCL与LCL。 实际上，Matlab软件中对于Shewhart控制图以及SPC统计过程控制方法有一套完整封装的库函数controlchart()，调用结果如下所示： 12load parts[st,plotdata] = controlchart(data,'charttype',{'xbar' 's'}); 其中第一张图为均值控制图，第二张图为标准差控制图。 通过观察图像，基于八大规则进行判断并通过查看返回对象plotdata的ooc属性（Logical that is true for points that are out of control）可知，该产品生产过程确实处于统计受控状态。除此之外，样本均值也在15.1mm左右，符合对于滚珠直径的一般行业要求，工艺水平良好；但实际工序能力指数Cpk仅有0.6896，说明工艺水平还有上升空间。 参考文献[^1]: 茆诗松,程依明,濮晓龙编著. 概率论与数理统计教程[M]. 高等教育出版社, 2019.[^2]: 贾新章 .. [等] 编著. 统计过程控制理论与实践[M]. 电子工业出版社, 2017.","link":"/2024/06/28/project1/"},{"title":"串联式机械臂小车","text":"一、串联式机械臂概括1.应用领域总结分析近年来，随着工业自动化水平的飞速发展，工业机器人在现代机械制造中发挥着越来越重要的作用，而串联机械臂作为工业制造领域的关键载体对航天、汽车等制造领域正起着越来越重要的作用，尤其在复杂和环境恶劣的作业条件下，更扮演着不可替代的角色。串联机械臂作为一种多学科高度综合的产品，集成了机械、计算机电子、自动控制理论等于一体，其技术水准直接反映了国家工业制造水平，目前广泛应用于汽车及汽车零部件制造业、机械加工行业、木材与家居制造业等领域，提高了各加工制造业的作业效率。比如焊接机器人在机械加工领域中代替传统的人工焊接，不仅提高了焊接效率和焊接精度，而且解决了工人在焊接恶劣条件的安全问题。 由于具有较高的灵活性和多自由度，串联机械臂在许多领域都有广泛应用： （1）自动化生产线：串联机器人在汽车制造、电子产品组装、食品加工等自动化生产线上发挥重要作用。它们可以完成精细的装配、焊接、喷涂等工作，提高生产效率和产品质量。 （2）医疗和健康：串联机器人在手术、康复辅助和医疗器械制造等领域得到应用。它们可以进行精确的手术操作、康复训练和辅助活动，提高手术精度和患者疗效。 （3）仓储和物流：串联机器人在仓储和物流领域可以完成货物的搬运、分拣和装载等任务。 （4）精密加工：串联机器人在精密加工领域扮演着重要角色，如机械零件加工、精密雕刻和模具制造等。其高精度和灵活性使其能够进行微小尺寸和复杂形状的加工操作。 （5）实验室研究：串联机器人在科学研究和实验室应用中具有广泛的应用。例如，在化学实验、材料测试和生物医学研究中，串联机器人可以进行精确的液体分注、样品处理和实验操作。 （6）危险环境：串联机器人可以在危险环境中代替人工进行操作，如核能厂、爆炸物处理和深海勘探等。它们能够承担高温、高压、有毒或放射性环境下的任务，保护人类的安全。 （7）娱乐和艺术：串联机器人还在娱乐和艺术领域展现出其创造力和表演能力。例如，在舞台表演、电影特效和艺术创作中，串联机器人可以呈现出流畅的舞蹈动作、惊人的表演和艺术装置。 2.机械臂技术研发需求随着中国工业机器人市场需求的不断增加，开发完全自主的工业机器人控制系统具有不可替代的意义。目前衡量工业机器人性能的重要标准是运行高速以及加工高精度，而这些也是市场非常看重的。其中工业机器人的运动精度和平稳性的基础和保障是平滑的位姿运动，同时速度规划算法的选择决定了机器人运动精度和平滑性，因此研究机器人的前瞻算法和轨迹规划控制算法对于提高机器人的控制精度和运行效率具有重要意义。 （1）机器人轨迹光顺技术 轨迹光顺是机器人轨迹规划中一个不可或缺的部分，通过各种曲线对运行路径进行近似，在满足轨迹弓高误差的情况下，生成新的运动轨迹，消除曲率和切向的不连续性，满足轨迹连续性要求，目前在三轴和五轴机床上应用非常广泛。 （2）机器人奇异位形规避技术 奇异位形是指机构在运动过程中机构的运动学、动力学性能发生瞬间突变，机构处于死点或者自由度减少，使得机构运动能力失常。串联机器人的运动奇异性由其串联机构所决定的，无法消除，产生的不良影响主要表现在两个方面：①自由度减少；②某些关节角速度趋向无穷大，引起机器人失控。 （3）机器人同步前瞻技术 速度前瞻是数控加工技术中的重要一环，基本思想是通过预读一段待运行路径，判断该路径上的高曲率约束点和危险点，提前进行速度规划，保证机床末端运行至危险点之前能够降速至合适速度，平稳过渡危险点后在加速至正常速度。 （4）机器人速度规划和插补技术 速度规划和插补是机器人运动控制中不可缺少的一部分，已知当前段始末点速度和位移，通过速度规划计算出当前段的运动时间，然后插补出每一循环周期的位移。常见的速度规划算法有直线加减速，也被称为梯形加减速，Ｓ曲线加减速，修正梯形加减速，指数型加减速，三角函数加减速等。 二、串联机械臂机构分析1.机械臂结构分析通过搭建组装机械臂平台，分析其基本结构与传动方式，并对部件具体尺寸进行测量，可以得到如下的机构简图，并建立对应的工具坐标： 其中，经过多次测量取平均值，测得如下物理结构参数（图中已标注)： 表1：机械臂物理参数 数值（mm） L1 152 L2 105 L3 98 L4 182 2.机械臂正运动学模型基于上述坐标系，进一步分析其传动关系与结构，得出如下D-H参数表： 表2：D-H参数表 参数\\关节 0 1 2 3 4 5 6 a_i 0 0 L2 L3 0 0 d_i L1 0 0 0 0 L4 α_i 0 -90° 0 0 -90° 0 θ_i θ1 θ2 θ3 θ4-90° θ5 0 通过如下变化通式，可以在各连杆的关节坐标系之间进行变换： 代入D-H表中对应的参数值即可计算得出对应的位姿矩阵，表中的θ_i（i=1,2,3,4,5）即表示舵机转角（最后一个舵机仅控制夹子夹紧，不影响总体位姿，默认为夹紧状态），在机械臂自身物理参数已经确定的情况下，一旦给定各舵机转角，机械臂末端在全局坐标系中的坐标也可立即得到。在本项目的六轴机械臂模型中，共可建立六个坐标系，得到六个相邻坐标系之间的位姿矩阵T；将六个位姿矩阵按顺序依次右乘，即可得到机械臂末端相对于0坐标系（即全局坐标系）的位姿矩阵: 该矩阵中前三行的最后一个元素分别代表了机械臂末端在全局坐标系中的x,y和z坐标。依据这样的原理，通过Matlab编程，可以实现正运动学的计算（附件1），例如设定五个舵机转角分别为0°、-45°、45°、45°、0°，可以计算得出如下的位姿矩阵：进一步可以绘制出此时各机械臂关节的位姿图，与实际控制结果进行比照： 3.机械臂逆运动学求解 通过观察与分析机械臂结构可以发现，由于θ5只影响末端夹子的转动，θ6只影响末端夹子夹紧的程度，即在固定θ5=0°、θ6=90°（夹子夹紧）时，机械臂的位姿与末端坐标只受θ1、θ2、θ3、θ4的控制，故只需求解该四者即可。 （1）求解θ1观察连杆简图（上左图），可以发现: θ1为机械臂在x-y平面中的投影与x轴的夹角，即只与机械臂末端的x与y坐标有关：θ1=arctan(yP*/x*P)。 （2）求解θ2、θ3、θ4进一步观察机械臂所在平面（上右图）：将原坐标系中的z轴作为纵坐标（y’ = z），将原x轴与y轴映射到机械臂所在平面内作为横坐标（x’ = sqrt(x^2+y^2))；利用几何法，建立方程组对θ2、θ3、θ4分别进行求解。 在求解公式推导的过程中，默认末端机械臂与水平面的夹角α已知，在给定机械臂末端坐标（x,y,z）的情况下，可解得如下结果（必须求出解析解，若将方程组输入Matlab调用求解器求解，可能会出现计算无解但实际有解的情况）： 其中： 事实上，这样求解得到的结果往往不唯一，为使得机械臂在各位姿转换的过程中更加直接迅速且满足机械结构约束，还需满足如下约束条件： 【1】求解位置不能低于底座： 【2】三角形ABC存在的几何约束 【3】三角形ACC’存在的几何约束 【4】运动连续性约束： 【5】角度范围约束： 实际编写Matlab程序进行求解时，末端机械臂与水平面的夹角α在不同位姿下会发生改变，因此需要在编程时对其在一定范围（-45°到90°之间）内进行遍历，当有合适的满足约束条件的解时输出对应的解并停止循环。 在Matlab程序（附件2）中，将目标机械臂末端坐标[x,y,z]设置为以IN_theta=[0,-45,45,45,0]作为输入的正解结果[300.9396, 0, 97.5528]，得到的逆解结果与IN_theta完全一致，正确性得到验证。 三、串联机械臂控制技术分析1.电机特性分析从本质上来说，电机属于一种能量转换装置，其目的是希望将电能转换为动能（机械能），但在实际的工作过程中这样的转换效率永远不会是100%，而是由于电机线圈的欧姆加热，会有相当部分的能量以热量形式散失；但总而言之，其工作过程本身仍然满足能量守恒定律，即其将输入的电能P_elec转换为输出的机械能P_mech与散失的热能P_heat： 图6：电机理论模型 将其改写成电气和机械量： 其中v_m为电机端子两端的电压，i是流过电机的电流，τ是电机产生的扭矩，ω是其角速度。 事实上，除此之外，电机内的线圈除具有电阻R之外，还具有电感L。加入电感项后，再将两边同时对电流i求导，可以得到电机的定义方程： 其中v_emf为反电动势，与电机转速n成正比，即（其中常数k_v取决于电机设计）: 电机产生的转矩与通过线圈的电流成正比，即： 但实际的输出扭矩还需要在此基础上减去负载扭矩与电机轴摩擦扭矩（与电机轴转速成正比，比例系数为电机自身特性)。 基于上述这些公式即可对于一个电机的特性与性能进行相对完整描述，通过对于上述公式进行变形和转换还可以得到电机的速度-扭矩曲线，从而得到失速扭矩与空载速度，为我们更好地把握电机的大致性能提供参考。 为了后续更精准地对电机进行控制（如调节PID参数等），可以在Simulink中对电机的基本物理特性进行仿真建模： 该模型的输入值为电机电压和负载扭矩，输出值为电机转角、电流与转速，能够很好地描述一个电机的物理特性，可以将其封装成单独的电机模块，并利用PID等控制模块实现对于该电机模块的控制。 不同的电机由于其结构、材料等的不同，性能也会有所差异，具体体现在不同的结构和材料对于上述公式中所涉及到的比例系数都有不同程度的影响，因而能够影响电机的速度-扭矩特性曲线。在对电机进行选型时，厂家往往不会直接给出这些系数，而是给出空载速度等参数以供参考，因此更需要清楚了解这些特性参数所代表的物理意义，从而更好地针对需求进行合适的选型。 2.电机控制策略与PID特性分析PID控制器是工业过程控制中广泛采用的一种控制算法，其特点是结构简单灵活、技术成熟、适应性强。在有一定精度和灵敏度要求的电机控制过程中，往往也偏向于采用PID控制器实现电机控制。 P、I、D分别为比例（Proportion）、积分（Integral）、微分（Differential)的简写；将偏差的比例、积分和微分通过线性组合构成控制量，用该控制量对受控对象进行控制，称为PID算法，本质上是对于偏差的控制算法。PID通过对输入的偏差进行比例积分微分运算，将其叠加结果用于控制执行机构。在工程实践中，一般P是必须的，衍生出有PI、PD、PID等多种PID控制器。 连续状态下，PID控制器的计算公式如下： （1）比例部分 作用是对系统瞬间产生的偏差进行快速修正，只有P时会有静差。偏差一旦产生，控制器立即产生控制作用，使控制量向减少偏差的方向变化。比例系数K_p越大，控制作用越强，则过渡过程越快，控制过程的静态偏差也就越小；但是越大，也越容易产生震荡，破坏系统的稳定性。因此，比例系数必须选择恰当，才能达到过渡时间少，静差小且稳定的效果。 （2）积分部分 作用是消除系统偏差，补偿系统的静态误差，只要存在偏差，则其控制作用就不断增加；只有在无偏差时，其积分值才为常数，控制作用才是一个不会增加的常数。积分环节的调节作用虽然会消除静态误差，但也会降低系统的响应速度，增加系统的超调量。积分常数越大，积分的积累作用越弱，这时系统在过渡时才不会产生震荡；但增大积分常数会减慢静态误差的消除过程，消除偏差所需的时间较长，但可以减少超调量，提高系统的稳定性。 （3）微分部分 作用是加快调节过程，阻止偏差的变化。偏差变化的越快，微分控制器的输出就越大，并能在偏差值变大之前进行修正。微分作用的引入，将有助于减少超调量，克服震荡，使系统趋于稳定，特别对高阶系统非常有利，它加快了系统的跟踪速度。但微分的作用对输入信号的噪声很敏感，对那些噪声较大的系统一般不用微分，或在微分起作用之前先对输入信号进行滤波。 总体而言，在PID控制器参数选择的过程中，一般遵循如下步骤顺序： 【1】确定比例系数Kp 【2】确定积分时间常数Ti 【3】确定微分时间常数Td 【4】系统空载、带载联调 3.嵌入式控制系统总结分析嵌入式系统是以应用为中心，以现代计算机技术为基础，能够根据用户需求(功能、可靠性、成本、体积、功耗、环境等)灵活裁剪软硬件模块的专用计算机系统。嵌入式系统的硬件和软件必须根据具体的应用任务，以功耗、成本、体积、可靠性、处理能力等为指标来进行选择。嵌入式系统的核心是系统软件和应用软件，由于存储空间有限，因而要求软件代码紧凑、可靠，且对实时性有严格要求。目前常见的嵌入式控制开发板有C51，STM32，Arduino，树莓派等。 本项目中使用的嵌入式控制系统基于Arduino Uno开发板搭建。作为一款便捷灵活、方便上手的开源硬件产品，其具有丰富的接口，有数字I/O口，模拟I/O口，同时支持SPI,IIC,UART串口通信，能通过各种各样的传感器来感知环境，通过控制灯光、马达和其他装置来反馈、影响环境。它没有复杂的单片机底层代码，没有难懂的汇编，只是简单而实用的函数。而且具有简便的编程环境IDE，极大的自由度，可拓展性能非常高，同时其标准化的接口模式也为它的可持续发展奠定了坚实的基础，但其低廉的价格也意味着性能并不尽如人意。 4.传感系统总结分析传感器是能感受到被测量的信息，并能将感受到的信息，按一定规律变换成为数字/模拟信号或其他所需形式的信息输出，以满足信息的传输、处理、存储、显示、记录和控制等要求的检测装置。传感器具有微型化、数字化、智能化、多功能化、系统化、网络化等特点，它是实现自动检测和自动控制的首要环节。 传感器一般由敏感元件、转换元件、变换电路和辅助电源四部分组成：敏感元件直接感受被测量，并输出与被测量有确定关系的物理量信号；转换元件将敏感元件输出的物理量信号转换为电信号；变换电路负责对转换元件输出的电信号进行放大调制；转换元件和变换电路一般还需要辅助电源供电。 按照其测量的物理量，传感器可大致分为如下种类： 【1】力学量传感器：包括压力传感器、力传感器、位移传感器、加速度传感器、速度传感器、转速传感器等，用于测量力、压力、运动等力学参数。 【2】热学量传感器：热敏电阻/热电偶/红外温度传感器等，用于测量温度。 【3】光学量传感器：如光电二极管、CCD/CMOS图像传感器等，用于检测光强度、颜色、图像信息。 【4】声学量传感器：麦克风，用于声音、噪声的检测。 【5】磁学量传感器：如霍尔效应传感器、磁敏电阻，用于测量磁场强度、磁通量。 【6】化学量传感器：如电化学传感器、气体传感器，用于检测特定气体浓度、pH值、离子浓度等。 本项目中用到的传感器主要有三类： （1）红外光学传感器：不断发出红外线并通过检测返回的红外线强弱返回不同的电信号，可用于区分亮处/暗处，通过与对应的控制算法相配合可以使小车实现沿黑线完成循迹任务； （2）超声波测距传感器：不断向前方发出超声波并接收反射回的超声波，通过检测发送与接收同一超声波信号的时间间隔，计算得出前方物体与自身的距离，进行距离的判断，可配合相应控制算法实现对应功能； （3）视觉传感器：采用Openmv视觉摄像头模块，对摄像头采集的图像进行实时的处理，需要配合编写对应的识别算法并烧录进去，并将识别结果以数字信号的形式反馈到指定的引脚上，与主控制板实现通信，从而根据不同的识别结果执行对应命令。 四、综合实践环节报告1. 任务目标与任务分解任务目标： 任务分解： 总体而言，可以将整个项目分解成如下模块： （1）利用红外传感器模块，实现对于黑线道路的循迹； （2）利用超声波测距模块与视觉模块，在对应的任务点停下，并根据视觉识别结果执行对应的任务； （3）在A点处，根据识别到的物块颜色判断应进行左转还是右转；在B点出，根据识别到的物块大小，控制机械臂沿不同的指定轨迹完成运动（写字）。 简而言之，任务主要分为循迹、视觉识别与机械臂控制运动三个模块。 2. 本人负责部分的实现过程（1）任务描述我主要负责的任务板块是最终B点处的写字任务，即需要在接收到Openmv模块识别反馈的物块大/小对应的电平信号后，执行对应的机械臂运动，最终达成在墙上写数字”1”或”2”的效果；由于该实现过程中大量涉及到对于Arduino编写C++程序并烧录以实现舵机控制的内容，同时还需要与Openmv视觉模块进行交互，因此我也一并负责了整个测试小车行进业务逻辑的编写与整合工作，将各个模块整合在一起。 （2）技术路径与策略在之前的机械臂控制（正/逆解）过程中，由于不涉及到写字任务这一具体情境，只是对于实验平台基本的物理参数进行了测量；但在写字任务中，机械臂末端的夹子需要夹取白板笔，用白板笔的尖端在墙壁上完成写字任务，因此需要对于机械臂的L4参数进行重新测量，端点由夹子末端更改至白板笔的末端，测得新的L4为250mm。 针对写”1”和”2”两个不同的字符，有不同的定位方式：如写”1”只需定位上端点，中间点与下端点即可，而写”2”则根据字形需要定位6个点才能完成任务（为简化控制流程，将各控制点之间的距离设置的较小从而不需要在控制点之间再进行直线插补，目标是仅需要完成字形而并不追求大小）。附件3中的综合控制代码中给出了这些控制点的坐标，在此不详细赘述。事实上，这些点坐标的确定还与小车在停下识别时与墙壁间的距离（即超声测距决定停下识别时的临界距离）有关，实际在反复多次的测试中磨合得出。 为使得机械臂控制流程更加流畅和自然，在基于Matlab实现机械臂正逆解算的代码后，将该算法移植至C++中，并以类的形式封装（名为Arm）,一个Arm对象即对应一个位姿，其构造时需要输入机械臂的结构参数（L1,L2,L3,L4）与希望机械臂末端到达的点坐标，当再次调用其setup()方法时，会自动根据该目标坐标进行逆解算，并控制舵机按照解算出的角度转动，实现控制效果。在舵机控制时，综合了测量出的转动误差，对于各舵机的转动角度都有对应的不同的比例系数实现误差补偿。 （3）核心程序逻辑最终完整项目的代码详见附件3，在此仅简要阐述其逻辑。 小车的默认状态为以循迹方式前进，即执行follow()函数；在行进过程中，始终构造一个Arm对象（在armset()函数中），控制机械臂保持一个相对合适的姿态（坐标280，0，320）；当超声波测距返回值小于19时，说明到达了A点，需要进行第一次识别，此时会反馈给Openmv一个高电平，告诉视觉模块需要开始识别颜色；视觉模块在识别完成后通过另一个引脚将识别结果以高/低电平形式反馈给主控Arduino开发板，主板在接收到对应信号后会对应做出向左/向右转的行动（执行turningleft()或turningright()）函数，并在随后的过程中继续完成循迹；在T字路口处，由于我们组并未采取视觉辅助循迹的解决方案，因此只能采取”背板”的方式，在A点处转弯后开始计时，当继续循迹达到30s左右时，根据前面判断执行的左转/右转指令对应再次执行左转/右转；但实际操作过程中”背板”往往无法在路口精准转弯，因此又补充了新的逻辑，在时间差不多的时候提前大角度拐弯并一直沿直线行驶，直到再次回到黑线上就继续循迹，这样就可以绕过T字路口；理想状态下，通过T字路口后再行驶短暂的一段距离后，应该就到达了需要写字的B点，此时与A点处处理类似，当超声测距返回值小于17时停下，通过Openmv模块识别红色物块的大小，并执行对应的机械臂运动操作（写”1”或”2”）。 （4）实现的实际效果上述操作逻辑仅仅在理论上可行，而实际测试时，由于没有采用视觉循迹方案，在T字路口屡败屡战，屡战屡败，最终在多次尝试后仍然没有进入T字弯后的B点写字区域；在第二次尝试过程中，由于个人的失误，在补充了绕过T字弯的逻辑之后忘记补充循迹逻辑，导致在到达A点后失去循迹功能，最终宣告失败。但总体而言，除了T字弯之外，其他所有功能的实现都非常良好，不论是前段的循迹，把速度稍微压下来一点但是比较稳不会跑出去，还是A点的颜色判断也非常准确而迅速。在私下练习测试时，物块大小识别与写字功能也非常流畅，正确率极高，只是可惜最后没有办法展示出来了。 4. 心得体会其实整个课程与项目过程中的心路历程和工作内容在上面已经基本讲完了，因为我没有打过机器人相关的竞赛，相比于其他同学而言少了很多这方面的经验，不论是这次课程中涉及到的机械臂正逆解算与控制也好，还是视觉模块的引入也好，甚至是超声波测距模块其实对我来说都是初次接触，都是一个迅速的从陌生到熟悉的过程，这个成长过程很突然但也很迅速，效果是拔群的。在后半学期的实践阶段，我一直在努力去主导我们整个组进度的推进，之前课上一些小的checkpoint也都顺利通过了；最终测试中也基本是我在主导整个组进度的推进，以及各模块任务的分配与整体业务逻辑的串联，而且由于我一直在跟随堂测试的机械臂控制部分同时也想充分利用我Matlab代码编写与数据处理计算的优势，我在最终测试中还主要负责了机械臂的控制部分（写字），巧妙利用C++面向对象的编程思想，大大简化了控制流程。但可惜由于我们组经验和技术水平比较有限，没有及时认识到视觉循迹的必要性，导致最终在T字路口功亏一篑，甚至使得最早调完的写字部分前功尽弃，最后一次测试本来调整了逻辑企图通过”歪门邪道”绕过T字弯（纯背板真的太难卡准了），但是由于个人失误导致在A点就提前结束了战斗，也是留下了一些遗憾吧。但总体来说，整个过程给我带来的成长和提升是显而易见的，我开始对于机器人、对于硬件慢慢地从心理上去接受这个事情并且甚至一度乐在其中，也学到了机械臂控制、电机控制等方面的一些知识，课上第一个把电机Simulink模型搭对确实给我增长了很多信心。我们组在编程的过程中除了直接移植部分模块外几乎没有用过Mixly图形化编程，而是直接使用Arduino IDE（虽然这好像也是最后逻辑不清晰留下遗憾的原因之一），这有效地提高了我们的开发效率。这一次从装车开始，到一步步熟悉起小车和开发板的每一个部分，看着程序从一行两行到最后近千行，整体功能不断扩充从一开始只有机械臂位姿控制，到加上循迹，加上与Openmv模块的通信逻辑，以及最后面对T字路口的垂死挣扎，其实在准备过程中也尝试去做视觉辅助循迹，但由于场地各方面条件限制（场地太拥挤，调试的人太多导致环境光源不稳定；摄像头安装位置不合适等），最终还是放弃了视觉循迹方案，选择背板赌一把，很可惜没有成功。 希望在以后的学习实践中，能够充分吸取本次项目的经验，利用好这次学到的理论知识，同时也在做事的过程中汲取这次的经验教训，我相信努力的过程与收获比结果更重要，当然如果能有好的结果也再好不过。感谢这门课一路上三位任课老师与助教学长的辛勤付出，是你们的倾情指导加速了我们成长的速度。 千言万语诉不尽收获与感激。最后，感谢一直努力的自己，以及一直陪伴的老师和朋友。 附件1：Matlab正运动学解算代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758clear;clc;%赋予输入值L1=152;L2=105;L3=98;L4=182;IN_theta=[0,-45,45,45,0];%建立D-H参数表C_a=[0,0,L2,L3,0,0];C_d=[0,L1,0,0,0,0,L4];C_alpha=[0,-90,0,0,-90,0];C_theta=[0,IN_theta(1),IN_theta(2),IN_theta(3),IN_theta(4)-90,IN_theta(5),0];i=1;%i-1=0T0_1=[cosd(C_theta(i+1)),-sind(C_theta(i+1)),0,C_a(i); cosd(C_alpha(i)).*sind(C_theta(i+1)),cosd(C_alpha(i)).*cosd(C_theta(i+1)),-sind(C_alpha(i)),-C_d(i+1).*sind(C_alpha(i)); sind(C_alpha(i)).*sind(C_theta(i+1)),sind(C_alpha(i)).*cosd(C_theta(i+1)),cosd(C_alpha(i)),C_d(i+1).*cosd(C_alpha(i)); 0,0,0,1];i=2;T1_2=[cosd(C_theta(i+1)),-sind(C_theta(i+1)),0,C_a(i);cosd(C_alpha(i)).*sind(C_theta(i+1)),cosd(C_alpha(i)).*cosd(C_theta(i+1)),-sind(C_alpha(i)),-C_d(i+1).*sind(C_alpha(i));sind(C_alpha(i)).*sind(C_theta(i+1)),sind(C_alpha(i)).*cosd(C_theta(i+1)),cosd(C_alpha(i)),C_d(i+1).*cosd(C_alpha(i));0,0,0,1];i=3;T2_3=[cosd(C_theta(i+1)),-sind(C_theta(i+1)),0,C_a(i);cosd(C_alpha(i)).*sind(C_theta(i+1)),cosd(C_alpha(i)).*cosd(C_theta(i+1)),-sind(C_alpha(i)),-C_d(i+1).*sind(C_alpha(i));sind(C_alpha(i)).*sind(C_theta(i+1)),sind(C_alpha(i)).*cosd(C_theta(i+1)),cosd(C_alpha(i)),C_d(i+1).*cosd(C_alpha(i));0,0,0,1];i=4;T3_4=[cosd(C_theta(i+1)),-sind(C_theta(i+1)),0,C_a(i);cosd(C_alpha(i)).*sind(C_theta(i+1)),cosd(C_alpha(i)).*cosd(C_theta(i+1)),-sind(C_alpha(i)),-C_d(i+1).*sind(C_alpha(i));sind(C_alpha(i)).*sind(C_theta(i+1)),sind(C_alpha(i)).*cosd(C_theta(i+1)),cosd(C_alpha(i)),C_d(i+1).*cosd(C_alpha(i));0,0,0,1];i=5;T4_5=[cosd(C_theta(i+1)),-sind(C_theta(i+1)),0,C_a(i);cosd(C_alpha(i)).*sind(C_theta(i+1)),cosd(C_alpha(i)).*cosd(C_theta(i+1)),-sind(C_alpha(i)),-C_d(i+1).*sind(C_alpha(i));sind(C_alpha(i)).*sind(C_theta(i+1)),sind(C_alpha(i)).*cosd(C_theta(i+1)),cosd(C_alpha(i)),C_d(i+1).*cosd(C_alpha(i));0,0,0,1];i=6;T5_6=[cosd(C_theta(i+1)),-sind(C_theta(i+1)),0,C_a(i);cosd(C_alpha(i)).*sind(C_theta(i+1)),cosd(C_alpha(i)).*cosd(C_theta(i+1)),-sind(C_alpha(i)),-C_d(i+1).*sind(C_alpha(i));sind(C_alpha(i)).*sind(C_theta(i+1)),sind(C_alpha(i)).*cosd(C_theta(i+1)),cosd(C_alpha(i)),C_d(i+1).*cosd(C_alpha(i));0,0,0,1];x0=[0;0;0];x1=T0_1(1:3,4);T0_2=T0_1*T1_2;x2=T0_2(1:3,4);T0_3=T0_1*T1_2*T2_3;x3=T0_3(1:3,4);T0_4=T0_1*T1_2*T2_3*T3_4;x4=T0_4(1:3,4);T0_5=T0_1*T1_2*T2_3*T3_4*T4_5;x5=T0_5(1:3,4);T0_6=T0_1*T1_2*T2_3*T3_4*T4_5*T5_6;x6=T0_6(1:3,4);% 将点的坐标分别存储在 x, y, z 向量中x = [x0(1), x1(1), x2(1), x3(1), x4(1), x5(1), x6(1)];y = [x0(2), x1(2), x2(2), x3(2), x4(2), x5(2), x6(2)];z = [x0(3),x1(3), x2(3), x3(3), x4(3), x5(3), x6(3)];% 绘制三维线figure; % 创建一个新的图窗plot3(x, y, z, '-o'); % 使用 '-o' 绘制带有圆圈标记的线grid on; % 打开网格xlabel('X-axis');ylabel('Y-axis');zlabel('Z-axis');title('3D Line Plot Connecting Points');T0_6 附件2：Matlab逆运动学解算代码12345678910111213141516171819202122232425262728293031323334353637383940clear;clc;% 初始化标志变量solution_found = false;x = 300.9396; y = 0;z = 97.5528;theta1=rad2deg(atan(y/x));disp(theta1);L1 = 152; L2 = 105; L3 = 98; L4 = 182; % 遍历 alpha 的值，从 -45 到 90for alpha = -45:90 t = sqrt(x^2 + y^2); m=z-L1-L4*sind(alpha); n=t-L4*cosd(alpha); theta3=acosd((m^2+n^2-L2^2-L3^2)/(2*L2*L3)); A=L3*sind(theta3); B=L2+L3*cosd(theta3); theta2=asind(n/sqrt(A^2+B^2))-acosd(A/sqrt(A^2+B^2)); if theta2&lt;0 theta2=180-asind(n/sqrt(A^2+B^2))-acosd(A/sqrt(A^2+B^2)); end theta4=theta2-theta3-alpha; % 检查是否找到解 if L4*sind(alpha)&lt;z &amp;&amp; L3*cosd(theta2-theta3)&gt;0 &amp;&amp; theta2&gt;0 &amp;&amp; theta2&lt;90 &amp;&amp; theta3&gt;0 &amp;&amp; theta3&lt;90 &amp;&amp; theta4&gt;0 &amp;&amp; theta4&lt;90 % 记录找到解的标志 solution_found = true; break; endendif solution_found % 显示结果 disp('Solution found:'); disp(['Alpha: ', num2str(alpha)]); disp('Theta1:'); disp(theta1); disp('Theta2:'); disp(-theta2); disp('Theta3:'); disp(theta3); disp('Theta4:'); disp(theta4);else disp('No solution found in the given alpha range.');end 附件3：项目测试完整Arduino控制代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;Servo.h&gt;Servo servo_7;Servo servo_3;Servo servo_5;Servo servo_6;Servo servo_9;const double L1 = 152;const double L2 = 105;const double L3 = 98;const double L4 = 250;volatile int item;int flag_cp1=0;int flag_cp2=0;unsigned long currentTime;unsigned long elapsedTime;unsigned long startTime;char cmd_return_tmp[64];int color;int size;struct Angles { double theta1; double theta2; double theta3; double theta4;};struct Points { double x1; double y1; double z1;};class Arm { public: Arm(double L1, double L2, double L3, double L4, Points terminal) { this-&gt;L1 = L1; this-&gt;L2 = L2; this-&gt;L3 = L3; this-&gt;L4 = L4; this-&gt;x0 = terminal.x1; this-&gt;y0 = terminal.y1; this-&gt;z0 = terminal.z1; Angles angles=inverseKinematics(this-&gt;x0,this-&gt;y0,this-&gt;z0); this-&gt;theta1=angles.theta1; this-&gt;theta2=angles.theta2; this-&gt;theta3=angles.theta3; this-&gt;theta4=angles.theta4; Points point=forwardKinematics(this-&gt;theta1,this-&gt;theta2,this-&gt;theta3,this-&gt;theta4); this-&gt;x1=point.x1; this-&gt;y1=point.y1; this-&gt;z1=point.z1; } void run() { double oc1=(140.25+1.12*this-&gt;theta1)*2/3; double oc2=(180+1.13*this-&gt;theta2)*2/3; double oc3=(142.5+1.07*this-&gt;theta3)*2/3; double oc4=(132+1.12*this-&gt;theta4)*2/3; servo_7.write(oc1); servo_3.write(oc2); servo_5.write(oc3); servo_6.write(oc4); servo_9.write(96); //servo_8.write(270); Serial.print(&quot;x1: &quot;); Serial.println(this-&gt;x1); Serial.print(&quot;y1: &quot;); Serial.println(this-&gt;y1); Serial.print(&quot;z1: &quot;); Serial.println(this-&gt;z1); Serial.print(&quot;terminalx1: &quot;); Serial.println(this-&gt;x0); Serial.print(&quot;terminaly1: &quot;); Serial.println(this-&gt;y0); Serial.print(&quot;terminalz1: &quot;); Serial.println(this-&gt;z0); } private: double L1; double L2; double L3; double L4; double x0; double y0; double z0; double theta1; double theta2; double theta3; double theta4; double x1; double y1; double z1; bool solution_found = false; Angles inverseKinematics(double x0, double y0, double z0) { Angles angles; double theta1 = atan2(y0,x0) * 180.0 / PI; angles.theta1=theta1; for (int alpha = -45; alpha &lt;= 90; alpha++) { double t0 = sqrt(x0 * x0 + y0 * y0); double m = z0 - this-&gt;L1 - this-&gt;L4 * sin(alpha * PI / 180.0); double n = t0 - this-&gt;L4 * cos(alpha * PI / 180.0); double cos_theta3 = (m * m + n * n - this-&gt;L2 * this-&gt;L2 - this-&gt;L3 * this-&gt;L3) / (2 * this-&gt;L2 * this-&gt;L3); if (cos_theta3 &lt; -1.0 || cos_theta3 &gt; 1.0) continue; double theta3 = acos(cos_theta3) * 180.0 / PI; double A = L3 * sin(theta3 * PI / 180.0); double B = L2 + L3 * cos(theta3 * PI / 180.0); double sin_theta2_part = n / sqrt(A * A + B * B); double cos_theta2_part = A / sqrt(A * A + B * B); if (sin_theta2_part &lt; -1.0 || sin_theta2_part &gt; 1.0 || cos_theta2_part &lt; -1.0 || cos_theta2_part &gt; 1.0) continue; double theta2 = asin(sin_theta2_part) * 180.0 / PI - acos(cos_theta2_part) * 180.0 / PI; if (theta2 &lt; 0) theta2 = 180.0 - asin(sin_theta2_part) * 180.0 / PI - acos(cos_theta2_part) * 180.0 / PI; double theta4 = theta2 - theta3 - alpha; if (this-&gt;L4 * sin(alpha * PI / 180.0) &lt; z0 &amp;&amp; this-&gt;L3 * cos((theta2 - theta3) * PI / 180.0) &gt; 0 &amp;&amp; theta2 &gt;= 0 &amp;&amp; theta2 &lt;= 90 &amp;&amp; theta3 &gt;= 0 &amp;&amp; theta3 &lt;= 90 &amp;&amp; theta4 &gt;= 0 &amp;&amp; theta4 &lt;= 90) { solution_found = true; angles.theta2=-theta2; angles.theta3=theta3; angles.theta4=theta4; break; } } if (solution_found) return angles; } Points forwardKinematics(double theta1, double theta2, double theta3, double theta4) { Points point; double IN_theta[] = {theta1, theta2, theta3, theta4, 0}; // 定义DH参数 double C_a[] = {0, 0, this-&gt;L2, this-&gt;L3, 0, 0}; double C_d[] = {0, this-&gt;L1, 0, 0, 0, 0, this-&gt;L4}; double C_alpha[] = {0, -90, 0, 0, -90, 0}; double C_theta[] = {0, IN_theta[0], IN_theta[1], IN_theta[2], IN_theta[3] - 90, IN_theta[4], 0}; // 计算变换矩阵 double T0_1[4][4], T1_2[4][4], T2_3[4][4], T3_4[4][4], T4_5[4][4], T5_6[4][4]; double T0_2[4][4], T0_3[4][4], T0_4[4][4], T0_5[4][4], T0_6[4][4]; dhMatrix(T0_1, C_theta[1], C_d[1], C_a[0], C_alpha[0]); dhMatrix(T1_2, C_theta[2], C_d[2], C_a[1], C_alpha[1]); dhMatrix(T2_3, C_theta[3], C_d[3], C_a[2], C_alpha[2]); dhMatrix(T3_4, C_theta[4], C_d[4], C_a[3], C_alpha[3]); dhMatrix(T4_5, C_theta[5], C_d[5], C_a[4], C_alpha[4]); dhMatrix(T5_6, C_theta[6], C_d[6], C_a[5], C_alpha[5]); // Initialize T0_6 as identity matrix for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) T0_6[i][j] = (i == j) ? 1 : 0; // 计算最终的变换矩阵 multiplyMatrix(T0_1, T1_2, T0_2); multiplyMatrix(T0_2, T2_3, T0_3); multiplyMatrix(T0_3, T3_4, T0_4); multiplyMatrix(T0_4, T4_5, T0_5); multiplyMatrix(T0_5, T5_6, T0_6); point.x1=T0_6[0][3]; point.y1=T0_6[1][3]; point.z1=T0_6[2][3]; return point; } void dhMatrix(double T[4][4], double theta, double d, double a, double alpha) { double radTheta = theta * PI / 180.0; double radAlpha = alpha * PI / 180.0; T[0][0] = cos(radTheta); T[0][1] = -sin(radTheta); T[0][2] = 0; T[0][3] = a; T[1][0] = cos(radAlpha) * sin(radTheta); T[1][1] = cos(radTheta) * cos(radAlpha); T[1][2] = -sin(radAlpha); T[1][3] = -d * sin(radAlpha); T[2][0] = sin(radAlpha) * sin(radTheta); T[2][1] = sin(radAlpha) * cos(radTheta); T[2][2] = cos(radAlpha); T[2][3] = d * cos(radAlpha); T[3][0] = 0; T[3][1] = 0; T[3][2] = 0; T[3][3] = 1; } void multiplyMatrix(double A[4][4], double B[4][4], double C[4][4]) { for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) { C[i][j] = 0; for (int k = 0; k &lt; 4; k++) C[i][j] += A[i][k] * B[k][j]; } }};void turnL() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500+400,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500+320,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500+320,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500+320,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 delay(10);}void turnR() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500+(-400),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500+(-320),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500+(-320),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500+(-320),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 delay(10);}void forward() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500+360,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500+(-320),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500+360,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500+(-320),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 delay(40);}void stop() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500+0,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500+0,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500+0,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500+0,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向}void turningleft() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500-400,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500-600,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500-400,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500-600,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 delay(700);}void turningright() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500+(+600),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500+(+400),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500+(+600),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500+(+400),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 delay(800);}void leftturningleft() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500-000,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500-800,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500-000,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500-800,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 delay(750);}void leftforward() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500+360,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500+(-360),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500+360,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500+(-360),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 delay(40);}void rightturningright() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500+800,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500-000,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500+800,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500-000,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 delay(750);}void rightforward() { sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,6,1500+360,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,7,1500+(-360),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,8,1500+360,0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 sprintf(cmd_return_tmp, &quot;#%03dP%04dT%04d!&quot;,9,1500+(-360),0); //组合指令 Serial.println(cmd_return_tmp); //解析ZMotor指令-左电机正向 delay(40);}float checkdistance_A1_A2() { digitalWrite(A1, LOW); delayMicroseconds(2); digitalWrite(A1, HIGH); delayMicroseconds(10); digitalWrite(A1, LOW); float distance = pulseIn(A2, HIGH) / 58.00; //delay(10); return distance;}void follow(){ if (digitalRead(A4) == 0 &amp;&amp; digitalRead(A5) == 1) { item = 0; forward(); } else if (digitalRead(A4) == 1 &amp;&amp; digitalRead(A5) == 0) { item = 1; forward(); } else if (digitalRead(A4) == 0 &amp;&amp; digitalRead(A5) == 0) forward(); else if (item == 0 &amp;&amp; (digitalRead(A4) == 1 &amp;&amp; digitalRead(A5) == 1)) turnL(); else if (item == 1 &amp;&amp; (digitalRead(A4) == 1 &amp;&amp; digitalRead(A5) == 1)) turnR();}void writeone(){ Points p1; Points p2; Points p3; p1.x1=345; p1.y1=0; p1.z1=400; p2.x1=345; p2.y1=0; p2.z1=360; p3.x1=345; p3.y1=0; p3.z1=320; Arm arm1(L1,L2,L3,L4,p1); arm1.run(); delay(1000); Arm arm2(L1,L2,L3,L4,p2); arm2.run(); delay(1000); Arm arm3(L1,L2,L3,L4,p3); arm3.run(); delay(1000); flag_cp2 = 3;}void writetwo(){ Points p1; Points p2; Points p3; Points p4; Points p5; Points p6; p1.x1=345; p1.y1=40; p1.z1=400; p2.x1=345; p2.y1=-40; p2.z1=400; p3.x1=345; p3.y1=-40; p3.z1=360; p4.x1=345; p4.y1=40; p4.z1=360; p5.x1=345; p5.y1=40; p5.z1=320; p6.x1=345; p6.y1=-40; p6.z1=320; Arm arm1(L1,L2,L3,L4,p1); arm1.run(); delay(1000); Arm arm2(L1,L2,L3,L4,p2); arm2.run(); delay(1000); Arm arm3(L1,L2,L3,L4,p3); arm3.run(); delay(1000); Arm arm4(L1,L2,L3,L4,p4); arm4.run(); delay(1000); Arm arm5(L1,L2,L3,L4,p5); arm5.run(); delay(1000); Arm arm6(L1,L2,L3,L4,p6); arm6.run(); delay(1000); flag_cp2 = 3;}void armset(){ Points p0; p0.x1=280; p0.y1=0; p0.z1=320; Arm arm0(L1,L2,L3,L4,p0); arm0.run();}void setup(){ servo_7.attach(7); servo_3.attach(3); servo_5.attach(5); servo_6.attach(6); servo_9.attach(9); //servo_8.attach(8); Serial.begin(115200); delay(400); item = 2; pinMode(A1, OUTPUT); pinMode(A2, INPUT_PULLUP); pinMode(A5, INPUT_PULLUP); pinMode(A4, INPUT_PULLUP); pinMode(A0, OUTPUT); pinMode(A3, INPUT_PULLUP);}int leftflag=0;int rightflag=0;void loop(){ if (flag_cp2 == 0) armset(); else if (flag_cp2 == 1) writeone(); else if (flag_cp2 == 2) writetwo(); float distance = checkdistance_A1_A2(); if (distance &gt; 19 &amp;&amp; flag_cp1==0) follow(); else if (distance &lt;=19 &amp;&amp; flag_cp1==0) { stop(); digitalWrite(A0, HIGH); delay(3000); color = digitalRead(A3);//0-green,1-blue if(color == 1) turningleft(); else if (color == 0) turningright(); digitalWrite(A0, LOW); flag_cp1=1; startTime = millis(); } else if (distance &gt;17 &amp;&amp; flag_cp1==1) { currentTime = millis(); elapsedTime = currentTime - startTime; if(color == 1) { if (elapsedTime&lt;=33000) follow(); else if (elapsedTime&gt;33000) { if(leftflag == 0) { leftturningleft(); leftforward(); leftflag=1; } if (digitalRead(A4) == 0 &amp;&amp; digitalRead(A5) == 0) leftforward(); else follow(); } } else if (color == 0) { if (elapsedTime&lt;=34000) follow(); else if (elapsedTime&gt;34000) { if(rightflag == 0) { rightturningright(); rightforward(); rightflag=1; } if (digitalRead(A4) == 0 &amp;&amp; digitalRead(A5) == 0) rightforward(); else follow(); } } } else if (distance &lt;=17 &amp;&amp; flag_cp1==1) { stop(); digitalWrite(A0, HIGH); delay(5000); size=digitalRead(A3);//0-small,1-big digitalWrite(A0, LOW); if (size==0 &amp;&amp; flag_cp2!=3) flag_cp2=1; else if (size==1 &amp;&amp; flag_cp2!=3) flag_cp2=2; }}","link":"/2024/06/26/robot/"},{"title":"商场火灾场景下救灾机器人抓取目标救援对象的距离特性研究","text":"摘要本报告主要探讨了救灾机器人在人机交互和远程控制平台设计中的距离特性问题。通过Unity软件搭建模拟实验平台，并收集操作人员在操作机器人”抓取”持续运动的目标救助人员时的相关数据，基于Matlab软件进行数据分析，挖掘用户潜在的操作习惯与背后的操作逻辑规律。研究表明，在机器人与目标救援人员为相遇（拦截）关系的前提下，通过摄像头远程返回影像做出抓取判断时的决策距离与待救援人员运动的速度成正相关，而与机器人移动的速度成负相关。这些发现对未来进一步改进远程救援控制平台的设计及机器人相关物理参数的优化具有重要意义。 关键词: 救灾机器人、人机交互、距离特性、Unity、Matlab Introduction救灾机器人是在安全生产和防灾减灾救灾过程中，执行监测预警、搜索救援、通信指挥、后勤保障、生产作业等任务，能够实现半自主或全自主控制，部分替代或完全替代人类工作的智能机器系统的总称。救灾机器人具有感知、决策、执行等特征，可提升复杂危险场景中生产和救援的效率与安全性。地震、火灾、核泄漏等事故发生时，由于事故现场环境复杂、风险因素较多，同时可能伴有次生灾害，因此现在越来越多的事故现场救援初期采用救灾机器人进行现场救援。救灾机器人的发展与应用，代表了应急管理装备现代化发展趋势，是衡量我国应急管理体系与能力现代化的重要标志。 常见的火灾救灾机器人（如下图）主要由以下几个基本部分组成： 行走机构：用于在复杂的地表环境下行走。 影音采集机构（如摄像头等）：用于采集复杂环境下的环境信息。 机械臂：用于远程操控执行部分操作。 在救灾机器人的实际使用过程中，一般通过无线通信的方式将救灾现场的影音信息远程传送给操作人员，并由操作人员对于机器人进行一系列操作，包括控制机器人的行走路径、通过机器人的机械臂进行障碍物移除、爆炸物拆除等操作，这些操作也往往通过远程控制平台实现。因此，设计一个能与机器人自身操作特性（尺寸等参数）良好契合且操作效率与精准度较高、简洁易用的远程救援控制平台是提高救援成功率的关键。 在远程救援控制平台的设计过程中必不可少地需要关注到人机交互的相关问题。一个值得注意的问题是，操作人员对于救灾机器人的物理参数可能相对了解较少，特别是在只能借助于机载摄像头对周围环境进行观察的情况下，无法通过摄像头远程返回的画面精准判断机器人与目标救助人员（多为行动不便）之间的距离，从而可能会因为二者的交互失败导致目标救助人员无法通过搭乘救灾机器人实现逃生，使得救援成功率不理想，甚至可能会由于机械臂的误操作等对目标救助人员造成二次伤害，这是我们所不希望看到的。因此，希望通过收集操作人员（用户）在模拟实验平台中操作机器人”抓取”持续运动的目标救助人员时的相关数据，分析用户的操作习惯，从而更好地指导远程救援控制平台的设计以及机器人相关物理参数与摄像头摆放位置等的改进。 Literature Review▼ 文献1[^1] : The different characteristics of human performance in selecting receding and approaching targets by rotating the head in a 3D virtual environment 综述: 初始距离、目标移动速度和目标容差对于操作的准确性影响较大。初始距离会影响抓取操作的时间特性，在远离运动中，需要以高于目标速度追击目标，而靠近运动中则需要拦截目标。目标移动速度增大会增加抓取难度，特别是在远离运动中，影响更为显著。目标容差主要影响调整阶段，影响抓取精度，但不影响加速和减速阶段。 ▼ 文献2[^2]: Beyond Fitts’s Law: A Three-Phase Model Predicts Movement Time to Position an Object in an Immersive 3D Virtual Environment综述: 理解距离特性对三维场景下的准确抓取来说至关重要。目标定位任务在三维虚拟环境中的特点明显不同于二维界面。例如，三维空间中的目标操作涉及大范围的手臂移动和虚拟手或射线投射技术。研究指出，人类的目标导向手臂运动包括快速的弹道阶段和慢速的修正阶段，这两个阶段在不同的因素影响下表现各异。此外，目标大小、运动幅度和目标容差是影响定位时间的主要因素，这些因素在三维环境中与传统的二维环境有所不同。 ▼ 文献3[^3]: Capture of moving targets: amodification of Fitts’ Law 综述: 该文章主要描述了一个根据Jagacinski等人的实验数据开发的数学模型，用于描述移动目标的捕获时间。该模型在位置和速度控制系统下都经过了测试，并且与实验数据拟合良好。在移动目标下，该模型对Fitts定律的主要修改在于稳态位置误差，从而减小了有效目标宽度。在静止目标情况下，该模型退化为经典的Fitts定律。该模型预测了一个临界速度，超过这个速度目标将无法被捕获，这与Jagacinski等人的实验数据相符，可用于理解救灾机器人在不同速度下捕获目标的效率和限制。 ▼ 文献4[^4] : 面向人机交互的机器人信息融合系统的研究与实现 综述: 本篇文章主要探讨了在人机交互中，利用多传感器信息融合技术提升机器人对人体目标跟随的效率和精度。作者提出了一个面向人机交互的机器人信息融合系统，包括人体感知、视觉跟踪和运动跟随模块。通过运用帧间差分法和骨架验证识别人体目标，利用小波变换融合深度图像和反向投影图提高视觉跟踪精度，并采用位姿信息融合方法实现运动跟随。这些技术和系统设计有助于提升机器人在火灾场景下抓取目标救助对象的距离检测的精准性。 ▼ 文献5[^5] : 三维虚拟空间中物体移动操作的交互模型 综述: 这项研究通过三个实验系统探讨了影响3D空间物体移动效率的因素，并建立了相应的数学模型。研究发现，除了传统的移动距离和目标大小外，被移动物体的大小和所处深度也影响移动效率。实验结果表明，移动物体的大小影响移动过程中的加速阶段，而移动物体所处的深度则影响整体移动时间。通过以视角为单位的修正模型，研究者成功地拟合了实验数据，提高了移动操作效率的预测准确性。这一研究成果为虚拟3D空间中的人机交互设计提供了有益的参考，可为设计更有效的救灾机器人操作策略提供理论支持。 ▼ 文献6[^6] : 虚拟运动目标人机交互方法设计与仿真 综述: 这项研究提出了一种基于多体感融合的虚拟运动目标人机交互方法，以解决当前虚拟手型逼真度偏低的问题。利用Kinect采集深度图像和彩色图像，结合颜色直方图匹配结果，实现了对虚拟运动目标的准确识别和跟踪。通过提取目标结构信息并融合全部体感特征，构建了笛卡尔空间映射关系，以实现人机交互。仿真结果显示，该方法不仅能够获取高逼真度的虚拟手型，还能够准确跟踪和识别目标，为解决商场火灾场景下救灾机器人抓取目标救助对象的距离特性提供了实用性解决方案，使虚拟实验平台上的交互操作在现实中成为可能。 ▼ 文献7[^7] : 救灾机器人远程操作控制台设计 综述: 本篇文章强调了在各种灾难中，特别是火灾等复杂环境下，使用消防机器人进行救援的必要性，从消防救援的角度出发，针对地震、火灾、核泄漏等灾害提出了机器人功能需求，并结合人因工程学等相关学科知识，从宏观层面探讨了远程操作平台的构建方法，并给出了一些关键的参考数值，为实验平台的搭建提供了指导性的重要参考。 ▼ 文献8[^8] : 可变形履带机器人数字孪生测试平台研究 综述: 作者利用Unity引擎开展了关于多地形多运动模式矿井救灾机器人的研究，围绕虚拟空间生成崎岖巷道的数字孪生环境展开，建立了数字化描述模型，并实现了可变形履带机器人的现实层面与抽象层面的复制，构建了物理级和系统级的数字孪生样机，以及信息级的数字孪生平台。这项研究的方法和成果为类似商场火灾场景下的救灾机器人开发提供了借鉴，特别是在抓取目标救助对象的距离特性研究方面，为机器人的设计与测试提供了新思路和技术支持。 ▼ 文献9[^9] : 一种基于三维建图和虚拟现实的人机交互系统 综述: 该研究提出了基于三维建图和虚拟现实技术的人机交互系统，旨在提高救援机器人在商场火灾场景下的应用效率。操作人员则可通过虚拟现实系统的交互设备生成控制指令，实现对机器人的运动控制。这一系统不仅能够将机器人环境实时可视化，提供操作人员极强的沉浸感，还为人与机器人的自然交互提供了新的思路，对于促进人机交互技术的发展具有重要意义，也从技术层面为救援机器人在路径规划导航与精准定位抓取等方面提供有力支持。 ▼ 文献10[^10] : 多模态交互中的目标选择技术 综述: 多模态交互技术利用各种传感器捕获的信息，预测人的交互意图，提升机器对人行为的理解能力，尤其适用于目标选择任务。在人机交互系统中，目标选择任务是一项基础任务，已有多个行为模型针对多模态交互进行了描述，这些理论对于开发多模态交互技术具有指导意义，可以有效推动人机交互向更自然的方向发展，也为远程操作平台在机器人与多个目标救助人员的交互逻辑设计方面提供参考。 Method and Results在一系列对于机器人与操作平台基本需求分析的基础上，我们基于Unity软件搭建了救灾机器人远程救援模拟实验平台，并希望通过模拟实验来帮助实际平台设计进行进一步改进。落实到该实验平台，本次研究的主题可以这么描述：通过收集用户操作机器人对虚拟人实现救援过程的数据，具体而言即”救援”这一行动（平台中的交互方式表现为机器人会”抓取”待救援人员并”牵引”其共同移动到终点）中的”抓取”行为（实验中简化为用户判断并发出抓取指令与完成抓取动作过程中无延迟）发生前的瞬间机器人与待救援人员之间的距离以及两者各自的运动速度，对其进行数据分析，从而寻找彼此之间的关系。实际上，用户（即操作人员）在无任何提示的情况下，应根据摄像头回传画面中出现的待救援人员的图像来判断两者之间的距离，当用户认为距离合适时便会做出判断、发出”抓取”指令以施行救援。但这样的主观判断往往具有不确定性，很容易造成误判从而带来不必要的损失甚至是二次伤害。因此，我们希望通过模拟实验的数据分析，初步得到机器人和待救援人员的移动速度与合适的实际抓取距离之间的关系，尽可能地探索用户主观判断抓取时机的规律，从而可以在检测两者数据的情况下，推测两者与合适的实际抓取距离之间的关系，进而可以提前在用户操作平台界面以UI形式给出提示，实现更精准更快速的救援，提高救援效率；同时这样的结果也可以反馈到摄像头安装位置的确定以及机械臂长度等等物理参数的确定过程，基于人因与工效学实验的结果进一步优化整体的结构设计，使整体更易上手、提高易用性。 在Unity远程救援模拟实验平台中，事先编写脚本记录所需要的实验数据，主要包括”抓取”动作发生时（按下鼠标左键即执行抓取，最大抓取范围设置为5单位）机器人与待救援人员之间的距离以及两者各自的移动速度，并编写控制与交互脚本，保证各项功能正常运行。考虑到实际应用场景，整体环境设置为商场场景，共设置3位NPC（动画与外形素材来源于蒯曙光老师的素材库[^11] ），各自具有不同的移动速度与行进路线；场地内模拟火灾场景，随时间推移火势会不断蔓延（烟雾扩散），在烟雾逼近时NPC会主动向最近的出口奔跑逃生，但行动不便的顾客移动速度较慢，需要机器人对其实施救援。用户（操作者）需要操作机器人，从入口出发进入火灾现场，通过”抓取”操作实施救援，最终将所有的顾客NPC全部救出至安全出口。值得注意的是，本实验仅考虑文献1[^1]中的简化情形，即只考虑机器人从正面”拦截”目标；这样的假设相对是合理的，因为机器人同样是从安全出口进入商场，寻找被困人员并将其带至安全出口，基本不存在从后方”追击”被困人员的情况，且实际实验过程中在具有多视角地图的情况下（实际操作时也会将商场平面图提前导入机器人与操作平台）也没有实验者采取”绕远路”的方式实行救援。 邀请到同组的5位同学作为实验者，每个人完成10次救援，共得到50组数据，并利用Matlab软件对于导出的数据集进行数据分析。原始数据集、代码与Unity实验环境均已上传至Github（链接：https://github.com/Asgard-Tim/ergonomic），在此仅对于数据分析过程与结果进行必要性的说明： 首先，对于抓取时刻的数据参数进行研究，明确自变量：机器人的移动速度robospeed、待救援人员的移动速度humanspeed；因变量：两者间相距距离distance。对于两个不同的自变量，分别以其为横轴，两者相距距离为纵轴，绘制散点图（下左图，颜色反映另一未在坐标轴上的变量值）； 可以看到， 由于顾客NPC在行走与奔跑逃生时都有各自的固定设定速度，右侧以humanspeed为横坐标的散点图的数值点集中分布在0*.5,* 0*.8, 2.0, 2.8四处。于是，在这样四个特定的humanspeed聚集点上，分别对各点对应的决策距离distance取均值并绘制直方图观察其关于NPC移动速度humanspeed的变化趋势（上右图）：随着humanspeed的增加，执行”抓取”操作的决策距离distance*也呈递增趋势。 虽然机器人的速度在实验平台中并没有以固定值的方式明确，但是在实际操作运行中机器人的移动速度robospeed仍然在2*.2937与2.*5291两发生了大批量的聚集现象。这里的探讨分两方面进行： 首先还是将聚集点用均值代替以观察总体上决策距离distance随机器人移动速度robospeed的变化趋势（下左图）； 尽管递减趋势较为明显，即机器人移动速度robospeed应与决策距离distance呈负相关关系，但散点图的线性度并不好，可能是由于存在相对较大的实验误差，或是本身就不成线性关系；较为有限的样本量也导致暂时找不到较为合适的初等函数对两者关系进行拟合。 另一方面，还可以对上述的数据处理过程做进一步拓展，即对于聚集点2*.2937与2.5291两处的数据可以从NPC移动速度humanspeed与决策距离distance变化关系的角度再次观测（如上右图），可以看到在这两个聚集点处NPC移动速度humanspeed与决策距离distance*仍然成正相关关系。 从总体而言，决策距离distance的均值为2*.8724，NPC移动速度humanspeed的均值为1.5660，机器人移动速度robospeed的均值为2.*3549。这为后续对于三者特别是决策距离的平均水平的宏观把握提供了一定的参考价值。 Discussion and Conclusion遗憾的是，由于各方面条件限制，实验条件与样本数量有限，从50个小样本数据中很难得到更加一般化的公式层面的结果来反映用户的决策距离distance与两者移动速度之间的定量关系，只是从定性角度进行分析。事实上，在文献7[^7]中有给出一些相应的数值参考， 但并未在我们的模型上取得良好的效果；而文献2[^2] 、文献3[^3]虽然给出了基于Fitts′ Law的公式化的结论，但也未在我们的实验数据集上得到良好的验证。但总体而言，我们的实验数据得到的初步统计分析的结果所反映出来的变化趋势与文献中所给出的函数的趋势走向是大致一致的，即：用户根据摄像头进行执行”抓取”操作判断的决策距离distance与NPC移动速度humanspeed成正相关，与机器人移动速度robospeed成负相关，这也验证了我们研究的有效性与可行性。希望能在未来能够进一步完善整个模拟操控平台、收集到更多的数据以完善统计结论，从而简化整体的交互设计，使最终实装的远程救援控制平台更加人性化、便捷、易上手，提高救援成功率，让更多的人享受科学技术带来的福祉。 参考文献[^1]: DENG Chenglong, GENG Peng, KUAI Shuguang. (2023). The different characteristics of human performance in selecting receding and approaching targets by rotating the head in a 3D virtual environment. Acta Psychologica Sinica, 55(1), 9-21.[^2]: Deng, C.-L., Geng, P., Hu, Y.-F., &amp; Kuai, S.-G. (2019). Beyond Fitts’ s Law: A Three-Phase Model Predicts Movement Time to Position an Object in an Immer- sive 3D Virtual Environment. Human Factors, 61(6), 879-894.[^3]: ERROL R. HOFFMANN (1991) Capture of moving targets: a modification of Fitts’ Law, Ergonomics, 34:2, 211-220.[^4]: 刘素成. 面向人机交互的机器人信息融合系统的研究与实现[D].电子科技大学,2018.[^5]:邓成龙,胡逸,耿鹏,等. 三维虚拟空间中物体移动操作的交互模型[C]//中国心理学会.第二十届全国心理学学术会议–心理学与国民心理健康摘要集.[出版者不详],2017:2.[^6]:龙年, 刘智惠. 虚拟运动目标人机交互方法设计与仿真[J]. 计算机仿真,2022, 39(06):201-205.[^7]: 于彦凤,刘力源,楚炎.救灾机器人远程操作控制台设计[J].大众标准化,2021(18):220-222.[^8]: 魏桢. 可变形履带机器人数字孪生测试平台研究[D]. 中国矿业大学,2022.[^9]: 张辉,王盼,肖军浩,等.一种基于三维建图和虚拟现实的人机交互系统[J].控制与决策,2018,33(11):1975-1982.[^10]: 周小舟, 宗承龙, 郭一冰, 等. 多模态交互中的目标选择技术[J]. 包装工程,2022,43(04):36-44.[^11]: Zhou, C., Han, M., Liang, Q., Hu, Y.-F., &amp; Kuai, S.-G. (2019). A social interaction field model accurately identifies static and dynamic social groupings. Nature Hu- man Behaviour, 3(8), 847–855.","link":"/2024/06/11/ergo/"},{"title":"QQ聊天记录分析 QQMsgAnalysis","text":"从PC端QQ中以txt格式导出聊天记录，存为message.txt。 需要安装的库: numpy, seaborn, pandas, wordcloud, tdqm, paddlepaddle, paddlenlp 准备阶段引入包 pandas: 基础数据框架 matplotlib &amp; seaborn: 主要绘图框架 jieba: 中文分词 wordcloud: 词云 paddlenlp: 情感分析 123456789101112131415161718import reimport timeimport numpy as npimport pandas as pdimport jiebaimport jieba.posseg as psegfrom PIL import Imagefrom wordcloud import WordCloudimport seaborn as snsimport matplotlib.ticker as mtickerimport matplotlib.transforms as mtransformsfrom matplotlib.colors import ListedColormapfrom matplotlib import pyplot as pltimport matplotlib.pyplot as pltfrom matplotlib import font_manager as fmfrom tqdm import tqdmfrom paddlenlp import Taskflow%matplotlib inline 数据预处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import csvfrom datetime import datetimedef convert_messages(input_file, output_file): # 定义CSV文件头部 header = [&quot;LocalId&quot;, &quot;TalkerId&quot;, &quot;Type&quot;, &quot;SubType&quot;, &quot;IsSender&quot;, &quot;CreateTime&quot;, &quot;Status&quot;, &quot;StrContent&quot;, &quot;StrTime&quot;, &quot;Remark&quot;, &quot;NickName&quot;, &quot;Sender&quot;] # 打开输入和输出文件 with open(output_file, 'w', newline='', encoding='utf-8') as outfile: csv_writer = csv.writer(outfile) csv_writer.writerow(header) # 写入头部 # 用集合存储姓名 names = set() # 逐行读取txt文件内容并转换为csv格式 with open(input_file, 'r', encoding='utf-8') as file: lines = file.readlines() for i in range(0, len(lines), 3): timestamp_and_name = lines[i].strip().split(' ', 2) date_time = timestamp_and_name[0] + ' ' + timestamp_and_name[1] # 日期时间 name = timestamp_and_name[2] # 姓名（或用户名） # 根据姓名判断是否在指定范围内，如果不在，则跳过该条消息 if name not in [&quot;王婧怡(清辉)&quot;, &quot;成王败寇。&quot;, &quot;皇后&quot;, &quot;王婧怡&quot;, &quot;世界之巅&quot;, &quot;2558749399&quot;]: continue message = lines[i + 1].strip() # 消息内容 # 如果消息内容为空，则跳过该条消息 if not message: continue # 根据消息内容设置Type字段的值 if &quot;[图片]&quot; in message: type_value = 3 elif &quot;[表情]&quot; in message: type_value = 47 else: type_value = 1 # 默认为1 # 根据姓名设置IsSender字段的值 if name in [&quot;王婧怡(清辉)&quot;, &quot;成王败寇。&quot;, &quot;皇后&quot;, &quot;王婧怡&quot;]: is_sender = 0 elif name in [&quot;世界之巅&quot;, &quot;2558749399&quot;]: is_sender = 1 # 将姓名添加到集合中，如果之前没有出现过的话 if name not in names: # print(name) names.add(name) # 自动生成LocalId local_id = i // 3 + 1 # 构建CSV行 csv_row = [local_id, 1, type_value, 0, is_sender, i, '', message, date_time, '', '', ''] csv_writer.writerow(csv_row) print(f&quot;转换完成，结果保存在 {output_file}&quot;)# 使用示例# convert_messages(&quot;message.txt&quot;, &quot;messages.csv&quot;) 绘图设置1234sns.set_theme(style=&quot;ticks&quot;)font = &quot;simsun.ttc&quot;fp = fm.FontProperties(fname=font)plt.rcParams[&quot;axes.unicode_minus&quot;] = False 人名标签1labels = [&quot;WJY&quot;, &quot;XJH&quot;] 数据读取 filePath: 消息记录文件的路径 dStart: 开始的时间 dEnd: 结束的时间 tZone: 时区，例如北京时间为 +8 1234filePath = &quot;messages.csv&quot;dStart = &quot;2022-08-07 00:00:00 +0800&quot;dEnd = &quot;2024-02-10 23:59:59 +0800&quot;tZone = 8 12345678df = pd.read_csv(filePath, encoding=&quot;utf-8&quot;)df.loc[:, &quot;StrTime&quot;] = pd.to_datetime(df[&quot;StrTime&quot;])df.loc[:, &quot;day&quot;] = pd.to_datetime(df[&quot;StrTime&quot;]).dt.dayofweekdf.loc[:, &quot;hour&quot;] = pd.to_datetime(df[&quot;StrTime&quot;]).dt.hourdf.loc[:, &quot;Count&quot;] = 1dfs = [df.query(&quot;IsSender == 0&quot;), df.query(&quot;IsSender == 1&quot;)] 消息过滤123456789def textFilter(text: str): text = text.lower() # try: # co = re.compile(&quot;[\\U00010000-\\U0010ffff]&quot;) # except re.error: # co = re.compile(&quot;[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]&quot;) # text = co.sub(&quot; &quot;, text) co = re.compile(&quot;\\[[\\u4e00-\\u9fa5]+\\]&quot;) return co.sub(&quot; &quot;, text) 获取文本消息1234texts = [ [textFilter(i) for i in dfs[0].query(&quot;Type == 1&quot;)[&quot;StrContent&quot;].to_list()], [textFilter(i) for i in dfs[1].query(&quot;Type == 1&quot;)[&quot;StrContent&quot;].to_list()],] 消息频率分析类型分析根据消息的类型进行分类，可以看出喜欢发送的消息类型，同时也可以看出谁发的多 1 = Text 3 = Image 34 = Voice 43 = Video 47 = Sticker 48 = Location 10000 = System 12345678910111213141516171819202122232425262728data = {}for i in range(2): data[labels[i]] = [ len(dfs[i].query(&quot;Type == 1&quot;)), len(dfs[i].query(&quot;Type == 3&quot;)), len(dfs[i].query(&quot;Type == 34&quot;)), len(dfs[i].query(&quot;Type == 43&quot;)), len(dfs[i].query(&quot;Type == 47&quot;)), ]data = ( pd.DataFrame(data, index=[&quot;Text&quot;, &quot;Image&quot;, &quot;Voice&quot;, &quot;Video&quot;, &quot;Sticker&quot;]) .reset_index() .melt(&quot;index&quot;) .rename(columns={&quot;index&quot;: &quot;Type&quot;, &quot;variable&quot;: &quot;Person&quot;, &quot;value&quot;: &quot;Count&quot;}))g = sns.catplot(data, kind=&quot;bar&quot;, x=&quot;Type&quot;, y=&quot;Count&quot;, hue=&quot;Person&quot;, palette=&quot;dark&quot;, alpha=0.6, height=6)for ax in g.axes.ravel(): for i in range(2): ax.bar_label(ax.containers[i], fontsize=9)sns.move_legend(g, &quot;upper right&quot;)plt.yscale(&quot;log&quot;)g.figure.set_size_inches(6, 5)g.figure.set_dpi(150)plt.show()plt.close() 消息长度分析 sN: 设置显示范围：$$\\mu + \\mathrm{sN} * \\sigma$$ multiple: 直方图堆叠格式 12sN = 3multiple = &quot;dodge&quot; 12345678910111213141516171819202122232425262728293031mu, std = 0, 0data = {&quot;Length&quot;: [], &quot;Person&quot;: []}for i in range(2): length = [len(textFilter(i)) for i in texts[i]] data[&quot;Length&quot;] += length data[&quot;Person&quot;] += [labels[i]] * len(length) if np.mean(length) + sN * np.std(length) &gt; mu + std: mu, std = np.mean(length), np.std(length)xlim = int(np.ceil(mu + sN * std))data = pd.DataFrame(data)bins = np.linspace(0, xlim, xlim + 1)ax = sns.histplot( data=data, x=&quot;Length&quot;, hue=&quot;Person&quot;, bins=bins, multiple=multiple, edgecolor=&quot;.3&quot;, linewidth=0.5, palette=&quot;dark&quot;, alpha=0.6,)ax.set_xlim(0, xlim)ax.set_xlabel(&quot;Length of Message&quot;)ax.figure.set_size_inches(8, 4)ax.figure.set_dpi(150)plt.show()plt.close() 每日活跃分析划分每日24小时内每小时发送的消息数，可以得知每天的活跃的时间段 123456789101112131415161718192021222324252627282930data = {&quot;Time&quot;: [], &quot;Person&quot;: []}for i in range(2): hour = dfs[i][&quot;hour&quot;].to_list() data[&quot;Time&quot;] += hour data[&quot;Person&quot;] += [labels[i]] * len(hour)data = pd.DataFrame(data)bins = np.arange(0, 25, 1)ax = sns.histplot( data=data, x=&quot;Time&quot;, hue=&quot;Person&quot;, bins=bins, multiple=multiple, edgecolor=&quot;.3&quot;, linewidth=0.5, palette=&quot;dark&quot;, alpha=0.6,)ax.set_xticks(bins)ax.set_xticklabels(bins)ax.set_xlabel(&quot;Hour&quot;)ax.set_xlim(0, 24)sns.move_legend(ax, loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, 1.2), ncol=2)ax.figure.set_size_inches(8, 4)ax.figure.set_dpi(150)plt.show()plt.close() 每周活跃分析查看一周内从周一到周日每天发送的消息数 12345678910111213grouper = pd.Grouper(key=&quot;day&quot;)data = df.groupby(grouper)[&quot;Count&quot;].sum()data = data.sort_index()data.index = [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;]ax = sns.barplot(data=data, errorbar=None)ax.set_xlabel(&quot;Weekday&quot;)ax.bar_label(ax.containers[0], fontsize=10)ax.figure.set_size_inches(5, 5)ax.figure.set_dpi(150)plt.show()plt.close() 按周划分年度活跃分析划分每7天内发送的消息数，可以得知每周的活跃的时间段 wTicks: 每个刻度相差的数值 wStart: 当年第一个周一的日期 wEnd: 次年第一个周一的日期 123wTicks = 500wStart = &quot;2022-08-01&quot;wEnd = &quot;2024-02-09&quot; 12345678910111213141516171819202122232425262728grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;W-MON&quot;)data = df.groupby(grouper)[&quot;Count&quot;].sum().to_frame()data.index = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;)data.columns = [&quot;Count&quot;]vM = np.ceil(data[&quot;Count&quot;].max() / wTicks) * wTicksnorm = plt.Normalize(0, vM)sm = plt.cm.ScalarMappable(cmap=&quot;Reds&quot;, norm=norm)ax = sns.barplot(x=data.index, y=data[&quot;Count&quot;], hue=data[&quot;Count&quot;], hue_norm=norm, palette=&quot;Reds&quot;)ax.set_xlabel(&quot;Date&quot;)plt.xticks(rotation=60)for bar in ax.containers: ax.bar_label(bar, fontsize=10, fmt=&quot;%.0f&quot;)ax.get_legend().remove()axpos = ax.get_position()caxpos = mtransforms.Bbox.from_extents(axpos.x1 + 0.02, axpos.y0, axpos.x1 + 0.03, axpos.y1)cax = ax.figure.add_axes(caxpos)locator = mticker.MultipleLocator(wTicks)formatter = mticker.StrMethodFormatter(&quot;{x:.0f}&quot;)cax.figure.colorbar(sm, cax=cax, ticks=locator, format=formatter)ax.figure.set_size_inches(20, 8)ax.figure.set_dpi(150)plt.show()plt.close() f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) 按周划分聊天热情分析划分每7天内的聊天热情指数，聊天热情指数为发送的消息数减去收到的消息数与总消息数的比值：$$E = \\frac{Q_\\mathrm{S} - Q_\\mathrm{R}}{Q_\\mathrm{S} + Q_\\mathrm{R}}$$ 1234567891011121314151617181920212223242526272829303132333435363738grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;W-MON&quot;)df_W1 = dfs[0].groupby(grouper)[&quot;Count&quot;].sum()df_W2 = dfs[1].groupby(grouper)[&quot;Count&quot;].sum()data = pd.DataFrame({&quot;E&quot;: (df_W1 - df_W2) / (df_W1 + df_W2)})data.index = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;)vM = data[&quot;E&quot;].abs().max()vm = data[&quot;E&quot;].min()norm = plt.Normalize(-vM, vM)sm = plt.cm.ScalarMappable(cmap=&quot;coolwarm&quot;, norm=norm)print(data.index)print(data[&quot;E&quot;])if data[&quot;E&quot;].isna().any(): print(&quot;列 'E' 中包含NaN项&quot;)else: print(&quot;列 'E' 中不包含NaN项&quot;)data[&quot;E&quot;].fillna(0, inplace=True)ax = sns.barplot(x=data.index, y=data[&quot;E&quot;], hue=data[&quot;E&quot;], hue_norm=norm, palette=&quot;coolwarm&quot;)ax.set_xlabel(&quot;Date&quot;)plt.xticks(rotation=60)ax.set_ylabel(&quot;Enthusiasm Index&quot;)for bar in ax.containers: ax.bar_label(bar, fontsize=10, fmt=&quot;%.2f&quot;)ax.get_legend().remove()axpos = ax.get_position()caxpos = mtransforms.Bbox.from_extents(axpos.x1 + 0.02, axpos.y0, axpos.x1 + 0.03, axpos.y1)cax = ax.figure.add_axes(caxpos)locator = mticker.MultipleLocator(0.1)formatter = mticker.StrMethodFormatter(&quot;{x:.2f}&quot;)cax.figure.colorbar(sm, cax=cax, ticks=locator, format=formatter)ax.figure.set_size_inches(20, 8)ax.figure.set_dpi(150)plt.show()plt.close() f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) F:\\user\\Temp\\ipykernel_9048\\3741989350.py:18: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method. The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy. For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. ​​ data[“E”].fillna(0, inplace=True) Index(['08-01', '08-08', '08-15', '08-22', '08-29', '09-05', '09-12', '09-19', '09-26', '10-03', '10-10', '10-17', '10-24', '10-31', '11-07', '11-14', '11-21', '11-28', '12-05', '12-12', '12-19', '12-26', '01-02', '01-09', '01-16', '01-23', '01-30', '02-06', '02-13', '02-20', '02-27', '03-06', '03-13', '03-20', '03-27', '04-03', '04-10', '04-17', '04-24', '05-01', '05-08', '05-15', '05-22', '05-29', '06-05', '06-12', '06-19', '06-26', '07-03', '07-10', '07-17', '07-24', '07-31', '08-07', '08-14', '08-21', '08-28', '09-04', '09-11', '09-18', '09-25', '10-02', '10-09', '10-16', '10-23', '10-30', '11-06', '11-13', '11-20', '11-27', '12-04', '12-11', '12-18', '12-25', '01-01', '01-08', '01-15', '01-22', '01-29', '02-05'], dtype='object') 08-01 0.120000 08-08 0.109091 08-15 0.071633 08-22 -0.007092 08-29 0.075426 ... 01-08 -0.003752 01-15 0.100529 01-22 0.159184 01-29 0.068273 02-05 0.014085 Name: E, Length: 80, dtype: float64 列 'E' 中包含NaN项 按日划分年度活跃分析以热力图的方式展示按日划分的年度活跃情况 123456789101112131415161718192021222324252627282930313233grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;D&quot;)data = df.groupby(grouper)[&quot;Count&quot;].sum()data = data.to_frame()wStart = &quot;2023-01-01&quot;wEnd = &quot;2024-01-01&quot;data[&quot;date&quot;] = data.indexdata[&quot;week&quot;] = data[&quot;date&quot;].dt.isocalendar()[&quot;week&quot;]data[&quot;day&quot;] = data[&quot;date&quot;].dt.dayofweekdata.index = range(len(data))for i in range(7): if data.loc[i, &quot;week&quot;] &gt; 1: data.loc[i, &quot;week&quot;] = 0print(data)data = data.pivot_table(index=&quot;day&quot;, columns=&quot;week&quot;, values=&quot;Count&quot;)data.index = [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;]data.columns = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;)ax = sns.heatmap( data, annot=False, linewidths=0.5, cbar_kws={&quot;orientation&quot;: &quot;vertical&quot;, &quot;location&quot;: &quot;left&quot;, &quot;pad&quot;: 0.03}, cmap=&quot;Reds&quot;,)ax.set_xlabel(&quot;Week&quot;)ax.set_ylabel(&quot;Weekday&quot;)ax.figure.set_size_inches(24, 4)ax.figure.set_dpi(150)plt.show()plt.close() f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) Count date week day 0 46 2022-08-07 0 6 1 104 2022-08-08 0 0 2 100 2022-08-09 0 1 3 47 2022-08-10 0 2 4 3 2022-08-11 0 3 .. ... ... ... ... 547 76 2024-02-05 6 0 548 0 2024-02-06 6 1 549 0 2024-02-07 6 2 550 47 2024-02-08 6 3 551 24 2024-02-09 6 4 [552 rows x 4 columns] 词语分析分词词典、停止词与去除词性1234jieba.load_userdict(&quot;thuocl.txt&quot;)jieba.load_userdict(&quot;userdict.txt&quot;)stopwords = [line.strip() for line in open(&quot;stopwords.txt&quot;, &quot;r&quot;).readlines()] + [&quot; &quot;, &quot;\\n&quot;, &quot;\\r\\n&quot;]wordclass = [&quot;v&quot;, &quot;u&quot;, &quot;vd&quot;, &quot;r&quot;, &quot;p&quot;, &quot;w&quot;] 分词函数123456789101112131415def wordSplit(texts, wordclass): words = [] pbar = tqdm(total=len(texts)) for i in range(len(texts)): res = pseg.lcut(texts[i]) for pair in res: if pair.word in stopwords: continue if pair.flag in wordclass: continue words.append(pair.word) if i % 1000 == 0: pbar.update(1000) pbar.close() return words 1words = [wordSplit(texts[i], wordclass) for i in range(2)] 15000it [00:08, 1837.45it/s] 17000it [00:07, 2395.06it/s] 词云绘制 font: 字体路径，至少支持中文，最好同时支持中文和emoji mask: 词云的蒙版，影响词云的形状 cmap: 色阶 12345678910111213141516171819font = &quot;simsun.ttc&quot;mask = np.array(Image.open(&quot;mask.png&quot;))masks = [np.array(Image.open(&quot;mask_L.jpg&quot;)), np.array(Image.open(&quot;mask_F.jpg&quot;))]cmap = ListedColormap( [ &quot;#fac1cf&quot;, &quot;#a9d7ba&quot;, &quot;#58b1db&quot;, &quot;#f296ab&quot;, &quot;#5dab81&quot;, &quot;#3d9ec4&quot;, &quot;#e16a8d&quot;, &quot;#237b50&quot;, &quot;#1e8299&quot;, &quot;#8d3549&quot;, &quot;#35563b&quot;, &quot;#2d5d73&quot;, ]) 123456789101112def wordCloud(text, font, mask, cmap): wc = WordCloud( background_color=&quot;white&quot;, scale=5, font_path=font, mask=mask, colormap=cmap, collocations=False, ).generate(text) plt.imshow(wc) plt.axis(&quot;off&quot;) plt.show() 1wordCloud(&quot; &quot;.join(words[0]), font, masks[0], cmap) 1wordCloud(&quot; &quot;.join(words[1]), font, masks[1], cmap) 1wordCloud(&quot; &quot;.join(words[0] + words[1]), font, mask, cmap) 高频词排行列出常用的 N 个词，并且展示双方的贡献 wN: 词的数目，默认为50 1wN = 50 12345678910111213data = pd.DataFrame( { &quot;words&quot;: words[0] + words[1], &quot;L&quot;: [1] * len(words[0]) + [0] * len(words[1]), &quot;F&quot;: [0] * len(words[0]) + [1] * len(words[1]), &quot;S&quot;: [1] * len(words[0]) + [1] * len(words[1]), })grouper = pd.Grouper(key=&quot;words&quot;)data = data.groupby(grouper).sum()data = data.sort_values(by=&quot;S&quot;, ascending=False)data = data.iloc[:wN] 123456789101112# 将部分无法识别的 emoji 转化为文字tmp = data.index.to_list()for i in range(wN): if tmp[i] == &quot;😘&quot;: tmp[i] = &quot;[亲亲]&quot; elif tmp[i] == &quot;😂&quot;: tmp[i] = &quot;[笑哭]&quot; elif tmp[i] == &quot;🤦&quot;: tmp[i] = &quot;[捂脸]&quot; elif tmp[i] == &quot;😁&quot;: tmp[i] = &quot;[呲牙]&quot;data.index = tmp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061ratio = data[&quot;L&quot;] / data[&quot;S&quot;]norm = plt.Normalize(0, 1)sm = plt.cm.ScalarMappable(cmap=&quot;coolwarm&quot;, norm=norm)fig = plt.figure(figsize=(10, 10), dpi=300)grid = plt.GridSpec(1, 4, wspace=0.5)ax0 = fig.add_subplot(grid[0, 0])sns.barplot(x=-data[&quot;L&quot;], y=data.index, ax=ax0, hue=ratio, hue_norm=norm, palette=&quot;coolwarm&quot;)ax1 = fig.add_subplot(grid[0, 1:])sns.barplot(x=data[&quot;F&quot;], y=data.index, ax=ax1, hue=(1 - ratio), hue_norm=norm, palette=&quot;coolwarm&quot;)ax0.set_xlabel(&quot;Word Frequency&quot;)ax0.set_ylabel(&quot;&quot;)ax0.set_xticks(range(-400, 1, 200))ax0.set_xticklabels([400, 200, 0])ax0.set_xlim(-400, 0)ax0.set_yticks([])ax0.spines[&quot;left&quot;].set_visible(False)ax0.spines[&quot;top&quot;].set_visible(False)ax0.spines[&quot;right&quot;].set_visible(False)ax0.set_title(&quot;WJY&quot;)ax0.get_legend().remove()ax1.set_xlabel(&quot;Word Frequency&quot;)ax1.set_ylabel(&quot;&quot;)ax1.set_xticks(range(0, 1201, 200))ax1.set_xticklabels([0, 200, 400, 600, 800, 1000, 1200])ax1.set_xlim(0, 1200)ax1.set_yticks([])ax1.spines[&quot;left&quot;].set_visible(False)ax1.spines[&quot;top&quot;].set_visible(False)ax1.spines[&quot;right&quot;].set_visible(False)ax1.set_title(&quot;XJH&quot;)ax1.get_legend().remove()axpos = ax1.get_position()caxpos = mtransforms.Bbox.from_extents(axpos.x0 + 0.06, axpos.y0 + 0.03, axpos.x1, axpos.y0 + 0.04)cax = ax1.figure.add_axes(caxpos)locator = mticker.MultipleLocator(0.1)formatter = mticker.StrMethodFormatter(&quot;{x:.1f}&quot;)cax.figure.colorbar(sm, cax=cax, orientation=&quot;horizontal&quot;, ticks=locator, format=formatter)# cax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)cax.set_title(&quot;ratio&quot;)x0 = ax0.get_position().x1x1 = ax1.get_position().x0xm = (x0 + x1) / 2y0 = ax0.get_position().y0y1 = ax0.get_position().y1for i in range(wN): fig.text( xm, y0 + (y1 - y0) * (wN - i - 0.5) / wN, data.index[i], color=&quot;black&quot;, ha=&quot;center&quot;, va=&quot;center&quot;, fontproperties=fp )fig.set_dpi(150)plt.show()plt.close() 情感分析使用 paddlenlp 进行情感分析，得到的分数在 [-1, 1] 之间，越小越消极，越大越积极 12dfE = df.query(&quot;Type == 1&quot;)[[&quot;IsSender&quot;, &quot;StrContent&quot;, &quot;StrTime&quot;, &quot;hour&quot;]]dfE.index = range(len(dfE)) 1senta = Taskflow(&quot;sentiment_analysis&quot;, home_path=&quot;./&quot;) 12scores = pd.DataFrame(senta([textFilter(i) for i in dfE[&quot;StrContent&quot;].to_list()]))scores.loc[scores[&quot;label&quot;] == &quot;negative&quot;, &quot;score&quot;] = 1 - scores.loc[scores[&quot;label&quot;] == &quot;negative&quot;, &quot;score&quot;] 12345dfE[&quot;score&quot;] = scores[&quot;score&quot;]dfE[&quot;score&quot;] = 2 * dfE[&quot;score&quot;] - 1dfE[&quot;Person&quot;] = dfE.apply(lambda x: labels[x[&quot;IsSender&quot;]], axis=1)dfEs = [dfE.query(&quot;IsSender == 0&quot;), dfE.query(&quot;IsSender == 1&quot;)] 年度总体情感分布12345678910ax = sns.histplot(data=dfE, x=&quot;score&quot;, hue=&quot;Person&quot;, palette=&quot;dark&quot;, alpha=0.6, bins=100)ax.set_xlabel(&quot;Sentiment Score&quot;)ax.set_ylabel(&quot;Count&quot;)ax.set_title(&quot;Sentiment Distribution&quot;)ax.set_xlim(-1, 1)ax.figure.set_size_inches(8, 3)ax.figure.set_dpi(150)plt.show() 按周统计平均情感指数1234567891011121314151617181920212223242526272829303132333435def weekAvgSenScore(df): wStart = &quot;2022-08-01&quot; wEnd = &quot;2024-02-10&quot; grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;W-MON&quot;) data = df.groupby(grouper)[&quot;score&quot;].mean().to_frame() data.index = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;) data.columns = [&quot;score&quot;] vM = data[&quot;score&quot;].abs().max() norm = plt.Normalize(-vM, vM) sm = plt.cm.ScalarMappable(cmap=&quot;coolwarm&quot;, norm=norm) data[&quot;score&quot;].fillna(0, inplace=True) ax = sns.barplot(x=data.index, y=data[&quot;score&quot;], hue=data[&quot;score&quot;], hue_norm=norm, palette=&quot;coolwarm&quot;) ax.set_xlabel(&quot;Date&quot;) plt.xticks(rotation=60) for bar in ax.containers: ax.bar_label(bar, fontsize=10, fmt=&quot;%.2f&quot;) ax.get_legend().remove() axpos = ax.get_position() caxpos = mtransforms.Bbox.from_extents(axpos.x1 + 0.02, axpos.y0, axpos.x1 + 0.03, axpos.y1) cax = ax.figure.add_axes(caxpos) locator = mticker.MultipleLocator(0.02) formatter = mticker.StrMethodFormatter(&quot;{x:.2f}&quot;) cax.figure.colorbar(sm, cax=cax, ticks=locator, format=formatter) ax.figure.set_size_inches(20, 8) ax.figure.set_dpi(150) plt.show() plt.close() return data[&quot;score&quot;] 1avgSenScore0 = weekAvgSenScore(dfEs[0]) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) F:\\user\\Temp\\ipykernel_9048\\3472776600.py:13: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method. The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy. For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. ​​ data[“score”].fillna(0, inplace=True) 1avgSenScore1 = weekAvgSenScore(dfEs[1]) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) F:\\user\\Temp\\ipykernel_9048\\3472776600.py:13: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method. The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy. For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. ​​ data[“score”].fillna(0, inplace=True) 1_ = weekAvgSenScore(dfE) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) F:\\user\\Temp\\ipykernel_9048\\3472776600.py:13: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method. The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy. For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. ​​ data[“score”].fillna(0, inplace=True) 12345678910111213ax = sns.lineplot(data=avgSenScore0, linewidth=3, marker=&quot;s&quot;, markersize=15, label=labels[0])ax = sns.lineplot(data=avgSenScore1, linewidth=3, marker=&quot;^&quot;, markersize=15, ax=ax, label=labels[1])ax.set_xlabel(&quot;Date&quot;)plt.xticks(rotation=60)ax.set_ylabel(&quot;Average Sentiment Score&quot;)ax.set_xlim(0, 52)ax.legend(prop={&quot;size&quot;: 24})ax.figure.set_size_inches(20, 8)ax.figure.set_dpi(150)plt.show()plt.close() 按周统计累计情感指数123456789101112131415161718192021222324252627282930313233def weekTotSenScore(df): wStart = &quot;2022-08-01&quot; wEnd = &quot;2024-02-10&quot; grouper = pd.Grouper(key=&quot;StrTime&quot;, freq=&quot;W-MON&quot;) data = df.groupby(grouper)[&quot;score&quot;].sum().to_frame() data.index = pd.date_range(start=wStart, end=wEnd, freq=&quot;W-MON&quot;).strftime(&quot;%m-%d&quot;) data.columns = [&quot;score&quot;] vM = data[&quot;score&quot;].abs().max() norm = plt.Normalize(-vM, vM) sm = plt.cm.ScalarMappable(cmap=&quot;coolwarm&quot;, norm=norm) ax = sns.barplot(x=data.index, y=data[&quot;score&quot;], hue=data[&quot;score&quot;], hue_norm=norm, palette=&quot;coolwarm&quot;) ax.set_xlabel(&quot;Date&quot;) plt.xticks(rotation=60) for bar in ax.containers: ax.bar_label(bar, fontsize=10, fmt=&quot;%.2f&quot;) ax.get_legend().remove() axpos = ax.get_position() caxpos = mtransforms.Bbox.from_extents(axpos.x1 + 0.02, axpos.y0, axpos.x1 + 0.03, axpos.y1) cax = ax.figure.add_axes(caxpos) locator = mticker.MultipleLocator(20) formatter = mticker.StrMethodFormatter(&quot;{x:.2f}&quot;) cax.figure.colorbar(sm, cax=cax, ticks=locator, format=formatter) ax.figure.set_size_inches(20, 8) ax.figure.set_dpi(150) plt.show() plt.close() return data[&quot;score&quot;] 1totSenScore0 = weekTotSenScore(dfEs[0]) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) 1totSenScore1 = weekTotSenScore(dfEs[1]) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) 1_ = weekTotSenScore(dfE) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) f:\\ProgramData\\miniconda3\\envs\\wechatmsg\\lib\\site-packages\\pandas\\core\\groupby\\grouper.py:381: FutureWarning: Dtype inference on a pandas object (Series, Index, ExtensionArray) is deprecated. The Index constructor will keep the original dtype in the future. Call `infer_objects` on the result to get the old behavior. ax = Index(obj[key], name=key) 12345678910111213ax = sns.lineplot(data=totSenScore0, linewidth=3, marker=&quot;s&quot;, markersize=15, label=labels[0])ax = sns.lineplot(data=totSenScore1, linewidth=3, marker=&quot;^&quot;, markersize=15, ax=ax, label=labels[1])ax.set_xlabel(&quot;Date&quot;)plt.xticks(rotation=60)ax.set_ylabel(&quot;Total Sentiment Score&quot;)ax.set_xlim(0, 52)ax.legend(prop={&quot;size&quot;: 24})ax.figure.set_size_inches(20, 8)ax.figure.set_dpi(150)plt.show()plt.close() 每日平均情感分析12345678910111213141516171819202122232425262728293031323334353637383940414243grouper = pd.Grouper(key=&quot;hour&quot;)data = []for k in range(2): tmp = dfEs[k].groupby(grouper)[&quot;score&quot;].mean().sort_index() for i in range(24): if i in tmp.index: data.append(tmp[i]) else: data.append(0) data.append(0)data = pd.DataFrame( { &quot;Score&quot;: data, &quot;Person&quot;: [labels[0]] * 25 + [labels[1]] * 25, })xBins = [i for i in range(25)]ax = sns.histplot( data=data, x=xBins * 2, bins=xBins, weights=&quot;Score&quot;, hue=&quot;Person&quot;, multiple=multiple, edgecolor=&quot;.3&quot;, linewidth=0.5, palette=&quot;dark&quot;, alpha=0.6,)ax.set_xticks(range(25))ax.set_xticklabels(range(25))ax.set_xlabel(&quot;Hour&quot;)ax.set_xlim(0, 24)ax.set_ylim(np.min([0, np.floor(data[&quot;Score&quot;].min() / 0.05) * 0.05]), np.ceil(data[&quot;Score&quot;].max() / 0.05) * 0.05)sns.move_legend(ax, loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, 1.2), ncol=2)ax.figure.set_size_inches(8, 4)ax.figure.set_dpi(150)plt.show()plt.close() 每日累计情感分析12345678910111213141516171819202122232425262728293031323334353637383940414243grouper = pd.Grouper(key=&quot;hour&quot;)data = []for k in range(2): tmp = dfEs[k].groupby(grouper)[&quot;score&quot;].sum().sort_index() for i in range(24): if i in tmp.index: data.append(tmp[i]) else: data.append(0) data.append(0)data = pd.DataFrame( { &quot;Score&quot;: data, &quot;Person&quot;: [labels[0]] * 25 + [labels[1]] * 25, })xBins = [i for i in range(25)]ax = sns.histplot( data=data, x=xBins * 2, bins=xBins, weights=&quot;Score&quot;, hue=&quot;Person&quot;, multiple=multiple, edgecolor=&quot;.3&quot;, linewidth=0.5, palette=&quot;dark&quot;, alpha=0.6,)ax.set_xticks(range(25))ax.set_xticklabels(range(25))ax.set_xlabel(&quot;Hour&quot;)ax.set_xlim(0, 24)ax.set_ylim(np.min([0, np.floor(data[&quot;Score&quot;].min() / 0.05) * 0.05]), np.ceil(data[&quot;Score&quot;].max() / 0.05) * 0.05)sns.move_legend(ax, loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, 1.2), ncol=2)ax.figure.set_size_inches(8, 4)ax.figure.set_dpi(150)plt.show()plt.close()","link":"/2024/02/11/QQmsganalysis/"},{"title":"斯特林发动机设计报告","text":"1 设计过程与方案概述任务要求为设计一个斯特林发动机，大部分零件采用金属加工的方式，最后能够提供0.5w的功率输出。有以下方面的目标：设计一个能够满足做功要求的气缸，设计与之配套的连杆机构，设计动力输出装置。 针对以上要求，我们先采用β型发动机作为模板进行设计，先设计气缸，后进行相关的理论计算和仿真，最后根据计算和仿真结果对设计进行修改，对修改好的设计进行加工，经过实地组装测试之后再对出现的问题进行分析和修改，最后得到能够满足要求的发动机。 中途进行测试的时候发现β型气缸相对于α来说加工有一定难度，即满足公差设计的加工也可能由于做功活塞和配气活塞之间的差距导致漏气，使得整体运行时存在一定的气体溢出，并未能推动活塞做功。所以我们后续改用了β，α两种发动机并行设计的方式，先在α型上测试成功后，再利用吸取到的经验和设计方式来完成β的设计。 最终测试结果如下：β发动机不能够正常运行，但是气缸的密封基本完成，α型发动机能正常运转，且能够点亮一个额定功率为0.5w的电灯泡，经电表测试约为一个3.2V的电压源，但在实际测试时，没有能够达到0.5W的输出功率。 2 气缸设计与加工设计2.1 气缸设计与做功计算单独对气缸进行分析和设计时，采用的计算方式是先估算转速和单个做功冲程所能做的功，作为一个机械功的功率来源，要先保证功率来源大概约为0.5w的3到5倍，使得为后续机械装置带动发动机皮带留够足够的功率。 气缸的设计关键在于密封性，体现在加工方面就是公差的设计，如果产生的偏差导致气缸和活塞的成品配合不好，则在加热过程中气体就会溢出，使得整个气缸无法产生较大的温差，使得内外压强之间的差距很小，自然无法推动活塞对外做功。在进行气缸设计时，气缸的直径也是一个关键的指标，如果直径过大，加热时间过长，则无法充分受热，无法产生推力，当直径过小时，压强产生的推力会小很多，影响最终的输出功率，我们根据之前学长的发动机进行了简单的估算，直径在1cm-2cm为宜，而公差设计要求气缸为负公差-0.02mm,活塞为正公差+0.02mm，即使加工得没有特别准确，也可以保证通过简单的手动打磨和不断测试可以使得气缸和活塞刚好匹配。 由于高度对称的模型气缸设计，可以建立温度随模型位置的函数t(x)，以及空气密度随温度变化的函数ρ（t），则根据理想气体方程PV=nRT，进行变形，得到PV=ρSX/MRT,调整位置得到，PV=S/MR*(ρXT)，变为微分形式可得到，PSdx=S/MR*(ρ（x）T（x）dx)，变形得，FSdx=S/MR*(ρ（x）T（x）dx)即dw=S/MR*(ρ（x）T（x）dx)，由于该过程恒处于大气压下，将各物理常数，代入积分后可直接得到结果。 以下为matlab计算步骤：先根据图进行采样，计算并拟合出温度位置曲线T(x),再代入公式进行计算，β型的计算过程过程如下图： 则单次做功冲程能够对活塞做功1.07J，也就是说在转速约为5-8转每秒时，完全可以提供足够的功率带动后续的传动装置和发电机。 对于α的计算如下图： {width=”5.759722222222222in”height=”2.3715277777777777in”} 则单次做功冲程能够对活塞做功0.9152J，也就是说在转速约为8-12转每秒时，完全可以提供足够的功率带动后续的传动装置和发电机。 2.2 密封、公差、轴承、振动的设计2.2.1 振动在经过组装测试后，我们观察了其运动时的振动情况，并对振动来源进行分析，从而提出了一些减少振动的方案。 对于β型的振动分析： {width=”2.42882217847769in”height=”3.2392957130358706in”} 可以看到，主要振动的来源在于两连杆间半个周期收活塞的推力传导产生对于中轴形成的错位的力矩，此外，飞轮转动使得由角动量产生的对抗上述力矩的回正力矩（类似惯性力）。综合上述过程，整体振动的来源就是上述周期性力矩的合力矩，但由于存在相互抵消的部分，只要飞轮和连杆的设计配合比较好，就能减小振动的影响，即飞轮设计的大一些，连杆的宽度设计得小一些。 对于β型的振动分析： 可以看到由于α冷热缸分开且加入回热器后，会由于气体做功出现两组相反的周期性旋转力矩，且时间错开，这导致会产生一个稳定的围绕支撑杆的左右转动进而引起振动，且最终呈现的合力矩会使在如上图方向时使发动机整体逆时针旋转，对整体的稳定性产生极大的影响。对此我们采用了相应的解决方案，在下部固定橡胶的减震底座，使底座与地面摩擦力增大，不使其绕固定轴进行旋转，同时减少其振动。 2.2.2 轴承（1）型号选择根据α、β斯特林发动机上需要使用轴承的部件及要求，我们分别采用了两种轴承：深沟球和推力球轴承。两种使用场景下，轴承都只收到径向压力，而α型上的轴承用来满足转轴高速转动需求，β型上的轴承用来连接不同平面内的连杆、飞轮。 （2）寿命分析 1．深沟球轴承寿命分析 轴承属性见上表（厂商提供）。工作温度小于120℃，ft=1。查表后fp取1.1。 F_R由G，Fn两部分构成。其中G是飞轮重力，Fn是向心力，积分可得Fn=2/3*πρω^2*r^3H，H(厚度)=0.008m，r=0.025m，ρ=2.7*10^3kg/m^3，ω实测为60πrad/s。因此P=F_R=G+Fn=0.46868N+25.503N≈25.97N。 带入公式可得，L_h=109096.1小时。 2．推力球轴承寿命分析 轴承属性见上表（厂商提供）。工作温度小于120℃，ft=1。查表后fp取1.1。F_R由G，Fn两部分构成。其中G是飞轮和轴重力、连杆重力分力，Fn公式同上。H(厚度)=0.004m，r=0.04m，ρ=2.7*10^3kg/m^3，ω假设为66πrad/s。因此P=F_R=G+Fn=0.4259N+62.237N≈62.66N。 带入公式可得，L_h=186713.1小时。 3 热力学仿真与斯特林循环计算3.1热力学仿真该部分主要是将四个冲程的斯特林循环带入，通过得到气缸的pv图和相关的力矩变化图线，从而更好地评估设计的情况。 计算的核心在于计算当下各设计在转动时的功率，以及在指定转速下的功率，最后调整传动装置的连杆比，以及活塞的运动空间，以及计算一次做功的最大功是否能驱动飞轮以指定的预测转速进行转速，从而进行调整。 β型发动机的计算结果如下: 计算出单次循环做功为0.0523J，若要达到设计目标的0.5W功率要求，需要转速达到：rmin=0.5*60/0.0523≈573.6rpm。 此外，以上设计参数所得到的P-V图线偏扁圆形，与常见的P-V图线形状有一定差异，这主要是与设定的初始相位角有关，若将相位角改为45°，则可以得出如下P-V图线，并可计算得出此时对应的单次循环做功为0.0608J，较先前有所提高；但在β型斯特林发动机中，相位角是由相关零件的设计直接确定的，故在后续仿真中仍保持相位角α=85°的设定。 α型的计算结果如下： 计算出单次循环做功为0.0172J，若要达到设计目标的0.5W功率要求，需要转速达到：rmin=0.5*60/0.0172≈1744.2rpm。 可以看到的是，α型由于回热器的引入，P-V图线的情况要好的多，整体效率有不少的提升，但是由于采用了更小的活塞面积，单次做功的大小减少了，经查询实际情况下相同气缸面积大小的斯特林发动机的转速，大多在两千转以上，则能够满足我们实际的做功要求。 3.2 Adams仿真结果计算推力乃至转矩关键就要计算气缸内密封气体对于活塞产生的压强，并用相应的公式可以根据实时的飞轮转动角度给出对应气压P的计算。于是，通过对于上述热力学斯特林循环代码的简单改写，结合推力与转矩的转换，再利用力的变化或者转矩的变化，得到整个运动情况的仿真如下： 除此之外，由于两个仿真系统之间的运算单位不统一，在将Adams中角度单位改为rad（弧度），长度单位改为m后，仍然需要对相应的角度与转速数据进行单位上的换算处理（如下图所示），从而可以得到数量级正确的数据图线。 则对于β型的仿真结果如下： α型的的仿真结果如下： 以上所有图像左图均为整体图像，右图均为局部图像。根据仿真结果可以看到，尽管大部分时候转速不是特别稳定，但是转速基本上能够满足功率输出的要求，同时也可以发现，在不加入减振措施的情况下，整体呈现出受到振动的扰动是很明显的，可以看到局部以及整体的一种周期性的输出变化。 4 中途迭代过程4.1 设计产生的问题对于β型来说，存在的最大问题是，尽管气缸最后的密封性设计加工得没有问题，达到按下做工活塞，配气活塞能够弹出的水准，但是在加热测试时，可以感受到气体推动气缸向外运动，但是向内移动时阻力没有明显增大，再次往外时活塞依然能够被推动，但是最终无法完整自行运转，分析情况如下：这是由于没有回热器导致的，冷热腔内的气体不能快速交换，这使得气体做工后不能快速进入冷腔内推动配气活塞转动，在回转时也无法快速由配气活塞压回，这使得斯特林循环中的加热和冷却两部分需要消耗的时间大大增加，也是造成β型的pv图像比较奇怪的原因，而α型采用了回热器的设计，就不存在相同的问题。 对于两种发动机来说，共有的问题是缸体与活塞的配合，采用金属加工的气缸时，常常出现配合不好的问题，需要经过手动打磨进行调整，从而使其能够进入，但是这样的话往往会导致后续的气密性测试出现不可控的问题，而且即使跟厂家要求加工后气密性测试达标之后再发货，到手测试也不一定能够完全达标，我们在最大限度采用金属气缸的情况下，采购了配套出售的玻璃气缸和活塞作为确保能够达到运行要求的方案，最终在α型的设计和测试中成功完成了尽可能多采用自己设计的金属气缸的同时能够确保发动机能够正常运行。 4.2 仿真部分的调整在12月5号课程的汇报中，老师对于我们的仿真提出了一些指导意见，其中最主要的就是提到将气体对活塞推力转化为飞轮转矩的合理性，以及随之带来的传动过程中的摩擦问题。同时老师还提到，不要轻易的去改动原先设计的尺寸参数，事实上在第一阶段的改动中仅仅是在热力学计算以及对应推力与转矩计算中改动了对应的参数，而由于修改模型再重新导入Adams设置连接与参数过于麻烦所以并未对应进行调整，所以我们对气缸与活塞半径的修改进行了回退处理。 事实上，基于斯特林发动机整体的运作机理考虑，首先需要在预热的同时人为拨动飞轮，本质上与给予初始转矩相对应，因此在t&lt;0.1s的启动阶段，仍然保留了初始力矩值torque的设定，而在后续的循环运作阶段传出实时气体对活塞的推力Fp作为force的值。 经过对于各种参数的多次调整与运行，我们进行了如下的补充仿真（该过程主要在β的仿真完成，因此下述所有内容均在β型发动机的基础上完成，α型发动机的相关仿真已经过了同样的仿真优化步骤，结果是准确的）： （1）给定初始力矩对于转速的影响 我们分别设定t&lt;0.1s时给定的初始转矩Torque=-0.5和-0.05，运行仿真并得出转矩图线： 通过观察上述两图并对比可以发现，事实上初始转矩的大小是决定运行初期转速变化情况的主要因素，具体体现为若初始转矩较大则会出现转速突增现象而降低初始转矩后则该现象消失，同时初始转矩较低时稳定后的转速也有对应降低，但降低幅度有限，大致还是稳定在1200rpm左右；同时在取消转换为传动后力矩这一操作后，转速也较之前有了明显的降低，说明各部件之间连接在动力学实际运作过程中的影响不可忽略，主要是由于各传动部件存在质量且相互的配合之间会产生摩擦。 （2）反转带来的反思——改变初始力矩方向（符号） 根据上述图线，我们发现在0.1s初始力矩作用后正向转速达到最大值，此后却一直衰减直至反向，而飞轮反向旋转后转速却一直增大，且在5s仿真末尾阶段有逐渐平稳的趋势。因此，我们考虑将初始力矩的符号改变（即方向更改）观察仿真效果如下（设置torque=0.05)： 可以发现，在初始力矩反向之后，转速的方向也随之改变，且在初始力矩施加的0.1s后迅速趋于平稳，稳定后转速平均值在1100rpm左右，仍然大于热力学计算中理论所需的最低转速573.6rpm，满足设计要求。 该情况下对应的推力force与转角theta图线如下图所示： 经过调整之后的仿真结果排除了摩擦设置不准确，振动与实际不符，转速波动过大等问题，使得结果更加准确，在后续采用玻璃气缸时提供了可靠参考。 4.3 最终调整该部分主要介绍自从α在不带电机能够转动之后的一些调整，以及在最终测试前发现的一些问题，以及剩余时间中对于未能成功运转的β型进行的调整。 首先是对于玻璃气缸的连接的润滑作出的一些调整，我们一开始采用矿物油进行润滑，希望既能够起到润滑作用，又能减少气体外溢，提高密封性，但经过实际测试的结果来看，效果是很不好的，反而减慢了达到稳定转动时的转速。跟气缸商家进行交流后，商家建议使用石墨进行润滑，因为油的粘性和表面张力很大，再加上玻璃活塞的粗糙表面，会增加很多摩擦力，采用石墨虽然不一定能增强其气密性，但是润滑效果要好的多半，经过实际测试之后，效果有很大提升。 其次是电机带动产生的问题，一开始我们购买的电机功率较大，产生的电磁阻力矩也比较大，在使用橡皮圈进行带动时，未能成功使其按照设想转动，稍微有点阻力就会停下，灯泡也不能按照预想的情况发光。后来，经过加热位置调整，更换电机，减少橡皮筋的张力等方法，我们成功地减少了整体的阻力，还成功地消除了橡皮筋相对于主从动轮之间的滑动，提高了功率输出效率，更换更大的从动轮，减少阻力矩，最后成功地使了功率为5w的灯泡发亮（实际功率大约在3w左右，没有达到灯泡最亮的情况），实际观察稳定转速在2300r/min左右，比仿真的转速要高一些，且实际做功冲程的长度和温度要略高一些，总体评估下来还是符合计算结果的，此外，我们发现，加负载后，需要更大的初始推动力，甚至需要推动两次，才能使其稳定旋转，估计是单次做功冲程提供的机械功较少导致，不过最后不影响实际运行的效果，达到稳定后无需人为干预。 对于β型，我们对于不同公差的气缸玻璃外套对现有的金属气缸进行测试，找寻气密性和推动效果的组合，实际上受阻还是比较大，因为每次都需要经历粘胶解胶的漫长过程，中途还需要手动打磨等，较大的零件调整时间上也不是很充裕。较长时间的加热有时候也会导致打印支架的部分融化导致损坏。不过我们经过调整，还是找出了一个目前能够实现最好推动和气密性的气缸，虽然依然不能正常带动斯特林发动机做功，不过相比于其他的组合，加热时可以感受到明显的外推力，压缩时也不会出现阻力过大的情况。 最后是0.5w功率的表征，我们采购到了由十个5730灯珠串联得到的灯泡，在发动机稳定旋转带动发电机时，测定灯泡的电压，最终完成对0.5w功率的表征。 5730灯珠的参数如下： 灯泡内部结构和实际电压测量情况如下： 则可以得到，能使串联的灯泡发亮，则需要电流1.5A,电压3.4V,则计算功率得到5.1W，虽然实际电流可能没达到1.5A，功率可能小于5W，但是对于0.5W的要求来说，已经足以满足转速的测试，满足了测试的范围要求。 最后测试时得到空载电压3.91V，负载电流19mA，则最终计算得到输出在电机上的功率为0.074W，没能完全达到0.5W的要求。 5 反思与总结尽管经过计算验证，输出到飞轮上的功率是超过0.5W的，但在使用电机进行实际测试时，还是没有达到预想的地步，一有可能是皮带，电机等设计效率降低比较大，损耗了很多能量，另一个是测试时不能很好确保稳定旋转，存在一定的测量误差，但纵观整个过程，实现效果还是相对成功的，只有0.5W的指标没有完成。 对于机械结构和公差配合的设计，我们有了很大的了解，尤其是在气缸的密封性以及最终成功运作上，不一定没有误差就能够保证气缸能够按照预想的方式正常运行；振动的产生和各器件的使用寿命的匹配的相关设计和思考在经过学习之后有了系统性的思考模式和设计方法；对于传动结构的受力分析和功率计算也在经过锻炼后有了更多更快更加准确的方法。 仿真软件在热力学部分和机械运动部分的运用使我们明白了如何通过仿真结果调整设计，以及根据实际测试情况调整仿真出现的问题从而更好地适配制作好地成品，此外，对于仿真软件的运用也提高了对于机械结构的认知以及建模装配等等方面的一些技术应用。 在实际调整中一些零件和工具的使用也使得我们的实践经验有很大提高，能够进行简单的加工，以及在设计思考加工方式从而减少加工难度和降低加工成本，提高迭代速度和优化方法；此外，在装配过程中，协作进行操作和调整也使得我们对于各种构件的装配和使用有了更加深入的了解。","link":"/2024/01/05/engineerdesign/"},{"title":"课题：斯特林发动机机械系统动力学仿真","text":"一、初始设计参数与热力学计算对于我们设计的β型斯特林发动机，提出了如下的设计目标： 物理参数 数值（单位） 输出功率 0.5W 在我们初步设计的斯特林发动机（模型如下图所示）中，相关的尺寸参数如下： 物理参数 数值（单位） 排气活塞行程h1 42mm 做功活塞行程h2 45mm 相位角α 85° 气缸内径r 10mm 排气活塞半径r0 8mm 气缸内气体压强最小值Pmin 101300Pa（与环境大气压一致） 将设计好的模型导入Ansys软件中进行静态热力学的仿真（如下图所示），可以得到气体温度的状态参数如下： 压缩空间气体温度Tc 439K 膨胀空间气体温度Te 611K 根据史密特理论的相关计算公式，可以编写相应程序，由以上参数为基础计算并绘制P-V图以及单次循环所作功，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243afa=2*85*pi/360;theta=0:0.01:pi*2;tc=439;te=611;l1=0.021;h1=l1*2;l2=0.0225;h2=l2*2;r=0.01;r0=0.008;vse=r0*r0*pi*h1;vsc=r*r*pi*h2;ve=vse.*(1-cos(theta))./2;vb=(vse+vsc)./2-sqrt((vse.*vse+vsc.*vsc)./4-vse.*vsc.*cos(afa)./2);vc=vse.*(1+cos(theta))./2+vsc.*(1-cos(theta-afa))./2-vb;vr=(r*r-r0*r0)*0.02*pi;tao=tc/te;k=vsc/te;xb=vb/vse;x=vr/vse;fai=atan(k.*sin(afa)./(1-tao-k.*cos(afa)));s=tao+4.*tao.*x./(1+tao)+k+1-2.*xb;b=sqrt(tao.*tao+2.*k.*(tao-1).*cos(afa)+k.*k-2.*tao+1);deta=b./s;pmin=101300;p=pmin.*(1+deta)./(1-deta.*cos(theta-fai));plot(rad2deg(theta),p);xlabel('角度θ（°）');ylabel('压强P（Pa）');title('α=85°时θ-P图线');v=ve+vr+vc;figure;plot(rad2deg(theta),v);xlabel('角度θ（°）');ylabel('体积V（m^3）');title('α=85°时θ-V图线');figure;plot(v,p);xlabel('体积V（m^3）');ylabel('压强P（Pa）');title('α=85°时P-V图线');w=10000000*pmin.*vse.*pi.*deta.*(1-tao).*sin(fai).*sqrt(1-deta)./((1+sqrt(1-deta.*deta)).*sqrt(1+deta));disp(w); 通过运行上述代码，可绘制出如下热力学数据图线，并计算出单次循环做功为**0.0523J**。 因此，若要达到设计目标的0.5W功率要求，需要转速达到rmin=0.5*60/0.0523≈573.6rpm。 此外，以上设计参数所得到的P-V图线偏扁圆形，与常见的P-V图线形状有一定差异，这主要是与设定的初始相位角有关，若将相位角改为45°，则可以得出如下P-V图线，并可计算得出此时对应的单次循环做功为0.0608J，较先前有所提高；但在β型斯特林发动机中，相位角是由相关零件的设计直接确定的，故在后面的仿真中仍然保持相位角α=85°的设定。 二、Adams动力学仿真在不考虑各类摩擦的情况下，对于基本的曲柄连杆传动机构来说，有如下基本公式： 根据此公式可得到如下代码，绘制转矩变化曲线如下图： 12345678910ap=pi*l2*l2; fp=ap.*(p-pmin); tq=(sin(theta)-cos(theta)).*fp.*r; t_qm=w/2/pi; t_qm_(1,1:629)=t_qm; figure; plot(rad2deg(theta),tq,rad2deg(theta),t_qm_); xlabel('角度θ（°）'); ylabel('转矩'); title('转矩变化曲线'); 根据如下仿真步骤，将Fusion360建模软件中建立完成的模型导出为STEP格式，进入Adams仿真软件中进行进一步的动力学仿真。 在第一次仿真时，仅仅将原有模型中设计到传动的部分保留，并将简化后的模型导入仿真，主要反映出两大问题，第一时间进行了修改（以上给的参数均为该次修改后确定的）： （1）传动部分设计失误，主要表现为各个曲柄的转动不同轴而导致角速度不一致，从而无法达到稳定的压缩与膨胀之间的状态转换，即活塞体系无法完成循环； （2）连杆设计尺寸不合适，导致部件之间出现穿模问题。 通过修改转动轴连接方式，重新捋清传动循环原理并对不合适的尺寸进行修改（将连接排气活塞的连杆长度缩短），最终实现了在给定初始转速下动力学仿真模型的稳定运转（演示效果见PPT）。 在验证Adams模型与连接建立设置的可行性后，为进行下一步仿真，设置了系统单元变量（推力，对应的力矩，飞轮转动角度与角速度），并将前两者作为输入，后两者作为输出，利用Controls插件导出对应文件以供与MATLAB中Simulink的联合仿真。 三、Simulink联合仿真打开Adams导出的m文件并运行从而加载对应系统变量，在命令行中输入adams_sys指令即可进入Simulink仿真界面。根据计算与仿真需求，建立Simulink原理图如下： 通过上述分析可知，对于整个发动机来说，我们需要根据不同时刻气缸中密封气体的状态来计算其对活塞的推力，并将其转换为转矩施加在飞轮上，从而形成对整个发动机循环工作的驱动。因此，在Adams建立系统单元时，我们选择气体推力及其等效飞轮转矩（无摩擦情况下）作为整个系统的输入变量，而将飞轮转动的实时角度作为输出量，同时设置飞轮转动的角速度即转速作为最终需要监测的关键输出变量。其中，气体对活塞产生的推力本质上与飞轮转动的实时角度息息相关，也正因此需要将该角度作为Adams仿真系统中的输出变量，以便于在Simulink中回传至模型中进行迭代仿真。而实现角度信息到推力乃至转矩数据的转换，就需要在Simulink中插入S-Function进行实时计算处理。在本原理图中，左侧的plant框体即为我们设置的S-Function函数。 事实上，计算推力乃至转矩关键就要计算气缸内密封气体对于活塞产生的压强，也就是气压值P，而这一值在前面的热力学分析中已有提及，并有相应的公式可以根据实时的飞轮转动角度给出对应气压P的计算。于是，通过对于上述热力学斯特林循环代码的简单改写，结合推力与转矩的转换，可以得到plant函数代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function [sys,x0,str,ts,simStateCompliance] = plant(t,x,u,flag)switch flag,case 0,[sys,x0,str,ts,simStateCompliance]=mdlInitializeSizes;case 1,sys=mdlDerivatives(t,x,u);case 2,sys=mdlUpdate(t,x,u);case 3,sys=mdlOutputs(t,x,u);case 4,sys=mdlGetTimeOfNextVarHit(t,x,u);case 9,sys=mdlTerminate(t,x,u);otherwiseDAStudio.error('Simulink:blocks:unhandledFlag', num2str(flag));endendfunction [sys,x0,str,ts,simStateCompliance]=mdlInitializeSizessizes = simsizes;sizes.NumContStates = 0;sizes.NumDiscStates = 0;sizes.NumOutputs = 2;sizes.NumInputs = 1;sizes.DirFeedthrough = 1;sizes.NumSampleTimes = 1; sys = simsizes(sizes);x0 = [];str = [];ts = [0 0];simStateCompliance = 'UnknownSimState';endfunction sys=mdlDerivatives(t,x,u)sys = [];endfunction sys=mdlUpdate(t,x,u)sys = [];endfunction sys=mdlOutputs(t,x,u)theta=u;afa=2*85*pi/360;tc=439;te=611;h1=0.042;h2=0.045;r=0.01;r0=0.008;vse=r0*r0*pi*h1;vsc=r*r*pi*h2;vb=(vse+vsc)./2-sqrt((vse.*vse+vsc.*vsc)./4-vse.*vsc.*cos(afa)./2);vr=(r*r-r0*r0)*0.02*pi;tao=tc/te;k=vsc/te;xb=vb/vse;x1=vr/vse;fai=atan(k.*sin(afa)./(1-tao-k.*cos(afa)));s=tao+4.*tao.*x1./(1+tao)+k+1-2.*xb;b=sqrt(tao.*tao+2.*k.*(tao-1).*cos(afa)+k.*k-2.*tao+1);deta=b./s;pmin=101300;P=pmin.*(1+deta)./(1-deta.*cos(theta-fai));Ap=pi*r*r;Fp=Ap.*(P-pmin);%对曲柄转矩 N.mif t&lt;0.1force=0;torque=-0.4;elseTq=(sin(theta)-cos(theta)).*Fp*r;force=0;torque=Tq;endsys(1)=force;sys(2)=torque;endfunction sys=mdlGetTimeOfNextVarHit(t,x,u)sampleTime = 1; % Example, set the next hit to be one second later.sys = t + sampleTime;endfunction sys=mdlTerminate(t,x,u)sys = [];% end mdlTerminateend 除此之外，由于两个仿真系统之间的运算单位不统一，在将Adams中角度单位改为rad（弧度），长度单位改为m后，仍然需要对相应的角度与转速数据进行单位上的换算处理（如下图所示），从而可以得到数量级正确的数据图线。 经过以上处理，并将adams_sub单元中的仿真模式（改为interactive）与步长（根据情况改为0.0001或0.0005较为合适）进行对应调整后，可以得到仿真结果的数据波形图如下（仿真时间设置为5s)： **图线结果分析**： （1）转速开始突增的原因：初始转矩设置为0.4（负方向），相对于后续整体产生的转矩值都较大，因此在开始时转速在迅速增长后又回落； （2）可以看到转速在短暂突增后逐渐趋于平稳，但稳定在3000rpm左右，这个转速较快，在现实中可能较难实现，会超过实际材料的承受极限； （3）但转速在稳定后仍有较大波动，初步判定是由于飞轮质量较轻导致其转动产生的震荡较大，初步观察图线可以发现其在平均值附近最大有将近±300rpm的浮动，需要在后续处理中予以优化； （4）角度的变化较为规律，且在单位换算调整后能够基本稳定在-180°到180°之间（偶尔有小的浮动），说明仿真运行基本正常； （5）转矩的变换也与前面动力学分析时绘制的转矩图线基本吻合，随角度变化也呈周期性变化，符合理想情况。 四、迭代改进及其仿真在上述章节中，我们已经完成了从Adams力学建模仿真到接入Simulink建立联合仿真并得到转速变化图线结果的全过程，但仍然存在一些问题，需要进行进一步修改以达到预期效果并指导发动机对应尺寸的设计修改。 1.初次修改——调节设计参数在之前的初步仿真中，得出的转速会在短暂突增后稳定在3000rpm左右，这在实际中对于我们设计的结构规模来说是不太可能实现的，同时也远远超出了实际材料的结构强度与承受范围，因此为了将稳定时的转速降低，同时进行了如下两处改动以达到效果： （1）减小活塞与气缸半径 减小活塞与气缸半径实质上是减小了活塞受气体推力作用的横截面积，同时也减小了气缸中容纳的气体体积，但由于密封前仍与外界空气联通，故初始气压（即Pmin）仍与大气压一致，也因此该改动实际上是降低了相同温度状态下气体的压强，从而导致气体对活塞推力的减小，传动到飞轮上的转矩也随之减小，最终导致了转速的降低。 在本次改动中，我们对活塞与气缸半径均进行了减小处理，并在plant函数中对应的结构参数部分做出了对应的调整，调整后的参数如下表所示： 物理参数 数值（单位） 气缸内径r 5mm 排气活塞半径r0 4mm 该设计参数的调节也同步影响到了单次循环做功的数值，通过重新代入修改后的参数进行热力学参数的计算，得到此参数下单次斯特林循环的做功数值为**0.0327J**。 （2）增大飞轮质量（转动惯量） 在之前的仿真中为便于贴合加工处理将所有部件的材质设置为铝（密度较低，质量轻），但是结果显示转速在大致稳定后仍然出现了一定程度的震荡浮动，这是我们想要避免的。因此，一方面为了降低转速的浮动幅度，另一方面也是为了通过增加转动惯量加大负载从而降低转速，我们希望将飞轮的质量增大；同时，为了尽可能减少我们的修正对于整体建模结构的影响，我们尽量不去改动飞轮本身的尺寸，而是在Adams中对于飞轮部件的质量特性做出调整，通过将其材质由铝转换为密度更大的不锈钢从而实现增加飞轮质量的效果。 综合以上两点调整后，再次进入Simulink中运行仿真，同时由于调整结构设计参数降低了气体对活塞做功施加到飞轮上的等效转矩的整体数值，因此也将初始驱动力矩降低为-0.2（尽可能贴近气体膨胀压缩产生等效力矩的浮动范围）以尽可能降低初始力矩对于最终稳定转速的影响，得到仿真结果如下图（演示视频见PPT）： **图线结果分析**： （1）转速在仿真开始阶段的突增消失； （2）转速在短暂的增加后迅速达到平稳状态，且稳定在1450rpm左右，较先前有了明显的降低，同时结合更改参数后热力学计算得到的单次斯特林循环做功数值为0.0327J，可以得出此时斯特林发动机运行的理论功率为0.7906W，满足初始设定的设计要求； （3）但转速在稳定后的波动明显减小，观察图线可以发现其在平均值附近仅有±50rpm左右的浮动，运行基本处于稳定状态； （4）角度的变化较为规律，且在单位换算调整后能够基本稳定在-180°到180°之间（偶尔有小的浮动），说明仿真运行基本正常； （5）转矩的变换也与前面动力学分析时绘制的转矩图线基本吻合，随角度变化也呈周期性变化，符合理想情况。 2.汇报后的更正——活塞推力的给予方式改变以及传动机构间摩擦的添加在12月5号课程的汇报中，老师对于我们的仿真提出了一些指导意见，其中最主要的就是提到将气体对活塞推力转化为飞轮转矩的合理性，以及随之带来的传动过程中的摩擦问题。同时老师还提到，不要轻易的去改动原先设计的尺寸参数，事实上在第一阶段的改动中仅仅是在热力学计算以及对应推力与转矩计算中改动了对应的参数，而由于修改模型再重新导入Adams设置连接与参数过于麻烦所以并未对应进行调整，所以我们对于气缸与活塞半径的修改进行了回退处理。 事实上，基于斯特林发动机整体的运作机理考虑，首先需要在预热的同时人为拨动飞轮，本质上与给予初始转矩相对应，因此在t&lt;0.1s的启动阶段，仍然保留了初始力矩值torque的设定，而在后续的循环运作阶段传出实时气体对活塞的推力Fp作为force的值，因此改动plant函数对应部分如下： 1234567891011121314pmin=101300;P=pmin.*(1+deta)./(1-deta.*cos(theta-fai));Ap=pi*r*r;Fp=Ap.*(P-pmin);if t&lt;0.1force=0;torque=-0.4;elseforce=Fp;torque=0;endsys(1)=force;sys(2)=torque;end 同时为监测对应的推力改变情况，修改Simulink系统原理图如下： 经过对于各种参数的多次调整与运行，我们进行了如下的补充仿真： （1）给定初始力矩对于转速的影响 我们分别设定t&lt;0.1s时给定的初始转矩Torque=-0.5和-0.05，运行仿真并得出转矩图线： 通过观察上述两图并对比可以发现，事实上初始转矩的大小是决定运行初期转速变化情况的主要因素，具体体现为若初始转矩较大则会出现转速突增现象而降低初始转矩后则该现象消失，同时初始转矩较低时稳定后的转速也有对应降低，但降低幅度有限，大致还是稳定在1200rpm左右；同时在取消转换为传动后力矩这一操作后，转速也较之前有了明显的降低，说明各部件之间连接在动力学实际运作过程中的影响不可忽略，主要是由于各传动部件存在质量且相互的配合之间会产生摩擦。 （2）增加飞轮与支架在旋转时产生的摩擦 综合各因素的调整与尝试，发现在各部件的传动摩擦中只有飞轮与支架之间由于飞轮旋转而产生的摩擦对于整体装置运作的影响相对较大，因此加上原本设置的气缸——做功活塞与做功活塞——排气活塞间摩擦（动摩擦系数均设置为0.5），运行Simulink仿真有如下结果： 观察图线可以发现，增加传动摩擦后，转速在短暂增长（由于初始转矩）后迅速衰减，并在0.34s左右停止转动。 为改变这一现象，计划采取润滑的方式降低动摩擦系数，因此在设置时将动摩擦系数降为0.2，重新运行Simulink仿真，转速图线结果如下： 观察图线可知，当摩擦系数降低后，转速衰减速率也明显降低，但仍有明显衰减且在2.5s左右发生反转现象，且转速逐渐增大。 （3）反转带来的反思——改变初始力矩方向（符号） 根据上述图线，我们发现在0.1s初始力矩作用后正向转速达到最大值，此后却一直衰减直至反向，而飞轮反向旋转后转速却一直增大，且在5s仿真末尾阶段有逐渐平稳的趋势。因此，我们考虑将初始力矩的符号改变（即方向更改）观察仿真效果如下（设置torque=0.05)： 可以发现，在初始力矩反向之后，转速的方向也随之改变，且在初始力矩施加的0.1s后迅速趋于平稳，稳定后转速平均值在**1100rpm左右，仍然大于热力学计算中理论所需的最低转速573.6rpm，满足设计要求**。 该情况下对应的推力force与转角theta图线如下图所示： 五、感悟与总结通过完成本次动力学仿真，对于斯特林发动机的热力循环过程以及机械转动部分的运作过程有了更加细致和深刻的理解，同时也通过函数的编写与变量的选取对于定量计算中的细节有了更深刻的把握。特别是Adams仿真过程中在建立变量（系统单元）时对于角度和角速度测量的坐标系选取，非常考验对于体系运动过程中细节的把握，究竟是哪个点绕着哪个点转才是正确的角速度，只有正确选取才可能得到正确的结论；单位换算也是仿真过程中的一大难点，不仅要在Adams中对于默认的单位进行修改，还要在MATLAB中编写对应的函数完成转换（Simulink图中的MATLAB Function图标中的函数内容），才可以得到正确的数值结果。除此之外，整个仿真过程中由于涉及到两个软件的联动，对于电脑的性能与配置也有不小的要求（具体体现为把MATLAB和Adams都重装了至少三遍最后还是被迫在别人的电脑上完成，说来也神奇，同样的模型，同样的代码，传到别人电脑上就能跑，我的就不行）。 在完成了整套仿真的流程并得到了正确的数值与图线结果后，还需要针对我们所需要的性能，结合实际情况的可行性，对于对应参数进行修改。经过不断的尝试和摸索，目前有如下的初步结论： （1）调大飞轮的质量（改变材质，增大材料密度而不改变原本飞轮的尺寸设计），可以使得转速在稳定后的周期性波动幅度明显减小； （2）为贴近真实情况，应该直接采用气体膨胀压缩对活塞的推力作为输入变量进入Adams仿真系统中进行仿真，转速会比转换为等效转矩作用于飞轮上的更低（因为传动部件本身具有的质量不可忽略，且各部件间存在摩擦）； （3）传动部分的摩擦损耗主要体现在飞轮在旋转过程中与支架的摩擦力； （4）如果代入铝材间原有的摩擦系数，发动机无法正常工作，需要通过加润滑油等方式来实现摩擦系数的降低； （5）初始力矩对应的是发动机在预热阶段用手拨动飞轮产生的驱动力，该转矩会直接影响飞轮在发动机工作初期的转速，并对后续的稳定转速产生一定的影响；因此给定的初始力矩要与后续气体推力对应的等效转矩浮动范围尽可能贴近，以免出现开始时转速突增的现象； （6）改变气缸与活塞的设计尺寸也能显著改变稳定后的转速，但并不建议这么做，因为需要每次重新导入对应修改后尺寸参数的新模型进行Adams中连接的创立，同时对于加工方面频繁的尺寸修改也不是长久之计。 总而言之，装置的转速与气缸与活塞的尺寸、飞轮质量（转动惯量）、摩擦系数等多方面因素有关。这次的仿真也指导了我们在后续的设计与加工过程中进行进一步的改进，并为发动机整体功率是否满足设计要求从计算上给出了合理的科学依据。","link":"/2023/12/10/%E6%9C%BA%E6%A2%B0%E7%B3%BB%E7%BB%9F%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F/"},{"title":"课题：斯特林发动机热力循环计算及分析","text":"根据选定的斯特林发动机类型，确定具体的传动机构，开展斯特林发动机的热力循环计算；从最大化斯特林发动机单次循环的输出功角度出发，优化斯特林发动机系统所涉及的传动机构、相位角等参数。 一、背景介绍通过学习本课程，我们需要完成斯特林发动机的设计与制造过程，在此过程中掌握工程设计全流程中的基本技能。之所以选择斯特林发动机，是因为能够将热能转化为机械能，并具有以下特点： 效率高：斯特林发动机的热效率相对较高，与理论上最高热效率的卡诺循环相同，实际中可以达到30%以上，远高于传统内燃机； 噪音低：斯特林发动机工作过程中没有爆炸过程，工作过程相对平滑，噪音和振动较小； 热源多：斯特林发动机作为一种外燃机，可以直接利用任何可用热源，如太阳能、地热能与生物质能等可再生能源； 排放少：斯特林发动机在工作过程中没有直接燃烧，为闭口系统，工质环境友好，没有任何有害物排放； 寿命长：连续运行，安全可靠，对高温侧材料要求较高。 斯特林发动机的概念可以追溯到19世纪初，但由于技术限制和市场竞争，长期以来并没有像内燃机那样广泛应用。最近，随着对环保和能源效率的关注不断增加，斯特林发动机再次引起了一些研究兴趣，在水下动力、太阳能动力、空间站动力、热泵空调动力，车用混合推进动力等方面得到了广泛的研究与重视，并且已得到了一些成功的应用。 斯特林发动机按照结构可分为α型、β型和γ型三类，其中α型又称为双动力活塞式发动机，β型和γ型又称为配气活塞式发动机。 通过对于三种类型发动机的基本结构和工作原理的分析与比较，我们最终选择β型斯特林发动机进行实际设计制作。同时考虑到整体项目要求、制作难度与成本等方面，选择单作用斯特林发动机进行制作。 β型斯特林发动机属于配气活塞式发动机，基本结构中包含配气与动力（做功）两种活塞。其中，配气活塞只起到配气作用，并不对外做功，其上下两端压力一致，用于使工质在循环回路中来回流动；动力活塞上、下两腔气压差很大，必须进行密封处理。 斯特林发动机的基本工作原理为斯特林循环。理想的斯特林循环主要包括定温压缩、定容吸热、定温膨胀和定容放热共四个过程，其中两个为定温过程，两个为定容过程： 定温压缩：工作气体在活塞的压力作用下被压缩，使得气体温度降低； 定容吸热：压缩后的工作气体通过外部热源加热，吸收热能，温度升高； 定温膨胀：加热后的工作气体在活塞的推动下膨胀，产生机械功，带动发电机等设备工作； 定容放热：膨胀后的工作气体通过冷却器冷却，使其温度降低，回到压缩前的状态。 上述四个过程循环往复，共同构成斯特林循环。为了确定并验证我们所初步设计的发动机模型能否满足课题要求的最大输出功率达到0.5W，我们需要分析研究在设定条件（与实际设计结构一致）下单次斯特林循环的输出功，并通过计算结果返回迭代传动结构、尺寸与相位角等参数的设计与确定，以实现斯特林发动机单次循环输出功的最大化。 二、物理模型本报告将给出根据我们目前设计的具体结构参数计算的单次斯特林循环输出功，并建立目标函数通过优化相位角等参数最大化单次循环输出功。 传动机构传动机构方面，我们采用曲柄连杆机构，基本的物理模型图与我们的设计建模图如下： 上述设计的相关参数如下： 【1】连杆比λ： 通过实际加热测试测定，四个过程状态下活塞的位置参数大致如下： （1）定温压缩 （2）定容吸热 （3）定温膨胀 （4）定容放热 根据以上实际测试结果，可得到配气活塞行程s=20-5=15mm，动力活塞行程S=54-24=30mm，我们将其设计为与连杆机构活塞位移最大值 max（x）=2R=30mm一致，于是有曲柄半径R=15mm，再设定连杆长度L=100mm，可得到连杆比λ=R/L=0.15； 【2】转速初步设定为n=120r/min； 【3】气缸内部半径为1cm（与动力活塞一致），长度为24mm; 【4】排气活塞半径为0.8cm，长度为20mm。 热力学模型为分析整个斯特林循环过程，结合我们以上的模型设计，给出如下热力学参数与假设： （1）系统气密性良好、无泄漏；气缸内部半径为1cm，长度为24mm，因此未进行加热时，内部初始的工质（空气）体积，由此可得到工质总质量为(空气密度为1.29kg/m3)； （2）工质为理想气体，气体常数为，比热容为； （3）通过Ansys静态热力学仿真分析（如图），在给定特定酒精灯热源的情况下，根据设计的气缸活塞模型（加上散热片），得到工质等温膨胀及等温压缩过程的温度分别为和； （4）系统等容加热及等容冷却过程的体积（如状态位置参数图所示）之比为=54mm/24mm； （5）忽略循环过程中的各种不可逆性。 三、循环计算分析理论情况在背景介绍中提到，一次斯特林循环主要分为四个过程，接下来将结合p-v图与物理模型中提到的实际参数数据对四个过程依次进行分析： 理论p-v图： 根据斯特林循环理论，有如下过程与单次循环做功计算结果： （1）1-2：定温压缩过程 （2）2-3：定容吸热过程 （3）3-4：定温膨胀过程 （4）4-1：定容放热过程 通过综合考虑由以上四个过程循环往复进行的斯特林循环，可以初步计算得出单次斯特林循环理论所作功为 在此情况下，若设定转速为n=120r/min=2r/s，则此时该斯特林发动机的功率P=0.389*2=0.778W&gt;0.5W，故此设计方案理论上符合项目功能要求。 特别的，如果回热器性能完全（即回热器效率ηR=1），则有Qin=Q34=1.382J，此时可计算得出该斯特林循环的单次做功效率为η=Wi/Qin=28.1%。 实际情况无法达到理想的等温或定容过程，因此需要借助史密特理论进行计算才能更接近真实情况下的单次循环做功大小。 基于史密特理论，暂时设定相位角为90°，可以得到实际中的p-v图如下（设定气缸内气体压强最小值即初始压强pmin为标准大气压=100kPa)： 根据理论推导公式，编写代码如下： 123456789101112131415161718192021222324252627afa=pi./2; theta=0:0.1:pi*2; tc=439; te=611; vse=15.*pi; vsc=30.*pi; ve=vse.*(1-cos(theta))./2; vb=(vse+vsc)./2-sqrt((vse.*vse+vsc.*vsc)./4-vse.*vsc.*cos(afa)./2); vc=vse.*(1+cos(theta))./2+vsc.*(1-cos(theta-afa))-vb; vr=(1-0.64).*20.*pi; tao=tc./te; k=vsc./te; xb=vb./vse; x=vr./vse; fai=atan(k.*sin(afa)./(1-tao-k.*cos(afa))); s=tao+4.*tao.*x./(1+tao)+k+1-2.*xb; b=sqrt(tao.*tao+2.*k.*(tao-1).*cos(afa)+k.*k-2.*tao+1); deta=b./s; pmin=100000; p=pmin.*(1+deta)./(1-deta.*cos(theta-fai)); v=ve+vr+vc; figure; plot(v,p); xlabel('体积V（mm^3）'); ylabel('压强P（Pa）'); title('α=90°时P-V图线'); w=pmin.*vse.*pi.*deta.*(1-tao).*sin(fai).*sqrt(1-deta)./((1+sqrt(1-deta.*deta)).*sqrt(1+deta))/1000000; 通过运行上述代码段，可以得到如上图所示的p-v图线，并计算出此时单次斯特林循环的实际做功大小W=0.1429J。 在此情况下，若设定转速为n=120r/min=2r/s，则此时该斯特林发动机的功率P=0.1429*2=0.2858W&lt;0.5W，故此设计方案理论上暂不符合项目功能要求；但若增加转速至n’=P0/W=3.5r/s=210r/min，即可满足设计要求。 四、优化在上述的设计过程中，我们将曲柄连杆机构中曲柄的半径设计为活塞在气体膨胀压缩过程中运动的最大距离（即行程）的一半，并设定相位角（排气器活塞与动力活塞的相位差角度值）为90°（依据已有的设计经验）。事实上，通过分析史密特理论的计算式不难发现，随着相位角的改变，最终计算出的单次循环所作功也发生改变，因此在优化时需要通过绘制W-α图像直观反映二者间的关系，并找到合适的相位角α值以最大化单次循环所作功W。 以下是设计的MATLAB代码与绘制的对应图像： 1234567891011121314151617181920212223242526afa=0:0.1:pi*2;theta=0:0.1:pi*2;tc=439;te=611;vse=15.*pi;vsc=30.*pi;ve=vse.*(1-cos(theta))./2;vb=(vse+vsc)./2-sqrt((vse.*vse+vsc.*vsc)./4-vse.*vsc.*cos(afa)./2);vc=vse.*(1+cos(theta))./2+vsc.*(1-cos(theta-afa))-vb;vr=(1-0.64).*20.*pi;tao=tc./te;k=vsc./te;xb=vb./vse;x=vr./vse;fai=atan(k.*sin(afa)./(1-tao-k.*cos(afa)));s=tao+4.*tao.*x./(1+tao)+k+1-2.*xb;b=sqrt(tao.*tao+2.*k.*(tao-1).*cos(afa)+k.*k-2.*tao+1);deta=b./s;pmin=100000;p=pmin.*(1+deta)./(1-deta.*cos(theta-fai));v=ve+vr+vc;w=pmin.*vse.*pi.*deta.*(1-tao).*sin(fai).*sqrt(1-deta)./((1+sqrt(1-deta.*deta)).*sqrt(1+deta))/1000000;plot(rad2deg(afa),w)xlabel('相位角α（°）');ylabel('单次循环所作功W（J）');title('单次循环所作功W随相位角α的变化关系图线'); 由图像可见，当相位角α=51.6°左右时，单次循环所作功达到最大值Wmax=0.169J，较原先相位角为90°的方案有所提升，只需要转速达到nmin=P0/Wmax≈2.96r/s=178r/min即可满足设计功能要求，实现了优化效果。 五、总结在本次课题任务中，借助了热力学方法研究气缸内的封闭气体，从而对于我们小组初步设计的β型斯特林发动机模型的动力（做功）性能进行了一定的评估分析，并在此基础上通过MATLAB工具绘制函数图像，通过对于目标函数的优化以指导我们进行结构上的进一步改进以提升性能。 在热力学分析过程中，从斯特林循环的四个基本环节入手，结合我们设计的气缸、活塞等尺寸参数、实际测试得到的经验参数以及简单的传动机构设计（曲柄连杆机构），从理论分析逐步逼近实际，最终借助一阶的史密特等温分析方法理论实现了较为接近实际的计算模拟，得到了单次斯特林循环对外做功的数值解从而给出达到目标功率所需要设定的飞轮转速。 同时，在此基础上，通过改变相位角等参数，基于史密特理论中单次循环做功的计算公式，得到了可以进行优化（求极值）的目标函数，并得到了当前尺寸参数下的最大单次循环做功及其对应的相位角，有效实现了基于理论计算的迭代与优化。","link":"/2023/11/12/%E6%96%AF%E7%89%B9%E6%9E%97%E5%BE%AA%E7%8E%AF/"},{"title":"课题：发动机驱动部件的制作（气缸）","text":"一、需求分析β型斯特林发动机是一种热机，通过气体的循环膨胀和压缩过程来产生功。气缸作为该发动机的核心部件之一，承担了容纳工作气体和推动活塞的重要职责，将工质气体受热膨胀的能量转化为机械功。本文旨在分析β型斯特林发动机气缸的工作原理及相关参数的确定与结构设计以满足一定的性能要求，同时在此过程中提升对气体膨胀做功及整个过程中密封、摩擦、公差设计、基本加工工艺、材料传热性能乃至动力学等的认识。 广义的设计要求 高热效率: 气缸必须具备高效的热传导和隔热性能，以确保最小的热能损失和高工作效率。 耐高温性: 由于斯特林发动机工作温度较高，气缸的材料需要能够承受高温环境，同时保持结构稳定。 公差精度: 在气缸的内径、外径和活塞直径等关键尺寸上需要达到高精度的公差，以确保气缸和活塞的匹配度。 耐腐蚀性: 考虑到工作气体可能包含腐蚀性物质，气缸的材料应耐腐蚀，以延长使用寿命。 轻量化: 尽量降低气缸的质量，以减小发动机的整体质量，提高机动性。 制造工艺: 采用精密的机械加工工艺，以确保气缸内外表面的平滑度和尺寸精度。 热传导设计: 优化气缸的热传导设计，以提高热能的传递效率。 具体的设计要求针对最终需要完成的斯特林发动机，需要满足如下几条设计指标与功能要求： 最大输出功率: 不小于0.5W 热源:普通酒精灯 连续运行时间:不小于30分钟 密封性能: 气缸必须能够有效密封工作气体，具有良好的密封性能以确保高效的热循环过程。 材料选择: 选择常用的适当材料与零部件以满足高温环境下的性能需求。 满足这些需求将有助于确保β型斯特林发动机的性能优越，同时提高其在各种应用领域的适用性。制作气缸需要综合考虑这些需求，并在制造过程中严格控制相关参数，以获得卓越的产品性能。 二、方案提出1. 加工方式——机加工选用机加工方法制作缸筒与活塞的理由如下： 精确尺寸控制：机加工可以实现非常高的尺寸精确度，确保气缸内径和活塞直径的精确匹配。这是确保气缸与活塞之间的紧密密封以及减少能量损失的关键。精确尺寸控制也有助于降低磨损，延长气缸和活塞的寿命。 表面质量：机加工可以产生平滑、光洁的表面，减少摩擦和磨损。这对于斯特林发动机的效率至关重要，因为高效的热循环需要最小的摩擦损失。 公差控制：机加工允许对关键尺寸的公差进行严格控制，确保气缸和活塞的尺寸在允许范围内，从而确保它们可以良好地配合。公差控制还有助于提高气缸和活塞的互换性，降低制造成本。 材料选择：机加工允许使用各种高强度、耐高温材料，如高温合金或陶瓷，以满足斯特林发动机在高温工作环境下的要求。这有助于提高耐高温性，确保气缸和活塞在极端条件下保持结构稳定。 加工复杂几何形状：斯特林发动机的气缸和活塞通常具有复杂的几何形状，以实现最佳性能。机加工可以实现这些复杂形状，包括内部凹凸和特殊的密封表面，以确保气缸能够有效地容纳工作气体。 总的来说，机加工满足了精确性、表面质量、公差控制、材料选择和复杂几何形状等多个需求，这些需求都对斯特林发动机的性能和产品质量产生显著影响。通过机加工，可以确保气缸和活塞能够稳定、高效地工作，从而提高发动机的性能和可靠性。 2. 装置主要部件确定β型斯特林发动机是一种热机，其原理基于气体的周期性膨胀和压缩过程，使发动机能够执行其热循环，将热能转化为机械能。基于实际的需求与制造情况，为方便后期接入整个斯特林发动机，考虑到β型斯特林发动机的基本工作原理，本驱动部件主要由如下四个主要部分构成： 气缸：气缸是β型斯特林发动机的关键组成部分，用于容纳和引导工作气体，包括热源和冷源。在工作过程中，气体会经历周期性的膨胀和压缩，这需要一个容器来容纳和引导气体。因此，气缸是必不可少的。 排气活塞：排气活塞是β型斯特林发动机的重要组成部分，它在工作过程中与冷源接触，以帮助气体压缩。排气活塞的运动导致气体的压缩，从而提供负功。它的存在有助于形成热循环，从而使发动机能够持续工作。 做功活塞：做功活塞是另一个重要的部件，它与热源接触，推动气体膨胀，从而提供正功。做功活塞的运动是热机的关键部分，因为它将热能转化为机械功，实现发动机的工作。 散热片：散热片在β型斯特林发动机中的必要性主要取决于工作条件和设计要求。由于发动机工作时产生热量，散热片用于冷却气缸和活塞，以确保它们不过热。如果不进行散热，发动机温度将升高，可能导致性能下降、部件损坏或设备故障。因此，散热片在保持发动机温度稳定和可控的情况下是必要的。 这些部件共同协作，构成了发动机的关键部分，使β型斯特林发动机能够将热能转化为机械能，并提供功率输出。 3. 材料选择基于需求分析与相关指标的要求，综合考虑各材料的导热性能与相关参数，基于这两种材料的特性和性能在斯特林发动机应用中的相对优势，最终选择**不锈钢-304材料用于制作活塞、铝合金-0001材料用于制作气缸**，理由如下： 不锈钢-304用于活塞制作： 高耐磨性和耐腐蚀性：不锈钢-304是一种耐磨性和耐腐蚀性较高的材料，这在活塞的应用中是非常重要的。不锈钢的表面抵抗摩擦和腐蚀，有助于提高活塞的寿命。 高强度：不锈钢-304具有相对较高的强度，这对于承受活塞运动和高压力的应力非常重要。这有助于确保活塞的结构稳定性。 高温稳定性：不锈钢-304在一定温度范围内表现出良好的稳定性，这对于斯特林发动机在高温环境下的应用非常有利。 可加工性：不锈钢-304相对容易加工，使其适合制作复杂几何形状的活塞，以满足特定的设计需求。 铝合金-0001用于气缸制作： 轻质高导热性：铝合金-0001具有较低的密度，因此相对轻便，有助于降低整个发动机的质量。此外，铝合金具有良好的导热性，其导热系数相对于其他材料而言更高，可以有效地传导热量，有利于优化发动机的热传导性能。 耐高温性：虽然铝合金的熔点较低，但在典型的斯特林发动机工作温度范围内，铝合金-0001表现出足够的耐高温性。此外，铝合金在高温下也能保持较好的强度。 可加工性：铝合金易于加工，因此可以比较容易地制造气缸的复杂几何形状，以确保其密封性和热性能。 这样的选择有助于确保活塞和气缸能够在高温、高压和高效率的工作环境下稳定运行，并且提高了产品的寿命和性能。 除此之外，考虑到成本、加工难度与加工时间等客观限制条件因素，这两种材料也易于获取与加工，有效控制了整个制造过程的经济与时间成本。 4. 散热片的型号选择与相关尺寸的确定散热片的主要作用是从热源（如电子元件、发动机、LED等）吸收热量，并将其有效地散发到周围环境中。使用散热片的主要原因： 保持温度稳定：散热片有助于保持热源的温度在可接受范围内。过高的温度可能导致设备故障或元件损坏，因此散热片对于稳定运行至关重要。 延长寿命：有效的散热可以延长设备和元件的寿命。高温环境可能导致元件老化，降低其寿命。通过散热片，可以有效地冷却元件并延长其寿命。 提高性能：在高温环境下，设备性能通常下降。通过散热片，可以确保设备在更长时间内保持高性能，以满足连续运行时间的需求。 安全性：一些应用中，如电子设备，高温可能导致火灾或其他安全问题。散热片有助于维持较低的温度，减少了潜在的安全风险。 考虑到制造过程的时间和经济成本有限，计划设计的大致尺寸均较小；同时为了提升散热效率，决定选用现成的特定型号的散热片，并根据散热片的相关尺寸参数确定设计的气缸与活塞的具体尺寸数据。如下图1所示，是本项目中所选用的散热片，其外径为32mm，内径为17mm，厚度为10mm。 图1：散热片型号选择 在确定了选用的散热片内径为17mm后，计划制造的气缸外径也随之确定为17mm。为尽可能地提高传热效率，气缸的侧壁厚应尽量小，在此设定为2mm。于是做功活塞的外径也随之确定为17-2=15mm。除此之外，排气活塞的圆柱长杆半径也应与做工活塞的孔洞内径保持一致，设定为5mm；排气活塞的活塞头半径应大于圆柱长杆半径且小于气缸内径，在此设定为12mm。 5. 热力学参数分析假设： 圆柱形气缸的半径 r=15mm=0.015m。 圆柱形气缸底部与排气活塞顶部之间的预留距离 L*=30mm=0.03m。 工质气体是空气。 温度差 ΔT = 高温 - 低温。 假设在气缸内，高温 T*h= 525°C = 798K，低温 Tc = 25°C = 298K（外部环境温度）。 以下是计算功率的推导过程： （1）计算气缸的截面积 A：A=π⋅r*^2=*π⋅(0.015m)^2≈7.07×10−4m2 （2）计算气缸内原有的空气的体积 V：V=A⋅L=(7.07×10−4m2)⋅(0.03m)=2.12×10−5m3 （3）计算气缸内的气体摩尔数 n。使用理想气体状态方程：PV=n R T 其中，P 是气体压力， V 是体积， n 是摩尔数， R 是气体常数， T 是温度。 解出 n：n=PV/RT 其中，P 可以根据工作条件确定， T 是绝对温度， R 是空气的气体常数。 （4）计算热力学效率 η，根据斯特林循环的定义：η=1−Tc/Th 其中，Tc 和 Th 分别是低温和高温的绝对温度。Tc=298K ,Th=798K 于是有η≈0.625 （5）计算气缸内的热量 Qh 和 Qc。根据斯特林循环的热量关系： Qh=Qc=n⋅Cp⋅ΔT 其中，Cp 是空气的定压比热容。Cp≈1005J/(kg*K) ΔT=Th−Tc=798K−298K=500K Qh=Qc=n⋅Cp⋅ΔT≈PV⋅Cp⋅Δ*T/RT （6）计算功率 P。功率是通过工质气体对气缸内工作物体做功而获得的热量。 斯特林发动机的热功率可以通过以下公式计算： P=Qh⋅η−Qc⋅η P=n⋅Cp⋅ΔT⋅η P≈P⋅V⋅Cp⋅ΔT⋅η/（R⋅T） 代入已知值，可计算得到功率 P 的数值解：**P≈0.839W&gt;0.5W，满足制造与设计需求。** 三、样机制作1. Fusion360 建模基于以上的设计方案，进一步细化各个部件各部分的尺寸，分别进行做功活塞、排气活塞与气缸的三维建模并结合已有的特定型号散热片完成总装，如下图2、3、4、5所示。图6为总装整体部件的剖面图。 图2：做功活塞建模效果图 图3：排气活塞建模效果图 图4：气缸建模效果图 图5：总装建模效果图 图6：总装剖面图 2. 图纸绘制为进一步将建模得到的部件模型通过机加工的方式制造出来，还需要进行工程制图以便进一步的加工与修改并最终提交给厂家进行制作。做功活塞、排气活塞与气缸的图纸如下图7、8、9所示。 图7：做功活塞工程图 图8：排气活塞工程图 图9：气缸工程图 在完成工程图后，与加工制造厂家确认尺寸无误后，按照以上图纸开始投入加工，历时半个月拿到加工完成的样机，并在公差的基础上对于个别部件进行简单的车削处理使各部分能够紧密连接并尽可能地减小摩擦力。 四、最终效果各部件加工效果如下图10、11、12所示，最终总装效果图如图13所示。 图10：做功活塞实物图 图11：排气活塞实物图 图12：气缸实物图 图13：总装实物图 其中做工活塞在加工时出现错误，中间的连杆原本设计为圆筒形，加工时外层错加工为正方形，但并不影响整体性能。 1020实际测试更新版测试视频见附件：气缸活塞演示视频 图14：测试始态与终态对比图 测试结果：在加热至18秒左右时，做功活塞有明显的运动，并在之后持续对外做功 通过实际验证实验可知，**在排气活塞预留30mm空气柱的情况下，对于气缸底部受热段进行一定时间的预热与加热，做功活塞可以成功被推出，并以一定的功率对外做功，满足基本设计需求。** 但由于未做密封圈等进一步设计，该驱动部件的气密性并不是特别良好，且做功活塞与气缸壁之间以及排气活塞与做功活塞之间的摩擦力相对较大，因此实际测试过程中并未达到理论计算的功率结果，需要在后续发动机的整体制造中进行进一步的设计改进。 五、总结在本项目中，成功制作了β型斯特林发动机的基本驱动部件：气缸与活塞，整体装置由排气活塞、做功活塞、气缸和散热片四个部件组成。在制作过程中，主要完成了从分析需求与设计要求，到提出具体的设计方案，再到实际建模确定具体尺寸参数并绘制工程图纸以进行机加工，最终完成了整个驱动部件的制造。在设计的同时也对确定的参数进行了一定的热力学数值分析进行验证使得制造出的部件能够初步满足最终斯特林发动机输出功率等方面的性能要求。 通过完成本次项目课题，对于气体受热膨胀做功有了更深层次的认识并将这一热力学原理成功运用于设计与制造实践中，同时也提升了对密封、摩擦、公差设计、基本加工工艺、材料传热性能等多方面的认识。该驱动部件的成功制作也为后续斯特林发动机的整体制造完善与效果参数实现打下了良好的基础，有助于后续进一步设计与制造流程的开展。 在本次项目课题中，从自己设计、建模出图纸到寻找加工方再到最终成品的组装与测试，大体完成了金属件从设计到加工再到实际测试的全流程。最终的测试结果并不算令人满意，主要是由于在设计阶段缺乏对于气密性的考虑，并未进行密封圈的设计与选型，特别是β型斯特林发动机的驱动部件，由于其有做功与排气两个活塞，两个活塞连杆之间的空隙也对整体装置的气密性造成了一定影响。除此之外，在图纸设计过程中，缺乏公差的预留也让最终加工出的成品在组装时遇到了一些小的瑕疵，进行了局部的二次微小加工才顺利完成安装，并在气密性上带来了一定的影响。不过也正是因为完成该驱动部件的制作，才能在实际的操作过程中体会到加工过程中可能存在的问题，这也有利于后面在发动机整体的一代与二代样机的过程中减少不必要的时间与加工成本，少走弯路。相信这次加工制作中所遇到的问题能在接下来的完整样机制作中得到进一步解决。","link":"/2023/10/13/%E6%B0%94%E7%BC%B8%E6%B4%BB%E5%A1%9E%E6%8A%A5%E5%91%8A/"},{"title":"3.线性神经网络","text":"3.1 线性回归123456789101112131415161718192021222324252627282930313233343536373839%matplotlib inlineimport mathimport timeimport numpy as npimport torchfrom d2l import torch as d2ln=10000a=torch.ones([n])b=torch.ones([n])#定义计时器class Timer: #@save #记录多次运行时间 def __init__(self): self.times=[] self.start() def start(self): #启动计时器 self.tik=time.time() def stop(self): #停止计时器并将时间记录在列表中 self.times.append(time.time()-self.tik) return self.times[-1] def avg(self): #返回平均时间 return sum(self.times)/len(self.times) def sum(self): #返回时间总和 return sum(self.times) def cumsum(self): #返回累计时间 return np.array(self.times).cumsum().tolist() 12345c=torch.zeros(n)timer=Timer()for i in range(n): c[i]=a[i]+b[i]f'{timer.stop():.5f}sec' '0.14660sec' 123timer.start()d=a+bf'{timer.stop():.5f}sec' '0.00000sec' 12345678910def normal(x,mu,sigma): p=1/math.sqrt(2*math.pi*sigma**2) return p*np.exp(-0.5/sigma**2*(x-mu)**2)#再次使用numpy进行可视化x=np.arange(-7,7,0.01)#均值和标准差对params=[(0,1),(0,2),(3,1)]d2l.plot(x,[normal(x,mu,sigma)for mu,sigma in params],xlabel='x',ylabel='p(x)',figsize=(4.5,2.5),legend=[f'mean{mu},std{sigma}'for mu,sigma in params]) ​​ 3.2 线性回归的从零开始实现123456789101112131415161718%matplotlib inlineimport randomimport torchfrom d2l import torch as d2l#生成数据集def synthetic_data(w,b,num_examples): #@save #生成y=Xw+b+噪声 X=torch.normal(0,1,(num_examples,len(w))) y=torch.matmul(X,w)+b y+=torch.normal(0,0.01,y.shape) return X,y.reshape((-1,1))true_w=torch.tensor([2,-3.4])true_b=4.2features,labels=synthetic_data(true_w,true_b,1000)print('features:',features[0],'\\nlabel:',labels[0]) features: tensor([ 0.7328, -0.5520]) label: tensor([7.5513]) 12d2l.set_figsize()d2l.plt.scatter(features[:,1].detach().numpy(),labels.detach().numpy(),1); ​​ 123456789101112131415#读取数据集def data_iter(batch_size,features,labels): num_examples=len(features) indices=list(range(num_examples)) #这些样本是随机读取的，没有特定顺序 random.shuffle(indices) for i in range(0,num_examples,batch_size): batch_indices=torch.tensor(indices[i:min(i+batch_size,num_examples)]) yield features[batch_indices],labels[batch_indices] batch_size=10for X,y in data_iter(batch_size,features,labels): print(X,'\\n',y) break tensor([[ 0.9175, -0.1441], [-0.3328, -0.4237], [-0.1287, 1.6801], [ 0.8705, -0.9030], [-0.4966, 1.4015], [ 1.3378, -1.8026], [ 0.5129, 1.2806], [ 1.1026, 1.2080], [ 0.6151, 0.6337], [-0.4683, -0.4388]]) tensor([[ 6.5336], [ 4.9801], [-1.7645], [ 9.0089], [-1.5652], [12.9979], [ 0.8680], [ 2.2893], [ 3.2902], [ 4.7695]]) 123456789101112131415161718192021222324252627282930313233343536373839#初始化模型参数w=torch.normal(0,0.01,size=(2,1),requires_grad=True)b=torch.zeros(1,requires_grad=True)#定义模型def linreg(X,w,b): #@save #线性回归模型 return torch.matmul(X,w)+b#定义损失函数def squared_loss(y_hat,y): #@save #均方损失 return(y_hat-y.reshape(y_hat.shape))**2/2#定义优化算法——小批量随机梯度下降#lr:学习速率(梯度下降步长)；batch_size:批量大小def sgd(params,lr,batch_size): #@save #小批量随机梯度下降 with torch.no_grad(): for param in params: param-=lr*param.grad/batch_size param.grad.zero_() #训练#设置超参数lr=0.03#学习率num_epochs=3#迭代周期个数net=linregloss=squared_lossfor epoch in range(num_epochs): for X,y in data_iter(batch_size,features,labels): l=loss(net(X,w,b),y)#X和y的小批量损失 #因为l的形状是（batch_size,1），而不是一个标量。l中的所有元素被加到一起，并以此计算关于[w,b]的梯度 l.sum().backward() sgd([w,b],lr,batch_size)#使用参数的梯度以更新参数 with torch.no_grad(): train_l=loss(net(features,w,b),labels) print(f'epoch{epoch+1},loss{float(train_l.mean()):f}') epoch1,loss0.036941 epoch2,loss0.000134 epoch3,loss0.000049 12print(f'w的估计误差：{true_w-w.reshape(true_w.shape)}')print(f'b的估计误差：{true_b-b}') w的估计误差：tensor([ 0.0002, -0.0002], grad_fn=&lt;SubBackward0&gt;) b的估计误差：tensor([0.0002], grad_fn=&lt;RsubBackward1&gt;) 3.3 线性回归的简洁实现1234567891011121314151617181920#生成数据集import numpy as npimport torchfrom torch.utils import datafrom d2l import torch as d2ltrue_w=torch.tensor([2,-3.4])true_b=4.2features,labels=d2l.synthetic_data(true_w,true_b,1000)#读取数据集def load_array(data_arrays,batch_size,is_train=True): #@save #构造一个pytorch数据迭代器 dataset=data.TensorDataset(*data_arrays) return data.DataLoader(dataset,batch_size,shuffle=is_train)batch_size=10data_iter=load_array((features,labels),batch_size)next(iter(data_iter)) [tensor([[-0.6422, -0.7470], [-2.1785, 0.3340], [ 1.4011, -1.1104], [-0.8083, -0.3035], [ 0.1077, -0.1201], [-0.4151, -0.1079], [ 1.8074, 0.0904], [-0.3707, 0.6197], [ 0.3739, 0.2972], [ 0.2383, 1.1791]]), tensor([[ 5.4457], [-1.3122], [10.7837], [ 3.6281], [ 4.8105], [ 3.7284], [ 7.5017], [ 1.3465], [ 3.9247], [ 0.6800]])] 123456#定义模型from torch import nn#nn:神经网络net=nn.Sequential(nn.Linear(2,1))#初始化模型参数net[0].weight.data.normal_(0,0.01),net[0].bias.data.fill_(0) (tensor([[ 0.0106, -0.0055]]), tensor([0.])) 1234#定义损失函数loss=nn.MSELoss()#均方误差：MSELoss类，平方L2范数#定义优化算法trainer=torch.optim.SGD(net.parameters(),lr=0.03) 123456789num_epochs=3#迭代周期个数for epoch in range(num_epochs): for X,y in data_iter: l=loss(net(X),y)#X和y的小批量损失 trainer.zero_grad() l.backward() trainer.step()#使用参数的梯度以更新参数 l=loss(net(features),labels) print(f'epoch{epoch+1},loss{l:f}') epoch1,loss0.000223 epoch2,loss0.000112 epoch3,loss0.000112 1234w=net[0].weight.dataprint('w的估计误差：',true_w-w.reshape(true_w.shape))b=net[0].bias.dataprint('b的估计误差：',true_b-b) w的估计误差： tensor([ 0.0014, -0.0004]) b的估计误差： tensor([0.0008]) 3.5 图像分类数据集12345678%matplotlib inlineimport torchimport torchvisionfrom torch.utils import datafrom torchvision import transformsfrom d2l import torch as d2ld2l.use_svg_display() 12345#通过框架内内置函数将Fashion-MNIST数据集下载并读取到内存中#通过ToTensor实例将图像数据由PIL类型变换为32位浮点数格式，并除以255使得所有像素数值均在0-1之间trans=transforms.ToTensor()mnist_train=torchvision.datasets.FashionMNIST(root=&quot;../data&quot;,train=True,transform=trans,download=True)mnist_test=torchvision.datasets.FashionMNIST(root=&quot;../data&quot;,train=False,transform=trans,download=True) 1len(mnist_train),len(mnist_test) (60000, 10000) 1mnist_train[0][0].shape torch.Size([1, 28, 28]) 123456789101112131415161718192021222324252627#在数字标签索引与文本名称之间进行转换def get_fashion_mnist_labels(labels): #@save #返回Fashion-MNIST数据集的文本标签 text_labels=['t-shirt','trouser','pullover','dress','coat','sandal','shirt','sneaker','bag','ankle boot'] return [text_labels[int(i)] for i in labels]#可视化样本def show_images(imgs,num_rows,num_cols,titles=None,scale=1.5): #@save #绘制图像列表 figsize=(num_cols*scale,num_rows*scale) _,axes=d2l.plt.subplots(num_rows,num_cols,figsize=figsize) axes=axes.flatten() for i,(ax,img) in enumerate(zip(axes,imgs)): if torch.is_tensor(img): #图片张量 ax.imshow(img.numpy()) else: #PIL图片 ax.imshow(img) ax.axes.get_xaxis().set_visible(False) ax.axes.get_yaxis().set_visible(False) if titles: ax.set_title(titles[i]) return axesX,y=next(iter(data.DataLoader(mnist_train,batch_size=50)))show_images(X.reshape(50,28,28),10,5,titles=get_fashion_mnist_labels(y)); ​​ 1234567891011121314#读取小批量batch_size=256 #批量大小def get_dataloader_workers(): #@save #使用4个进程来读取数据 return 4train_iter=data.DataLoader(mnist_train,batch_size,shuffle=True,num_workers=get_dataloader_workers())#读取训练数据所需时间timer=d2l.Timer()for X,y in train_iter: continuef'{timer.stop():.2f}sec' '2.11sec' 1234567891011121314def load_data_fashion_mnist(batch_size,resize=None): #@save #下载Fashion-MNIST数据集，然后将其加载到内存中 trans=[transforms.ToTensor()] if resize: trans.insert(0,transforms.Resize(resize)) trans=transforms.Compose(trans) mnist_train=torchvision.datasets.FashionMNIST(root=&quot;../data&quot;,train=True,transform=trans,download=True) mnist_test=torchvision.datasets.FashionMNIST(root=&quot;../data&quot;,train=False,transform=trans,download=True) return(data.DataLoader(mnist_train,batch_size,shuffle=True,num_workers=get_dataloader_workers()),data.DataLoader(mnist_test,batch_size,shuffle=False,num_workers=get_dataloader_workers()))train_iter,test_iter=load_data_fashion_mnist(32,resize=64)for X,y in train_iter: print(X.shape,X.dtype,y.shape,y.dtype) break torch.Size([32, 1, 64, 64]) torch.float32 torch.Size([32]) torch.int64 3.6 softmax回归的从零开始实现123456import torchfrom IPython import displayfrom d2l import torch as d2lbatch_size=256train_iter,test_iter=d2l.load_data_fashion_mnist(batch_size) 123456#初始化模型参数num_inputs=784num_outputs=10W=torch.normal(0,0.01,size=(num_inputs,num_outputs),requires_grad=True)#用正态分布初始化权重Wb=torch.zeros(num_outputs,requires_grad=True)#偏置b初始化为0 12X=torch.tensor([[1.0,2.0,3.0],[4.0,5.0,6.0]])X.sum(0,keepdim=True),X.sum(1,keepdim=True) (tensor([[5., 7., 9.]]), tensor([[ 6.], [15.]])) 123456789#定义softmax操作def softmax(X): X_exp=torch.exp(X) partition=X_exp.sum(1,keepdim=True) return X_exp/partition #应用广播机制X=torch.normal(0,1,(2,5))X_prob=softmax(X)X_prob,X_prob.sum(1) (tensor([[0.2143, 0.0127, 0.1268, 0.2248, 0.4214], [0.3360, 0.2826, 0.0913, 0.1454, 0.1446]]), tensor([1.0000, 1.0000])) 123#定义模型def net(X): return softmax(torch.matmul(X.reshape((-1,W.shape[0])),W)+b) #使用reshape函数将每张原始图像展平为向量 123y=torch.tensor([0,2])y_hat=torch.tensor([[0.1,0.3,0.6],[0.3,0.2,0.5]])y_hat[[0,1],y] tensor([0.1000, 0.5000]) 12345#定义交叉熵损失函数def cross_entropy(y_hat,y): return - torch.log(y_hat[range(len(y_hat)),y])cross_entropy(y_hat,y) tensor([2.3026, 0.6931]) 12345678def accuracy(y_hat,y): #@save #计算正确预测的数量 if len(y_hat.shape)&gt;1 and y_hat.shape[1]&gt;1: y_hat=y_hat.argmax(axis=1) cmp=y_hat.type(y.dtype)==y return float(cmp.type(y.dtype).sum())accuracy(y_hat,y)/len(y) #正确预测的概率（分类精度率） 0.5 12345678910111213141516171819202122232425def evaluate_accuracy(net,data_iter): #@save #计算在指定数据集上模型的精度 if isinstance(net,torch.nn.Module): net.eval() #将模型设置为评估模式 metric=Accumulator(2) #正确预测数、预测总数的叠加 with torch.no_grad(): for X,y in data_iter: metric.add(accuracy(net(X),y),y.numel()) #accracy(net(X),y):正确预测数；y.numel()预测总数 return metric[0]/metric[1]class Accumulator: #@save #在n个变量上累加 def __init__(self,n): self.data=[0.0]*n def add(self,*args): self.data=[a+float(b) for a,b in zip(self.data,args)] def reset(self): self.data=[0.0]*len(self.data) def __getitem__(self,idx): return self.data[idx] evaluate_accuracy(net,test_iter) 0.1326 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#训练def train_epoch_ch3(net,train_iter,loss,updater): #@save #训练模型一个迭代周期 #将模型设置为训练模型 if isinstance(net,torch.nn.Module): net.train() #训练损失总和、训练准确度总和、样本数 metric=Accumulator(3) for X,y in train_iter: #计算梯度并更新参数 y_hat=net(X) l=loss(y_hat,y) if isinstance(updater,torch.optim.Optimizer): #使用PyTorch内置的优化器和损失函数 updater.zero_grad() l.mean().backward() updater.step() else: #使用定制的优化器和损失函数 l.sum().backward() updater(X.shape[0]) metric.add(float(l.sum()),accuracy(y_hat,y),y.numel()) #返回训练损失和训练精度 return metric[0]/metric[2],metric[1]/metric[2]class Animator: #@save #在动画中绘制数据 def __init__(self, xlabel=None, ylabel=None, legend=None, xlim=None,ylim=None, xscale='linear', yscale='linear',fmts=('-', 'm--', 'g-.', 'r:'), nrows=1, ncols=1,figsize=(3.5, 2.5)): # 增量地绘制多条线 if legend is None: legend = [] d2l.use_svg_display() self.fig, self.axes = d2l.plt.subplots(nrows, ncols, figsize=figsize) if nrows * ncols == 1: self.axes = [self.axes, ] # 使用lambda函数捕获参数 self.config_axes = lambda: d2l.set_axes( self.axes[0], xlabel, ylabel, xlim, ylim, xscale, yscale, legend) self.X, self.Y, self.fmts = None, None, fmts def add(self, x, y): # 向图表中添加多个数据点 if not hasattr(y, &quot;__len__&quot;): y = [y] n = len(y) if not hasattr(x, &quot;__len__&quot;): x = [x] * n if not self.X: self.X = [[] for _ in range(n)] if not self.Y: self.Y = [[] for _ in range(n)] for i, (a, b) in enumerate(zip(x, y)): if a is not None and b is not None: self.X[i].append(a) self.Y[i].append(b) self.axes[0].cla() for x, y, fmt in zip(self.X, self.Y, self.fmts): self.axes[0].plot(x, y, fmt) self.config_axes() display.display(self.fig) display.clear_output(wait=True) def train_ch3(net,train_iter,test_iter,loss,num_epochs,updater): #@save #训练模型 animator=Animator(xlabel='epoch',xlim=[1,num_epochs],ylim=[0.3,0.9],legend=['train loss','train acc','test acc']) for epoch in range(num_epochs): train_metrics=train_epoch_ch3(net,train_iter,loss,updater) test_acc=evaluate_accuracy(net,test_iter) animator.add(epoch+1,train_metrics+(test_acc,)) train_loss,train_acc=train_metrics assert train_loss&lt;0.5,train_loss assert train_acc&lt;=1 and train_acc&gt;0.7,train_acc assert test_acc&lt;=1 and test_acc&gt;0.7,test_acc lr=0.1 #学习率def updater(batch_size): return d2l.sgd([W,b],lr,batch_size)#小批量随机梯度下降num_epochs=10 #迭代周期train_ch3(net,train_iter,test_iter,cross_entropy,num_epochs,updater) ​​ 1234567891011#预测def predict_ch3(net,test_iter,n=6): #@save #预测标签 for X,y in test_iter: break trues=d2l.get_fashion_mnist_labels(y) preds=d2l.get_fashion_mnist_labels(net(X).argmax(axis=1)) titles=[true+'\\n'+pred for true,pred in zip(trues,preds)] d2l.show_images(X[0:n].reshape((n,28,28)),1,n,titles=titles[0:n]) predict_ch3(net,test_iter) ​​ 3.7 softmax回归的简洁实现123456import torchfrom torch import nnfrom d2l import torch as d2lbatch_size=256train_iter,test_iter=d2l.load_data_fashion_mnist(batch_size) 123456789#初始化模型参数#PyTorch不会隐式地调整输入的形状，因此，我们在线性层前定义了展平层（flatten),来调整网络输入的形状net=nn.Sequential(nn.Flatten(),nn.Linear(784,10))def init_weights(m): if type(m)==nn.Linear: nn.init.normal_(m.weight,std=0.01)net.apply(init_weights); 1loss=nn.CrossEntropyLoss(reduction='none') #保留softmax函数，但在计算交叉熵损失函数时传递未规范化的预测并同时计算softmax及其对数以防止数值上溢或下溢 12#优化算法：学习度为0.1的小批量随机梯度下降trainer=torch.optim.SGD(net.parameters(),lr=0.1) 123#训练num_epochs=10d2l.train_ch3(net,train_iter,test_iter,loss,num_epochs,trainer) ​​","link":"/2023/10/05/3.%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"title":"课题：典型建筑墙体的稳态传热分析","text":"一、背景介绍建筑墙体作为建筑的重要组成部分，在维护室内舒适温度和能源效率方面起着重要作用，研究其作用及在传热过程中的特性对生态建筑的可持续发展具有重要的指导意义。发展生态节能建筑最终的目标就是要在满足室内居住者的热舒适基础上降低建筑的能耗，对实际居住者而言较关注的是如何以较低的能耗获得舒适的建筑室内热环境。考虑到当前大部分大型公共建筑、工业建筑与高层住宅的主要承重构件包括梁、板、柱等均采用钢筋混凝土结构，因此本文将着重针对此种结构简化模型的传热过程进行分析。 稳态传热是指传热系统中各点的温度仅随位置而变化，不随时间而改变的传热过程，对于这一传热过程的分析有助于评估墙体在不同环境条件下的隔热性能，其中一个关键参数是环境空气流速。本研究旨在分析单位面积上典型建筑墙体的稳态散热过程，特别关注墙体散热量随环境空气流速的变化关系。 二、物理模型钢筋混凝土墙体结构的物理模型如下图1、2、3所示。 图1：钢筋结构图解 图2：墙体结构物理模型 图3：墙体处传热物理模型 在上述简化模型中，选取房间中心为坐标原点，定义有如下参数： （1）室内方墙高宽比为Ar=L/H； （2）模型左端设有厚度为s的墙体； （3）墙体内侧空气流速为V1，墙体外侧空气流速为V2； （4）墙体内侧温度为Tf1，墙体外侧温度为Tf2，且由于研究室内散热过程，默认Tf1&gt;Tf2； （5）钢筋混凝土结构内表面温度为Tw1，钢筋混凝土结构外表面温度为Tw2，且由于研究室内散热过程，默认Tw1&gt;Tw2。 注意：模型中方腔右侧墙体及上、下墙体均为绝热且不考虑厚度。 三、传热过程分析该简化传热过程主要可以分为以下三个环节： （1）墙体内侧的对流换热该过程为热对流过程，由牛顿冷却公式可得：单位面积墙体上的对流传热量Q1=hΔT1 其中，h为表面对流换热系数，通过查询相关文献与手册（《民用建筑热工设计规范》 GB 50176-2016)可得，当Ar=L/H&lt;=0.3时，空气在钢筋混凝土内表面的对流换热系数约为8.7W/m^2-K；当Ar=L/H&gt;0.3时，空气在钢筋混凝土内表面的对流换热系数约为7.6W/m^2-K（如图4所示）。ΔT1为室内空气温度Tf1与钢筋混凝土内表面的温度Tw1之差。 图4:内表面换热系数αi和内表面换热阻Ri （2）通过墙壁的导热（散热）过程该过程为热传导过程，由傅里叶定律可得：单位面积墙体上的传导热量Q2=λΔT2/Δx 其中，λ为钢筋混凝土结构的导热系数，通过查询相关文献与手册（《民用建筑热工设计规范》 GB 50176-2016)可得其值约为1.74W/m-K；ΔT2为钢筋混凝土内外表面两侧的温度差，由于传热总是自发由高温向低温处进行，故此处特别定义为Tw1-Tw2；Δx则为墙体厚度s。 （3）墙体外侧的对流换热该过程为热对流过程，由牛顿冷却公式可得：单位面积墙体上的对流传热量Q3=hΔT3 其中，h为表面对流换热系数，通过查询相关文献与手册（《民用建筑热工设计规范》 GB 50176-2016)可得，冬季时，空气在钢筋混凝土外表面的对流换热系数约为23.0W/m^2-K；夏季时，空气在钢筋混凝土外表面的对流换热系数约为19.0W/m^2-K（如图5所示）。ΔT3为钢筋混凝土外表面温度Tw2与室外空气温度Tf2之差。 图5:外表面换热系数αe和外表面换热阻Re 全热路过程分析在分别考虑上述三个传热过程环节后，针对整个完整的传热过程，通过查阅相关文献资料（详见《民用建筑热工设计规范》 GB 50176-2016：3.4 基本计算方法），有如下公式： 单位面积墙体上的散热量Q=Q1+Q2+Q3=KΔT； 其中ΔT为室内与室外的温度差值Tf1-Tf2；K为该传热过程的传热系数； 传热系数K=1/R0，R0为整个结构的传热阻值； R0=Ri+R+Re，其中Ri为内表面换热阻，R为钢筋混凝土材料的热阻，Re为外表面换热阻； Ri,Re的一般数值均可查表获得，如上图4、5所示； 通过查阅资料，钢筋混凝土结构的热阻计算可采用公式R=δ/λ，其中δ即为墙壁厚度s，λ查表可得约为1.74W/m-K。 至此即可在给定的条件下计算出单位面积墙体稳态散热量（传热方程与热路图如下图6、7所示）。 图6:传热方程——单位面积墙体稳态散热量的定量表达式 图7:典型建筑墙体稳态传热过程的简化热路图 如需要计算夏季Ar=L/H&gt;0.3的房屋（钢筋混凝土结构），厚度s=0.5m的单位面积墙体稳态散热量，则依据上述数据，取Ri=0.13m^2-K/W,Re=0.05m^2-K/W,λ=1.74W/m-K,则可计算得出总热阻R0≈0.467m^2-K/W，传热系数K≈2.141W/m^2-K，若室内外温差为10K，则可计算得出此时单位面积上墙体的散热量Q约等于21.41W。 值得注意的是，上述数据均取自于实际的民用建筑热工设计规范标准，因此较接近于大部分情况下建筑墙体的实际情况。但事实上，表面对流换热系数的数值与换热过程中流体的物理性质、换热表面的形状、部位以及流体的流速等都有密切关系。物体表面附近的流体的流速愈大，其表面对流换热系数也愈大，一般采用经验公式进行计算。目前相关的参考资料较少，无法给出针对该典型建筑墙体结构的准确的定量计算公式衡量对流换热系数与流体流速之间的数值对应关系，只能进行定性分析与查表获取一般情况。 四、结论通过对于上述分析所得到公式的整理与总结，综合可能影响墙体的表面对流换热系数等关键参数的因素，可以得出如下结论： 墙体导热系数λ和墙体厚度s(δ）的增加都会导致墙体散热量减小。 外部环境空气流速V的增加会增加墙体散热量，尤其是在寒冷的条件下，但暂时无法给出定量的公式分析，不同的场景下该因素对于散热量的影响不同。 对流换热系数h的增加会显著增加墙体散热量，这取决于墙体表面特性和空气性质。 因此，我们可以根据这些分析结果来优化建筑墙体的隔热性能，选择合适的材料、厚度和对流措施，以提高能源效率并确保室内舒适度。在寒冷气候下，特别要注意增加对流传热（可以通过加快内外空气对流的方式）以减少能源损失。","link":"/2023/10/01/%E6%8A%A5%E5%91%8A/"},{"title":"2.预备知识","text":"2.1 数据操作123import torchx = torch.arange(12)x tensor([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) 1x.shape torch.Size([12]) 1x.numel() 12 12X=x.reshape(3,4)X tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 1X.shape torch.Size([3, 4]) 12Y=x.reshape(-1,4)Y tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 12Z=x.reshape(3,-1)Z tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 1torch.zeros((2,3,4)) tensor([[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]], [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]]) 1torch.ones((2,3,4)) tensor([[[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]], [[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]]) 1torch.randn(3,4) tensor([[ 1.6438, -1.2879, 0.2324, 0.2719], [-0.6636, 0.9939, -0.8435, -1.0906], [-0.5617, 0.2107, -0.9530, 0.7362]]) 123x=torch.tensor([1.0,2,4,8])y=torch.tensor([2,2,2,2])x+y,x-y,x*y,x/y,x**y (tensor([ 3., 4., 6., 10.]), tensor([-1., 0., 2., 6.]), tensor([ 2., 4., 8., 16.]), tensor([0.5000, 1.0000, 2.0000, 4.0000]), tensor([ 1., 4., 16., 64.])) 1torch.exp(x) tensor([2.7183e+00, 7.3891e+00, 5.4598e+01, 2.9810e+03]) 12X=torch.arange(12,dtype=torch.float32).reshape((3,4))X tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]]) 12Y=torch.tensor([[2.0,1,4,3],[1,2,3,4],[4,3,2,1]])Y tensor([[2., 1., 4., 3.], [1., 2., 3., 4.], [4., 3., 2., 1.]]) 1torch.cat((X,Y),dim=0) tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [ 2., 1., 4., 3.], [ 1., 2., 3., 4.], [ 4., 3., 2., 1.]]) 1torch.cat((X,Y),dim=1) tensor([[ 0., 1., 2., 3., 2., 1., 4., 3.], [ 4., 5., 6., 7., 1., 2., 3., 4.], [ 8., 9., 10., 11., 4., 3., 2., 1.]]) 1X==Y,X&lt;Y (tensor([[False, True, False, True], [False, False, False, False], [False, False, False, False]]), tensor([[ True, False, True, False], [False, False, False, False], [False, False, False, False]])) 1X.sum() tensor(66.) 123a=torch.arange(6).reshape(3,2,1)b=torch.arange(2).reshape(1,2)a,b (tensor([[[0], [1]], [[2], [3]], [[4], [5]]]), tensor([[0, 1]])) 12c=a+bc tensor([[[0, 1], [1, 2]], [[2, 3], [3, 4]], [[4, 5], [5, 6]]]) 1c[0] tensor([[0, 1], [1, 2]]) 1X[-1],X[1:3] (tensor([ 8., 9., 10., 11.]), tensor([[ 4., 5., 6., 7.], [ 8., 9., 10., 11.]])) 12X[1,2]=9X tensor([[ 0., 1., 2., 3.], [ 4., 5., 9., 7.], [ 8., 9., 10., 11.]]) 12X[0:2,:]=12X tensor([[12., 12., 12., 12.], [12., 12., 12., 12.], [ 8., 9., 10., 11.]]) 123before=id(Y)Y=Y+Xid(Y)==before False 12Z=torch.zeros_like(Y)Z tensor([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) 1print('id(Z):',id(Z)) id(Z): 3055861362752 12Z[:]=X+Yprint('id(Z):',id(Z)) id(Z): 3055861362752 123before=id(X)X+=Yid(X)==before True 123A=X.numpy()B=torch.tensor(A)type(A),type(B) (numpy.ndarray, torch.Tensor) 1A,B (array([[26., 25., 28., 27.], [25., 26., 27., 28.], [20., 21., 22., 23.]], dtype=float32), tensor([[26., 25., 28., 27.], [25., 26., 27., 28.], [20., 21., 22., 23.]])) 12a=torch.tensor([3.5])a,a.item(),float(a),int(a) (tensor([3.5000]), 3.5, 3.5, 3) 123x = torch.arange(12)X=x.reshape(3,2,2)X tensor([[[ 0, 1], [ 2, 3]], [[ 4, 5], [ 6, 7]], [[ 8, 9], [10, 11]]]) 2.2 数据预处理12345678910import osos.makedirs(os.path.join('..', 'data'), exist_ok=True)data_file = os.path.join('..', 'data', 'house_tiny.csv')with open(data_file, 'w') as f: f.write('NumRooms,Alley,Price\\n') # 列名 f.write('NA,Pave,127500\\n') # 每行表示一个数据样本 f.write('2,NA,106000\\n') f.write('4,NA,178100\\n') f.write('NA,NA,140000\\n') 1234import pandas as pddata = pd.read_csv(data_file)print(data) NumRooms Alley Price 0 NaN Pave 127500 1 2.0 NaN 106000 2 4.0 NaN 178100 3 NaN NaN 140000 123inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]inputs = inputs.fillna(inputs.mean())print(inputs) NumRooms Alley 0 3.0 Pave 1 2.0 NaN 2 4.0 NaN 3 3.0 NaN 123inputs = pd.get_dummies(inputs)#inputs = pd.get_dummies(inputs, dummy_na=True)print(inputs) NumRooms Alley_Pave Alley_nan 0 3.0 1 0 1 2.0 0 1 2 4.0 0 1 3 3.0 0 1 123456import torchX = torch.tensor(inputs.to_numpy(dtype=float))y = torch.tensor(outputs.to_numpy(dtype=float))#X，y = torch.tensor(inputs.values),torch.tensor(outputs.values)X, y (tensor([[3., 1., 0.], [2., 0., 1.], [4., 0., 1.], [3., 0., 1.]], dtype=torch.float64), tensor([127500., 106000., 178100., 140000.], dtype=torch.float64)) 2.3 线性代数123456import torchx = torch.tensor(3.0)y = torch.tensor(2.0)x + y, x * y, x / y, x**y (tensor(5.), tensor(6.), tensor(1.5000), tensor(9.)) 12x=torch.arange(4)x tensor([0, 1, 2, 3]) 1x[-1] tensor(3) 1len(x) 4 1x.shape torch.Size([4]) 12A=torch.arange(20).reshape(5,4)A tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19]]) 1A.T tensor([[ 0, 4, 8, 12, 16], [ 1, 5, 9, 13, 17], [ 2, 6, 10, 14, 18], [ 3, 7, 11, 15, 19]]) 12B=torch.tensor([[1,2,3],[2,0,4],[3,4,5]])B tensor([[1, 2, 3], [2, 0, 4], [3, 4, 5]]) 1B==B.T tensor([[True, True, True], [True, True, True], [True, True, True]]) 12X=torch.arange(24).reshape(2,3,4)X tensor([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) 123A=torch.arange(20,dtype=torch.float32).reshape(5,4)B=A.clone()A,A+B (tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.], [16., 17., 18., 19.]]), tensor([[ 0., 2., 4., 6.], [ 8., 10., 12., 14.], [16., 18., 20., 22.], [24., 26., 28., 30.], [32., 34., 36., 38.]])) 1A*B tensor([[ 0., 1., 4., 9.], [ 16., 25., 36., 49.], [ 64., 81., 100., 121.], [144., 169., 196., 225.], [256., 289., 324., 361.]]) 123a=2X=torch.arange(24).reshape(2,3,4)a+X,(a*X).shape (tensor([[[ 2, 3, 4, 5], [ 6, 7, 8, 9], [10, 11, 12, 13]], [[14, 15, 16, 17], [18, 19, 20, 21], [22, 23, 24, 25]]]), torch.Size([2, 3, 4])) 12x=torch.arange(4,dtype=torch.float32)x,x.sum() (tensor([0., 1., 2., 3.]), tensor(6.)) 1A.shape,A.sum() (torch.Size([5, 4]), tensor(190.)) 12A_sum_axis0=A.sum(axis=0)A_sum_axis0,A_sum_axis0.shape (tensor([40., 45., 50., 55.]), torch.Size([4])) 12A_sum_axis1=A.sum(axis=1)A_sum_axis1,A_sum_axis1.shape (tensor([ 6., 22., 38., 54., 70.]), torch.Size([5])) 1A.sum(axis=[0,1]) tensor(190.) 1A.mean(),A.sum(),A.numel(),A.sum()/A.numel() (tensor(9.5000), tensor(190.), 20, tensor(9.5000)) 1A.mean(axis=0),A.sum(axis=0)/A.shape[0] (tensor([ 8., 9., 10., 11.]), tensor([ 8., 9., 10., 11.])) 12sum_A=A.sum(axis=1,keepdims=True)sum_A tensor([[ 6.], [22.], [38.], [54.], [70.]]) 1A / sum_A tensor([[0.0000, 0.1667, 0.3333, 0.5000], [0.1818, 0.2273, 0.2727, 0.3182], [0.2105, 0.2368, 0.2632, 0.2895], [0.2222, 0.2407, 0.2593, 0.2778], [0.2286, 0.2429, 0.2571, 0.2714]]) 1A.cumsum(axis=0) tensor([[ 0., 1., 2., 3.], [ 4., 6., 8., 10.], [12., 15., 18., 21.], [24., 28., 32., 36.], [40., 45., 50., 55.]]) 12y=torch.ones(4,dtype=torch.float32)x,y,torch.dot(x,y) (tensor([0., 1., 2., 3.]), tensor([1., 1., 1., 1.]), tensor(6.)) 1torch.sum(x*y) tensor(6.) 1A.shape,x.shape,torch.mv(A,x) (torch.Size([5, 4]), torch.Size([4]), tensor([ 14., 38., 62., 86., 110.])) 12B=torch.ones(4,3)torch.mm(A,B) tensor([[ 6., 6., 6.], [22., 22., 22.], [38., 38., 38.], [54., 54., 54.], [70., 70., 70.]]) 12u=torch.tensor([3.0,-4.0])torch.norm(u) tensor(5.) 1torch.abs(u).sum() tensor(7.) 1torch.norm(torch.ones((4,9))) tensor(6.) 12x=torch.arange(24,dtype=torch.float32).reshape((2,3,4))x,len(x) (tensor([[[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]], [[12., 13., 14., 15.], [16., 17., 18., 19.], [20., 21., 22., 23.]]]), 2) 1x.sum(axis=0),x.sum(axis=1),x.sum(axis=2) (tensor([[12., 14., 16., 18.], [20., 22., 24., 26.], [28., 30., 32., 34.]]), tensor([[12., 15., 18., 21.], [48., 51., 54., 57.]]), tensor([[ 6., 22., 38.], [54., 70., 86.]])) 12y=torch.arange(120,dtype=torch.float32).reshape(2,3,4,5)y tensor([[[[ 0., 1., 2., 3., 4.], [ 5., 6., 7., 8., 9.], [ 10., 11., 12., 13., 14.], [ 15., 16., 17., 18., 19.]], [[ 20., 21., 22., 23., 24.], [ 25., 26., 27., 28., 29.], [ 30., 31., 32., 33., 34.], [ 35., 36., 37., 38., 39.]], [[ 40., 41., 42., 43., 44.], [ 45., 46., 47., 48., 49.], [ 50., 51., 52., 53., 54.], [ 55., 56., 57., 58., 59.]]], ​​ [[[ 60., 61., 62., 63., 64.],​ [ 65., 66., 67., 68., 69.],​ [ 70., 71., 72., 73., 74.],​ [ 75., 76., 77., 78., 79.]],​​ [[ 80., 81., 82., 83., 84.],​ [ 85., 86., 87., 88., 89.],​ [ 90., 91., 92., 93., 94.],​ [ 95., 96., 97., 98., 99.]],​ [[100., 101., 102., 103., 104.], [105., 106., 107., 108., 109.], [110., 111., 112., 113., 114.], [115., 116., 117., 118., 119.]]]]) 123456z=torch.linalg.norm(y)#torch.linalg.norm函数可用于求解多轴张量的类L2范数，要求张量各元素数据类型为浮点数或者复数#z=torch.linalg.norm(input,p,dim)#input：输入张量。它的数据类型必须是浮点型或复数型。对于复数的输入，范数使用每个元素的绝对值。注意，输入张量中元素的数据类型一定得是浮点型或者是复数哦，不然就会报错！这个就是主要变化，其次是不能使用 input.norm#p：范数的阶数。默认是2阶—“fro”，也就是弗罗贝尼乌斯范数（Frobenius norm）。如果输入p=某个正整数，则求解对应的p阶范数。其公式为 sum(abs(x)**p)**(1./p)。#dim：对输入的张量计算其指定维度（如dim=1，则表示计算第二个维度）上所有元素的范数。如果不对dim进行赋值，则会计算输入张量所有维度上的范数。当然如果指定维数不在输入张量的尺寸之内，将出现错误。z tensor(754.2015) 2.4 微积分1234567891011121314import numpy as npfrom matplotlib_inline import backend_inlinefrom d2l import torch as d2ldef f(x): return 3*x**2-4*xdef numerical_lim(f,x,h): return (f(x+h)-f(x))/hh=0.1for i in range(5): print(f'h={h:.5f},numerical limit={numerical_lim(f,1,h):.5f}') h*=0.1 h=0.10000,numerical limit=2.30000 h=0.01000,numerical limit=2.03000 h=0.00100,numerical limit=2.00300 h=0.00010,numerical limit=2.00030 h=0.00001,numerical limit=2.00003 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#三个用于图形配置的函数def use_svg_display(): #@save ##@save标记可将对应函数/类/语句保存在d2l包中，以后无需定义就可以直接调用；e.g:d2l.use_svg_display() #使用svg格式在Jupyter中显示绘图 backend_inline.set_matplotlib_formats('svg')from matplotlib import pyplot as pltdef set_figsize(figsize=(3.5,2.5)): #@save #设置matplotlib的图表大小 use_svg_display() d2l.plt.rcParams['figure.figsize']=figsize #@savedef set_axes(axes,xlabel,ylabel,xlim,ylim,xscale,yscale,legend): #设置matplotlib的轴 axes.set_xlabel(xlabel) axes.set_ylabel(ylabel) axes.set_xscale(xscale) axes.set_yscale(yscale) axes.set_xlim(xlim) axes.set_ylim(ylim) if legend: axes.legend(legend) axes.grid() #plot函数：可绘制多条曲线#@savedef plot(X,Y=None,xlabel=None,ylabel=None,legend=None,xlim=None,ylim=None,xscale='linear',yscale='linear',fmts=('-','m--','g-.','r:'),figsize=(3.5,2.5),axes=None): #绘制数据点 if legend is None: legend=[] set_figsize(figsize) axes=axes if axes else d2l.plt.gca() #如果X有一个轴，输出True def has_one_axis(X): return(hasattr(X,&quot;ndim&quot;) and X.ndim==1 or isinstance(X,list) and not hasattr(X[0],&quot;__len__&quot;)) if has_one_axis(X): X=[X] if Y is None: X,Y=[[]]*len(X),X elif has_one_axis(Y): X=X*len(Y) if len(X)!=len(Y): X=X*len(Y) axes.cla() for x,y,fmt in zip(X,Y,fmts): if len(x): axes.plot(x,y,fmt) else: axes.plot(y,fmt) set_axes(axes,xlabel,ylabel,xlim,ylim,xscale,yscale,legend) 12x=np.arange(0,3,0.1)plot(x,[f(x),2*x-3],'x','f(x)',legend=['f(x)','Tangent line(x=1)']) ​​ 123def g(x): return x**3-(1/x)plot(x,[g(x),4*x-4],'x','g(x)',legend=['g(x)','Tangent line(x=1)']) F:\\user\\Temp\\ipykernel_25528\\1423519574.py:2: RuntimeWarning: divide by zero encountered in true_divide return x**3-(1/x) 2.5 自动微分1234import torchx=torch.arange(4.0)x tensor([0., 1., 2., 3.]) 12y=2*torch.dot(x,x)y tensor(28.) 12x.requires_grad_(True) #等价于x=torch.arange(4.0,requires_grad=True)x.grad #默认值为None 12y=2*torch.dot(x,x)y tensor(28., grad_fn=&lt;MulBackward0&gt;) 12y.backward()#通过调用反向传播函数自动计算y关于x每个分量的梯度x.grad tensor([ 0., 4., 8., 12.]) 1x.grad==4*x tensor([True, True, True, True]) 12345x.grad.zero_()#在默认情况下，PyTorch会累积梯度，我们需要清除之前的值y=x.sum()y.backward()x.grad tensor([1., 1., 1., 1.]) 123456#对非标量变量：不计算微分矩阵，而是单独计算批量中每个样本的偏导数之和#对[非标量]调用backward需要传入一个gradient参数，该参数指定微分函数关于self的梯度x.grad.zero_()y=x*xy.sum().backward()#等价于y.backward(torch.ones(len(x)))——传递1的梯度合适：只求偏导数的和y,x.grad (tensor([0., 1., 4., 9.], grad_fn=&lt;MulBackward0&gt;), tensor([0., 2., 4., 6.])) 1234567x.grad.zero_()y=x*xu=y.detach()#分离变量（复制副本，保留计算结果，后续处理的u不带有y除数值外的其他性质）z=u*xz.sum().backward()x.grad==u tensor([True, True, True, True]) 123x.grad.zero_()y.sum().backward()x.grad==2*x tensor([True, True, True, True]) 123456789101112131415def f(a): b=a*2 while b.norm()&lt;1000: b=b*2 if b.sum()&gt;0: c=b else: c=100*b return ca=torch.randn(size=(),requires_grad=True)d=f(a)d.backward()#注意：运行backward函数会自动清除计算图；但可通过在第一次backward中加一句retain_grad=True，即d.backward(retain_graph=True)，意思为一直保留计算图a,d,a.grad==d/a,a.grad (tensor(0.1050, requires_grad=True), tensor(1719.5204, grad_fn=&lt;MulBackward0&gt;), tensor(True), tensor(16384.)) 2.6 概率123456import torchfrom torch.distributions import multinomial#multinomial 多项分布from d2l import torch as d2lfair_probs=torch.ones([6])/6fair_probs,multinomial.Multinomial(1,fair_probs).sample() (tensor([0.1667, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667]), tensor([0., 0., 0., 0., 1., 0.])) 1multinomial.Multinomial(10,fair_probs).sample() tensor([2., 0., 1., 3., 1., 3.]) 12counts=multinomial.Multinomial(1000,fair_probs).sample()#将结果储存为float32以进行除法counts/1000#相对频率作为估计值 tensor([0.1640, 0.1610, 0.1720, 0.1730, 0.1610, 0.1690]) 1234567891011counts=multinomial.Multinomial(10,fair_probs).sample((500,))cum_counts=counts.cumsum(dim=0)#cumsum:累加函数estimates=cum_counts/cum_counts.sum(dim=1,keepdims=True)d2l.set_figsize((6,4.5))for i in range(6): d2l.plt.plot(estimates[:,i].numpy(),label=(&quot;P(die=&quot;+str(i+1)+&quot;)&quot;))d2l.plt.axhline(y=0.167,color='black',linestyle='dashed')d2l.plt.gca().set_xlabel('Groups of experiments')d2l.plt.gca().set_ylabel('Estimated probability')d2l.plt.legend(); ​​ 2.7 查阅文档12import torchprint(dir(torch.distributions)) ['AbsTransform', 'AffineTransform', 'Bernoulli', 'Beta', 'Binomial', 'CatTransform', 'Categorical', 'Cauchy', 'Chi2', 'ComposeTransform', 'ContinuousBernoulli', 'CorrCholeskyTransform', 'CumulativeDistributionTransform', 'Dirichlet', 'Distribution', 'ExpTransform', 'Exponential', 'ExponentialFamily', 'FisherSnedecor', 'Gamma', 'Geometric', 'Gumbel', 'HalfCauchy', 'HalfNormal', 'Independent', 'IndependentTransform', 'Kumaraswamy', 'LKJCholesky', 'Laplace', 'LogNormal', 'LogisticNormal', 'LowRankMultivariateNormal', 'LowerCholeskyTransform', 'MixtureSameFamily', 'Multinomial', 'MultivariateNormal', 'NegativeBinomial', 'Normal', 'OneHotCategorical', 'OneHotCategoricalStraightThrough', 'Pareto', 'Poisson', 'PowerTransform', 'RelaxedBernoulli', 'RelaxedOneHotCategorical', 'ReshapeTransform', 'SigmoidTransform', 'SoftmaxTransform', 'SoftplusTransform', 'StackTransform', 'StickBreakingTransform', 'StudentT', 'TanhTransform', 'Transform', 'TransformedDistribution', 'Uniform', 'VonMises', 'Weibull', 'Wishart', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'bernoulli', 'beta', 'biject_to', 'binomial', 'categorical', 'cauchy', 'chi2', 'constraint_registry', 'constraints', 'continuous_bernoulli', 'dirichlet', 'distribution', 'exp_family', 'exponential', 'fishersnedecor', 'gamma', 'geometric', 'gumbel', 'half_cauchy', 'half_normal', 'identity_transform', 'independent', 'kl', 'kl_divergence', 'kumaraswamy', 'laplace', 'lkj_cholesky', 'log_normal', 'logistic_normal', 'lowrank_multivariate_normal', 'mixture_same_family', 'multinomial', 'multivariate_normal', 'negative_binomial', 'normal', 'one_hot_categorical', 'pareto', 'poisson', 'register_kl', 'relaxed_bernoulli', 'relaxed_categorical', 'studentT', 'transform_to', 'transformed_distribution', 'transforms', 'uniform', 'utils', 'von_mises', 'weibull', 'wishart'] 1help(torch.ones) Help on built-in function ones in module torch: ones(...) ones(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -&gt; Tensor Returns a tensor filled with the scalar value `1`, with the shape defined by the variable argument :attr:`size`. Args: size (int...): a sequence of integers defining the shape of the output tensor. Can be a variable number of arguments or a collection like a list or tuple. Keyword arguments: out (Tensor, optional): the output tensor. dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor. Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`). layout (:class:`torch.layout`, optional): the desired layout of returned Tensor. Default: ``torch.strided``. device (:class:`torch.device`, optional): the desired device of returned tensor. Default: if ``None``, uses the current device for the default tensor type (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types. requires_grad (bool, optional): If autograd should record operations on the returned tensor. Default: ``False``. Example:: &gt;&gt;&gt; torch.ones(2, 3) tensor([[ 1., 1., 1.], [ 1., 1., 1.]]) &gt;&gt;&gt; torch.ones(5) tensor([ 1., 1., 1., 1., 1.]) ​ 1torch.ones(4) tensor([1., 1., 1., 1.]) 1? 1list? 1help(list) Help on class list in module builtins: class list(object) | list(iterable=(), /) | | Built-in mutable sequence. | | If no argument is given, the constructor creates a new empty list. | The argument must be an iterable if specified. | | Methods defined here: | | __add__(self, value, /) | Return self+value. | | __contains__(self, key, /) | Return key in self. | | __delitem__(self, key, /) | Delete self[key]. | | __eq__(self, value, /) | Return self==value. | | __ge__(self, value, /) | Return self&gt;=value. | | __getattribute__(self, name, /) | Return getattr(self, name). | | __getitem__(...) | x.__getitem__(y) &lt;==&gt; x[y] | | __gt__(self, value, /) | Return self&gt;value. | | __iadd__(self, value, /) | Implement self+=value. | | __imul__(self, value, /) | Implement self*=value. | | __init__(self, /, *args, **kwargs) | Initialize self. See help(type(self)) for accurate signature. | | __iter__(self, /) | Implement iter(self). | | __le__(self, value, /) | Return self&lt;=value. | | __len__(self, /) | Return len(self). | | __lt__(self, value, /) | Return self&lt;value. | | __mul__(self, value, /) | Return self*value. | | __ne__(self, value, /) | Return self!=value. | | __repr__(self, /) | Return repr(self). | | __reversed__(self, /) | Return a reverse iterator over the list. | | __rmul__(self, value, /) | Return value*self. | | __setitem__(self, key, value, /) | Set self[key] to value. | | __sizeof__(self, /) | Return the size of the list in memory, in bytes. | | append(self, object, /) | Append object to the end of the list. | | clear(self, /) | Remove all items from list. | | copy(self, /) | Return a shallow copy of the list. | | count(self, value, /) | Return number of occurrences of value. | | extend(self, iterable, /) | Extend list by appending elements from the iterable. | | index(self, value, start=0, stop=9223372036854775807, /) | Return first index of value. | | Raises ValueError if the value is not present. | | insert(self, index, object, /) | Insert object before index. | | pop(self, index=-1, /) | Remove and return item at index (default last). | | Raises IndexError if list is empty or index is out of range. | | remove(self, value, /) | Remove first occurrence of value. | | Raises ValueError if the value is not present. | | reverse(self, /) | Reverse *IN PLACE*. | | sort(self, /, *, key=None, reverse=False) | Sort the list in ascending order and return None. | | The sort is in-place (i.e. the list itself is modified) and stable (i.e. the | order of two equal elements is maintained). | | If a key function is given, apply it once to each list item and sort them, | ascending or descending, according to their function values. | | The reverse flag can be set to sort in descending order. | | ---------------------------------------------------------------------- | Class methods defined here: | | __class_getitem__(...) from builtins.type | See PEP 585 | | ---------------------------------------------------------------------- | Static methods defined here: | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | ---------------------------------------------------------------------- | Data and other attributes defined here: | | __hash__ = None ​ 1list??","link":"/2023/09/27/2.%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"title":"基于ROS（机器人操作系统）的数据展示系统","text":"tips:请在使用该系统前安装好相应的库文件（详见附录二），并在不同控制台分别运行roscore（ros操作系统内核）、rosbag play –loop –pause all.bag（ros数据包展示）和rosrun gmapping slam_gmapping（任务四建图处理进程） 该系统程序名为final_system，使用以下命令克隆git仓库： 1git clone https://github.com/Asgard-Tim/ROS-Coding.git 安装好相关库文件后可通过以下命令运行系统程序： 12345678910111213//项目构建cd /home/ubuntu/project/catkin_wscatkin_make//程序运行source /home/ubuntu/project/catkin_ws/devel/setup.bashcd /home/ubuntu/project/catkin_wsrosrun final_system final_system 完整代码已上传至Github平台，URL地址：Asgard-Tim/ROS-Coding: 重庆大学明月科创实验班软件设计课程作业 (github.com) Bilibili同步上传系统演示视频Demo，链接：重庆大学明月科创实验班软件设计作业–ROS数据展示系统_哔哩哔哩_bilibili 程序主要结构与算法分析在**main()**函数中： 创建ROS节点和节点句柄。 调用**initialize()**函数显示初始菜单:提示用户选择登录、注册或退出系统。 定义一个user类，用于保存用户的用户名和密码信息;根据用户选择执行不同的操作： 登录：要求用户输入用户名和密码，然后检查是否匹配存储在文件中的用户信息。 注册：要求用户输入新的用户名和密码，然后将用户信息保存到文件中。 退出系统：结束程序运行。 如果登录成功，调用**systeminitialize()**函数显示登录成功后的菜单:提示用户选择不同的数据可视化选项或退出系统。 根据用户选择执行不同的数据可视化操作： 任务一：用命令行窗口显示小车的IMU和里程计（odometry）数据 IMU数据：订阅IMU数据的ROS话题，将数据传递给回调函数callback1进行处理。 回调函数callback1，处理IMU数据： 从接收到的IMU消息中获取线性加速度和角速度信息。 使用std::cout打印出线性加速度和角速度信息。 里程计数据：订阅里程计数据的ROS话题，将数据传递给回调函数callback2进行处理。 回调函数callback2，处理里程计数据： 从接收到的里程计消息中获取位置和姿态信息。 使用std::cout打印出位置和姿态信息。 任务二：用图形界面显示颜色相机和深度相机的数据（利用OpenCV库） 颜色相机数据：订阅颜色相机数据的ROS话题，将数据传递给回调函数callback3进行处理。 回调函数callback3，处理颜色相机数据： 将接收到的彩色图像消息转换为OpenCV的图像格式。 使用OpenCV的窗口显示彩色图像。 深度相机数据：订阅深度相机数据的ROS话题，将数据传递给回调函数callback4进行处理。 回调函数callback4，处理深度相机数据： 将接收到的深度图像消息转换为OpenCV的图像格式。 使用OpenCV的窗口显示深度图像。 任务三：用图形界面显示激光雷达的点云数据（利用PCL库） 点云数据：订阅点云数据的ROS话题，将数据传递给回调函数callback5进行处理。 **pcl::visualization::CloudViewer viewer(“Cloud Viewer”);**：创建一个PCL点云可视化器。 回调函数callback5，处理点云数据： 将接收到的点云消息转换为PCL的点云格式。 使用PCL的可视化器显示点云。 任务四：自行选择一种高级算法（例如语义分割、三维重建、导航定位（SLAM）等），实现该算法（可以直接利用第三方库），将其集成到系统中 选择Gmapping算法（一个基于2D激光雷达使用RBPF（Rao-Blackwellized Particle Filters）算法完成二维栅格地图构建的SLAM算法） 占据栅格地图数据：订阅占据栅格地图数据的ROS话题，将数据传递给回调函数callback6进行处理。 回调函数callback6，处理占据栅格地图数据： 从接收到的占据栅格地图消息中获取分辨率、宽度和高度等信息。 创建一个OpenCV的图像对象，用于绘制地图。 遍历地图的每个栅格，根据栅格的值绘制不同的颜色圆点。 使用OpenCV的窗口显示地图。 各功能部分构建过程与实现效果1.系统界面（1）登录界面 （2）功能选择界面 2.各部分功能整体架构思路（以imu数据显示为例，其余任务基本一致）： （1）在运行rosbag后利用rostopic list指令查看当前开放的所有话题 （2）找到所需数据所对应的话题（如imu数据对应的是/imu/data_raw这一topic)，利用rostopic info指令查看其消息类型(如图中Type所示) （3）根据获得的消息类型（如上图Type所示应为sensor_msg/Imu),利用rosmsg show指令查看其对应的各部分数据类型 （4）根据获得的数据类型，编写对应callback函数展示对应数据 12345678910111213141516171819202122232425262728293031323334353637383940void callback1(const sensor_msgs::Imu::ConstPtr&amp; ptr){ cout &lt;&lt; &quot;std_msgs/Header header&quot; &lt;&lt; endl; cout &lt;&lt; &quot; uint32 seq: &quot; &lt;&lt; ptr-&gt;header.seq &lt;&lt; endl; cout &lt;&lt; &quot; time stamp: &quot; &lt;&lt; ptr-&gt;header.stamp &lt;&lt; endl; cout &lt;&lt; &quot; string frame_id: &quot; &lt;&lt; ptr-&gt;header.frame_id &lt;&lt; endl; cout &lt;&lt; &quot;geometry_msgs/Quaternion orientation&quot; &lt;&lt; endl; cout &lt;&lt; &quot; float64 x: &quot; &lt;&lt; ptr-&gt;orientation.x &lt;&lt; endl; cout &lt;&lt; &quot; float64 y: &quot; &lt;&lt; ptr-&gt;orientation.y &lt;&lt; endl; cout &lt;&lt; &quot; float64 z: &quot; &lt;&lt; ptr-&gt;orientation.z &lt;&lt; endl; cout &lt;&lt; &quot; float64 w: &quot; &lt;&lt; ptr-&gt;orientation.w &lt;&lt; endl; cout &lt;&lt; &quot;float64[9] orientation_covariance&quot; &lt;&lt; endl; cout &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; ptr-&gt;orientation_covariance[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;geometry_msgs/Vector3 angular_velocity&quot; &lt;&lt; endl; cout &lt;&lt; &quot; float64 x: &quot; &lt;&lt; ptr-&gt;angular_velocity.x &lt;&lt; endl; cout &lt;&lt; &quot; float64 y: &quot; &lt;&lt; ptr-&gt;angular_velocity.y &lt;&lt; endl; cout &lt;&lt; &quot; float64 z: &quot; &lt;&lt; ptr-&gt;angular_velocity.z &lt;&lt; endl; cout &lt;&lt; &quot;float64[9] angular_velocity_covariance&quot; &lt;&lt; endl; cout &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; ptr-&gt;angular_velocity_covariance[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;geometry_msgs/Vector3 linear_acceleration&quot; &lt;&lt; endl; cout &lt;&lt; &quot; float64 x: &quot; &lt;&lt; ptr-&gt;linear_acceleration.x &lt;&lt; endl; cout &lt;&lt; &quot; float64 y: &quot; &lt;&lt; ptr-&gt;linear_acceleration.y &lt;&lt; endl; cout &lt;&lt; &quot; float64 z: &quot; &lt;&lt; ptr-&gt;linear_acceleration.z &lt;&lt; endl; cout &lt;&lt; &quot;float64[9] linear_acceleration_covariance&quot; &lt;&lt; endl; cout &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; ptr-&gt;linear_acceleration_covariance[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------------------------------------------&quot; &lt;&lt; endl; return ;} （5）编写主函数程序建立订阅者节点订阅话题内容，并调用对应callback函数进行数据处理与显示 1234567ros::init(argc, argv, &quot;imu&quot;);ros::NodeHandle nodeHandle;ros::Subscriber subscriber = nodeHandle.subscribe(&quot;/imu/data_raw&quot;, 1000, callback1);ros::spin(); 注意：在任务二、三中，对应的callback函数需要分别调用opencv和pcl库，将读取的数据进行处理，以可视化图形界面的形式显示出来。 这里以任务三为例展示如何使用库文件进行数据处理并进行图形化界面显示： 123456789101112void callback5(const sensor_msgs::PointCloud2::ConstPtr&amp; msg){ pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud; // 创建一个存储PointXYZ类型点云数据的PointCloud对象，每个点有三个坐标值 pcl::PCLPointCloud2 pcl_pc; // 创建一个PCLPointCloud2对象，用于存储传感器消息中的点云数据 pcl_conversions::toPCL(*msg, pcl_pc); // 将ROS中的sensor_msgs::PointCloud2类型消息转换为PCL中的PCLPointCloud2类型 pcl::fromPCLPointCloud2(pcl_pc, cloud); // 将PCLPointCloud2类型转换为PointCloud&lt;pcl::PointXYZ&gt;类型 viewer.showCloud(cloud.makeShared()); // 在可视化窗口中显示点云数据} 最终各部分功能实现的效果图如下： （1）展示imu数据 （2）展示里程计数据 （3）展示颜色相机数据 （4）展示深度相机数据 （5）展示激光雷达点云数据 3.Gmapping建图算法的实现（1）msg数据类型查询 （2）启动Gmapping算法功能包输入如下命令： 1rosrun gmapping slam_gmapping （3）编写回调函数，利用opencv库绘制2D地图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void callback6(const nav_msgs::OccupancyGrid::ConstPtr&amp; ptr){ std::cout &lt;&lt; &quot;resolution: &quot; &lt;&lt; ptr-&gt;info.resolution &lt;&lt; std::endl; std::cout &lt;&lt; &quot;width: &quot; &lt;&lt; ptr-&gt;info.width &lt;&lt; std::endl; std::cout &lt;&lt; &quot;height: &quot; &lt;&lt; ptr-&gt;info.height &lt;&lt; std::endl; double scale = 1.0; int width = 1200; int height = 1200; cv::Point offset(-1600, -1600); cv::Mat map = cv::Mat::zeros(cv::Size(width, height), CV_8UC3); for (int i = 0; i &lt; ptr-&gt;info.width * ptr-&gt;info.height; ++i) { int x = (i % ptr-&gt;info.width + offset.x) * scale, y = (i / ptr-&gt;info.width + offset.y) * scale; if (ptr-&gt;data[i] == -1) { cv::circle(map, cv::Point(x, y), 1, cv::Scalar(255, 255, 255), -1); } else if (ptr-&gt;data[i] &gt;= 80) { cv::circle(map, cv::Point(x, y), 3, cv::Scalar(0, 0, 0), -1); } else { cv::circle(map, cv::Point(x, y), 3, cv::Scalar(0, 255, 0), -1); } } cv::imshow(&quot;map&quot;, map); cv::waitKey(1000); return ;} （4）建立节点并订阅/map话题，调用回调函数1234ros::init(argc, argv, &quot;show_map&quot;);ros::NodeHandle nodeHandle;ros::Subscriber subscriber = nodeHandle.subscribe(&quot;/map&quot;, 1000, callback6);ros::spin(); （5）建图结果 附录一：必要的库文件和头文件： ****：用于输入输出操作。 ****：用于文件读写操作。 ****：用于处理字符串。 ****：用于时间相关操作。 ****：用于格式化输出。 **”ros/ros.h”**：ROS的主要头文件。 **”sensor_msgs/Imu.h”**：ROS中IMU（惯性测量单元）数据的消息类型。 **”nav_msgs/Odometry.h”**：ROS中里程计数据的消息类型。 ****：用于C风格字符串操作。 **&lt;opencv2/opencv.hpp&gt;**：OpenCV库的头文件。 **”cv_bridge/cv_bridge.h”**：ROS中用于将ROS图像消息转换为OpenCV图像格式的库。 **”image_transport/image_transport.h”**：ROS中用于图像传输的库。 ****：用于内存管理。 **”pcl/visualization/cloud_viewer.h”**：PCL（点云库）中用于可视化点云的类。 **”pcl_conversions/pcl_conversions.h”**：PCL与ROS消息类型转换的库。 **”pcl/point_types.h”**：定义了PCL中常用的点类型。 **”pcl/PCLPointCloud2.h”**：PCL中点云数据的消息类型。 **”pcl/conversions.h”**：PCL与ROS消息类型转换的库。 **”pcl_ros/transforms.h”**：PCL中点云坐标系变换的库。 **”nav_msgs/OccupancyGrid.h”**：ROS中占据栅格地图数据的消息类型。 附录二：安装各库文件的命令 sudo apt-get update 123452. 更新包管理器的软件包列表。3. ``` sudo apt-get upgrade 升级系统中的所有已安装软件包。 sudo apt-get install libopencv-dev 123456. 安装OpenCV库的开发文件。7. ``` sudo apt-get install libopencv-contrib-dev 安装OpenCV贡献模块的开发文件。 sudo apt-get update 1234510. 再次更新包管理器的软件包列表。11. ``` sudo apt-get install libproj-dev 安装Proj库的开发文件，Proj库提供了地理投影转换的功能。 sudo apt-get install libpcl-dev 1234514. 安装PCL（Point Cloud Library）库的开发文件，PCL库用于点云数据处理和分析。15. ``` sudo apt-get install libsdl1.2-dev 安装SDL 1.2库的开发文件，SDL库用于创建图形用户界面和处理多媒体。 sudo apt install libsdl-image1.2-dev 1234518. 安装SDL_image 1.2库的开发文件，SDL_image库提供了图像处理功能。19. ``` sudo apt-get install ros-kinetic-gmapping 安装ROS Kinetic版本中的gmapping软件包，gmapping是用于构建占据栅格地图的SLAM算法。 sudo apt-get install ros-kinetic-slam-gmapping 安装ROS Kinetic版本中的slam_gmapping软件包，slam_gmapping提供了用于构建占据栅格地图的SLAM算法。","link":"/2023/07/02/ROS%20Task/"},{"title":"QQ聊天机器人(接入ChatGPT)","text":"更新记录 V1.0 成功搭建QQ机器人，接入ChatGPT的API 机器人QQ号：2641924697 可以选择与机器人私聊或者在群中@机器人进行提问（tips:在群聊中@机器人提问时，转发消息中的@无效） 提问时直接输入想要提问的问题即可 V1.1 新增功能： 聊天过程机器人可以联系上下文作出回答 用户发送“再见”时或累计发送词数超过1024时自动清除聊天记录（之前发送的消息无法在之后的提问中进行复现） 漏洞修复： 修复了无法识别提问信息中“+”符号的bug 项目搭建过程 想法来源事实上，在ChatGPT的整体使用过程中，对于稳定的科学上网渠道始终有着一定的要求，一些客观因素日益严苛的限制条件使得使用的体验与便捷度并不尽如人意。基于这样的考量，同时也是受到软件设计老师提供的公用ChatGPT对话脚本（现已无法使用）的启发，决定基于python并利用网上开源的go-cqhttp和OpenAI官网提供的API接口使用方法例程等资源搭建QQ端的接口，使得更多人能够更加便捷地享受这一空前的语言模型带来的巨大红利。 具体实施在利用ChatGPT进行咨询学习的过程中，我也意识到网页端ChatGPT使用的繁琐与不稳定，同时其使用也具有一定的门槛。虽然随着API的开放，国内也有很多镜像资源以及免费的平台可以实现与AI的交流，但对于大多数人来说，许多黑心商家利用ChatGPT外接套壳赚钱的现状还是让大家对于ChatGPT望而生畏。对于我个人而言，也是为了让自己能够更加便捷地与ChatGPT沟通进行学习，希望通过python脚本，利用QQ平台搭建机器人接通ChatGPT的API，以实现与ChatGPT更加快捷方便的沟通，并进一步方便更多的人。 整体架构搭建思路如下图所示。 获取API-KEY由于本人的账号没有免费额度，特地从淘宝购入了大额度的api-key（实测可用）以进行进一步的搭建。 Django服务端接口的搭建结合OpenAI官网提供的接入api-key的相关代码样例，完成了这一部分的搭建，通过运行manage.py服务器脚本，实现了在全局代理的前提下利用api-key通过本地8000端口与ChatGPT实现通信。 接入noneBot机器人聊天逻辑借助现成的noneBot机器人聊天逻辑框架，将其接入上述已连接ChatGPT API服务的Django服务器端口实现机器人进一步构建；运行bot.py脚本即可打开聊天机器人终端。 利用go-cqhttp工具连接QQ借助开源的go-cqhttp程序工具，实现QQ账号的登入并接入以上利用noneBot创建的机器人，即可将ChatGPT语言模型顺利接入该QQ账号，并使用其他QQ账号通过该账号与ChatGPT实现沟通。 下图是与我们接入的聊天机器人进行沟通的部分聊天记录。 迭代与优化通过上述流程，基本完成了接入ChatGPT的QQ聊天机器人的架构。在接入完成后，第一时间邀请了部分同学通过与机器人交流进行实际测试，反馈出了如下问题，并在当前的发行版本中予以修正。 该项目代码已在github中开源，并将根据进一步的测试结果不断迭代更新。 仓库地址：Asgard-Tim/ChatGPT-QQBOT: 重庆大学明月科创实验班个性化实践 (github.com) 提问关键词限制问题出于安全性以及防止误操作等考量，在noneBot机器人聊天逻辑设置时，我们特地设置了需要通过在问题前键入关键字“ChatGPT”才能对于机器人进行提问，否则会提示“命令格式错误”；但在实际使用中，我们发现每次都需要进行这样的额外键入无疑给沟通带来了不必要的麻烦，并最终对于机器人聊天逻辑部分__init__.py内的代码进行了修改，删去了额外键入关键词的限制，可以直接对机器人进行提问。 联系上下文问题在测试过程中，部分用户反馈，该机器人无法像正常的人类一样联系聊天过程中的上下文给出回答。针对这一问题，对代码进行修改，储存用于每一次问和答得记录并在下一次提问时一并向服务器发送，从而实现该功能。但是，这样的方式无疑加剧了服务器的处理压力，一旦累积的消息记录过多，会对机器人的回答效率造成很大影响，且对于接入账户的额度消耗较大。目前联系上下文功能已经实装，在消息记录达到一定数量后清空从而保证回答效率，但仍需进一步优化。 漏洞修复：“+”号的识别在实际测试中，部分用户将运算式输入聊天框，希望通过ChatGPT得到正确的计算结果。但由于对于输入信息的编码存在漏洞，导致输入信息中的“+”号无法被识别并传输到服务器端发送给ChatGPT，从而输出了错误的结果。结合跟网页版ChatGPT的沟通学习后，修改了对应部分的代码，成功在noneBot聊天逻辑中改变了输入信息的编码方式，使得“+”号得以保留从而得到正确结果。 0730更新新问题：无法正确识别消息换行之后的左右内容（待修正） 未来规划 机器人持续优化未来打算将机器人推广到更大的测试范围，让更多的朋友能够便捷地用上ChatGPT进行交流学习，因此需要在输入信息处理等方面进行进一步的规范与优化以提高效率。短期内的优化目标是将不同QQ好友的信息分开在不同的服务器端口进行处理与储存，并设置一定的安全防护措施（如用户密码等）。 机器人远程部署要实现QQ机器人的长期在线，目前还需要在本地电脑上运行脚本才能实现整体的构建以及与QQ客户端的连接；为减轻本地内存压力，计划将优化后的机器人放置至远程服务器中运行从而持续稳定地提供接入ChatGPT的聊天服务。 嵌入硬件实体目前的聊天机器人仅仅是建立在QQ客户端上的，而在实际的运用当中ChatGPT可以在更为广泛的人机交互层面得到运用。因此，可以借助ChatGPT提供的现成模型，将聊天机器人接入硬件层面的机器人或产品实体中，从而进一步提升交互性与趣味性，增加附加值。 训练并使用自己的模型事实上，在OpenAI的官方文档中，还给出了根据自身需求投喂数据样本进行训练的方法与对应代码。在未来的产品中，如果我们需要嵌入聊天机器人，可以通过这样的方式训练更加个性化与更具针对性的模型，根据不同的产品需求定制自己的接口与聊天机器人，使其更加灵活自然。","link":"/2023/06/27/chatbot/"},{"title":"小车路径规划","text":"本项目全部代码已同步上传至Github,仓库链接：Asgard-Tim/Path-Planning: 重庆大学明月科创实验班定量工程设计方法课程项目 (github.com) 一、设计要求 在本部分的课程项目中，要求我们运用LD14雷达扫描地图，在MATLAB中进行人工势场添加并对STM32小车进行路径规划，在一规定的场地中让小车避开两个矩形障碍物并以尽可能短的路径最终抵达圆形目标位置。 二、系统方案 2.1 移动底盘分析小车为履带式小车，左右履带分别由一枚直流电机进行驱动，运动模式类似常规双轮小车，通过左右两枚电机转动的差速实现转向。该小车相对来说较为容易进行控制，只需要控制两个驱动轮的速度存在差异，即两轮差速，即可控制机器人实现无滑动摩擦的旋转，也可实现零半径转弯。 图2-1 双轮履带小车外观图 图2-2 两轮差速式机器人运动学分析图 对小车移动底盘的运动学分析（如上图2-2所示）： 小车的速度控制主要是控制 X 轴（前后方向）和 Z 轴（旋转方向）的速度， 以 Vx 和 Vz 来指代，单位分别是 m/s 和弧度/s。X 轴方向以前进记为正，Z 轴方向以右转记为正。车轮速度是使用编码器来计算和得出，读取编码器计数后再转化成车轮的速度。Vz则是通过左右电机转动的差速计算得到的。 图中参数分别代表： 2.2 电机特性分析在本次项目中，我们采用带有减速器与编码器的直流电机驱动小车前进。 直流电机的物理模型图如下图2-3所示。其中，固定部分有磁铁，这里称作主磁极；固定部分还有电刷。转动部分有环形铁心和绕在环形铁心上的绕组。 (其中 2 个小圆圈是为了方便表示该位置上的导体电势或电流的方向而设置的) 它的固定部分（定子）上，装设了一对直流励磁的静止的主磁极 N 和S，在旋转部分（转子）上装设电枢铁心。在电枢铁心上放置了两根导体连成的电枢线圈， 线圈的首端和末端分别连到两个圆弧形的铜片上，此铜片称为换向片。换向片之间 互相绝缘，由换向片构成的整体称为换向器。换向器固定在转轴上，换向片与转轴 之间亦互相绝缘。在换向片上放置着一对固定不动的电刷 B1 和 B2，当电枢旋转时，电枢线圈通过换向片和电刷与外电路接通。在电刷上施加直流电压 U,电枢线圈中的电流流向为：N 极下的有效边中的电流总是一个方向，而 S 极下的有效边中的电流总是另一个方向。这样两个有效边所受的洛伦兹力的方向一致（可以根据左手法则判定），电枢开始转动。具体来说就是，把上图中的+和-分别接到电池的正极和负极，电机即可转动；如果是把上图中的+和-分别接到电池的负极和正极，则电机会反方向转动。电机的转速可以理解为和外接的电压是正相关的（实际是由电枢电流决定）。 总而言之，如果我们可以调节施加在电机上面的直流电压大小，即可实现直流 电机调速，改变施加电机上面直流电压的极性，即可实现电机换向。 图2-3 直流电机的物理模型 在具体的使用过程中，我们需要通过在特定的引脚之间（如本次项目所用电机为1/6引脚）接上一个直流电源，电机即可转动，且改变电压大小即可改变电机转速。接线方式说明如下图2-4所示。 2.3 电机控制策略以及PID特性分析小车电机驱动器芯片使用 AT8236，具有过流保护功能，并可设置电流阈值。驱动芯片只需两个逻辑输入，便可达到调速和正反转的功能，本小车中，每个电机使用两路PWM进行调速（实际上一个普通 IO 和一路 PWM 即可进行正反转 和调速）。 电机的速度使用 13 线霍尔编码器输出 AB 相进行测量，电机减速比为 1:30，使用 STM32 的编码器测量功能，并初始化为脉冲上升沿和下降沿都进行计数，可实现轮子转一圈输出 1560 个计数。 电机调速框图如下图2-5所示。 图2-5 电机调速框图 基于2.1节提到的小车移动地盘的运动学分析，我们可以进一步讨论这些物理量之间的关系，并求出其运动学正逆解公式（如下图2-6），结合PID实现控制。 图2-6 两轮差速式机器人的运动学正逆解公式 下图2-7为PID的控制框图，每个方块代表控制系统的一个组成部分，从图中可看出系统中各组成部分的相互关系和影响，即 PID 调节系统是具有被调参数负反馈的闭环系统。当被控量 Y 受到干扰的影响而升高时，反馈信号将高于给定值 X，经过比较而到放大元件去的偏差信号 e 将为负值，控制器将发出信号而使执行元件动作，其作用方向为负，使被控量下降，这就达到了自动控制的目的。 图2-7中的目标速度一般我们可以通过按键或者开关等方式编程实现改变目标值，测量速度就是通过单片机定时去采集编码器的数据并清零。目标速度和测量速度之间做差这个就是目前系统的偏差。在控制过程中，需要将目标速度、测量速度与偏差三者送入 PID 控制器进行计算输出，然后再经过电机驱动的功率放大控制电机的转动去减小偏差，最终达到目标速度。 图2-7 PID控制框图 对于上述PID控制的基于C语言的实现，我们给出以下代码： 1234567891011121314151617`int Incremental_PI (int Encoder,int Target)` `{` `static float Bias,Pwm,Last_bias;` `Bias=Encoder-Target; //计算偏差` `Pwm+=Velocity_KP*(Bias-Last_bias)+Velocity_KI*Bias;` `//增量式 PI 控制器` `Last_bias=Bias; //保存上一次偏差` `return Pwm; //增量输出` `}` 其中，入口参数为编码器的速度测量值和速度控制的目标值，返回值为电机控制 PWM。第一行是相关内部变量的定义。第二行是求出速度偏差，由测量值减去目标值。第三行使用增量 PI 控制器求出电机 PWM。第四行保存上一次偏差，便于下次调用。最后一行是返回。 2.4 嵌入式控制系统总结分析总体而言，我们基于小车本身的轮距等基本参数编写了一整套嵌入式PID控制流程与系统（基于C语言，面向STM32编程），结合PWM波控制电压，从而控制电机的转速以实现对于车轮速度的反馈调节机制，能够保证小车始终保持相对稳定的速度前进，便于后面进一步规划算法，使小车的运动更加可控。此部分编写的KEIL工程详见附件“PID.zip”。 2.5 传感系统总结分析本次项目所采用的传感器主要为激光雷达，在此我们选用LD14雷达。LD14 主要由激光测距核心，无线传电单元，无线通讯单元，角度测量单元、电机驱动单元和机械外壳组成。LD14测距核心采用三角测量法技术，可进行每秒 2300 次的测距。每次测距时，LD14从一个固定的角度发射出红外激光，激光遇到目标物体后被反射到接收单元。通过激光、目标物体、接收单元形成的三角关系，从而解算出距离。获取到距离数据后，LD14 会融合角度测量单元测量到的角度值组成点云数据，再进行导出。 雷达扫描点云数据形式如下图2-8所示： 图2-8 雷达扫描点云极坐标数据形式（下图2数据为角度（角度制），右侧为距离） 在项目的实践过程中，我们需要通过对STM32单片机进行编程，从激光雷达读取数据并通过串口将处理后的数据传输至电脑中（用特定的软件读取串口输出信息）。STM32中烧录的KEIL工程见附件“Lidar.zip”，接线方式如下图所示。 图2-9 激光雷达与单片机接线方式对应 这里给出KEIL工程中main.c中的主干代码（图2-10），最终会输出数据θ和r,分别代表偏转的角度（AvoidData[i].angle）和距离原点的距离（AvoidData[i].distance）。 图2-10 读取激光雷达数据的主干代码 三、硬件电路设计 主要运用模块电路图如下图3-1所示： 图3-1 主要模块电路图 其中，小车的主控为STM32 F103RCT6芯片，其主控板实物图如下图3-2所示： 图3-2 STM32主控板实物图 由于本次项目需要完成的目标较为单一，仅使用其中少部分接口和器件。 四、软件算法设计 4.1 任务描述在本项目中，我们需要通过激光雷达对于小车所处的地图环境（2m*2m，放置有三个正方体障碍物与一个圆柱体目标物）进行扫描，并对扫描得到的数据结果进行处理。通过一定的算法对于目标物与障碍物进行识别后，我们还需要通过人工势场法进行路径规划，使得小车能够以最优的路径绕开障碍物到达目标物。 本次项目任务分为静态和动态两个部分，其中动态测试过程中会对障碍物的位置进行人为的随机改动。测试过程中，小车的起点位置与目标物的位置始终不变，且可自由选定小车的初始面对方向。 4.2 技术路径和策略通过对于任务描述的分析，我们大致可以将静态情况下的路径规划问题拆解为以下几个部分，并给出相应的处理工具与解决策略： （1） 地图扫描：需要通过对STM32单片机进行编程（利用软件工具KEIL），利用串口通信读取激光雷达扫描所获取的周围地图环境点云的极坐标数据 （2） 处理数据：将串口所得到的数据导入MATLAB中，利用坐标变换将不同点位扫描的极坐标数据统一到同一个笛卡尔坐标系中以便后续处理与识别 （3） 识别物体：在获取扫描后得到的地图后，需要利用RANSAC算法（随机抽样一致算法）识别点云数据中的直线与圆形，并得到相应的障碍物与目标物的二维坐标 （4） 路径规划：在MATLAB中编程，利用得到的出发点、障碍物和目标点各自的坐标建立势场，并用梯度下降法寻找避开障碍物、到达目标点的最优路径 实际上，在动态情况下的路径规划问题中，实现的步骤也与上述大致相同，只是并没有MABLAB等电脑端的辅助软件帮助其进行数据处理与路径规划，需要将这些算法通过对STM32单片机编程集成到小车上，从而实现在测试地图环境随机发生改变的情况下仍然能够按照局部最优的路线避开障碍物到达目标点。 4.3 核心程序逻辑4.3.1 激光雷达极坐标点云数据的处理与变换——得到二维地图在2.5节，我们给出了我们的KEIL工程。通过将其烧入至STM32内，并按照特定接线方式将激光雷达与主控板连接，利用串口通信及相关软件成功在电脑上读取了激光雷达扫描得到的点云极坐标数据（如图2-8右图）。在实际测试时，我们选取了五个坐标点分别放置小车（控制朝向相同）对周围地图环境进行扫描，获得了“data1.txt”等一系列数据文件（详见附件）。 在MATLAB程序的第一部分，我们首先利用importdata函数从数据文本文件中读取相应数据，并将其按列分割为“angle”和“distance”两部分。随后，我们利用MATLAB中自带的坐标变换函数pol2cart将一系列的极坐标数据转换为笛卡尔坐标系下的x-y数据（算法原理如下图4-1）。事实上，由于小车每次扫描的位置均不同，因此还需要将多次扫描的结果结合每次小车放置位置的坐标进行一系列的拼接与变换，才可得到最终的场地二维地图（效果如下图4-2）。 图4-1 利用pol2cart函数进行坐标变换的原理示意图 图4-2 经拼接后得到的场地二维地图 该部分的代码给出如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465`%Step1:处理激光雷达扫描数据，绘制二维坐标系地图``ans=importdata(&quot;data1.txt&quot;);``angle=ans(:,1);``angle=angle.*2.*3.1415926./360;``distance=ans(:,2);``[x,y] = pol2cart(angle,distance);``ans1=importdata(&quot;data2.txt&quot;);``angle1=ans1(:,1);``angle1=angle1.*2.*3.1415926./360;``distance1=ans1(:,2);``[x1,y1] = pol2cart(angle1,distance1);``ans2=importdata(&quot;data3.txt&quot;);``angle2=ans2(:,1);``angle2=angle2.*2.*3.1415926./360;``distance2=ans2(:,2);``[x2,y2] = pol2cart(angle2,distance2);``ans3=importdata(&quot;data4.txt&quot;);``angle3=ans3(:,1);``angle3=angle3.*2.*3.1415926./360;``distance3=ans3(:,2);``[x3,y3] = pol2cart(angle3,distance3);``ans5=importdata(&quot;data5.txt&quot;);``angle5=ans5(:,1);``angle5=angle5.*2.*3.1415926./360;``distance5=ans5(:,2);``[x5,y5] = pol2cart(angle5,distance5);``x4 = [x;x1-100;x2+1850;x3+1400;x5+1500]/100;``y4 = [y;y1+1750;y2+100;y3+1650;y5+1000]/100;``figure(1);``scatter(x4,y4,1);``hold on``axis equal``axis( [ -3, 22, -3, 22 ] )` 4.3.2 利用RANSAC算法识别地图中的直线和圆——获得目标点与障碍物的坐标在成功利用激光雷达的扫描数据建立了二维地图后，我们需要让机器人知道哪里能走哪里不能走，要走向哪里，即明确目标点以及障碍物的具体坐标。在本测试项目中，设定圆柱为目标物而正方体为障碍物，所以问题的关键即为如何从二维地图中识别出圆形以及正方形（本质上为直线的拼接）并获得其坐标。 在之前的课程中，介绍了RANSAC这一算法。随机样本一致性(Random Sample Consensus RANSAC) 是一种迭代方法，用于从包含异常值的观察数据中估计出数学模型参数，因此也可以理解为一种异常值检测方法。RANSAC的一个基本假设是，数据由内点(“inliers”)和外点(“outliers”)组成，其中内点是在一定误差范围内可以通过一些模型参数来解释的数据，外点是不符合模型的数据。RANSAC的另一个假设是，随机选取的样本数据都是内点，存在一个可以估计模型参数的过程，该模型可以最佳地解释或拟合该数据。通过该算法，我们可以有效地从已有的地图（本质上是二维坐标系下的点集数据）中拟合出直线与圆的轮廓，并获取相应图形的对应坐标。 该算法的实现步骤如下： （1） 从原始数据集S中随机选择子集s，s为假设的内点(子集s一般为最小子集，如：直线选取两个点，圆选择三个点) （2） 依据子集s估计模型参数 （3） 遍历数据集S中除子集s外的所有数据，如果数据点在给定误差e以内，则标记为内点，否则标记为外点 （4）所有内点组成一致集，如果一致集中点的个数满足给定阈值T，则用一致集中所有内点重新估计模型参数，然后结束算法 （5）如果一致集中内点个数少于阈值T，则重新选择新的子集s，并重复步骤（1）-（4） （6） 经过K次迭代，选择一个内点数量最多的一致集，用一致集中所有内点重新估计模型参数，然后结束算法 基于上述基本思想与步骤，我们编写了一段MATLAB代码，用于二维坐标地图中直线的识别与拟合。在此基础之上，我们根据算法原理，从点集中随机取出三个点，利用三点成圆获得圆的方程（利用自己编写的函数ThreePoint2Circle）。再对圆的轨迹赋予一个宽度，统计落入这个宽度中的点的数量，对所有的点进行逐个取点，获得最优的圆的方程。值得注意的是，由于待识别的正方形是由多条直边构成，这要求我们需要重复对于该图像进行扫描拟合，且需要在一次拟合之后将该次拟合中涉及的数据点删除以防影响下次拟合。下面将给出这一部分的代码实现以及拟合效果（如图4-3、4-4）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257`%Step2:利用RANSAC算法识别直线和圆``%(1)圆的识别``a = [x4,y4];``% RANSCA参数：``% 迭代次数``iter = 0;``% 查看圆数据的大小``[m,n] = size(a);``% 误差参数``berr = 0.02;``% 拟合参数``bfit = [];``% 内点个数为点数的1/3``t = floor(m/3);``% 开始循环迭代``while iter&lt;100` `% 随机挑选三个点，三个点不重复` `% 拟合圆最少需要三个点，拟合直线最少需要两个` `% ran为索引编号` `ran = randperm(m,3)';` `% b为索引得到的点` `b = a(ran,:);` `% 根据随机得到的三个点，计算圆的半径和圆心` `[r1,p1] = ThreePoint2Circle(b(1,1:2), b(2,1:2), b(3,1:2));` `% 选择除了随机得到的三个点外的其他点` `c = setdiff(a,b,&quot;rows&quot;);` `% 计算每个点到圆心的距离dis` `dis = sqrt(sum((c(:,1:2)-p1).^2,2));` `% 计算 dis和拟合圆的误差` `res = dis - r1;` `% 选择小于误差的点，进入到内点中` `d = c(res&lt;berr,:);` `len = length(d(:,1));` `% 判断内点数量是否满足条件` `if len &gt; t`​ `% 满足条件时，多点拟合圆，这里用平均值计算圆心`​ `p = mean(d);`​ `r = mean(sqrt(sum((d(:,1:2)-p(:,1:2)).^2,2)));`​ `% 多点拟合的圆和随机点拟合的圆的误差`​ `err = sqrt(sum((p-p1).^2))+sqrt((r-r1)^2);`​ `% 如果误差满足条件，则可以结束循环`​ `% 不满足则继续`​ `if err &lt; berr`​ `bfit = [p,r];`​ `berr = err;`​ `break`​ `else`​ `iter = iter+1;`​ `continue`​ `end` `else`​ `iter = iter+1;` `end``end``%绘图``para = [p(1)-r, p(2)-r, 2*r, 2*r];``rectangle('Position', para, 'Curvature', [1 1]);` `%（2）直线的识别``iter = 100;``data1=transpose(x4);``data2=transpose(y4);``data=[data1;data2];``for t=1:10` `number = size(data,2); % 总点数` `bestParameter1=0; bestParameter2=0; % 最佳匹配的参数` `sigma = 1;` `pretotal=0; %符合拟合模型的数据的个数` `for i=1:iter` `%随机选择两个点` `idx = randperm(number,2);` `sample = data(:,idx);` `%拟合直线方程 y=kx+b` `line = zeros(1,3);` `x = sample(:, 1);` `y = sample(:, 2);` `k=(y(1)-y(2))/(x(1)-x(2)); %直线斜率` `b = y(1) - k*x(1);` `line = [k -1 b];` `mask=abs(line*[data; ones(1,size(data,2))]); %求每个数据到拟合直线的距离` `total=sum(mask&lt;sigma); %计算数据距离直线小于一定阈值的数据的个数` `if total&gt;pretotal %找到符合拟合直线数据最多的拟合直线`​ `pretotal=total;`​ `bestline=line; %找到最好的拟合直线` `end` `end``%显示符合最佳拟合的数据` `mask=abs(bestline*[data; ones(1,size(data,2))])&lt;sigma;` `hold on;` `k=1;` `index=[];` `for i=1:length(mask)` `if mask(i)`​ `inliers(1,k) = data(1,i);`​ `k=k+1;`​ `index=[index i];` `end` `end` `%删除完成拟合的点以进行下一次拟合` `for i=1:length(index)` `data(:,index(i))=[];` `for j=1:length(index)`​ `if(index(j)&gt;index(i))`​ `index(j)=index(j)-1;`​ `end` `end` `end` `% 绘制最佳匹配曲线` `bestParameter1 = -bestline(1)/bestline(2);` `bestParameter2 = -bestline(3)/bestline(2);` `xAxis = min(inliers(1,:)):max(inliers(1,:));` `yAxis = bestParameter1*xAxis + bestParameter2;` `plot(xAxis,yAxis,'r-','LineWidth',2);``end``function [R,P0] = ThreePoint2Circle(P1, P2, P3)``%% 求圆心和半径，三个点可以求圆心和半径` `x1 = P1(1); x2 = P2(1); x3 = P3(1);` `y1 = P1(2); y2 = P2(2); y3 = P3(2);` `z1 = x2^2 + y2^2 - x1^2 - y1^2;` `z2 = x3^2 + y3^2 - x1^2 - y1^2;` `z3 = x3^2 + y3^2 - x2^2 - y2^2;` `A = [(x2-x1), (y2-y1); (x3-x1), (y3-y1); (x3-x2), (y3-y2)];` `B = 0.5*[z1; z2; z3];` `P0 = (A'*A)\\A'*B;` `R1 = sqrt( (P0(1) - P1(1))^2 + (P0(2) - P1(2))^2 );` `R2 = sqrt( (P0(1) - P2(1))^2 + (P0(2) - P2(2))^2 );` `R3 = sqrt( (P0(1) - P3(1))^2 + (P0(2) - P3(2))^2 );` `R = (R1 + R2 + R3)/3;` `P0 = P0';``End` 图4-3（上） 对于二维地图中一条直线的拟合（红线为拟合结果） （可以看到拟合效果相对良好） 图4-4（右） 对于给定圆坐标数据的RANSAC拟合（上图为给定的圆，下图为拟合出的圆） （说明该算法实现的有效性） 4.3.3 建立势场并利用梯度下降法确定最优路径（人工势场法）人工势场法引入了物理中斥力场和引力场的思想，把工作环境抽象为一个电磁场，而机器人则是其中的一个电荷，机器人在磁场力的作用下移动。人工势场法会在障碍物周围构建斥力场、在目标点周围构建引力场；这样，机器人便能够在斥力场和引力场的作用下向目标点移动。同时，当障碍物和目标点太近时，机器人很可能会因为刹不住车而出现无法到达目标点等问题，这也就出现了一堆相应的优化算法。 通过利用RANSAC算法对于地图中具有特定形状的边界、障碍物与目标物进行识别，我们成功获得了障碍物与目标点的坐标。在此基础之上，我们基于原型函数（a,b即为障碍物/目标点的x,y坐标）建立势场。通过观察不难发现，在以（a,b）为圆心、半径为1的圆之外的地方该势函数均为正，反之为负。事实上，对于场地内的3个障碍物以及1个目标物而言，所形成的是一个叠加场，由原型函数作用于不同的点叠加而成。在此，我们不妨认为势场为正处具有排斥力而势场为负处具有吸引力，需要吸引小车向目标点走去而花费尽量少的能量。在这样的算法理念基础上，我们需要在代表目标点的原型函数部分加上负号；更进一步的，我们还希望这个吸引力足够大而防止被障碍物阻断，因此在建立势场时，不妨在代表目标点的原型函数前乘上一定的系数以保证其足够强大的吸引力。最终，我们根据地图实际情况，建立了整个势场叠加后的函数方程：F=log(sqrt((x-4.75).^2+(y-12.5).^2))+log(sqrt((x-12).^2+(y-7.6).^2))+log(sqrt((x-11.2).^2+(y-13).^2))-5*log(sqrt((x-16.5).^2+(y-18.5).^2))，并根据该函数绘制了势能图（如图4-5）与等势线图（如图4-6)。 图4-5 势场函数势能图 图4-6 势场函数等势线图 该部分代码如下： 123456789101112131415161718192021`%Step3:通过识别得到的障碍物和目标坐标建立势场``v=-2:1:22;``[x,y]=meshgrid(v);``F=log(sqrt((x-4.75).^2+(y-12.5).^2))+log(sqrt((x-12).^2+(y-7.6).^2))+log(sqrt((x-11.2).^2+(y-13).^2))-5*log(sqrt((x-16.5).^2+(y-18.5).^2));``[px,py]=gradient(F,1,1);``contour(x,y,F);``hold on;``title('人工势场法路径规划');``quiver(x,y,px,py,0);``figure(2);``surf(x,y,-F);` 在建立完势场之后，由于我们需要寻找的是避开障碍物而通往目标点的最优路径，实际上即为所耗费能量最少的路径，我们引入了梯度下降法，通过间隔相同距离的不断迭代，在每一处都寻找能量下降最快的方向（即为梯度方向）前进（在MATLAB中通过调用函数文件path_plan.m与computP.m实现该功能），最终得到了如下图4-7绿色线所示的最优路径。 图4-7 人工势场法路径规划结果（绿色即为规划出的最优路径） 其中，path_plan函数是整个算法过程中的关键，也是梯度下降思想的集中体现，其大致实现思路流程如下： 1）起点、终点 、障碍物、迭代次数、取点半径等参数的设定 2）以起点为中心，作半径为r的圆，从圆上取八个均布的点 3）分别计算八个点的前进“代价”—— 终点对其的引力+所有障碍物对其的斥力 4）取“代价”最小的点的坐标，结合现有起点，计算得到新的起点，然后重复上述内容 5）当发现 一个点距离终点很近 or 迭代的次数计算完 程序停止。 该部分的实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899`%Step4:通过人工势场法确定最优路径``axis([-3 22 -3 22]);``begin=[0;0]%起始点坐标``over=[16.5;18.5];%目标点坐标``figure(1);``hold on;``plot(begin(1),begin(2),'*b','MarkerSize',10);``plot(over(1),over(2),'*b','MarkerSize',10);``obstacle=[4.75,12,11.35;12.75,7.5,12];%障碍物坐标``point= path_plan(begin,over,obstacle);``function [ point ] = path_plan(begin,over,obstacle)``iters=1; %迭代次数``curr=begin;``testR=0.1; %测试8点的圆的半径为0.1``while (norm(curr-over)&gt;0.2) &amp;&amp; (iters&lt;=2000)` `point(:,iters)=curr;``% attr=attractive(curr,over);``% repu=repulsion(curr,obstacle);``%curoutput=computP(curr,over,obstacle);` `%计算当前点附近半径为0.2的8个点的势能，然后让当前点的势能减去8个点的势能取差值最大的，确定这个方向，就是下一步迭代的点` `%先求这八个点的坐标` `for i=1:8 testPoint(:,i)=[testR*sin((i-1)*pi/4)+curr(1);testR*cos((i-1)*pi/4)+curr(2)];`​ `testOut(:,i)=computP(testPoint(:,i),over,obstacle);`​ `%找出来最小的就可以了` `end` `[temp num]=min(testOut);` `%迭代的距离为0.1` `curr=(curr+testPoint(:,num))/2;` `plot(curr(1),curr(2),'og');` `iters=iters+1;``end``end``function [ output ] = computP( curr,over,obstacle )` `k_att=1;``repu=0;``k_rep=100;``Q_star=2;``%计算当前点距离终点的引力``attr=1/2*k_att*(norm(curr-over))^2;``%计算障碍点与当前点的斥力``%设定障碍的斥力作用半径为2``for i=1:size(obstacle,2)` `if norm(curr-obstacle(:,i))&lt;=Q_star`​ `repu=repu+1/2*k_rep*(1/norm(curr-obstacle(:,i))-1/Q_star)^2;` `else`​ `repu=repu+0;` `end``end``output=attr+repu;``end` 4.4 实现的实际效果事实上，尽管RANSAC算法在理论上已经具备足够的拟合精度，但在实际的识别过程中，由于激光雷达扫描获取的数据过多而导致干扰噪点的数量达到了一定规模，以及在算法参数设置上考虑到算力有限等因素而没有采用精确度最高的设置，诸如此类的干扰因素导致在多条直线识别时出现了互相覆盖与识别错误的情况，识别圆形时也并未识别出目标点的圆柱所在处，因此在实际的测试过程中，利用RANSAC算法识别圆与直线以获取目标点和障碍物坐标这一过程并未取得特别良好的效果。为了后面的路径规划算法顺利开展，我们最终采用人工识别的方式，分别给出了起点、障碍物以及目标点的大致坐标，并顺利实现了利用人工势场法进行路径规划的算法，合理规划出了从起点避开障碍物到达目标点停下的最优路径，并通过STM32单片机编程成功驱动了小车按照规划好的路径进行运动，顺利完成开环测试。 五、实验结果及分析 经过几次测试，在进行4至5个位置的扫描之后，通过将数据进行变换与拼接，可以得到一张较为完整的二维地图，再将地图中通过RANSAC算法识别出的特定点位数据读入程序运行，可以得到一条较为合理的最优路径。 事实上，在前面的嵌入式控制系统设计部分，我们计划采用PID方式对于小车与电机进行反馈调节控制，但在实际的测试中，PID的控制方式实现的效果并不尽如人意，无法合理利用MATLAB路径规划所得到的数据结果顺利完成测试。于是我们果断选择了重新使用PWM的方式，依托于MATLAB程序运行规划出的路径对应的相关数据计算所需要的PWM以及延时的时间。最终采用的代码如下图5-1所示（具体KEIL工程内容详见Run.zip附件)。 图5-1 PWM电机驱动部分实现代码 通过调整PWM的方式对小车进行开环运动控制，最终可以较好达到项目要求。（实现效果见下图5-2及视频附件“测试.mp4”） 图5-2 静态路径规划实现效果实地测试 虽然静态路径规划部分完成情况相对较好，但遗憾的是，由于对于C语言编程不是特别熟悉，包括受限于对库的了解、算法的时间复杂度较高、实现繁琐以及对于STM32内部利用效率的不完全开发等因素，最终并没有能够成功完成动态部分的路径规划。事实上，动态情况下的路径规划更符合我们在日常生活中常见的应用场景，不论是扫地机器人还是汽车导航，本身所应对的环境都在时刻发生着改变，因此动态的路径规划问题仍然值得在课程结束之后继续进行深挖和探索。希望在未来的工程实践中，我们能够以更加定量化的思维去分析和思考问题，同时更加熟练的掌握相关的算法设计，提高自己的硬件嵌入式编程能力。 六、个人总结 在路径规划这一阶段的课程中，我在前半段主要负责的是STM32单片机的一些基础开发，对于其基本的开发流程以及GPIO等基本的功能模块有了一定的了解并能进行一些简单的32单片机编程；在后半段，我主要负责整体路径规划项目的思路整理与算法设计，结合课堂上介绍的RANSAC识别算法以及人工势场法规划路径，课下积极结合概念的巩固以及相关资料的查询，阅读了相关的示例代码，并根据算法的整体思路自己动手实现了RANSAC算法对于直线与圆的识别拟合以及在建立的势场中利用梯度下降法实现路径规划的MATLAB程序，积极将自己的算法实现与队友编写的STM32 C语言程序融合在一起，在与队友的充分交流沟通与合作的基础上共同完成了该项目。在死亡之桥的测试项目中，我在一个人调试了单片机程序许久未果后，与队友进行了积极的沟通与合作，也基本确定了由我负责编写MATLAB算法程序给队友的单片机编程提供数据支持的合作模式，对于我们团队的所有人来说都是一次难忘的经历。在利用激光雷达扫描地图的过程中，我们也充分信任彼此，在他们编写好了读取雷达数据的相关程序后，我结合着MATLAB程序的需求对于KEIL代码的输出格式部分进行了一定的修改，在通力合作下最终圆满完成了该项任务。除此之外，也非常感谢整个课程阶段过程中凌睿老师在算法思路方面对我们进行的一系列教学与指导以及助教学长们在答疑时的倾力相助。","link":"/2023/06/25/QEA-Radar-Car/"},{"title":"具有一定扶正能力的船舶设计","text":"本项目定量分析部分Matlab代码已同步上传至Github,仓库链接：Asgard-Tim/QEA-Boat: 重庆大学明月科创实验班定量工程设计方法课程项目 (github.com) 一、项目介绍 在该项目中，我们需要设计制造一艘小船，该小船需要满足以下条件：该艘船的倾覆角度须满足在120°至140°的范围之内，即在倾斜角度到达120°之前都能够回正，同时在超过140°之后不再具有扶正的能力；此外，船体具备一定的载重能力（两罐听装可乐），不会沉没或者有太大（平衡位置甲板与水面夹角超过10°的倾斜）。为了达到以上的指标要求，我们将使用Matlab软件进行相应的定量分析设计，并以木板为材料进行加工制作。具体的呈现详见下文。 二、第一性原理分析 在明确需要达成的指标之后，我们需要使用第一性原理对需要解决的问题进行回归、逐层拨开，回到基本的数学物理公式之中，以便进行较为精确的定量化设计。深入过程见上图。 三、船体设计 3.1设计方向3.1.1第一性原理的实现倾覆角度（120°~140°）实现： 设计灵感来源于鱼漂（鱼漂主要分为漂尾、漂身、漂脚，三部分。漂脚大致分为碳脚、竹脚、钢脚等，漂脚的材质不同，自身的重量就不相同，漂脚越重整支鱼漂的重心就会偏下，使鱼漂入水后翻身站立的时间缩短，也就是我们常说的翻身快。）鱼漂的结构恰好可以很好地解决90°以上倾覆角回正的问题，即“头轻脚重”。通过为船体加装舰岛等提供浮力的模块以及合理调节船体各部分高度来进一步精确化满足倾覆角区间。 载重能力（约700g）实现： 除去船体本身的重量将实现700g左右的载重。船体设计将在船体舰岛中为所载货物预留空间，并且预留出排水体积（即预留最大吃水深度），以满足载重要求。 稳定性实现： 当船舶受到外力倾斜时，其重力的大小位置不发生变化，浮力的大小也不变，但浮力的中心位置会发生偏移。我们知道浮力作用的中心是水下体积的中心，当船舶倾斜时，水下体积形状发生改变，倾斜下沉一侧的水下体积会增加，此时浮力的作用中心会向倾斜的一侧移动，浮力和重力不在同一条直线上，他们形成的力矩和倾斜力矩相反，这就是船舶的复原力矩。只要船舶倾斜，船舶的复原力矩就必然出现，方向永远和船舶的倾斜方向相反，这就是船舶拥有稳性的原因。我们将船舶这种受到外力矩（如风浪等）的作用而发生倾斜，在外力矩消失后自行恢复到原来平衡位置的能力，称为船舶的稳性。 我们对船的剖面演示分析可以发现。当船发生倾斜时，浮心位置改变，我们将浮心所在的垂线于船体中心线交点称为稳心。当稳心在船舶的重心之上时，船舶可以回正。当稳心在重心之下，船舶就发生了倾覆。那么船舶横摇的角度达到多大的时候，我们的船会发生倾覆呢？我们分析研究稳性力臂随着船身倾斜角度变化的曲线。当稳心与重心等高时，也就是这条曲线由正变为负的时候，所对应的船身倾斜角度叫做稳性消失角。当船体的倾斜超过了这个角度，船就会翻。也就是说船舶倾斜在稳性消失角之前，稳心的位置比重心高，稳性力臂为正，复原力矩值也就为正，这时即使船体倾斜，也会回复到船舶原有的平衡位置。当船舶倾斜角度超过了这个稳性消失角，稳心位置就比重心低，稳性力臂比为负，复原力矩值也就为负数，那么这个时候就会发生翻船。这样就解释了船受到外力作用会在海中左右摇摆，随着外力的增加摇摆的更加激烈，船的横摇由于复原力矩的存在，能使其回正，但若超过了稳定消失角这个值，就会发生倾覆。 提高船体稳定性一是降低船体的重心来提高船舶的稳性。例如比赛帆船，通过加中竖龙骨的方法来降低它的重心，使其稳性消失角能够达到150度~170度的角度，接近于永不颠覆的船。另外，增加船宽也可以使船舶获得更高的稳性。例如对安全性要求较高的原油运输船，船体会比较宽，船型比较的矮胖。其他还有多种方式可以抵御船舶倾覆的风险。 动力实现： 动力大致分为驱动和电控两个模块，以及电池，螺旋桨的装配，选取适当控制模块来实现。 3.1.2船体造型与其他功能的实现本次项目设计船舶计划设计类似军舰外形的船体，并且达到船体轻巧，航速较快的目标，在此基础上可以实现节能，造价低廉的非硬性目标。 3.2船体初步设计方案 根据本次项目要求以及船型设计初衷（类军舰）采用了以上减小阻力的第一种设计类型，即通过收窄船体且前尖后宽的方式。 船头借鉴了05式两栖装甲突击车前减阻板的结构，并与上图传统船型结合的联合减租模型。 关于中国05式两栖装甲突击车 新型国产高速两栖突击车首先列装海军陆战队，已经成为海军利器。它不但能在摇摆的海上，精准摧毁敌方阵地工事，而且其强大的威力足以摧毁各型主战坦克。中国05式两栖突击车，操作简单，已没有离合器，具备浮渡精准射击能力。 简介 ZBD-05两栖步兵战车又被称为05式两栖步兵战车，是中华人民共和国研制的”05式两栖装甲车族“一员，装备中国人民解放军海军陆战队和陆军两栖机械化部队的滑水型高速两栖装甲车辆，部分言论称它与美国海军陆战队的”远征战斗车”(Expeditionary Fighting Vehicle, EFV)在概念上相似。 评价 该车外形新颖，车体前部的防浪板是带加强筋的，不但外形宽大而且具有液压伸直调节功能，可以根据海浪的高低和需要的航速自行调节其前倾角度，这就使得整个车体具有了滑行板的功能，在水中行驶时，通过滑行板将水的浮力和速度转化为上抬的力量，类似快艇一样，可以将整个车体短时抬离水面，降低阻力，提高速度。车体前后的防浪板再加上车体两侧打开的侧裙板，可以使得整个车体和水的接触面积大大增加，既增加了该型车在航渡中的稳定性和安全性，还能使得大口径武器如轻型坦克上的105mm火炮具有了在航渡过程中随时可以开火而不致翻沉。在正常陆战使用中，防浪板和后调节板收回车体，还能起到装甲防护的作用。 总结 05式两栖突击车独特巧妙的外形设计是它能快速机动的重要原因。车体前后部的防浪板外形宽大，能根据海浪的高低和需要的航速自行调节前倾角度。突击车在水中行驶时，防浪板将水的浮力转化为向上的力量，再配合车体两侧打开的侧裙板，将突击车短时抬离水面，从而大大降低阻力，提高速度。 舰岛部分以空心提供浮力为主，辅助来进行大角度回调。 驱动控制部分设计为电路模块，包括信号揭发部分，电动机控制部分；驱动模块包括电子调速器，电动机，螺旋桨模块以及锂电池。行进方式采用双桨无舵型，以两个推进器的差速法控制船体行进方向。 ※具体实现以及其他细节后续介绍这里不再给出 四、程序定量设计 4.1 量化指标的数学物理分析基于上述对实际问题的第一性原理分析后，我们不难得出，要使得负有一定载重的船体呈现出满足要求的扶正能力，关键在于对于船体稳定性的量化考察与计算。具体而言，我们可以通过重心、浮心、扶正力矩与稳性消失角等一系列量化参数对于船体的扶正能力进行进一步的定量描述，并根据定量分析结果调整船体设计使其具有相应的扶正能力。 4.1.1 重心重心（Centroids）即为重力中心，本质上是物体在重力场中所受重力作用的等效作用点。在对于船体扶正能力的定量分析中，我们需要通过物体重心与浮心的位置关系判断扶正力矩的正负从而得到稳性消失角以衡量船体的扶正能力。 事实上，由于实验环境处于重力场相对均匀的地表，重心和质心(Center of Mass)在误差允许范围之内可视为重合，因此在定量计算时，我们实际上是将重心等效于质心，通过对于船体质量中心的计算间接得到重力中心的三维坐标。 在上述理论事实的支撑下，我们成功地将问题转化为“如何求取物体质量中心”。不可忽略的一点是，在实际定量计算中，对于物体质量中心的求取首先要将整个物体进行离散化处理，即将物体视作由许多质点组成的质点系，再对这些离散的点进行处理；同时，由于项目中的船体负有载重，离散化的质点系处理过程还便于额外添加船体外壳之外的其他额外质量点（如配重的质心等）。因此，控制物体离散化（本质上是从x,y,z三个方向进行微分）的精度是使得质心坐标结果更为精确的重要一环。在离散化的基础之上，对于N（该项目中N=3）维空间中的质点系而言，在坐标系中有以下质量中心坐标计算公式： 其中X表示某一坐标轴；mi表示物质系统中，某i质点的质量；xi表示物质系统中，某i质点的坐标。 而具体到本项目中所处的三维环境下，又有如下更为细化的公式： 其中，x(y,z)为各坐标轴下质点分布的方程，ρ为船体材料的密度，dA为微分后每一小块的体积。 通过这一公式，就可以得出三维空间中物体离散化后的质点系的质量中心坐标。当离散化程度足够（微分步长足够小）时，在地表实验环境下，这一坐标同时也就是物体重心的坐标。 4.1.2 浮心浮心（Center of Buoyancy）是指浮体或潜体水下部分体积的形心，本质上是浮力的等效作用点。当浮体方位在铅直面内发生偏转时，其水下部分的体积虽保持不变，但其形状却发生变化，因而浮心的位置也相应的移动。在对于船体扶正能力的定量分析中，我们需要通过物体重心与浮心的位置关系判断扶正力矩的正负从而得到稳性消失角以衡量船体的扶正能力。 当物体放入流体中时，由于物体与流体的上下接触面受到流体的压强不等，上小下大，故会产生压强差，进而物体会受到流体竖直向上的压力，即受到流体的浮力。依据阿基米德定律，可得出物体受浮力大小为物体排开那部分流体所受到的重力。自然的，浮心的位置即为被排开流体部分的重心位置。若被排开流体的几何形状是规则的，那么浮心就在被排开的流体原先的几何中心。 事实上，在不同的倾斜角度情况下，物体在水下部分的形状都各不相同，因此随着倾斜角度的改变，浮心也在时刻发生着改变。而在某一固定倾斜角度时，对于浮心的求取本质上即为对于物体排开部分的水的重心求取。在上一节中我们详细阐述了如何计算物体的重心，只是在这里我们需要在不同的倾斜角度下分别求取水下部分的重心，具体计算原理完全一致，在此不过多赘述。但在浮心求取中涉及到的另一个问题是，应该如何确定船体水下部分的船体形状呢？在这里，我们引入水线的概念，即对于船体截面而言，水下部分与水上部分的分界线。上面提到，随着倾斜角度的改变，尽管排开水体部分的形状不尽相同，但提供的浮力大小一致，由阿基米德原理不难得出，即排开水的体积始终不变。因此，我们可以依据这条原理，得到各倾斜角度下水线的方程，与船体截面方程在水线之下的部分共同框定水下部分的形状，从而进行浮心的计算。 4.1.3 扶正力臂（矩）与稳性消失角船的稳性消失角(AVS)是角度θ，当船体的倾斜角度达到该角度后，船体就会倾覆而不再能够自动回倾。利用前两节给出的方法，我们可以得到船体的重心与浮心坐标，它们同时也是重力与浮力作用在船体上的等效作用点。而在这两个力的作用下，会对船体产生一个由重心与浮心之间的距离创建的力矩臂，浮力作用在该臂上以产生扭矩。随着倾斜角度的改变，扭矩的大小与正负也在不断改变，这里不妨规定船体扶正的力矩方向为正。在倾斜角度增大的过程中，力矩臂从正到负，而船体则在力矩臂由正转负的转折点时达到其AVS从而倾覆。当这一浮力产生的扭矩能够使得船体回到稳定平衡的原始位置时，它就是扶正力矩。为此，重心与浮心必须大致满足垂直对齐。如果这两个点稍微偏离对齐状态，则会产生一个扶正扭矩，将两个点推回到对齐状态。两点对齐的下一个可能角度是不稳定的平衡，这意味着如果稍微偏移，系统将无法恢复到其原始状态。当系统稍微偏离不稳定的平衡状态时，所产生的扭矩将改变角度，以使两点变得更加偏离对齐状态。 基于上述对于扶正力矩的定义阐述与分析，我们可以得出以下公式： 式中的GZ为重力作用线与浮力作用线的垂直距离，称为扶正力臂；而MR则为扶正力矩。 扶正力矩与扶正力臂在受力分析图中的呈现如下图所示： 上述分析中提到，稳性消失角仅仅与扶正力矩由正转负的过程有关。通过对于上述式子的观察，不难发现，由于船体扶正或倾覆仅仅取决于扶正力矩的正负，而该计算式中扶正力矩的正负仅仅由扶正力臂的正负所决定，因此基于我们的分析需求，要得到稳性消失角以衡量扶正能力，只需要关注扶正力臂的正负而不关心具体的数值大小，事实上由公式可知扶正力矩只是在扶正力臂的基础上乘上了恒为正的系数（浮力大小）。于是，关键即在于对于坐标系中扶正力臂的求取。具体到坐标系中扶正力臂的计算公式会在后续Matlab程序仿真实现时详细推导与阐述，在此不详细展开。 对于不同的倾斜角度而言，由于淹没部分的形状不同导致浮心位置不同，扶正力臂的大小和正负自然也不同。因此，为了得到稳性消失角，我们可以通过绘制不同倾斜角度下的扶正力臂数值图像，从而得出图像零点处的倾斜角度（横坐标）即为稳性消失角（如下图)。 4.2船体模型构建与仿真模拟4.2.1设计思路基于以上数学物理分析，结合定量分析的需求，我们制定如下设计流程： 具体到实际的设计流程中，我们考虑到如下事实：当船底形状越平，该船的重心越低，船在载重的时候越不容易倾斜，船的平衡性更好。因此，我们基于以上原理，首先通过设计手绘图纸（见附件：切片.docx）的形式确定每一个切片（即船体沿长度方向的横截面）的轮廓形状，然后将切片以草图的形式在Fusion360建模软件中进行绘制，再对各切片草图进行放样操作即可得到船体外壳建模模型；在建模的草图绘制过程中，同时又在y(宽度)方向以一定步长进行采样，得到一系列离散坐标点，从而导入Matlab中进行进一步的仿真定量分析，最终得到符合要求的稳性消失角。 4.2.2基于Fusion 360软件实现船体建模具体实现步骤如下： 将绘制的切片曲线草图依次插入作为画布，并根据草图轮廓（适当修正）利用多点曲线拟合工具得到每一个切片的草图（如下图），各切片之间相隔特定的长度。 在绘制草图曲线的过程中，对于拟合后的放样曲线在宽度方向上以0.5cm为步长进行采样，结合各切片所在的长度坐标可得到船体的点云数据(详见附件our boat.xlsx)，以供后续Matlab仿真处理。 切换至曲面工具，对得到的每一个切片草图的曲线轮廓进行放样操作，得到船体模型大致的表面曲线；再修改选择使用曲面切线，使得曲线更加符合设计草图并更加自然流畅；最后进行封顶，完成船体外形的大致建构。 4.2.3基于Matlab软件构造船体外壳曲面数学模型通过上述利用Fusion360进行的建模过程，我们成功地将切片的草图实体化成了3D模型，并在这一过程中获得了点云数据坐标。接下来，我们将记录在excel表格中的x、y、z点云坐标分别导入Matlab中的mat文件并命名为“X.mat”、“Y.mat”和“Z.mat”存储下来。随后，通过load命令将三个数据文件导入Matlab中的工作区，并利用cftool指令使用曲线拟合器，分别选择X、Y、Z数据，通过多项式对点云数据进行拟合，效果如下图所示。（详情见文件”ourboat.sfit”） 值得注意的是，在点云的获取过程中，我们以船体最下方的点在船体前端的投影作为坐标原点，以船体的长度方向作为x轴，由船头向船尾延伸；船体的宽度方向为y轴，以船的中轴线为分界线，沿x正方向看去左边y值为负，右边y值为正；船底到船顶为z轴正方向。 将所得到的拟合图与建构出的3D模型进行对比，除去比例尺的因素外，外壳形状基本一致，说明模型建构有效，数据与拟合函数可信度高，可以进行下一步仿真。在验证数据有效性的同时，我们也得到了拟合出的曲面函数（如图中右下“结果”框图所示），将其存于函数文件“calculate.m”中，便于后续仿真验证时进行调用。 除此之外，在仿真验证的程序中，我们在导入点集数据之外还需要对船体的各项参数进行定义，并给出微分步长，同时对已有的点集数据进行适当的处理使结果更加合理。 下面给出船体数学模型建立部分的Matlab实现代码： 123456789101112131415161718192021222324252627282930%Step1:船体数学模型建立%导入船体点集数据load('X.mat');load('Y.mat');load('Z.mat');%定义船体参数 单位：cm g%以下参数都基于对于船体实物的测量给出boat.L =39.9; %长boat.W = 17.4; %宽boat.HB = boat.W / 2; %半宽boat.D = 5.4; %深density_water = 1; % g / cm^3boat.mass = 2000; %船体外壳总质量%x为长，y为宽，z为深，做切片（微分）；切片数量为num%dx,dy,dz即为三个方向的微分步长num=100;dy = boat.W/num; dz = boat.D/num; dx = boat.L/num;%构建船体外壳曲面模型mesh.xs = 0:dx:boat.L;mesh.ys = -boat.HB:dy:boat.HB; mesh.zs = 0:dz:boat.D;[mesh.ygrid,mesh.zgrid] = meshgrid(mesh.ys,mesh.zs);[Xi,Yi]=meshgrid(mesh.xs,mesh.ys);Zi=griddata(X,Y,Z, Xi,Yi);%griddata:对二维或三维散点数据插值——增加有效数据量，减少误差surf(Xi,Yi,Zi);shading flat;axis('equal'); 在这里，我们运用了griddata插值函数，对于取样的点云进行了进一步的补充，使得拟合的函数模型曲面更接近于实际情况。所得到的船体曲面模型如下图所示。 至此，我们成功地在Matlab中对我们设计的船体进行了数学函数的拟合，并通过对于函数图像的绘制模拟出船体的外壳模型，同时在程序中对于船体的点云数据以及宏观参数与微分步长都进行了导入与定义，为后续的仿真过程做好准备。 4.2.4船体重心与浮心三维坐标计算及其Matlab实现重心计算：在前面的原理分析部分，我们已经给出物体重心的详细计算方法。 下面给出了Matlab中的实现代码： 123456789101112131415161718192021222324252627282930313233343536373839%Step2:计算船体重心的三维坐标:COM_x=0;%x轴上的重心COM_y=0;%y轴上的重心COM_z=0;%z轴上的重心tnt=0;%有效点个数i=find(isnan(Zi));Zi(i)=0;%去掉NaN点的影响for i=1:num for j=1:num COM_x=COM_x+Xi(i,j); COM_y=COM_y+Yi(i,j); COM_z=COM_z+Zi(i,j); tnt=tnt+1; endend%加入除船壳外的结构，数据均通过实际测量得出%可乐1m1=500;boat.finalmass=boat.mass+m1;x1=10;y1=0;z1=1;%可乐2m2=500;boat.finalmass=boat.finalmass+m2;x2=30;y2=0;z2=1;%桅杆m3=1000;boat.finalmass=boat.finalmass+m3;x3=20;y3=0;z3=8;%最终的重心三维坐标：COM_x, COM_y, COM_zdensity=boat.mass/tnt;COM_x=(COM_x*density+m1*x1+m2*x2+m3*x3)/boat.finalmass;COM_y=(COM_y*density+m1*y1+m2*y2+m3*y3)/boat.finalmass;COM_z=(COM_z*density+m1*z1+m2*z2+m3*z3)/boat.finalmass; 通过运行上述程序，我们可以得到我们设计的船在加上配重与桅杆后的最终重心坐标为： 各倾角下浮心计算：在原理分析部分我们提到，船体的浮心位置会随倾斜角度的改变而不断改变。结合我们在获取稳性消失角时的绘图需求，我们采用循环结构，对从0度到180的所有倾斜角度进行遍历，分别求出各角度下的浮心坐标。 以下是浮心三维坐标计算的Matlab实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243%Step3:计算船体浮心三维坐标%初始化：COB_x,COB_y,COB_z记录每个切片的浮心（2D）COB_x=[];COB_y=[];COB_z=[];MMass=[];%每个浮心点的权重（质量）tot_mass=0;%总质量Y=[];%遍历1-180度的所有theta值for theta=1:1:180 for i=1 :num %对每个x积分 ZZ=[];%记录该X下的Z轴坐标 for j=1 :num+1 %讨论y从-boat.HB到boat.HB t=calculate(i*dx,mesh.ys(1,j)); ZZ=[ZZ t]; end boat.hull = mesh.zgrid &gt; ZZ; %在所计算的Z的值之上的就是船的截面 %不同theta下的水线表示 %确定重力浮力平衡以迭代调整水线 d =water_line(mesh,theta,boat,dx,dy,dz,num);%寻找函数零点 y = mesh.ys; z = -tand(theta).*y+d; if theta&gt;90 &amp;&amp; theta&lt;=180 water = (mesh.zgrid-boat.D/2) &lt; z; elseif theta&lt;=90 &amp;&amp; theta&gt;=0 water = (mesh.zgrid-boat.D/2) &gt; z; end %定义淹没区域 sub_region = flipud(boat.hull)&amp;water;%矩阵交集,求取排水体积;&amp;位与运算（都是1才得1） %计算船体浮心 COB = centerOfMass2(sub_region,mesh); COB_z=[COB_z COB(1,2)]; COB_y=[COB_y COB(1,1)]; COB_x=[COB_x i*dx]; MMass=[MMass matrixSum(sub_region)]; tot_mass=tot_mass+matrixSum(sub_region); end %得出三维浮心坐标 ANS=centerOfMass3(COB_x,COB_y,COB_z,MMass,tot_mass,num);%计算三维浮心 COB_x=ANS(1,1); COB_y=ANS(1,2); COB_z=ANS(1,3); 从而我们可以得到不同倾斜角度theta下的浮心三维坐标。 在上述计算浮心的程序实现中，事实上我们是对于整个船体的浮心进行了整体的求取，具体而言是将船体沿x轴（长度）方向以一定步长微分为num（船体模型建构程序段中有给出定义，是微分的分数）份切片，每一片都分别求取重心的y-z坐标并最终沿x轴方向叠加得到整个船体的浮心。 具体到对于每一个切片的浮心求取，虽然实际情况中是船体在水中倾斜，但为了方便计算，我们不妨处理成船体不动而水线不断改变，当船体的倾斜角度为theta时，水线的斜率应为-tan(theta)；同时在计算时，基于浮力大小不变的原则，即船体淹没部分的体积不变，可以通过函数water_line进行迭代从而得到水线在船体切片的二维y-z坐标系的截距（在数据处理上对于迭代次数与精度进行限制以节约计算时间）。经过上述处理，我们可以得到各倾斜角度theta下各个切片平面中的水线方程。值得注意的是，这里为了使结果更加精确，我们将各点的x,y坐标重新带入了建构模型时所得到的calculate函数从而得到与实际更加接近的z值坐标，并以此来框定各个切片下的函数方程描述。在原理分析部分提到，在某一切片平面中，水线与水线之下的船体函数共同框定了水体淹没面积，对这一部分进行重心的求取即为切片的浮心。 下面给出water_line函数的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839function D_line = water_line(mesh,theta,boat,dx,dy,dz,num) number = 1; i=1; d = -0.02; d_gap = 0.07; density_water = 1000; while number&lt;100 y = mesh.ys; z = -tand(theta).*y+d; if theta&gt;90 &amp;&amp; theta&lt;=180 water = (mesh.zgrid-boat.D/2) &lt; z; elseif theta&lt;=90 &amp;&amp; theta&gt;=0 water = (mesh.zgrid-boat.D/2) &gt; z; end %水线下的水体矩阵 sub_region = flipud(boat.hull)&amp;water; %矩阵交集，求取排水体积 force=sub_region.*density_water*dz*dy*dx; %计算单个微分方块的力 lift= matrixSum(force); %整体浮力 up_force=lift-(boat.finalmass/num); %浮力剩余值 if up_force&lt;0 d=d+d_gap/i; elseif up_force&gt;0 d=d-d_gap/i; else break; end if up_force&gt;-0.01&amp;&amp;up_force&lt;0.01 %判断阈值，水线收敛 break; end i=i*2; %缩短步长 number=number+1;end D_line = d; End 此处同时展示部分功能函数： 12345678910111213141516171819202122232425262728293031323334353637383940function COM = centerOfMass2(masses,mesh) % centerOfMass2: computes center of mass in 2D % masses: matrix of masses % mesh: structure containing ygrid and zgrid % returns: Vector [ycom,zcom] M = matrixSum(masses); ycom = matrixSum(masses .* mesh.ygrid) / M; zcom = matrixSum(masses .* mesh.zgrid) / M; COM = [ycom,zcom];endfunction plotMatrix(A,mesh,cmap) % plotMatrix: plots a matrix using image % A: matrix % mesh: srtruct containing ys and zs % cmap: Colormap colormap(cmap); image(mesh.ys,mesh.zs,flipud(A),'AlphaData',0.5);endfunction M = matrixSum(masses) % matrixSum: returns total of all elements in the matrix % normally sum(m) computes the sums of the columns % selecting m(:) flattens the matrix and computes the sum of all elements % see https://stackoverflow.com/questions/1721987/what-are-the-ways-to-sum-matrix-elements-in-matlab M = sum(masses(:));endfunction ANS=centerOfMass3(XMass,YMass,ZMass,MMass,m,num)x=0;y=0;z=0; for i=1:num x=x+XMass(1,i)*MMass(1,i)/m; y=y+YMass(1,i)*MMass(1,i)/m; z=z+ZMass(1,i)*MMass(1,i)/m; end ANS=[x,y,z];end 4.2.5 船体扶正力臂计算与图像绘制扶正力臂计算原理与公式推导： 在原理分析部分中，我们给出了扶正力矩的定义与扶正力臂的图示，并揭示了只需要计算扶正力臂即可通过判断其正负来获得稳性消失角，但并没有给出具体在坐标系中的计算公式。在这里，将进行计算方法的推导并给出扶正力臂的计算公式。 在上述对于浮心坐标求取的代码实现阐述中，我们提出可以将水中船体的倾斜等效为以船体为参考系下水线的旋转。基于这样的分析思路，我们给出了如下左图所示的示意图，以对于扶正力臂的计算进行进一步的推导。 值得注意的是，尽管图中所表示的仅仅是船体的一个截面，但在实际情况中，若船体在无干扰情况下能稳定在水中平稳漂浮，船体重心与浮心的x坐标在误差允许范围内应可以视为一致，因此在仿真计算中，我们暂时忽略重心与浮心的x坐标而仅仅关心两者的位置关系及这一关系在y-z坐标上的体现。 基于这样的分析，结合上述图示，我们不难得出如上右图所示公式。 另外，所谓扶正力矩必然能够使得船体回正而非倾覆，这就要求力矩的方向应与倾斜角度theta增加的方向相反，因此我们不妨规定这一方向为正方向，在图中第二种情况中显示为船体向右（顺时针方向）倾斜，于是扶正力矩（臂）则以逆时针方向为正。基于这一原理，我们给出了如下方法以判定其正负性，这也是得到最终稳性消失角的关键一环。 在完成了上述推导之后，即可根据推导分析结果设计Matlab程序实现仿真验证。 该部分的程序实现代码如下： 12345678910%Step4:求恢复力臂 k1 = -tand(theta); if ((k1*COB_z+COB_y-COM_y)/k1)-COM_z&lt;0 flag1=1; else flag1=-1; end l = flag1*abs(COB_y+k1*COB_z-k1*COM_z-COM_y)/(k1^2+1)^0.5;%恢复力臂 Y=[Y,l];end 扶正力臂-倾斜角度图像绘制与稳性消失角： 在扶正力臂的求取部分，我们在不同的theta情况下用矩阵Y来存储各角度下的扶正力臂值，以便于绘制θ-l图像，从而根据观察图像得出稳性消失角。 以下为该部分代码实现： 12345%Step5:绘制扶正力臂曲线x=1:1:180;x1=1:1:180;y1=interp1(x,Y,x1,'spline');plot(x1,y1); 最终得到的图像如下图所示。通过观察图像，可以得到我们的船体模型的稳性消失角大致在120-140度之间，满足稳定性要求。 4.2.6误差分析(1)采样点云、拟合曲线与实际船体模型的误差： 由于采样的点云坐标是在对于手绘草图的建模刻画过程中进行读取的，与手绘出的供船体加工的切片草图仍然存在一定的差距，这会带来一定的误差；而在对于点云数据的插值与函数拟合过程中也存在着一定的误差。除此之外，载重的测量误差以及船体在实际加工建造时产生的误差也不可忽略。但由于缺乏一定的工具对于我们建造出的船体实体进行精确的测量与3D模型建构，在数据处理的过程中我们已经对于一些偏差较大的离散点数据进行了纠正或删除处理，使得最终的结果仍然在预期范围之内，并与实际情况相一致。 (2)Matlab仿真时微分步长不足够细分而引起的误差： 在程序仿真设计过程中，我们对于船体从x、y、z三个方向按一定步长分割为若干份，并重点研究沿x轴方向进行切分的各切片以求得船体的重心与浮心坐标。但在实际程序实现的过程中，考虑到运算速度与准确度等多方面因素，各个方向进行分割的份数num不可能做到逼近于现实的无穷大，在上述程序中我们经过测试得到的一个较为合适的num值为100，这导致我们的仿真计算与实际的情况仍然存在一定的误差。但由于采样点的数量也较为有限，num的有限选取也不会对最终的结果造成致命的影响，仍然可以使得船体的稳性消失角最终呈现在可控的目标范围。 五、初代船体制造与实现效果 5.1船型外壳5.1.1结构设计实现为了减轻船体重量，采用了木制板材作为船体材料，通过骨架搭建，外层包裹来实现船模外壳的搭建，过程中主要用到了实木板，白乳胶等材料，加工过程使用绳锯，切割机，打磨机以及电钻等工具。 首先，我们根据最初的船体建模，对模型进行切片处理，以此来获得设计船的肋骨图纸和甲板图纸的必要参数，并根据设计出的肋骨图纸以及甲板图纸加工船体骨架，并进行拼装（详见下图）。 然后利用乳胶，热熔胶和木板，将船体外构型粘贴以达到塑性目的。 5.1.2舰岛设计同样利用模板拼接的方式，构筑舰岛模型。此设计中舰岛的上半部分与下半部分并未粘接，属于分体，用于装载货物使用。 5.2 动力装置 电池：3.5V锂电池 130电机：3.5V 0.7W 双发推力约1.5N 电路板含有电机控制模块（MX1919H实现）与信号接收处理模块。此外设计了对水的感应电路，螺旋桨触水可以遥控发动，离水则发生断路不可发动 螺旋桨部分采用万向结构，这样来减弱偏移对传动的影响。 5.3 防水设计对于船体设计采用了报纸与乳胶混合贴合加固船体的方法，使船体表面硬化并做到初步防水，在彩绘之后涂刷丙烯酸透明防水胶达到更高水平的防水效果。 *船舶防水涂料的应用止水胶防水施工技术。止水胶是一种单组分，无溶剂，遇水膨胀的聚氨酯类无定型膏体，在隧道二次初砌施工缝处设止水胶防水带，以及在钢筋，管线等周围设置止水胶，当接缝中有水渗入时，止水胶的弹性压缩应力和遇水膨胀压力双重作用填塞缝隙，可以有效的防止因接缝不密封出现的渗漏情况，具有较好的密封止水性能，能抗大的水压力。 在舰岛可拆卸部分的设计中，我们采用了轮廓加橡塑胶带的方法，一方面使舱盖固定，另一方面填充缝隙达到防水的效果。 5.4 实现效果在额外载重约700g时，“冲浪者号”吃水过深，并且行进速度大幅降低，全速只有约0.15m/s，而且倾覆角度区间难以满足，于是我们对船体进行了进一步的改进与升级，以达到最初的设计要求。 六、基于定量分析的迭代 6.1 迭代方案思路基于上述的实验效果并结合Matlab建模仿真的结果进行比照，尽管从船型设计上来讲我们所设计的初代船体外形已经达到了额定的稳性消失角要求，具有一定的扶正能力，但在实际的工程测试过程中我们发现，由于船型设计得过小，在装载上配重后整体的吃水深度较大导致船舶在水中航行的稳定性与扶正力矩相关指标的实际表现并不尽如人意；除此之外，在Matlab仿真过程中给出的除船体外壳外的离散质量点的坐标数据也较为模糊，对于稳性消失角模拟的结果造成了一定程度上的印象。通过以上的分析，我们初步设想在迭代过程中尽可能对船体进行再加工，通过延长船体长度的方式扩大相同吃水深度下排开水的体积以提供更大的浮力，从而控制船体满载情况下的吃水深度仍然在可控范围内；同时在仿真模拟的过程中增加对于电力驱动模块中的电机、电池等具有相当质量的组件的坐标导入与运算，并对于各离散质量点的坐标进行精细化处理使其更接近于实际情况，以提高仿真模拟的准确度与有效性。 6.2 迭代方案的定量分析6.2.1 船体外形的修正基于上述的分析结果与初步迭代思路，我们初步定下了延长船体长度的再加工方案，结合对于已有船体的加工现状分析与船体的稳定性考虑，最终决定将船体长度延长至74cm。以下代码给出了对于重新设计的船体的基本参数的定义与设置： 12345678%定义船体参数 单位：cm g%以下参数都基于对于船体实物的测量给出boat.L = 74; %长boat.W = 16.5; %宽boat.HB = boat.W / 2; %半宽boat.D = 7; %深density_water = 1; % g / cm^3boat.mass = 653.8; %船体外壳总质量 除了船体的宏观参数调整之外，相应的，我们还需要在原有的点集数据基础之上对于延长后的部分进行数据的补充，并将新的点云数据集存储在Matlab文件中，再利用cftool曲线拟合器工具获得新的拟合函数表达式并导入函数文件calculate.m中以在后续的仿真模拟中重复调用。下图展示了新点云数据集所拟合出的函数曲面图像以及对应拟合函数的表达式： 在仿真验证的程序中，我们在导入新的点云数据后，为了进一步验证数学模型建构的准确性，仍然需要通过插值函数griddata补充数据并绘制函数曲面图像与fusion 360建模结果进行一定的比对，效果图如下: 6.2.2 离散数量点数据的校准与补充在第一代船的仿真模拟数据中，我们在船体外壳的点云数据之外仅补充了配重与桅杆两部分的质心坐标数据及其质量，而忽略了电控模块其余组件的相关数据，且显然由于电控模块中电池与电机的重量相对于船体整体重量来说并不可忽略不计，所以在本次迭代过程中，在Matlab仿真程序的代码实现中对于这一部分进行了补充，同时对于船体中各零散组件的质心坐标及其质量进行了相对精准的测量与估算，从而提高仿真模拟的准确度，使其更加贴近实际情况。补充调整后船体内的离散质量点的相关数据如下列程序段所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384%加入除船壳外的结构%可乐1m1=356;boat.finalmass=boat.mass+m1;x1=34;y1=0;z1=9.8;%可乐2m2=356;boat.finalmass=boat.finalmass+m2;x2=44;y2=0;z2=9.5;%桅杆m3=116;boat.finalmass=boat.finalmass+m3;x3=39;y3=0;z3=49.5;%上层外壳m4=116.1;boat.finalmass=boat.finalmass+m4;x4=0;y4=39;z4=12.5;%尾部甲板m5=49.4;boat.finalmass=boat.finalmass+m5;x5=64.5;y5=0;z5=6.2;%电池m6=185.1;boat.finalmass=boat.finalmass+m6;x6=12;y6=0;z6=5.5;%电机1m7=190.4;boat.finalmass=boat.finalmass+m7;x7=53;y7=4;z7=3;%电机2m8=191.6;boat.finalmass=boat.finalmass+m8;x8=53;y8=-4;z8=3;%电调1m9=49.4;boat.finalmass=boat.finalmass+m9;x9=20.5;y9=6;z9=7;%电调2m10=49.6;boat.finalmass=boat.finalmass+m10;x10=20.5;y10=-6;z10=7;%船桨1m11=43.5;boat.finalmass=boat.finalmass+m11;x11=73.5;y11=3.8;z11=1;%船桨2m12=40.3;boat.finalmass=boat.finalmass+m12;x12=73.5;y12=-3.8;z12=1;%前端甲板m13=18.2;boat.finalmass=boat.finalmass+m13;x13=20.5;y13=0;z13=6.3;%最终的重心三维坐标density=boat.mass/tnt;COM_x=(COM_x*density+m1*x1+m2*x2+m3*x3+m4*x4+m5*x5+m6*x6+m7*x7+m8*x8+m9*x9+m10*x10+m11*x11+m12*x12+m13*x13)/boat.finalmass;COM_y=(COM_y*density+m1*y1+m2*y2+m3*y3+m4*y4+m5*y5+m6*y6+m7*y7+m8*y8+m9*y9+m10*y10+m11*y11+m12*y12+m13*y13)/boat.finalmass;COM_z=(COM_z*density+m1*z1+m2*z2+m3*z3+m4*z4+m5*z5+m6*z6+m7*z7+m8*z8+m9*z9+m10*z10+m11*z11+m12*z12+m13*z13)/boat.finalmass; 在获得了更加精准的离散质量点的相关数据后，我们可以利用上述程序段的最后部分来计算整个船体在装载了配重与电力驱动模块后的重心在x、y、z轴上的坐标，结果如下图所示： 6.2.3 稳性消失角的最终呈现经过上述结合实际情况后对于点云与离散质量点的数据补充与完善，我们将新的数据导入Matlab程序并再次运行，最终得到了如下图所示的l-θ图像以反映船体倾斜角度与扶正力臂之间的函数关系： 该图也成功体现了改进后的船型设计仍然能够使得稳性消失角维持在120-140度之间，能够满足对于船体稳定性与扶正能力的相关要求，可以进行下一步的迭代加工操作。 七、迭代产品制造过程与实现效果 7.1 迭代产品制造7.1.1 船体再制造为解决原有船体载重后吃水过深的问题，第二代的“刃海级”加长了“冲浪者号”船体长度，本次船体长度在制造前进行了较为周密的运算（各模块重量数据见程序部分），通过对各模块质量的初步掌握，以及配重块和所载重物的估计重量，结合原船型截面面积，计算出额在不改变原有船模外形的前提下，所需加长船身的长度以及大致的吃水情况(船体加长至74cm，空载预估吃水2.87cm，满载预估吃水4.56cm，后经实验实际情况与估计值差距不超过10%) 7.1.2 电控系统改进由于船体整体加大增重以及为解决之前动力不足的问题，更换了另外一套控制系统（功率更大的电机，螺旋桨，电池，电子调速器以及信号接收发遥控系统），改进后的推力更强，满足了设计要求中对动力的需求。 电机参数情况： 实际安装情况： 7.1.3 驱动优化以及节能设计在更换大功率电机之后，电机发热明显增加，为了提高船舶的安全性，可靠性，在迭代过程中，加入了水冷却系统。除此之外为了合理利用船体空间并节约一定能源，在船舶顶部加装了与冷却系统相连的供电装置。 太阳能板与内置电池串联，同时并联水泵与控制板，达到水冷与控制喷水的效果。 额定发电电压：6V 发电最大：150mA 尺寸：60mm*110mm 7.2 迭代产品实现效果7.2.1 实验效果 空载条件下，倾覆角150° 载有饮料的条件下倾覆角大约为130° 7.2.2 微调满足设计要求船舶下水后未调整前倾覆角明显大于140°，于是在船体舰岛舱内加装配重块（仓顶左右两侧各25g），空载倾覆角135°左右，满载倾覆角125°左右。 八、最终成品与总结 8.1 “刃海级” 8.2 项目总结与感悟本次项目历经两次迭代，最后基本实现了项目设计要求，产品还存在需要改进的地方。第一代“冲浪者号”设计中在定量化设计步骤中有疏忽掉配重块的问题，帮助我们发现了我们定量化设计方法的问题所在，总结了第一代的经验之后第二代“刃海级”较为成功地实现了项目设计地要求。 产品的研发设计离不开严格的定量化分析，更离不开多次地迭代更新，在这个过程中我们可以不断学习用到的相关知识，包括电路，控制，材料，结构，力学，软件等等一系列的相关知识，给了我们更开阔的眼界，也锻炼了我们的能力和意志。最重要的是教会了我们定量化分析的思想，为以后项目及产品的开发提供了极大的帮助！","link":"/2023/05/19/boat/"},{"title":"进销存管理系统","text":"本项目全部代码已同步上传至Github,仓库链接：Asgard-Tim/Vendition: 重庆大学明月科创实验班软件设计课程作业 (github.com) 一、需求分析 1.1 进销存管理业务概述随着近年来世界各方面的发展进步和物联网时代的到来及其不断发展，货物销售行业发生了翻天覆地的巨大变革，随着从卖方市场向买方市场的转变，我国的零售行业迅速崛起，并且时时刻刻面临着日益激烈并不断变化的竞争环境。因此，提高进销存管理水平，探索降低成本的方法成为提高企业竞争力的必然选择[1]。 伴随着企业规模的不断扩大和企业效益的进一步发展，原先的管理已经不能跟上企业的发展步伐，更无法满足企业对管理工作快速、准确的要求。在销售业务不断增长的同时，公司日常所需要处理的数据量不断增长，公司内部运转周转的中间传递环节也逐渐增多，进而发展到非常的复杂的经营管理模式，同时，现在复杂多变的市场，人工管理等传统的方法方式在相关方面已无法应对。更为重要的是商品的进销存方面缺乏实时处理的相关分析，管理人员对及时传递资料和命令的需求得无法实现。最后发现如果能够在面对不同种类的货物信息时，能够让管理人员实时掌握销售流程及销售情况，进而支持管理人员对相关商品销售的运营并且可以有效地加速的周转率，从而可以进一步提高行业的服务质量。这时可以组建一个记录、更新、保存数据信息的数据库以建立和支持一个合理高效的软件项目[2]。 具体而言，进销存管理业务的核心是对于商品流动信息的储存与管理，主要涉及到商品品类的新增与删除、进货、商品销售与盘点、平库等相互关联的诸多业务流程。因此，在进销存管理系统中，我们需要让这些业务流程在系统中有所体现，从而达到高效管理的目的。 1.2 功能性需求1.2.1 商品信息管理在进销存管理系统中，需要提供渠道给操作管理人员以录入或删除商品信息，同时对于日常的进货与销售过程予以记录，并在需要的时候对库存中已有的商品种类与数量进行盘点，必要时还需要进行平库操作。这些流程会涉及到公司内的诸多部门，诸如采购部、市场部、财务部等，组织架构的复杂性也对软件系统设计的联动能力与处理效率提出了较高的要求。因此，我们不仅需要通过程序设计实现与实际操作对应的相关功能，对于操作人员在系统中输入的文本信息进行读取与必要的处理以模拟上述诸多对于商品实体的实际操作流程，同时还需要建立与实际仓库所对应的商品的数据库，通过对于所有商品的编号、名称、单价、库存数量与计量单位等具体信息进行存储，并在管理人员进行操作的过程中对库中存储的商品信息进行与实际情况同步的改动，实现更加高效的管理。 1.2.2 系统安全对于公司而言，系统的安全性是软件系统设计过程中一个至关重要的考虑因素，由于系统缺乏维护管理与必要的保护措施所造成的损失与影响将是不可估量且难以弥补的。在进销存管理系统中，系统安全的问题主要可能出现在操作权限与非法输入等方面。基于这样的考虑，软件系统在处理数据时，需要对于非法的输入进行区分并给予用户一定的操作提示；在功能上，需要通过账户密码匹配的机制以对于操作人员的权限进行一定的限制从而保证系统的安全性；在存储数据时，应对于存入的数据在写入文件的同时进行一定的加密操作，防止外部人员盗取或进行修改；同时在用户进行操作时，需要同步保留用户的操作记录，在必要时以供核查。 1.3 非功能性需求1.3.1 性能需求 1.系统必须具备高可用性，能够保证系统长时间连续运行的需求； ​ 2.系统的响应时间应尽可能的短，系统登陆、信息保存等操作响应时间小于1.5秒，信息查询等复杂操作时间小于2秒； ​ 3.数据库容量要大，能够满足商品采购、销售、库存管理等详细信息长时间保存的需求； ​ 4.可供多个用户分时使用该系统平台。 1.3.2 易用性需求 1.系统的相关提示信息一致，如进货、销售、删除、查询等操作功能，应尽可能使人容易理解； ​ 2.有明确的输入限制提示信息； ​ 3.中英文对应正确。 1.3.3 可扩展性需求 在系统底层设计时，需要强化系统的配置和扩展能力，主要体现在以下方面： ​ 1.系统底层支持的可扩展性； ​ 2.系统数据结构可搭建； ​ 3.系统信息展示的可配置性。 二、系统设计 2.1 系统开发方案进销存系统需要在简单快速，并且容易维护的、安全性强的开发环境中进行设计[3]。 2.1.1 系统开发技术事实上，进销存管理的过程，本质上是由操作人员对货物信息进行的一系列操作，而不论是操作人员还是货物，都是系统中的对象，操作人员具有账户和密码等属性，货物则具有编号、名称、数量的属性。基于这样的考量，本进销存管理系统基于命令行界面进行设计，利用面向对象的思想，选用Microsoft Visual Studio Code 作为系统开发工具，后台数据库采用txt格式的文本文件，开发语言选择C++语言。 2.2 技术架构设计系统技术架构上，从上往下分为表示层、业务逻辑层和数据层。系统对每一层定义功能明确的功能接口，同时在层次内实现组件化的接口实现。层次化、模块组件化的实现，使系统具备了最大程度的灵活度，从而能对业务需求的变化作出快速的反应，使系统具有很好的扩展性。 表现层主要是调用业务逻辑层的功能与用户直接进行交互。 业务逻辑层包含了所有业务逻辑的设计与实现，如用户登录、新增商品种类、删除商品种类、商品进货、商品销售、浏览商品信息、显示操作记录、盘点等。 数据层指具体存储系统各种业务数据的数据库系统，在本进销存管理系统中，选用了txt格式的文本文件作为数据库，以便于数据的快速读写。 本进销存管理系统的总体架构如图2.1所示。 图2.1 系统体系架构图 2.3 功能结构与模块设计2.3.1 系统管理该系统包括系统界面初始化、用户注册账户、用户登录等相关功能。系统管理模块主要具体实现以下功能： 1.系统界面初始化 用户进入系统，为用户显示操作功能菜单，提示用户进行相应操作；在用户完成一项操作后，刷新界面并重新初始化当前界面。 2.用户注册账户 若用户第一次使用该系统，需要注册自己的账号并设置密码，不符合规定的密码无效，需要重新注册；完成注册操作后，系统会自动将输入的账号与密码配对并存入数据库中，供登录时进行比对。 3.用户登录 若用户已有账号或已完成注册，可输入自己的账号、密码进行登录操作，若与数据库中的已有条目相一致，则说明该用户具有操作权限，可进入进销存系统内部模块进行下一步操作；若输入的账号与密码不匹配或输入有误，会提示用户重新进行输入。 2.3.2 商品采购、销售与库存管理商品采购、销售与库存管理系统主要包括新增商品种类、删除商品种类、商品进货、商品销售、浏览商品信息、显示操作记录、盘点与平库等相关功能。商品信息管理模块主要具体实现以下功能： 1.新增商品种类 输入需要录入系统的商品的编号、名称、单价、计量单位与库存数量等基本信息，增加商品种类，并同步在数据库中存入该商品的相关信息与操作记录。 2.删除商品种类 输入需要删除的商品种类的编号，即可在系统数据库删除该商品的所有条目信息，并在数据库中留下操作记录；若输入的商品编号无法在数据库中检索到，则该操作无效并给予用户反馈提示。 3.商品进货 对于数据库中已有的商品种类可以进行该操作，否则提示操作失败；输入需要进货的商品种类的编号，界面中会出现数据库中该商品的所有信息，再输入需要进货的数量，若进货的数量有效（为正数），会对应增加该商品的数量并存入数据库中，同时留下操作记录。 4.商品销售 对于数据库中已有的商品种类可以进行该操作，否则提示操作失败；输入需要销售的商品种类的编号，界面中会出现数据库该商品的所有信息，再输入需要销售出去的货物数量，若销售的数量有效（小于等于库存量且为正数），会对应减少该商品的数量并存入数据库中，同时留下操作记录。 5.浏览商品信息 可以将数据库中已有的所有商品的编号、名称、单价、计量单位与库存数量等基本信息以表格的形式展示在界面中以供操作人员进行核对查验。 6.显示操作记录 可以显示改变商品数量的所有操作的操作记录，包括每一次操作的操作类型、操作参数（输入的库存改变量）、操作人员账号和操作时间；其中平库操作进行标红处理。 7.盘点与平库 可以将数据库中已有的所有商品的编号、名称、单价、计量单位与库存数量等基本信息以表格的形式展示在界面中以供操作人员进行核对查验；在盘点完成后，若数据库中的商品数量与实际情况存在出入，在确认原因后可以选择进行平库操作，对于特定商品进行额外的出库或入库操作；平库操作会进行标红处理。 8.数据存储 为了保留已有的操作结果与操作记录，在每一次对于数据库中的商品进行操作时，都会从数据库中重新读取商品信息数据，并在操作完成后将改动之后的商品数据重新存入磁盘的数据库中，并在数据库中保留操作的记录以供日后查验；这也有利于不同操作人员在该系统平台上的协同操作，同时重新启动系统时程序的状态也不会发生改变。 2.4 设计目的与优势2.4.1 设计目的在系统界面与整体功能架构的设计上，对于两个模块均采取了先初始化界面显示操作列表、再根据用户的操作指令给予对应的提示、完成相应操作的模式进行设计，并在各个功能的完成过程中贯穿了对于数据库的读写操作以实时修改，以功能实现为导向，希望帮助操作用户更加高效地实现商品信息的读取与写入。 2.4.2 设计优势1.界面简洁自然，各项功能列表一目了然，方便操作人员迅速完成操作，减少误操作的概率； 2.对于所有输入的位点都进行了规范化处理，保证输入的数据格式都是合乎要求的，同时对于非法的输入操作都给予了反馈警告，便于用户快速上手； 3.设计功能齐全，可以满足大多数情况下商品的采购、销售与库存管理操作； 4.运用数据库实时储存用户信息、商品信息与操作记录，方便必要时进行查询，同时也有利于保存数据，支持多用户对于系统进行操作； 5.用户登录机制与操作记录保存机制为系统的安全性提供了一定的保障。 三、系统实现 本系统的具体框架如下图3.1所示。当成功登录窗口后，用户即进入到主界面中，此时用户可以通过模块选择在自己操作权限范围内的操作，并可在各个功能模块之间进行切换。 图3.1 系统功能流程图 3.1 命令行界面的初始化实现在设计时，我们根据需求，希望系统的界面能够在完成一项指令操作后刷新并重新加载操作功能菜单以使用其他功能。因此，在登录窗口与系统内部商品处理两个模块的界面加载中，采用了相同的实现逻辑以达到这一效果。具体实现逻辑如下图3.2所示。最终实现效果符合预期。 图3.2 命令行界面初始化流程图 3.2 登录界面——用户权限管理实现在登录界面，系统为用户提供了三个选项卡：用户登录、用户注册与退出系统，并分别有与之对应的操作代码。具体实现时，采用了选择分支结构，对于用户输入的功能编号进行检测，并对非法的输入给予反馈，提示需要重新输入正确的功能编号（本系统中所有需要输入操作代码的地方均采用了该流程，后面不再赘述）。 对于文件的读写，在程序中创建了相应的文件操作对象以进行相应的读写操作，并在每一次操作完成后关闭文件并重新打开以重置读写指针，防止影响到后续的操作。（进销存模块的文件读写操作与这里方式相同，后面不再赘述）。 对于用户的个人信息，设计了类user，具有用户名和密码两个私有属性，并设计了一系列公有函数对其进行读写，随后在用户注册与登录环节对该类进行实例化，并对实例化后的对象进行一系列的读写操作以实现功能。（在进销存模块中，对于商品类goods与操作记录类operations也采取了相同的方式进行处理，后面不再赘述）。 若选择“退出系统”选项卡，会提示用户是否确认退出：若确认推出，则立刻自动关闭窗口，反之则重新加载界面。效果图如图3.3。 若选择“用户注册”选项卡，会提示用户输入自己想要设置的用户名与密码（会提示用户用户名和密码只能包含字母和数字；用户名若与库中已有的用户名重复，会提示注册失败；密码还限制了位数不得少于六位，若不足六位也会提示注册失败，需要重新注册）；注册成功后，用户的信息会自动存入用户数据库文件“userinformation.txt”，同时重新加载界面。效果图如图3.4。 若选择“用户登录”选项卡，会提示用户输入用户名和密码，输入完成后与数据库中的对应文件进行匹配，若匹配成功则进入进销存系统模块（在程序编写过程中具体体现为进入函数login），反之则提示输入有误，请重新输入，并重新加载界面。效果图如图3.5。 该模块的详细实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;class user{private: string username; string password;public: void putusername(){cin&gt;&gt;username;} void putpassword(){cin&gt;&gt;password;} string getusername(){return username;} string getpassword(){return password;}};void initialize(){ cout&lt;&lt;&quot;********************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 欢迎您使用进销存系统 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 1.用户登录 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 2.用户注册 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 0.退出系统 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;********************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入您需要执行的功能编号:&quot;;}int main(){ while(true) { fstream userinformation; userinformation.open(&quot;userinformation.txt&quot;,ios::in|ios::app); initialize();//初始化界面 //账号注册与登录模块 string op1; cin&gt;&gt;op1; if(op1==&quot;1&quot;) { //用户登录，先让用户输入账号和密码 user user1; int flagin=0; cout&lt;&lt;&quot;请输入您的用户名:&quot;; user1.putusername(); cout&lt;&lt;&quot;请输入您的用户密码:&quot;; user1.putpassword(); //将用户录入的与文件中保存的账号密码进行比对 string use=user1.getusername()+&quot; &quot;+user1.getpassword(); while(true) { string inform; getline(userinformation,inform); if(inform==&quot;&quot;) break; if(use==inform) { cout&lt;&lt;&quot;亲爱的用户&quot;&lt;&lt;user1.getusername()&lt;&lt;&quot;,欢迎您登录本系统&quot;&lt;&lt;endl; Sleep(1000); system(&quot;cls&quot;); login(user1.getusername());//进入进销存系统 flagin=1; break; } } if(flagin==0) { cout&lt;&lt;&quot;您输入的账号或密码错误,请检查后重新输入&quot;; Sleep(1000); } } else if(op1==&quot;2&quot;) { //用户注册，输入用户名与密码 user user1; cout&lt;&lt;&quot;请输入您的用户名(仅可使用数字与字母):&quot;; user1.putusername(); //判断用户名是否已经存在 int flag=0; while(true) { string name; userinformation&gt;&gt;name; string empty; getline(userinformation,empty); if(name==&quot;&quot;) break; if(user1.getusername()==name) { cout&lt;&lt;&quot;您输入的用户名已经存在,注册失败,请重新输入&quot;&lt;&lt;endl; Sleep(1000); flag=1; break; } } userinformation.close(); userinformation.open(&quot;userinformation.txt&quot;,ios::in|ios::app); if(flag==0) { cout&lt;&lt;&quot;请输入您的用户密码(仅可使用数字或字母,不小于6位):&quot;; user1.putpassword(); //判断用户输入的密码是否符合要求，若符合要求则录入文件 string pass=user1.getpassword(); if(pass.length()&lt;6) { cout&lt;&lt;&quot;您输入的密码小于6位,请重新输入&quot;&lt;&lt;endl; Sleep(1000); } else { cout&lt;&lt;&quot;您已成功注册,请进行登录&quot;&lt;&lt;endl; userinformation&lt;&lt;user1.getusername()&lt;&lt;&quot; &quot;&lt;&lt;user1.getpassword()&lt;&lt;endl; Sleep(1000); } } } else if(op1==&quot;0&quot;) { int fl=0; while(fl==0) { cout&lt;&lt;&quot;您确认要退出该系统吗?(是请按1,否请按0)&quot;; int opp; cin&gt;&gt;opp; if(opp==1) exit(0); else if(opp==0) fl=1; else cout&lt;&lt;&quot;您输入有误,请重新输入&quot;&lt;&lt;endl; } } else { cout&lt;&lt;&quot;您输入了无效的操作代码,请重新输入&quot;; Sleep(1000); } userinformation.close(); system(&quot;cls&quot;); } return 0;} 图3.3 “退出系统”功能效果图 图3.4 “用户注册”功能效果图 图3.5 “用户登录”功能效果图 3.3 商品进销存功能实现进入进销存模块界面，系统为用户提供了八个选项卡：新增商品种类、删除商品种类、商品进货、商品销售、浏览商品信息、显示操作记录、盘点、退出登录，并分别有与之对应的操作代码。 若选择“退出登录”选项卡，会直接退出登录，停顿一秒后回到登录主界面。效果图如图3.6。 若选择“新增商品种类”选项卡，会提示用户输入需要新增种类的商品编号（不得与数据库中已有的商品编号相同，否则会提示重新输入），并依次提示输入商品的名称、单位、价格与库存数量；提示添加成功后，该商品的信息会自动存入商品数据库文件“goodsinformation.txt”，而相应的操作记录（包括操作编号、操作的商品编号、操作的种类、操作的商品数量、操作人的用户名与操作时间等详细信息）会被录入操作数据库文件“operationinformation.txt”(“删除商品种类”、“商品进货”、“商品销售”、“盘点”等操作也会在操作完成后录入该数据库，后面不再赘述)，同时重新加载界面。效果图如图3.7。 若选择“删除商品种类”选项卡，会提示用户输入需要删除的商品编号（必须是库中已有的商品种类，否则会提示重新输入）；提示删除成功后，数据库中该商品的条目信息也会一并删除，同时留下操作记录，并重新加载界面。效果图如图3.8。 若选择“商品进货”选项卡，会提示用户输入需要进货的商品编号（必须是库中已有的商品种类，否则会提示重新输入），并相应显示该商品的详细信息；用户还需要输入进货量（不可以为负数，否则提示重新输入）。提示进货成功后，数据库中该商品的库存量也会相应增加，同时留下操作记录，并重新加载界面。效果图如图3.9。 若选择“商品销售”选项卡，会提示用户输入需要销售的商品编号（必须是库中已有的商品种类，否则会提示重新输入），并相应显示该商品的详细信息；用户还需要输入销售量（不可以为负数或小于库存量，否则提示重新输入）。提示销售成功后，数据库中该商品的库存量也会相应减少，同时留下操作记录，并重新加载界面。效果图如图3.10。 若选择“浏览商品信息”选项卡，将会把数据库中所有货物的详细信息列举出来以供查看。效果图如图3.11。 若选择“显示操作记录”选项卡，将会把数据库中所有操作记录的具体信息列举出来以供查看。其中，平库过程中的出库与入库操作均会被标红。效果图如图3.12。 若选择“盘点”选项卡，将会把数据库中所有货物的详细信息列举出来以供查看，并在下方提示是否需要平库。若选择不需要平库，则会直接重新加载界面；若选择需要平库，则需选择需要出库或者入库（此行会被标红以示警告），出库操作与商品销售类似，而入库操作则与商品进货类似，在此不再重复。效果图如图3.13。 该模块的详细实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;#include&lt;ctime&gt;#include&lt;iomanip&gt;using namespace std;string gettime(){ time_t t=time(NULL); tm *now=localtime(&amp;t); int year=1900+now-&gt;tm_year; int mon=1+now-&gt;tm_mon; int day=now-&gt;tm_mday; int hour=now-&gt;tm_hour; int min=now-&gt;tm_min; int sec=now-&gt;tm_sec; string to_year=to_string( year ); string to_month=to_string( mon ); string to_day=to_string( day ); string to_hour=to_string( hour ); string to_min=to_string( min ); string to_sec=to_string( sec ); return to_year+&quot;-&quot;+to_month+&quot;-&quot;+to_day+&quot; &quot;+to_hour+&quot;:&quot;+to_min+&quot;:&quot;+to_sec;}class goods{private: string no; string name; string count; string price; int num;public: void putno(){cin&gt;&gt;no;} void putname(){cin&gt;&gt;name;} void putcount(){cin&gt;&gt;count;} void putprice(){cin&gt;&gt;price;} void putnum(){cin&gt;&gt;num;} void putnum(int input){num=input;} void putno(string input){no=input;} void putname(string input){name=input;} void putcount(string input){count=input;} void putprice(string input){price=input;} string getno(){return no;} string getname(){return name;} string getcount(){return count;} string getprice(){return price;} int getnum(){return num;}};class operations{private: string no; string kinds; int num; string acount; string date; int flag;public: void putno(string input){no=input;} void putkinds(string input){kinds=input;} void putnum(int input){num=input;} void putacount(string input){acount=input;} void putdate(){date=gettime();} string getno(){return no;} string getkinds(){return kinds;} int getnum(){return num;} string getacount(){return acount;} string getdate(){return date;} int putflag(int input){flag=input;} int getflag(){return flag;}};void systeminitialize(string username){ cout&lt;&lt;&quot;******************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 功能菜单 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 1.新增商品种类 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 2.删除商品种类 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 3.商品进货 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 4.商品销售 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 5.浏览商品信息 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 6.显示操作记录 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 7.盘点 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 0.退出登录 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;******************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;亲爱的用户&quot;&lt;&lt;username&lt;&lt;&quot;,欢迎进入进销存管理平台&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入您需要执行的功能编号:&quot;;}string CharToStr(char * contentChar){ string tempStr; for (int i=0;contentChar[i]!='\\0';i++) { tempStr+=contentChar[i]; } return tempStr;}void DelLineData(char* fileName, int lineNum){ ifstream in; in.open(fileName); string strFileData = &quot;&quot;; int line = 0; char lineData[1024] = {0}; while(in.getline(lineData, sizeof(lineData))) { line++; if (line == lineNum) continue; else { strFileData += CharToStr(lineData); strFileData += &quot;\\n&quot;; } } in.close(); //写入文件 ofstream out; out.open(fileName); out.flush(); out&lt;&lt;strFileData; out.close();}void login(string username){ while(true) { fstream goodsinformation; goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); fstream operationinformation; operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); systeminitialize(username);//初始化界面 //进销存系统内部操作 string op2; cin&gt;&gt;op2; if(op2==&quot;1&quot;) { goods good1; cout&lt;&lt;&quot;请输入商品编号:&quot;; good1.putno(); //检测输入商品的编号，若编号与之前的一致，则需要重新输入 int flag1=0; while(true) { string no; goodsinformation&gt;&gt;no; string empty1; getline(goodsinformation,empty1); if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(good1.getno()==no) { cout&lt;&lt;&quot;您输入的商品种类已经存在,本次录入操作失败,请重新输入&quot;&lt;&lt;endl; Sleep(1000); flag1=1; break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag1==0) { cout&lt;&lt;&quot;请输入商品名称:&quot;; good1.putname(); cout&lt;&lt;&quot;请输入商品单位:&quot;; good1.putcount(); cout&lt;&lt;&quot;请输入商品价格:&quot;; good1.putprice(); cout&lt;&lt;&quot;请输入商品库存数量:&quot;; good1.putnum(); cout&lt;&lt;&quot;添加商品种类成功&quot;&lt;&lt;endl; goodsinformation&lt;&lt;setw(10)&lt;&lt;good1.getno()&lt;&lt;setw(10)&lt;&lt;good1.getname()&lt;&lt;setw(10)&lt;&lt;good1.getcount()&lt;&lt;setw(10)&lt;&lt;good1.getprice()&lt;&lt;setw(10)&lt;&lt;good1.getnum()&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(good1.getno()); operate1.putkinds(&quot;新增商品种类&quot;); operate1.putnum(good1.getnum()); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } } else if(op2==&quot;2&quot;) { cout&lt;&lt;&quot;请输入您需要删除的商品编号:&quot;; string no1; cin&gt;&gt;no1; int flag2=0; int line=1; while(true) { string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { //删除商品信息 DelLineData(&quot;goodsinformation.txt&quot;, line); cout&lt;&lt;&quot;删除商品种类成功&quot;&lt;&lt;endl; flag2=1; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;删除商品种类&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } line++; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,删除商品失败,请检查后再试&quot;&lt;&lt;endl; system(&quot;pause&quot;); } else if(op2==&quot;3&quot;) { cout&lt;&lt;&quot;请输入需要进货的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //显示该商品在系统中的信息 cout&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; cout&lt;&lt;no2&lt;&lt;setw(10)&lt;&lt;name2&lt;&lt;setw(10)&lt;&lt;count2&lt;&lt;setw(10)&lt;&lt;price2&lt;&lt;&quot; &quot;&lt;&lt;setw(10)&lt;&lt;num2&lt;&lt;endl; //进货 cout&lt;&lt;&quot;请输入进货量：&quot;; int num1; cin&gt;&gt;num1; //判断非负 if(num1&lt;0) { cout&lt;&lt;&quot;进货量不能小于零,输入有误,请重新输入&quot;&lt;&lt;endl; break; } good2.putnum(num1+num2); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;进货成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;商品进货&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品进货失败,请检查后再试&quot;&lt;&lt;endl; system(&quot;pause&quot;); } else if(op2==&quot;4&quot;) { cout&lt;&lt;&quot;请输入需要售出的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //显示该商品在系统中的信息 cout&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; cout&lt;&lt;no2&lt;&lt;setw(10)&lt;&lt;name2&lt;&lt;setw(10)&lt;&lt;count2&lt;&lt;setw(10)&lt;&lt;price2&lt;&lt;&quot; &quot;&lt;&lt;setw(10)&lt;&lt;num2&lt;&lt;endl; //进货 cout&lt;&lt;&quot;请输入销售量：&quot;; int num1; cin&gt;&gt;num1; if(num1&lt;0) { cout&lt;&lt;&quot;销售量不能小于零,输入有误,请重新输入&quot;&lt;&lt;endl; break; } int out=num2-num1; if(out&lt;0) { cout&lt;&lt;&quot;库存量不足,无法销售,请核对后重新输入&quot;&lt;&lt;endl; break; } good2.putnum(out); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;商品销售成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;商品销售&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品销售失败,请检查后再试&quot;&lt;&lt;endl; system(&quot;pause&quot;); } else if(op2==&quot;5&quot;) { cout&lt;&lt;setw(10)&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; while(!goodsinformation.eof()) { string informate; getline(goodsinformation,informate); if(goodsinformation.fail()) break; cout&lt;&lt;informate&lt;&lt;endl; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } else if(op2==&quot;6&quot;) { int optime=1; cout&lt;&lt;setw(15)&lt;&lt;&quot;编号&quot;&lt;&lt;setw(15)&lt;&lt;&quot;商品编号&quot;&lt;&lt;setw(15)&lt;&lt;&quot;所作操作&quot;&lt;&lt;setw(15)&lt;&lt;&quot;数量&quot;&lt;&lt;setw(15)&lt;&lt;&quot;操作人账户&quot;&lt;&lt;setw(25)&lt;&lt;&quot;操作时间&quot;&lt;&lt;endl; while(!operationinformation.eof()) { int flag; operationinformation&gt;&gt;flag; string empty; getline(operationinformation,empty); if (flag==0) { string informate; getline(operationinformation,informate); if(operationinformation.fail()) break; cout&lt;&lt;setw(15)&lt;&lt;optime&lt;&lt;informate&lt;&lt;endl; optime++; } else if (flag==1) { string informate; getline(operationinformation,informate); if(operationinformation.fail()) break; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED); cout&lt;&lt;setw(15)&lt;&lt;optime&lt;&lt;informate&lt;&lt;endl; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED |FOREGROUND_GREEN | FOREGROUND_BLUE); optime++; } } operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } else if(op2==&quot;7&quot;) { cout&lt;&lt;setw(10)&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; while(!goodsinformation.eof()) { string informate; getline(goodsinformation,informate); if(goodsinformation.fail()) break; cout&lt;&lt;informate&lt;&lt;endl; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); cout&lt;&lt;&quot;---------------------------------------------&quot;&lt;&lt;endl; int flagx=0; while(flagx==0) { cout&lt;&lt;&quot;是否需要平库?(是请按1,否请按0)&quot;; int op3; cin&gt;&gt;op3; if(op3==1) { int flagy=0; while(flagy==0) { //设置红色字体 SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED); cout &lt;&lt; &quot;您需要出库还是入库?(出库请按1,入库请按0):&quot; ; int op4; cin&gt;&gt;op4; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED |FOREGROUND_GREEN | FOREGROUND_BLUE);//把颜色换回来 if(op4==0) { flagy=1; cout&lt;&lt;&quot;请输入需要入库的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //入库 cout&lt;&lt;&quot;请输入入库量：&quot;; int num1; cin&gt;&gt;num1; //判断非负 if(num1&lt;0) { cout&lt;&lt;&quot;入库量不能小于零,输入有误,请重新输入入库量:&quot;; break; } good2.putnum(num1+num2); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;商品盘点成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;盘点入库&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(1); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品盘点失败,请检查后再试&quot;&lt;&lt;endl; } else if(op4==1) { flagy=1; cout&lt;&lt;&quot;请输入需要出库的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //出库 cout&lt;&lt;&quot;请输入出库量：&quot;; int num1; cin&gt;&gt;num1; if(num1&lt;0) { cout&lt;&lt;&quot;出库量不能小于零,输入有误,请重新输入出库量:&quot;; break; } int out=num2-num1; if(out&lt;0) { cout&lt;&lt;&quot;库存量不足,无法完成出库操作,请核对后重新输入出库量:&quot;; break; } good2.putnum(out); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;商品盘点成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;盘点出库&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(1); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品进货失败,请检查后再试&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;输入有误,请重新输入&quot;&lt;&lt;endl; } flagx=1; } else if(op3==0) flagx=1; else cout&lt;&lt;&quot;输入有误,请重新输入&quot;&lt;&lt;endl; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } else if(op2==&quot;0&quot;) { cout&lt;&lt;&quot;正在为您登出中……&quot;; Sleep(1000); return; } else { cout&lt;&lt;&quot;您输入了无效的操作代码,请重新输入&quot;; Sleep(1000); } goodsinformation.close(); operationinformation.close(); system(&quot;cls&quot;); }} 图3.6 “退出登录”功能效果图 图3.7 “新增商品种类”功能效果图 图3.8 “删除商品种类”功能效果图 图3.9 “商品进货”功能效果图 图3.10 “商品销售”功能效果图 图3.11 “浏览商品信息”功能效果图 图3.12 “显示操作记录”功能效果图 图3.13 “盘点”功能效果图 四、总结 本文首先对进销存管理业务的现状进行归纳，通过分析目前的进销存管理流程，找出存在的问题和原因，对信息化手段给进销存管理带来的好处进行评估，并制订流程以改进管理方案，从系统功能、性能、运行环境等方面提出进销存管理系统的需求，确定开发方案，本着面向对象编程的核心思想，根据数据结构，找到实体间的关系，细化设计思路，并最终依托命令行界面完成了整个进销存管理系统的设计与实现。 根据需要，本进销存管理系统采用三层架构设计，功能模块涵盖了系统管理与商品信息管理两大板块，采用文本文件作为整个系统的数据库，具有实用性、通用性、使用性、扩充性、安全性能高，维护成本低等优点。 在完成了初版的整体设计以及程序实现之后，又对其各项功能进行了多方面的测试，针对其中不足的方面以及小的漏洞进行了进一步的调试、修正、完善与迭代，目前已经能够正常运行。在整个项目的完成过程中，一方面是对于C++编程语言的掌握在实践中进行又一次的巩固加强，另一方面也是对于面向对象这一重要的程序设计思想的深入体会。 总而言之，个人对于本次进销存管理系统项目的完成度是比较满意的，但目前的系统程序仍然存在着许多问题有待于进一步深入研究与学习。一方面是模块化的程度并没有达到预期的效果，整个程序结构仍然稍显冗长。事实上在整个程序设计过程中，受限于不断要对文件进行读写，很难将每一个选项卡单独拆分出来作为独立的函数，同时对于面向对象过程中类的使用仅仅停留在对于其内部私有成员的封装与访问，而并没有涉及到更进一步的针对于特定对象的函数编写与使用 ，希望之后可以进行进一步的迭代与改进。另一方面，虽然在界面设计时本着简洁实用的思想，但很多流程上以及设计上的细节仍然可以进一步深挖改进，这也需要基于一定的实际投放测试并收集反馈来进行；同时受限于时间紧迫，对于QT图形界面无法进行详细的学习以应用在本项目中，希望如果之后有机会可以基于QT界面对于本进销存管理系统进行进一步的重塑与迭代。 参考文献 [1] 郭宁 , 郑小玲.管理信息系统[M].北京 : 人民邮电出版社 , 2009. [2] 刘俊 , 钱瑞明 , 基于 B/S 结构、面向供应链的供销管理系统设计[J] , 微计算机管理 , 2004 ( 1 ) : 42-43 [3] 吴雪海.食品公司进销存系统设计与实现[D].导师：赫枫龄;张雪松.吉林大学,2015.","link":"/2023/05/02/vendition/"},{"title":"寻迹小车","text":"一、绪论 1.1 实验背景1.1.1 问题的情景长期以来，由于我国是人口大国而且工业基础薄弱，因此早期在我国机器人的发展受到一定的限制。然而随着制造业工人的人力成本的不断上升与社会自动化程度的不断提高，我国也开始着重于发展机器人，并且也取得了较大的进步。在 1995 年，我国沈阳自动化所开始研制HT—100A点焊机器人，是我国较早的机器人了，如图1所示；此后，沈阳新松公司研发出了6 kg弧焊机器人，此机器人不仅实用，而且轻便，如图 2 所示；之后，哈尔滨工业大学机器 人研究所也研发出了便携式机器人，此机器人具有 6 自由度，增强了焊接能力，成为在恶劣环境中实现焊接功能的重要设备。总之，在国家“863 计划”与“十一五”计划的指导下，我国机器人的设计取得了飞速发 展，甚至在机器人的某些关键部件的设计已经接近于世界先进水平，并在世界工业机器人领域已经占有一席之地了。 1.1.2 实验的目的目前，机器人的发展趋势非常的迅猛，机器人可以替代人类去从事高危险的工作，减轻了人类的劳动强度。本文通过对机器人的发展史进行简要的介绍，阐明了我国发展机器人的必要性。同时，对于我国的发展而言，我国正处于工业化进程的关键时期，将来的高强度、高危险行业的工人数量将会急剧的下降，机器人将会迎来新的“春天”，所以机器人的发展仍拥有巨大的发展空间。同时，由于我国各机器人的厂商对于机器人的研发能力与金钱投资的不同，在我国的机器人市场上的竞争也会愈演愈烈，最终也将形成我国的机器人研发市场。总之，在未来的几十年里，相信重点发展机器人将会成为社会的发展趋势，不久机器人将会引领未来，加入到我国现代化建设的行列中。小车，也就是轮式机器人，作为以学科交叉、产品创新为特色的明月班同学，切入这个产业不失为优秀的选择，故而选取小车为切入点了解相关知识。 1.2 实验内容1.2.1 使用51单片机控制及其元器件STC89C52控制板芯片、1.5V干电池x4、L298N电机驱动板x1、红外循迹模块、直流电机x2以及搭建材料若干； 1.2.2使用FPGA开发板控制及其元器件Cyclonell EP2C5T144控制板芯片1.5V干电池x4、L298N电机驱动板x1、红外循迹模块、直流电机x2以及搭建材料若干； 二、实现过程 2.1 总体工作原理简释2.1.2 红外循迹模块第一步，位于小车前端的红外模块会释放红外线探测下方是否为黑色区域，并将相应的高低电平信号传递至控制模块（51单片机/FPGA开发板）处理，控制模块随后将发送信息至L298N电机驱动的控制模块，并由此控制左右两轮的转动速度以及转动方向，从而实现对黑线的反应和循迹。 作为电机的驱动模块，该模块对控制小车移动有着重要且直接的作用。 利用红外发射器向地面发射红外线，并用传感器接收由地面反射的红外线。当红外接收模块下方为黑色轨迹时，红外线被黑色轨迹吸收，传感器没有接收到红外线，红外循迹模块输出低电平到单片机。反之，传感器接收到红外线，红外循迹模块输出高电平到单片机。可通过红外循迹模块输出的信号来判断小车是否偏离轨迹。可调电阻可以调节传感器的灵敏度，易于调试。使用红外循迹模块方案也易于实现，红外循迹方案相比于摄像循迹成本更加便宜，软件设计更加简单，设计制作周期短，具备一定可靠性。 对于左电机，共有输入ENA、IN1、IN2，输出OUT1（黑线）、OUT2（红线）、其信号与运动对应如下：（0,X,X）停止、（1,0,0）停止、（1,1,0）正传、（1,0,1）反转、（1,1,1）停止； 对于右电机，共有输入ENB、IN3、IN4，输出OUT3（黑线）、OUT4（红线），其信号与运动对应如下：（0,X,X）停止、（1,0,0）停止、（1,1,0）反传、（1,0,1）正转、（1,1,1）停止。 2.1.3 L298N电机驱动模块 L298N是ST公司的一款电机驱动芯片，也是集成了双H桥，但与上面两个略有不同。电机驱动电压3~48V；可持续工作的输出电流为2A，峰值可达3A。如上图，L298N模块明显有较多的外接元件，这与L298N的内部结构有关。如上图，由于该芯片在H桥上的损耗严重发热较明显（饱和压降大），需要加装散热片，因此在使用上比前两个芯片复杂，体积也相对较大。其各引脚如下图所示。 2.2 使用51单片机部分2.2.1 硬件接线 1为电源输入，与电池盒的输出线相连；2为电源输出，3为驱动板输入，两者需要相连，注意红线为VCC，黑线为GND；4 为单片机IO口引脚，5为驱动板的IN1到 IN4以及ENA和ENB，按照器件上的标注对应连接即可。 6 为与循迹模块的对应接口，按照器件上的标注对应连接即可。 7 和 8 为驱动板与两个电机之间的连线，按照上图所示连接即可。 到这里，基本完成了小车的硬件组装与线路连接，小车要完成循迹进行这些连线就够了，不过在烧录程序到单片机中时还需要 额外的连线，这个将在后面进行说明。 供电上使用四节5号电池。 2.2.2 程序设计首先是如何处理红外模块的探测结果。我们需要先对结果进行编码。我们记没有识别到黑线为0，识别到为1，则我们需要一个算式来囊括左右传感器结果并能对不同情况进行表示。在这里，我们记data2为左边的结果，data3为右边的结果，现给出算式data1=data2*10+data3，data1即检测结果。根据data2、data3不同组合：（1,1）在黑线上；（1,0）略向右偏离；（0,1）略向左偏离；（0,0）完全偏离轨道，分别对应了data1的四个取值，即11、10、1、0，亦即四种情况。相应的，我们需要做出四种反馈，即“前进”、“左转”、“右转”、“停下”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;reg52.h&gt;//51头文件unsigned char pwm\\_val\\_left, pwm\\_val\\_right; //中间变量unsigned char pwm\\_left, pwm\\_right; //定义PWM输出高电平的时间的变量（用户操作PWM的变量）#define PWM\\_DUTY 100 //定义PWM的周期，数值为定时器0溢出周期，假如定时器溢出时间为100us，则PWM周期为10ms。#define PWM\\_HIGH\\_MIN 35 //限制PWM输出的最小占空比#define PWM\\_HIGH\\_MAX PWM\\_DUTY //限制PWM输出的最大占空比/\\*电机驱动IO定义\\*/sbit leftMotorPwm = P1^5; //为1 左电机使能sbit IN1 = P1^4; //为1 左电机正转sbit IN2 = P1^3; //为1 左电机反转sbit IN3 = P1^2; //为1 右电机反转sbit IN4 = P1^1; //为1 右电机正转sbit rightMotorPwm = P1^0; //为1 右电机使能sbit leftSensor = P3^4;//左传感器：为0没有识别到黑线，为1识别到黑线sbit rightSensor = P3^5;//右传感器：为0没有识别到黑线，为1识别到黑线void Timer0\\_Init(void); //定时器初始化void LoadPWM(void);//装入PWM输出值void forward(unsigned char LeftSpeed, unsigned char RightSpeed);//前进void left\\_run(unsigned char LeftSpeed, unsigned char RightSpeed);//左转void right\\_run(unsigned char LeftSpeed, unsigned char RightSpeed);//右转void back(void);//后退修正void Tracking(){//为0 没有识别到黑线 为1识别到黑线char data1, data2 = leftSensor,data3 = rightSensor;data1 = data2\\*10+data3;if(data1 == 11)//在黑线上，前进{//forward(120,120);//前进forward(70,70);//前进}else{if(data1 == 10)//小幅偏右，左转{//left\\_run(80,160);//左转left\\_run(70,70);//左转}if(data1 == 1)//小幅偏左，右转{//right\\_run(160,80);//右转right\\_run(70,70);//右转}if(data1 == 0)//大幅偏左或偏右，已脱离轨道{back();//后退校正}}}/\\*主函数\\*/void main(void){Timer0\\_Init();//定时0初始化while(1){Tracking();}}void forward(unsigned char LeftSpeed,unsigned char RightSpeed){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 1;IN2 = 0;IN3 = 0;IN4 = 1;}void left\\_run(unsigned char LeftSpeed, unsigned char RightSpeed){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 1;IN2 = 0;IN3 = 1;IN4 = 0;}void right\\_run(unsigned char LeftSpeed, unsigned char RightSpeed){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 0;IN2 = 1;IN3 = 0;IN4 = 1;}void back(void){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 0;IN2 = 1;IN3 = 1;IN4 = 0;}/\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\* Timer0初始化\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/void Timer0\\_Init(void){TMOD |= 0x02;//定时器0，8位自动重装模块TH0 = 164;TL0 = 164;//11.0592M晶振，12T溢出时间约等于100微秒TR0 = 1;//启动定时器0ET0 = 1;//允许定时器0中断EA = 1;//总中断允许}/\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\* Timer0中断函数\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/void timer0\\_int (void) interrupt 1{pwm\\_val\\_left++;pwm\\_val\\_right++;if(pwm\\_left &gt; PWM\\_HIGH\\_MAX) pwm\\_left = PWM\\_HIGH\\_MAX; //如果左输出写入大于最大占空比数据，则强制为最大占空比。if(pwm\\_left &lt; PWM\\_HIGH\\_MIN) pwm\\_left = PWM\\_HIGH\\_MIN; //如果左输出写入小于最小占空比数据，则强制为最小占空比。if(pwm\\_right &gt; PWM\\_HIGH\\_MAX) pwm\\_right = PWM\\_HIGH\\_MAX; //如果右输出写入大于最大占空比数据，则强制为最大占空比。if(pwm\\_right &lt; PWM\\_HIGH\\_MIN) pwm\\_right = PWM\\_HIGH\\_MIN; //如果右输出写入小于最小占空比数据，则强制为最小占空比。if(pwm\\_val\\_left&lt;=pwm\\_left) leftMotorPwm = 1; //装载左PWM输出高电平时间else leftMotorPwm = 0; //装载左PWM输出低电平时间if(pwm\\_val\\_left&gt;=PWM\\_DUTY) pwm\\_val\\_left = 0; //如果左对比值大于等于最大占空比数据，则为零if(pwm\\_val\\_right&lt;=pwm\\_right) rightMotorPwm = 1; //装载右PWM输出高电平时间else rightMotorPwm = 0; //装载右PWM输出低电平时间if(pwm\\_val\\_right&gt;=PWM\\_DUTY) pwm\\_val\\_right = 0; //如果右对比值大于等于最大占空比数据，则为零} 2.3 使用FPGA开发板部分2.3.1 硬件接线系统时钟和复位信号必须为PIN17和PIN_90，不过这两个引脚在开发板上已经连接上了，无须手动连接。其它的引脚可以在下表中“FPGA引出I/O”部分选择即可，然后参照之间的51单片机进行连接。 此处附上接线实物图，需要注意的是，FPGA需要独立的接线供电，如充电宝等等。 2.3.2程序设计逻辑上大体与51相同，此处附上代码部分以及引脚的设置图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687LIBRARY ieee;USE ieee.std\\_logic\\_1164.all;ENTITY cartracking ISGENERIC (--时钟为50MHz，为了产生100Hz的PWM波，设置计数值为500000cnt\\_meta : INTEGER := 500000;--对应了停止、前进、左转、右转状态IN4到IN1的输出Back : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;0110&quot;;Forward : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;1001&quot;;Left\\_Go : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;0101&quot;;Right\\_Go : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;1010&quot;);--\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*输入输出端口\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*PORT (sys\\_clk : IN STD\\_LOGIC;sys\\_rst\\_n : IN STD\\_LOGIC;infrared : IN STD\\_LOGIC\\_VECTOR(1 DOWNTO 0);pwm\\_left : OUT STD\\_LOGIC;pwm\\_right : OUT STD\\_LOGIC;in\\_motor : OUT STD\\_LOGIC\\_VECTOR(3 DOWNTO 0));END cartracking;ARCHITECTURE trans OF cartracking ISSIGNAL cnt : INTEGER;SIGNAL duty\\_left : INTEGER;SIGNAL duty\\_right : INTEGER;BEGINPROCESS (sys\\_rst\\_n, infrared)BEGINIF (sys\\_rst\\_n = '0') THENduty\\_right &lt;= 60;duty\\_left &lt;= 60;ELSECASE infrared ISWHEN &quot;00&quot; =&gt;in\\_motor &lt;= Back;--后退WHEN &quot;01&quot; =&gt;in\\_motor &lt;= Right\\_Go;--右转--PWM波的占空比，应设置合适的值来控制小车的转速，为了在仿真时可以对比，特将左右轮设置了不同的占空比。duty\\_left &lt;= 35;duty\\_right &lt;= 55;WHEN &quot;10&quot; =&gt;in\\_motor &lt;= Left\\_Go;--左转duty\\_left &lt;= 55;duty\\_right &lt;= 35;WHEN OTHERS =&gt;in\\_motor &lt;= Forward;--前进duty\\_left &lt;= 50;duty\\_right &lt;= 50;END CASE;END IF;END PROCESS;PROCESS (sys\\_clk, sys\\_rst\\_n)BEGINIF (sys\\_rst\\_n = '0') THENcnt &lt;= 0;ELSIF (sys\\_clk'EVENT AND sys\\_clk = '1') THENIF (cnt = cnt\\_meta) THENcnt &lt;= 0;ELSEcnt &lt;= cnt + 1;END IF;END IF;END PROCESS;PROCESS (sys\\_clk, sys\\_rst\\_n)BEGINIF (sys\\_rst\\_n = '0') THENpwm\\_left &lt;= '0';pwm\\_right &lt;= '0';ELSIF (sys\\_clk'EVENT AND sys\\_clk = '1') THENIF (cnt &gt;= (cnt\\_meta / 100)\\* duty\\_left) THENpwm\\_left &lt;= '0';ELSEpwm\\_left &lt;= '1';END IF;IF (cnt &gt;= (cnt\\_meta / 100) \\* duty\\_right) THENpwm\\_right &lt;= '0';ELSEpwm\\_right &lt;= '1';END IF;END IF;END PROCESS;END trans; 3调试及优化 3.1简单优化由于在测试时需要在保证小车前进速度的同时兼顾其转弯的效率和稳定性，特别是如果直行时转速过快会导致小车在转弯时直接冲出赛道而无法循迹。在原本的设计中，我们将未识别到黑线的反应设置为电机停转而使得小车停止，而这会使得小车无法在冲出赛道后进行自我校正。因此，我们将未识别到黑线时的输出信号由“0000”改为“0110”，即使得左右电机均由原本的停转改为反转，从而实现循迹过程中对于轨道循迹的自我修正。 在 PWM 频率设置的时候， PWM 的频率太低可能导致电机转动不稳定，不 是匀速转动，而 PWM 频率过高可能导致电机反应不过来或者超过电路的上限截止频率。事实上，考虑到转弯过程的稳定性与速度问题，包括与直行过程的速度以及传感器的灵敏度调节配合，我们需要通过实际测试来进一步确定在直行、左转、右转和倒退过程中设定的PWM占空比与转速。具体在调试之后所得到的合适参数已经在上面的代码中有所体现，在此不过多赘述。 3.2调试过程考虑到验收时的重要评判标准是小车循迹一周的时间，且小车本身运动缓慢，我们首先将目光放在了转速的提高上。修改参数大幅提高了轮子的转速后，我们进行了一次实验：结果出乎意料，小车非但没有预想的那样，反而在行进的过程中持续摇摆。分析原因是行进角度不平行于轨道时容易冲出轨道，后续针对此原因，在红外灵敏度以及直行、左转、右转和倒退过程中设定的PWM占空比与转速多次调试与测试。中途红外模块损坏，经过排查确定后更换了新的。此外，我们注意到行进中的不稳定性还来自于万向轮的松散，我们尝试了不限于胶带、缠绳等各种方式加以限制，效果均不理想，虽然直道可以稳定快速行进，转弯却尤为吃力。 最后51的部分取得了第二名的不错成绩。但是FPGA部分却难遂人意。我们一直将注意力放在数据的调试上却忽略了时间的把控，以至于直到最后快结束才仓促进行测试，测试时还发生了接线断开等突发状况。我们本着希望更加灵活的愿望想别的同学借来充电宝供电，没想到这成为了测试失败的最大缘由——充电宝供电严重不足，导致小车行进乏力，但等到我们重新接上电脑供电确认可以正常运行时，却被告知时间已到，不允许再次测试以保证公平。最后无奈接受这个最慢的成绩。 参考文献 [1] 默默无闻小菜鸡. 电机驱动芯片（H桥、直流电机驱动方式）——DRV8833、TB6612、A4950、L298N的详解与比较[EB/OL]. https://blog.csdn.net/qq_44897194/article/details/105524808, 2020-5-11. [2] 周海,叶兵. 机器人的发展现状及应用前景[J]. https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C44YLTlOAiTRKibYlV5Vjs7iAEhECQAQ9aTiC5BjCgn0Rn5ykE3W8_mbbrKtMuQk3r9gP-p4derKJErhs1XrNO9Y&amp;uniplatform=NZKPT, 2017-6-18. 致谢 感谢老师们在本课程中的精心准备与付出。在数电和模电部分得到了曾正教授和袁刚教授的悉心教诲，在后续的项目部分得到了李敏教授和凌睿教授的认真指导，最终得以基本实现预定目标，特此鸣谢！","link":"/2023/03/05/car/"},{"title":"人脸识别项目","text":"本项目全部代码已同步上传至Github,仓库链接：Asgard-Tim/face_recoginition: 重庆大学明月科创实验班线性代数课程项目 (github.com) 使用方法与识别效果如下。","link":"/2023/02/11/facerecognition/"}],"tags":[{"name":"动手学深度学习","slug":"动手学深度学习","link":"/tags/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"定量分析","slug":"定量分析","link":"/tags/%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"船","slug":"船","link":"/tags/%E8%88%B9/"},{"name":"单片机","slug":"单片机","link":"/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"路径规划","slug":"路径规划","link":"/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"},{"name":"RANSAC","slug":"RANSAC","link":"/tags/RANSAC/"},{"name":"小车","slug":"小车","link":"/tags/%E5%B0%8F%E8%BD%A6/"},{"name":"C51","slug":"C51","link":"/tags/C51/"},{"name":"FPGA","slug":"FPGA","link":"/tags/FPGA/"},{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"数据处理分析","slug":"数据处理分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"},{"name":"可视化","slug":"可视化","link":"/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"自动控制原理","slug":"自动控制原理","link":"/tags/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"name":"自动调光","slug":"自动调光","link":"/tags/%E8%87%AA%E5%8A%A8%E8%B0%83%E5%85%89/"},{"name":"Buck变换器","slug":"Buck变换器","link":"/tags/Buck%E5%8F%98%E6%8D%A2%E5%99%A8/"},{"name":"PID闭环控制","slug":"PID闭环控制","link":"/tags/PID%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/"},{"name":"光伏MPPT","slug":"光伏MPPT","link":"/tags/%E5%85%89%E4%BC%8FMPPT/"},{"name":"ChatGPT","slug":"ChatGPT","link":"/tags/ChatGPT/"},{"name":"QQbot","slug":"QQbot","link":"/tags/QQbot/"},{"name":"信号与系统","slug":"信号与系统","link":"/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"name":"傅里叶变换","slug":"傅里叶变换","link":"/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"频谱分析","slug":"频谱分析","link":"/tags/%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/"},{"name":"数字信号处理","slug":"数字信号处理","link":"/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"心电信号采集","slug":"心电信号采集","link":"/tags/%E5%BF%83%E7%94%B5%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86/"},{"name":"FreeRTOS","slug":"FreeRTOS","link":"/tags/FreeRTOS/"},{"name":"ADS1292","slug":"ADS1292","link":"/tags/ADS1292/"},{"name":"滤波器","slug":"滤波器","link":"/tags/%E6%BB%A4%E6%B3%A2%E5%99%A8/"},{"name":"FIR","slug":"FIR","link":"/tags/FIR/"},{"name":"IIR","slug":"IIR","link":"/tags/IIR/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"图像识别","slug":"图像识别","link":"/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"救灾机器人","slug":"救灾机器人","link":"/tags/%E6%95%91%E7%81%BE%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"name":"人机交互","slug":"人机交互","link":"/tags/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"},{"name":"距离特性","slug":"距离特性","link":"/tags/%E8%B7%9D%E7%A6%BB%E7%89%B9%E6%80%A7/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"斯特林发动机","slug":"斯特林发动机","link":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%91%E5%8A%A8%E6%9C%BA/"},{"name":"机械设计","slug":"机械设计","link":"/tags/%E6%9C%BA%E6%A2%B0%E8%AE%BE%E8%AE%A1/"},{"name":"斯特林循环","slug":"斯特林循环","link":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%BE%AA%E7%8E%AF/"},{"name":"动力学仿真","slug":"动力学仿真","link":"/tags/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F/"},{"name":"卷积神经网络","slug":"卷积神经网络","link":"/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"自编码器","slug":"自编码器","link":"/tags/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机视觉","slug":"计算机视觉","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"XJH","slug":"XJH","link":"/tags/XJH/"},{"name":"产品质量管理","slug":"产品质量管理","link":"/tags/%E4%BA%A7%E5%93%81%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"},{"name":"统计过程控制","slug":"统计过程控制","link":"/tags/%E7%BB%9F%E8%AE%A1%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"name":"假设检验","slug":"假设检验","link":"/tags/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"name":"Shewhart控制图","slug":"Shewhart控制图","link":"/tags/Shewhart%E6%8E%A7%E5%88%B6%E5%9B%BE/"},{"name":"二分类","slug":"二分类","link":"/tags/%E4%BA%8C%E5%88%86%E7%B1%BB/"},{"name":"支持向量机","slug":"支持向量机","link":"/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"name":"Logistic回归","slug":"Logistic回归","link":"/tags/Logistic%E5%9B%9E%E5%BD%92/"},{"name":"高斯核函数","slug":"高斯核函数","link":"/tags/%E9%AB%98%E6%96%AF%E6%A0%B8%E5%87%BD%E6%95%B0/"},{"name":"柔性套索惩罚","slug":"柔性套索惩罚","link":"/tags/%E6%9F%94%E6%80%A7%E5%A5%97%E7%B4%A2%E6%83%A9%E7%BD%9A/"},{"name":"快速截断Huber损失","slug":"快速截断Huber损失","link":"/tags/%E5%BF%AB%E9%80%9F%E6%88%AA%E6%96%ADHuber%E6%8D%9F%E5%A4%B1/"},{"name":"R语言","slug":"R语言","link":"/tags/R%E8%AF%AD%E8%A8%80/"},{"name":"设计思维","slug":"设计思维","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/"},{"name":"烟雾扩散","slug":"烟雾扩散","link":"/tags/%E7%83%9F%E9%9B%BE%E6%89%A9%E6%95%A3/"},{"name":"COMSOL","slug":"COMSOL","link":"/tags/COMSOL/"},{"name":"有限元仿真","slug":"有限元仿真","link":"/tags/%E6%9C%89%E9%99%90%E5%85%83%E4%BB%BF%E7%9C%9F/"},{"name":"扩散方程","slug":"扩散方程","link":"/tags/%E6%89%A9%E6%95%A3%E6%96%B9%E7%A8%8B/"},{"name":"本征值求解","slug":"本征值求解","link":"/tags/%E6%9C%AC%E5%BE%81%E5%80%BC%E6%B1%82%E8%A7%A3/"},{"name":"闭环控制","slug":"闭环控制","link":"/tags/%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/"},{"name":"Arduino","slug":"Arduino","link":"/tags/Arduino/"},{"name":"机械臂","slug":"机械臂","link":"/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/"},{"name":"电机控制","slug":"电机控制","link":"/tags/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/"},{"name":"传热学","slug":"传热学","link":"/tags/%E4%BC%A0%E7%83%AD%E5%AD%A6/"},{"name":"工程热力学","slug":"工程热力学","link":"/tags/%E5%B7%A5%E7%A8%8B%E7%83%AD%E5%8A%9B%E5%AD%A6/"}],"categories":[{"name":"动手学深度学习","slug":"动手学深度学习","link":"/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"课程项目","slug":"课程项目","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/"},{"name":"About XJH","slug":"About-XJH","link":"/categories/About-XJH/"},{"name":"自动控制原理","slug":"课程项目/自动控制原理","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"name":"定量工程设计方法I","slug":"课程项目/定量工程设计方法I","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95I/"},{"name":"个人项目","slug":"个人项目","link":"/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"},{"name":"定量工程设计方法II","slug":"课程项目/定量工程设计方法II","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95II/"},{"name":"线性代数","slug":"课程项目/线性代数","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"工程原理","slug":"课程项目/工程原理","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"name":"工效学","slug":"课程项目/工效学","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E6%95%88%E5%AD%A6/"},{"name":"工程设计","slug":"课程项目/工程设计","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"软件设计","slug":"课程项目/软件设计","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"},{"name":"智能图像处理","slug":"课程项目/智能图像处理","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"明诚","slug":"About-XJH/明诚","link":"/categories/About-XJH/%E6%98%8E%E8%AF%9A/"},{"name":"明慵","slug":"About-XJH/明慵","link":"/categories/About-XJH/%E6%98%8E%E6%85%B5/"},{"name":"概率论与数理统计","slug":"课程项目/概率论与数理统计","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"产品设计","slug":"课程项目/产品设计","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/"},{"name":"数学物理方法","slug":"课程项目/数学物理方法","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"},{"name":"机器人基础","slug":"课程项目/机器人基础","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%9F%BA%E7%A1%80/"}],"pages":[]}