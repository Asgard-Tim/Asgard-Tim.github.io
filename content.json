{"posts":[{"title":"Welcome to XJH&#39;s Secret Base!","text":"个人简介 We all started from nothing and yet still wants to be someone. We came to this world empty handed, so let’s make something with our bare hands. We never asked for much because we know that it’s the sweat from our perseverance that taste the sweetest. I started from nothing, but I will get there soon. -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息： CQU明月科创实验班在读 KPL资深观众 钢琴只有业余八级的A叔屑粉丝 音游玩家（主玩Phigros，入坑不是很久） 痒痒鼠一枚 计划2023暑期 2023.08.04 学习向 英语学习，备战六级 python基础学习 合唱队暑期集训进度补齐 个人网页搭建 科创训练营制作样机技术储备 生活向 8.15-8.19 成都行 回十中看一次 约老王和5人组出来各一次（约小周群一次？） 去看一次KPL现场比赛","link":"/2023/08/02/index/"},{"title":"20230705","text":"“不论事情是对是错，在做之前，先考虑最坏的后果。这不是让你们当一个悲观主义者，而是要把乐观与悲观相结合。”他嘴很笨，可最质朴的语言却说出了那么多人不曾了解的真理。倏忽之间，我们也终要脱下这身军装，回到各自的人生。或许彼此的相遇就是意外，可我们也走过了这么多的烈日炎炎和风吹雨打。彼此包容，互相理解，通力合作，我们携手共度，也曾历经磕磕绊绊，共同冲向同一个终点，然后四散奔赴各自的山河。那些年少轻狂和叛逆愤懑，都随着那一声解散而烟消云散。可你不再是你，我也不再是我。我们都在这场洗礼中，迎来了属于我们自己的成长。再见，不负遇见。","link":"/2023/07/05/20230705/"},{"title":"20230703","text":"那一声慷慨激昂的散抚平了所有的烦躁与不安好像也不是那么讨厌下雨天了因为雨后总会天晴可不知道为什么那些浅显的至理却会因为对立而变得如此刺耳等到回想起来那些廉价的愤懑似乎都不值一提或许这里真的是家但烈日下的我们却无时不刻不想着逃离。","link":"/2023/07/03/20230703/"},{"title":"基于ROS（机器人操作系统）的数据展示系统","text":"tips:请在使用该系统前安装好相应的库文件（详见附录二），并在不同控制台分别运行roscore（ros操作系统内核）、rosbag play –loop –pause all.bag（ros数据包展示）和rosrun gmapping slam_gmapping（任务四建图处理进程） 该系统程序名为final_system，使用以下命令克隆git仓库： 1git clone https://github.com/Asgard-Tim/ROS-Coding.git 安装好相关库文件后可通过以下命令运行系统程序： 12345678910111213//项目构建cd /home/ubuntu/project/catkin_wscatkin_make//程序运行source /home/ubuntu/project/catkin_ws/devel/setup.bashcd /home/ubuntu/project/catkin_wsrosrun final_system final_system 完整代码已上传至Github平台，URL地址：Asgard-Tim/ROS-Coding: 重庆大学明月科创实验班软件设计课程作业 (github.com) Bilibili同步上传系统演示视频Demo，链接：重庆大学明月科创实验班软件设计作业–ROS数据展示系统_哔哩哔哩_bilibili 程序主要结构与算法分析在**main()**函数中： 创建ROS节点和节点句柄。 调用**initialize()**函数显示初始菜单:提示用户选择登录、注册或退出系统。 定义一个user类，用于保存用户的用户名和密码信息;根据用户选择执行不同的操作： 登录：要求用户输入用户名和密码，然后检查是否匹配存储在文件中的用户信息。 注册：要求用户输入新的用户名和密码，然后将用户信息保存到文件中。 退出系统：结束程序运行。 如果登录成功，调用**systeminitialize()**函数显示登录成功后的菜单:提示用户选择不同的数据可视化选项或退出系统。 根据用户选择执行不同的数据可视化操作： 任务一：用命令行窗口显示小车的IMU和里程计（odometry）数据 IMU数据：订阅IMU数据的ROS话题，将数据传递给回调函数callback1进行处理。 回调函数callback1，处理IMU数据： 从接收到的IMU消息中获取线性加速度和角速度信息。 使用std::cout打印出线性加速度和角速度信息。 里程计数据：订阅里程计数据的ROS话题，将数据传递给回调函数callback2进行处理。 回调函数callback2，处理里程计数据： 从接收到的里程计消息中获取位置和姿态信息。 使用std::cout打印出位置和姿态信息。 任务二：用图形界面显示颜色相机和深度相机的数据（利用OpenCV库） 颜色相机数据：订阅颜色相机数据的ROS话题，将数据传递给回调函数callback3进行处理。 回调函数callback3，处理颜色相机数据： 将接收到的彩色图像消息转换为OpenCV的图像格式。 使用OpenCV的窗口显示彩色图像。 深度相机数据：订阅深度相机数据的ROS话题，将数据传递给回调函数callback4进行处理。 回调函数callback4，处理深度相机数据： 将接收到的深度图像消息转换为OpenCV的图像格式。 使用OpenCV的窗口显示深度图像。 任务三：用图形界面显示激光雷达的点云数据（利用PCL库） 点云数据：订阅点云数据的ROS话题，将数据传递给回调函数callback5进行处理。 **pcl::visualization::CloudViewer viewer(“Cloud Viewer”);**：创建一个PCL点云可视化器。 回调函数callback5，处理点云数据： 将接收到的点云消息转换为PCL的点云格式。 使用PCL的可视化器显示点云。 任务四：自行选择一种高级算法（例如语义分割、三维重建、导航定位（SLAM）等），实现该算法（可以直接利用第三方库），将其集成到系统中 选择Gmapping算法（一个基于2D激光雷达使用RBPF（Rao-Blackwellized Particle Filters）算法完成二维栅格地图构建的SLAM算法） 占据栅格地图数据：订阅占据栅格地图数据的ROS话题，将数据传递给回调函数callback6进行处理。 回调函数callback6，处理占据栅格地图数据： 从接收到的占据栅格地图消息中获取分辨率、宽度和高度等信息。 创建一个OpenCV的图像对象，用于绘制地图。 遍历地图的每个栅格，根据栅格的值绘制不同的颜色圆点。 使用OpenCV的窗口显示地图。 各功能部分构建过程与实现效果1.系统界面（1）登录界面 （2）功能选择界面 2.各部分功能整体架构思路（以imu数据显示为例，其余任务基本一致）： （1）在运行rosbag后利用rostopic list指令查看当前开放的所有话题 （2）找到所需数据所对应的话题（如imu数据对应的是/imu/data_raw这一topic)，利用rostopic info指令查看其消息类型(如图中Type所示) （3）根据获得的消息类型（如上图Type所示应为sensor_msg/Imu),利用rosmsg show指令查看其对应的各部分数据类型 （4）根据获得的数据类型，编写对应callback函数展示对应数据 12345678910111213141516171819202122232425262728293031323334353637383940void callback1(const sensor_msgs::Imu::ConstPtr&amp; ptr){ cout &lt;&lt; &quot;std_msgs/Header header&quot; &lt;&lt; endl; cout &lt;&lt; &quot; uint32 seq: &quot; &lt;&lt; ptr-&gt;header.seq &lt;&lt; endl; cout &lt;&lt; &quot; time stamp: &quot; &lt;&lt; ptr-&gt;header.stamp &lt;&lt; endl; cout &lt;&lt; &quot; string frame_id: &quot; &lt;&lt; ptr-&gt;header.frame_id &lt;&lt; endl; cout &lt;&lt; &quot;geometry_msgs/Quaternion orientation&quot; &lt;&lt; endl; cout &lt;&lt; &quot; float64 x: &quot; &lt;&lt; ptr-&gt;orientation.x &lt;&lt; endl; cout &lt;&lt; &quot; float64 y: &quot; &lt;&lt; ptr-&gt;orientation.y &lt;&lt; endl; cout &lt;&lt; &quot; float64 z: &quot; &lt;&lt; ptr-&gt;orientation.z &lt;&lt; endl; cout &lt;&lt; &quot; float64 w: &quot; &lt;&lt; ptr-&gt;orientation.w &lt;&lt; endl; cout &lt;&lt; &quot;float64[9] orientation_covariance&quot; &lt;&lt; endl; cout &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; ptr-&gt;orientation_covariance[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;geometry_msgs/Vector3 angular_velocity&quot; &lt;&lt; endl; cout &lt;&lt; &quot; float64 x: &quot; &lt;&lt; ptr-&gt;angular_velocity.x &lt;&lt; endl; cout &lt;&lt; &quot; float64 y: &quot; &lt;&lt; ptr-&gt;angular_velocity.y &lt;&lt; endl; cout &lt;&lt; &quot; float64 z: &quot; &lt;&lt; ptr-&gt;angular_velocity.z &lt;&lt; endl; cout &lt;&lt; &quot;float64[9] angular_velocity_covariance&quot; &lt;&lt; endl; cout &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; ptr-&gt;angular_velocity_covariance[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;geometry_msgs/Vector3 linear_acceleration&quot; &lt;&lt; endl; cout &lt;&lt; &quot; float64 x: &quot; &lt;&lt; ptr-&gt;linear_acceleration.x &lt;&lt; endl; cout &lt;&lt; &quot; float64 y: &quot; &lt;&lt; ptr-&gt;linear_acceleration.y &lt;&lt; endl; cout &lt;&lt; &quot; float64 z: &quot; &lt;&lt; ptr-&gt;linear_acceleration.z &lt;&lt; endl; cout &lt;&lt; &quot;float64[9] linear_acceleration_covariance&quot; &lt;&lt; endl; cout &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; ptr-&gt;linear_acceleration_covariance[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------------------------------------------&quot; &lt;&lt; endl; return ;} （5）编写主函数程序建立订阅者节点订阅话题内容，并调用对应callback函数进行数据处理与显示 1234567ros::init(argc, argv, &quot;imu&quot;);ros::NodeHandle nodeHandle;ros::Subscriber subscriber = nodeHandle.subscribe(&quot;/imu/data_raw&quot;, 1000, callback1);ros::spin(); 注意：在任务二、三中，对应的callback函数需要分别调用opencv和pcl库，将读取的数据进行处理，以可视化图形界面的形式显示出来。 这里以任务三为例展示如何使用库文件进行数据处理并进行图形化界面显示： 123456789101112void callback5(const sensor_msgs::PointCloud2::ConstPtr&amp; msg){ pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud; // 创建一个存储PointXYZ类型点云数据的PointCloud对象，每个点有三个坐标值 pcl::PCLPointCloud2 pcl_pc; // 创建一个PCLPointCloud2对象，用于存储传感器消息中的点云数据 pcl_conversions::toPCL(*msg, pcl_pc); // 将ROS中的sensor_msgs::PointCloud2类型消息转换为PCL中的PCLPointCloud2类型 pcl::fromPCLPointCloud2(pcl_pc, cloud); // 将PCLPointCloud2类型转换为PointCloud&lt;pcl::PointXYZ&gt;类型 viewer.showCloud(cloud.makeShared()); // 在可视化窗口中显示点云数据} 最终各部分功能实现的效果图如下： （1）展示imu数据 （2）展示里程计数据 （3）展示颜色相机数据 （4）展示深度相机数据 （5）展示激光雷达点云数据 3.Gmapping建图算法的实现（1）msg数据类型查询 （2）启动Gmapping算法功能包输入如下命令： 1rosrun gmapping slam_gmapping （3）编写回调函数，利用opencv库绘制2D地图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void callback6(const nav_msgs::OccupancyGrid::ConstPtr&amp; ptr){ std::cout &lt;&lt; &quot;resolution: &quot; &lt;&lt; ptr-&gt;info.resolution &lt;&lt; std::endl; std::cout &lt;&lt; &quot;width: &quot; &lt;&lt; ptr-&gt;info.width &lt;&lt; std::endl; std::cout &lt;&lt; &quot;height: &quot; &lt;&lt; ptr-&gt;info.height &lt;&lt; std::endl; double scale = 1.0; int width = 1200; int height = 1200; cv::Point offset(-1600, -1600); cv::Mat map = cv::Mat::zeros(cv::Size(width, height), CV_8UC3); for (int i = 0; i &lt; ptr-&gt;info.width * ptr-&gt;info.height; ++i) { int x = (i % ptr-&gt;info.width + offset.x) * scale, y = (i / ptr-&gt;info.width + offset.y) * scale; if (ptr-&gt;data[i] == -1) { cv::circle(map, cv::Point(x, y), 1, cv::Scalar(255, 255, 255), -1); } else if (ptr-&gt;data[i] &gt;= 80) { cv::circle(map, cv::Point(x, y), 3, cv::Scalar(0, 0, 0), -1); } else { cv::circle(map, cv::Point(x, y), 3, cv::Scalar(0, 255, 0), -1); } } cv::imshow(&quot;map&quot;, map); cv::waitKey(1000); return ;} （4）建立节点并订阅/map话题，调用回调函数1234ros::init(argc, argv, &quot;show_map&quot;);ros::NodeHandle nodeHandle;ros::Subscriber subscriber = nodeHandle.subscribe(&quot;/map&quot;, 1000, callback6);ros::spin(); （5）建图结果 附录一：必要的库文件和头文件： ****：用于输入输出操作。 ****：用于文件读写操作。 ****：用于处理字符串。 ****：用于时间相关操作。 ****：用于格式化输出。 **”ros/ros.h”**：ROS的主要头文件。 **”sensor_msgs/Imu.h”**：ROS中IMU（惯性测量单元）数据的消息类型。 **”nav_msgs/Odometry.h”**：ROS中里程计数据的消息类型。 ****：用于C风格字符串操作。 **&lt;opencv2/opencv.hpp&gt;**：OpenCV库的头文件。 **”cv_bridge/cv_bridge.h”**：ROS中用于将ROS图像消息转换为OpenCV图像格式的库。 **”image_transport/image_transport.h”**：ROS中用于图像传输的库。 ****：用于内存管理。 **”pcl/visualization/cloud_viewer.h”**：PCL（点云库）中用于可视化点云的类。 **”pcl_conversions/pcl_conversions.h”**：PCL与ROS消息类型转换的库。 **”pcl/point_types.h”**：定义了PCL中常用的点类型。 **”pcl/PCLPointCloud2.h”**：PCL中点云数据的消息类型。 **”pcl/conversions.h”**：PCL与ROS消息类型转换的库。 **”pcl_ros/transforms.h”**：PCL中点云坐标系变换的库。 **”nav_msgs/OccupancyGrid.h”**：ROS中占据栅格地图数据的消息类型。 附录二：安装各库文件的命令 sudo apt-get update 123452. 更新包管理器的软件包列表。3. ``` sudo apt-get upgrade 升级系统中的所有已安装软件包。 sudo apt-get install libopencv-dev 123456. 安装OpenCV库的开发文件。7. ``` sudo apt-get install libopencv-contrib-dev 安装OpenCV贡献模块的开发文件。 sudo apt-get update 1234510. 再次更新包管理器的软件包列表。11. ``` sudo apt-get install libproj-dev 安装Proj库的开发文件，Proj库提供了地理投影转换的功能。 sudo apt-get install libpcl-dev 1234514. 安装PCL（Point Cloud Library）库的开发文件，PCL库用于点云数据处理和分析。15. ``` sudo apt-get install libsdl1.2-dev 安装SDL 1.2库的开发文件，SDL库用于创建图形用户界面和处理多媒体。 sudo apt install libsdl-image1.2-dev 1234518. 安装SDL_image 1.2库的开发文件，SDL_image库提供了图像处理功能。19. ``` sudo apt-get install ros-kinetic-gmapping 安装ROS Kinetic版本中的gmapping软件包，gmapping是用于构建占据栅格地图的SLAM算法。 sudo apt-get install ros-kinetic-slam-gmapping 安装ROS Kinetic版本中的slam_gmapping软件包，slam_gmapping提供了用于构建占据栅格地图的SLAM算法。","link":"/2023/07/02/ROS%20Task/"},{"title":"小车路径规划","text":"本项目全部代码已同步上传至Github,仓库链接：Asgard-Tim/Path-Planning: 重庆大学明月科创实验班定量工程设计方法课程项目 (github.com) 一、设计要求 在本部分的课程项目中，要求我们运用LD14雷达扫描地图，在MATLAB中进行人工势场添加并对STM32小车进行路径规划，在一规定的场地中让小车避开两个矩形障碍物并以尽可能短的路径最终抵达圆形目标位置。 二、系统方案 2.1 移动底盘分析小车为履带式小车，左右履带分别由一枚直流电机进行驱动，运动模式类似常规双轮小车，通过左右两枚电机转动的差速实现转向。该小车相对来说较为容易进行控制，只需要控制两个驱动轮的速度存在差异，即两轮差速，即可控制机器人实现无滑动摩擦的旋转，也可实现零半径转弯。 图2-1 双轮履带小车外观图 图2-2 两轮差速式机器人运动学分析图 对小车移动底盘的运动学分析（如上图2-2所示）： 小车的速度控制主要是控制 X 轴（前后方向）和 Z 轴（旋转方向）的速度， 以 Vx 和 Vz 来指代，单位分别是 m/s 和弧度/s。X 轴方向以前进记为正，Z 轴方向以右转记为正。车轮速度是使用编码器来计算和得出，读取编码器计数后再转化成车轮的速度。Vz则是通过左右电机转动的差速计算得到的。 图中参数分别代表： 2.2 电机特性分析在本次项目中，我们采用带有减速器与编码器的直流电机驱动小车前进。 直流电机的物理模型图如下图2-3所示。其中，固定部分有磁铁，这里称作主磁极；固定部分还有电刷。转动部分有环形铁心和绕在环形铁心上的绕组。 (其中 2 个小圆圈是为了方便表示该位置上的导体电势或电流的方向而设置的) 它的固定部分（定子）上，装设了一对直流励磁的静止的主磁极 N 和S，在旋转部分（转子）上装设电枢铁心。在电枢铁心上放置了两根导体连成的电枢线圈， 线圈的首端和末端分别连到两个圆弧形的铜片上，此铜片称为换向片。换向片之间 互相绝缘，由换向片构成的整体称为换向器。换向器固定在转轴上，换向片与转轴 之间亦互相绝缘。在换向片上放置着一对固定不动的电刷 B1 和 B2，当电枢旋转时，电枢线圈通过换向片和电刷与外电路接通。在电刷上施加直流电压 U,电枢线圈中的电流流向为：N 极下的有效边中的电流总是一个方向，而 S 极下的有效边中的电流总是另一个方向。这样两个有效边所受的洛伦兹力的方向一致（可以根据左手法则判定），电枢开始转动。具体来说就是，把上图中的+和-分别接到电池的正极和负极，电机即可转动；如果是把上图中的+和-分别接到电池的负极和正极，则电机会反方向转动。电机的转速可以理解为和外接的电压是正相关的（实际是由电枢电流决定）。 总而言之，如果我们可以调节施加在电机上面的直流电压大小，即可实现直流 电机调速，改变施加电机上面直流电压的极性，即可实现电机换向。 图2-3 直流电机的物理模型 在具体的使用过程中，我们需要通过在特定的引脚之间（如本次项目所用电机为1/6引脚）接上一个直流电源，电机即可转动，且改变电压大小即可改变电机转速。接线方式说明如下图2-4所示。 2.3 电机控制策略以及PID特性分析小车电机驱动器芯片使用 AT8236，具有过流保护功能，并可设置电流阈值。驱动芯片只需两个逻辑输入，便可达到调速和正反转的功能，本小车中，每个电机使用两路PWM进行调速（实际上一个普通 IO 和一路 PWM 即可进行正反转 和调速）。 电机的速度使用 13 线霍尔编码器输出 AB 相进行测量，电机减速比为 1:30，使用 STM32 的编码器测量功能，并初始化为脉冲上升沿和下降沿都进行计数，可实现轮子转一圈输出 1560 个计数。 电机调速框图如下图2-5所示。 图2-5 电机调速框图 基于2.1节提到的小车移动地盘的运动学分析，我们可以进一步讨论这些物理量之间的关系，并求出其运动学正逆解公式（如下图2-6），结合PID实现控制。 图2-6 两轮差速式机器人的运动学正逆解公式 下图2-7为PID的控制框图，每个方块代表控制系统的一个组成部分，从图中可看出系统中各组成部分的相互关系和影响，即 PID 调节系统是具有被调参数负反馈的闭环系统。当被控量 Y 受到干扰的影响而升高时，反馈信号将高于给定值 X，经过比较而到放大元件去的偏差信号 e 将为负值，控制器将发出信号而使执行元件动作，其作用方向为负，使被控量下降，这就达到了自动控制的目的。 图2-7中的目标速度一般我们可以通过按键或者开关等方式编程实现改变目标值，测量速度就是通过单片机定时去采集编码器的数据并清零。目标速度和测量速度之间做差这个就是目前系统的偏差。在控制过程中，需要将目标速度、测量速度与偏差三者送入 PID 控制器进行计算输出，然后再经过电机驱动的功率放大控制电机的转动去减小偏差，最终达到目标速度。 图2-7 PID控制框图 对于上述PID控制的基于C语言的实现，我们给出以下代码： 1234567891011121314151617`int Incremental_PI (int Encoder,int Target)` `{` `static float Bias,Pwm,Last_bias;` `Bias=Encoder-Target; //计算偏差` `Pwm+=Velocity_KP*(Bias-Last_bias)+Velocity_KI*Bias;` `//增量式 PI 控制器` `Last_bias=Bias; //保存上一次偏差` `return Pwm; //增量输出` `}` 其中，入口参数为编码器的速度测量值和速度控制的目标值，返回值为电机控制 PWM。第一行是相关内部变量的定义。第二行是求出速度偏差，由测量值减去目标值。第三行使用增量 PI 控制器求出电机 PWM。第四行保存上一次偏差，便于下次调用。最后一行是返回。 2.4 嵌入式控制系统总结分析总体而言，我们基于小车本身的轮距等基本参数编写了一整套嵌入式PID控制流程与系统（基于C语言，面向STM32编程），结合PWM波控制电压，从而控制电机的转速以实现对于车轮速度的反馈调节机制，能够保证小车始终保持相对稳定的速度前进，便于后面进一步规划算法，使小车的运动更加可控。此部分编写的KEIL工程详见附件“PID.zip”。 2.5 传感系统总结分析本次项目所采用的传感器主要为激光雷达，在此我们选用LD14雷达。LD14 主要由激光测距核心，无线传电单元，无线通讯单元，角度测量单元、电机驱动单元和机械外壳组成。LD14测距核心采用三角测量法技术，可进行每秒 2300 次的测距。每次测距时，LD14从一个固定的角度发射出红外激光，激光遇到目标物体后被反射到接收单元。通过激光、目标物体、接收单元形成的三角关系，从而解算出距离。获取到距离数据后，LD14 会融合角度测量单元测量到的角度值组成点云数据，再进行导出。 雷达扫描点云数据形式如下图2-8所示： 图2-8 雷达扫描点云极坐标数据形式（下图2数据为角度（角度制），右侧为距离） 在项目的实践过程中，我们需要通过对STM32单片机进行编程，从激光雷达读取数据并通过串口将处理后的数据传输至电脑中（用特定的软件读取串口输出信息）。STM32中烧录的KEIL工程见附件“Lidar.zip”，接线方式如下图所示。 图2-9 激光雷达与单片机接线方式对应 这里给出KEIL工程中main.c中的主干代码（图2-10），最终会输出数据θ和r,分别代表偏转的角度（AvoidData[i].angle）和距离原点的距离（AvoidData[i].distance）。 图2-10 读取激光雷达数据的主干代码 三、硬件电路设计 主要运用模块电路图如下图3-1所示： 图3-1 主要模块电路图 其中，小车的主控为STM32 F103RCT6芯片，其主控板实物图如下图3-2所示： 图3-2 STM32主控板实物图 由于本次项目需要完成的目标较为单一，仅使用其中少部分接口和器件。 四、软件算法设计 4.1 任务描述在本项目中，我们需要通过激光雷达对于小车所处的地图环境（2m*2m，放置有三个正方体障碍物与一个圆柱体目标物）进行扫描，并对扫描得到的数据结果进行处理。通过一定的算法对于目标物与障碍物进行识别后，我们还需要通过人工势场法进行路径规划，使得小车能够以最优的路径绕开障碍物到达目标物。 本次项目任务分为静态和动态两个部分，其中动态测试过程中会对障碍物的位置进行人为的随机改动。测试过程中，小车的起点位置与目标物的位置始终不变，且可自由选定小车的初始面对方向。 4.2 技术路径和策略通过对于任务描述的分析，我们大致可以将静态情况下的路径规划问题拆解为以下几个部分，并给出相应的处理工具与解决策略： （1） 地图扫描：需要通过对STM32单片机进行编程（利用软件工具KEIL），利用串口通信读取激光雷达扫描所获取的周围地图环境点云的极坐标数据 （2） 处理数据：将串口所得到的数据导入MATLAB中，利用坐标变换将不同点位扫描的极坐标数据统一到同一个笛卡尔坐标系中以便后续处理与识别 （3） 识别物体：在获取扫描后得到的地图后，需要利用RANSAC算法（随机抽样一致算法）识别点云数据中的直线与圆形，并得到相应的障碍物与目标物的二维坐标 （4） 路径规划：在MATLAB中编程，利用得到的出发点、障碍物和目标点各自的坐标建立势场，并用梯度下降法寻找避开障碍物、到达目标点的最优路径 实际上，在动态情况下的路径规划问题中，实现的步骤也与上述大致相同，只是并没有MABLAB等电脑端的辅助软件帮助其进行数据处理与路径规划，需要将这些算法通过对STM32单片机编程集成到小车上，从而实现在测试地图环境随机发生改变的情况下仍然能够按照局部最优的路线避开障碍物到达目标点。 4.3 核心程序逻辑4.3.1 激光雷达极坐标点云数据的处理与变换——得到二维地图在2.5节，我们给出了我们的KEIL工程。通过将其烧入至STM32内，并按照特定接线方式将激光雷达与主控板连接，利用串口通信及相关软件成功在电脑上读取了激光雷达扫描得到的点云极坐标数据（如图2-8右图）。在实际测试时，我们选取了五个坐标点分别放置小车（控制朝向相同）对周围地图环境进行扫描，获得了“data1.txt”等一系列数据文件（详见附件）。 在MATLAB程序的第一部分，我们首先利用importdata函数从数据文本文件中读取相应数据，并将其按列分割为“angle”和“distance”两部分。随后，我们利用MATLAB中自带的坐标变换函数pol2cart将一系列的极坐标数据转换为笛卡尔坐标系下的x-y数据（算法原理如下图4-1）。事实上，由于小车每次扫描的位置均不同，因此还需要将多次扫描的结果结合每次小车放置位置的坐标进行一系列的拼接与变换，才可得到最终的场地二维地图（效果如下图4-2）。 图4-1 利用pol2cart函数进行坐标变换的原理示意图 图4-2 经拼接后得到的场地二维地图 该部分的代码给出如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465`%Step1:处理激光雷达扫描数据，绘制二维坐标系地图``ans=importdata(&quot;data1.txt&quot;);``angle=ans(:,1);``angle=angle.*2.*3.1415926./360;``distance=ans(:,2);``[x,y] = pol2cart(angle,distance);``ans1=importdata(&quot;data2.txt&quot;);``angle1=ans1(:,1);``angle1=angle1.*2.*3.1415926./360;``distance1=ans1(:,2);``[x1,y1] = pol2cart(angle1,distance1);``ans2=importdata(&quot;data3.txt&quot;);``angle2=ans2(:,1);``angle2=angle2.*2.*3.1415926./360;``distance2=ans2(:,2);``[x2,y2] = pol2cart(angle2,distance2);``ans3=importdata(&quot;data4.txt&quot;);``angle3=ans3(:,1);``angle3=angle3.*2.*3.1415926./360;``distance3=ans3(:,2);``[x3,y3] = pol2cart(angle3,distance3);``ans5=importdata(&quot;data5.txt&quot;);``angle5=ans5(:,1);``angle5=angle5.*2.*3.1415926./360;``distance5=ans5(:,2);``[x5,y5] = pol2cart(angle5,distance5);``x4 = [x;x1-100;x2+1850;x3+1400;x5+1500]/100;``y4 = [y;y1+1750;y2+100;y3+1650;y5+1000]/100;``figure(1);``scatter(x4,y4,1);``hold on``axis equal``axis( [ -3, 22, -3, 22 ] )` 4.3.2 利用RANSAC算法识别地图中的直线和圆——获得目标点与障碍物的坐标在成功利用激光雷达的扫描数据建立了二维地图后，我们需要让机器人知道哪里能走哪里不能走，要走向哪里，即明确目标点以及障碍物的具体坐标。在本测试项目中，设定圆柱为目标物而正方体为障碍物，所以问题的关键即为如何从二维地图中识别出圆形以及正方形（本质上为直线的拼接）并获得其坐标。 在之前的课程中，介绍了RANSAC这一算法。随机样本一致性(Random Sample Consensus RANSAC) 是一种迭代方法，用于从包含异常值的观察数据中估计出数学模型参数，因此也可以理解为一种异常值检测方法。RANSAC的一个基本假设是，数据由内点(“inliers”)和外点(“outliers”)组成，其中内点是在一定误差范围内可以通过一些模型参数来解释的数据，外点是不符合模型的数据。RANSAC的另一个假设是，随机选取的样本数据都是内点，存在一个可以估计模型参数的过程，该模型可以最佳地解释或拟合该数据。通过该算法，我们可以有效地从已有的地图（本质上是二维坐标系下的点集数据）中拟合出直线与圆的轮廓，并获取相应图形的对应坐标。 该算法的实现步骤如下： （1） 从原始数据集S中随机选择子集s，s为假设的内点(子集s一般为最小子集，如：直线选取两个点，圆选择三个点) （2） 依据子集s估计模型参数 （3） 遍历数据集S中除子集s外的所有数据，如果数据点在给定误差e以内，则标记为内点，否则标记为外点 （4）所有内点组成一致集，如果一致集中点的个数满足给定阈值T，则用一致集中所有内点重新估计模型参数，然后结束算法 （5）如果一致集中内点个数少于阈值T，则重新选择新的子集s，并重复步骤（1）-（4） （6） 经过K次迭代，选择一个内点数量最多的一致集，用一致集中所有内点重新估计模型参数，然后结束算法 基于上述基本思想与步骤，我们编写了一段MATLAB代码，用于二维坐标地图中直线的识别与拟合。在此基础之上，我们根据算法原理，从点集中随机取出三个点，利用三点成圆获得圆的方程（利用自己编写的函数ThreePoint2Circle）。再对圆的轨迹赋予一个宽度，统计落入这个宽度中的点的数量，对所有的点进行逐个取点，获得最优的圆的方程。值得注意的是，由于待识别的正方形是由多条直边构成，这要求我们需要重复对于该图像进行扫描拟合，且需要在一次拟合之后将该次拟合中涉及的数据点删除以防影响下次拟合。下面将给出这一部分的代码实现以及拟合效果（如图4-3、4-4）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257`%Step2:利用RANSAC算法识别直线和圆``%(1)圆的识别``a = [x4,y4];``% RANSCA参数：``% 迭代次数``iter = 0;``% 查看圆数据的大小``[m,n] = size(a);``% 误差参数``berr = 0.02;``% 拟合参数``bfit = [];``% 内点个数为点数的1/3``t = floor(m/3);``% 开始循环迭代``while iter&lt;100` `% 随机挑选三个点，三个点不重复` `% 拟合圆最少需要三个点，拟合直线最少需要两个` `% ran为索引编号` `ran = randperm(m,3)';` `% b为索引得到的点` `b = a(ran,:);` `% 根据随机得到的三个点，计算圆的半径和圆心` `[r1,p1] = ThreePoint2Circle(b(1,1:2), b(2,1:2), b(3,1:2));` `% 选择除了随机得到的三个点外的其他点` `c = setdiff(a,b,&quot;rows&quot;);` `% 计算每个点到圆心的距离dis` `dis = sqrt(sum((c(:,1:2)-p1).^2,2));` `% 计算 dis和拟合圆的误差` `res = dis - r1;` `% 选择小于误差的点，进入到内点中` `d = c(res&lt;berr,:);` `len = length(d(:,1));` `% 判断内点数量是否满足条件` `if len &gt; t`​ `% 满足条件时，多点拟合圆，这里用平均值计算圆心`​ `p = mean(d);`​ `r = mean(sqrt(sum((d(:,1:2)-p(:,1:2)).^2,2)));`​ `% 多点拟合的圆和随机点拟合的圆的误差`​ `err = sqrt(sum((p-p1).^2))+sqrt((r-r1)^2);`​ `% 如果误差满足条件，则可以结束循环`​ `% 不满足则继续`​ `if err &lt; berr`​ `bfit = [p,r];`​ `berr = err;`​ `break`​ `else`​ `iter = iter+1;`​ `continue`​ `end` `else`​ `iter = iter+1;` `end``end``%绘图``para = [p(1)-r, p(2)-r, 2*r, 2*r];``rectangle('Position', para, 'Curvature', [1 1]);` `%（2）直线的识别``iter = 100;``data1=transpose(x4);``data2=transpose(y4);``data=[data1;data2];``for t=1:10` `number = size(data,2); % 总点数` `bestParameter1=0; bestParameter2=0; % 最佳匹配的参数` `sigma = 1;` `pretotal=0; %符合拟合模型的数据的个数` `for i=1:iter` `%随机选择两个点` `idx = randperm(number,2);` `sample = data(:,idx);` `%拟合直线方程 y=kx+b` `line = zeros(1,3);` `x = sample(:, 1);` `y = sample(:, 2);` `k=(y(1)-y(2))/(x(1)-x(2)); %直线斜率` `b = y(1) - k*x(1);` `line = [k -1 b];` `mask=abs(line*[data; ones(1,size(data,2))]); %求每个数据到拟合直线的距离` `total=sum(mask&lt;sigma); %计算数据距离直线小于一定阈值的数据的个数` `if total&gt;pretotal %找到符合拟合直线数据最多的拟合直线`​ `pretotal=total;`​ `bestline=line; %找到最好的拟合直线` `end` `end``%显示符合最佳拟合的数据` `mask=abs(bestline*[data; ones(1,size(data,2))])&lt;sigma;` `hold on;` `k=1;` `index=[];` `for i=1:length(mask)` `if mask(i)`​ `inliers(1,k) = data(1,i);`​ `k=k+1;`​ `index=[index i];` `end` `end` `%删除完成拟合的点以进行下一次拟合` `for i=1:length(index)` `data(:,index(i))=[];` `for j=1:length(index)`​ `if(index(j)&gt;index(i))`​ `index(j)=index(j)-1;`​ `end` `end` `end` `% 绘制最佳匹配曲线` `bestParameter1 = -bestline(1)/bestline(2);` `bestParameter2 = -bestline(3)/bestline(2);` `xAxis = min(inliers(1,:)):max(inliers(1,:));` `yAxis = bestParameter1*xAxis + bestParameter2;` `plot(xAxis,yAxis,'r-','LineWidth',2);``end``function [R,P0] = ThreePoint2Circle(P1, P2, P3)``%% 求圆心和半径，三个点可以求圆心和半径` `x1 = P1(1); x2 = P2(1); x3 = P3(1);` `y1 = P1(2); y2 = P2(2); y3 = P3(2);` `z1 = x2^2 + y2^2 - x1^2 - y1^2;` `z2 = x3^2 + y3^2 - x1^2 - y1^2;` `z3 = x3^2 + y3^2 - x2^2 - y2^2;` `A = [(x2-x1), (y2-y1); (x3-x1), (y3-y1); (x3-x2), (y3-y2)];` `B = 0.5*[z1; z2; z3];` `P0 = (A'*A)\\A'*B;` `R1 = sqrt( (P0(1) - P1(1))^2 + (P0(2) - P1(2))^2 );` `R2 = sqrt( (P0(1) - P2(1))^2 + (P0(2) - P2(2))^2 );` `R3 = sqrt( (P0(1) - P3(1))^2 + (P0(2) - P3(2))^2 );` `R = (R1 + R2 + R3)/3;` `P0 = P0';``End` 图4-3（上） 对于二维地图中一条直线的拟合（红线为拟合结果） （可以看到拟合效果相对良好） 图4-4（右） 对于给定圆坐标数据的RANSAC拟合（上图为给定的圆，下图为拟合出的圆） （说明该算法实现的有效性） 4.3.3 建立势场并利用梯度下降法确定最优路径（人工势场法）人工势场法引入了物理中斥力场和引力场的思想，把工作环境抽象为一个电磁场，而机器人则是其中的一个电荷，机器人在磁场力的作用下移动。人工势场法会在障碍物周围构建斥力场、在目标点周围构建引力场；这样，机器人便能够在斥力场和引力场的作用下向目标点移动。同时，当障碍物和目标点太近时，机器人很可能会因为刹不住车而出现无法到达目标点等问题，这也就出现了一堆相应的优化算法。 通过利用RANSAC算法对于地图中具有特定形状的边界、障碍物与目标物进行识别，我们成功获得了障碍物与目标点的坐标。在此基础之上，我们基于原型函数（a,b即为障碍物/目标点的x,y坐标）建立势场。通过观察不难发现，在以（a,b）为圆心、半径为1的圆之外的地方该势函数均为正，反之为负。事实上，对于场地内的3个障碍物以及1个目标物而言，所形成的是一个叠加场，由原型函数作用于不同的点叠加而成。在此，我们不妨认为势场为正处具有排斥力而势场为负处具有吸引力，需要吸引小车向目标点走去而花费尽量少的能量。在这样的算法理念基础上，我们需要在代表目标点的原型函数部分加上负号；更进一步的，我们还希望这个吸引力足够大而防止被障碍物阻断，因此在建立势场时，不妨在代表目标点的原型函数前乘上一定的系数以保证其足够强大的吸引力。最终，我们根据地图实际情况，建立了整个势场叠加后的函数方程：F=log(sqrt((x-4.75).^2+(y-12.5).^2))+log(sqrt((x-12).^2+(y-7.6).^2))+log(sqrt((x-11.2).^2+(y-13).^2))-5*log(sqrt((x-16.5).^2+(y-18.5).^2))，并根据该函数绘制了势能图（如图4-5）与等势线图（如图4-6)。 图4-5 势场函数势能图 图4-6 势场函数等势线图 该部分代码如下： 123456789101112131415161718192021`%Step3:通过识别得到的障碍物和目标坐标建立势场``v=-2:1:22;``[x,y]=meshgrid(v);``F=log(sqrt((x-4.75).^2+(y-12.5).^2))+log(sqrt((x-12).^2+(y-7.6).^2))+log(sqrt((x-11.2).^2+(y-13).^2))-5*log(sqrt((x-16.5).^2+(y-18.5).^2));``[px,py]=gradient(F,1,1);``contour(x,y,F);``hold on;``title('人工势场法路径规划');``quiver(x,y,px,py,0);``figure(2);``surf(x,y,-F);` 在建立完势场之后，由于我们需要寻找的是避开障碍物而通往目标点的最优路径，实际上即为所耗费能量最少的路径，我们引入了梯度下降法，通过间隔相同距离的不断迭代，在每一处都寻找能量下降最快的方向（即为梯度方向）前进（在MATLAB中通过调用函数文件path_plan.m与computP.m实现该功能），最终得到了如下图4-7绿色线所示的最优路径。 图4-7 人工势场法路径规划结果（绿色即为规划出的最优路径） 其中，path_plan函数是整个算法过程中的关键，也是梯度下降思想的集中体现，其大致实现思路流程如下： 1）起点、终点 、障碍物、迭代次数、取点半径等参数的设定 2）以起点为中心，作半径为r的圆，从圆上取八个均布的点 3）分别计算八个点的前进“代价”—— 终点对其的引力+所有障碍物对其的斥力 4）取“代价”最小的点的坐标，结合现有起点，计算得到新的起点，然后重复上述内容 5）当发现 一个点距离终点很近 or 迭代的次数计算完 程序停止。 该部分的实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899`%Step4:通过人工势场法确定最优路径``axis([-3 22 -3 22]);``begin=[0;0]%起始点坐标``over=[16.5;18.5];%目标点坐标``figure(1);``hold on;``plot(begin(1),begin(2),'*b','MarkerSize',10);``plot(over(1),over(2),'*b','MarkerSize',10);``obstacle=[4.75,12,11.35;12.75,7.5,12];%障碍物坐标``point= path_plan(begin,over,obstacle);``function [ point ] = path_plan(begin,over,obstacle)``iters=1; %迭代次数``curr=begin;``testR=0.1; %测试8点的圆的半径为0.1``while (norm(curr-over)&gt;0.2) &amp;&amp; (iters&lt;=2000)` `point(:,iters)=curr;``% attr=attractive(curr,over);``% repu=repulsion(curr,obstacle);``%curoutput=computP(curr,over,obstacle);` `%计算当前点附近半径为0.2的8个点的势能，然后让当前点的势能减去8个点的势能取差值最大的，确定这个方向，就是下一步迭代的点` `%先求这八个点的坐标` `for i=1:8 testPoint(:,i)=[testR*sin((i-1)*pi/4)+curr(1);testR*cos((i-1)*pi/4)+curr(2)];`​ `testOut(:,i)=computP(testPoint(:,i),over,obstacle);`​ `%找出来最小的就可以了` `end` `[temp num]=min(testOut);` `%迭代的距离为0.1` `curr=(curr+testPoint(:,num))/2;` `plot(curr(1),curr(2),'og');` `iters=iters+1;``end``end``function [ output ] = computP( curr,over,obstacle )` `k_att=1;``repu=0;``k_rep=100;``Q_star=2;``%计算当前点距离终点的引力``attr=1/2*k_att*(norm(curr-over))^2;``%计算障碍点与当前点的斥力``%设定障碍的斥力作用半径为2``for i=1:size(obstacle,2)` `if norm(curr-obstacle(:,i))&lt;=Q_star`​ `repu=repu+1/2*k_rep*(1/norm(curr-obstacle(:,i))-1/Q_star)^2;` `else`​ `repu=repu+0;` `end``end``output=attr+repu;``end` 4.4 实现的实际效果事实上，尽管RANSAC算法在理论上已经具备足够的拟合精度，但在实际的识别过程中，由于激光雷达扫描获取的数据过多而导致干扰噪点的数量达到了一定规模，以及在算法参数设置上考虑到算力有限等因素而没有采用精确度最高的设置，诸如此类的干扰因素导致在多条直线识别时出现了互相覆盖与识别错误的情况，识别圆形时也并未识别出目标点的圆柱所在处，因此在实际的测试过程中，利用RANSAC算法识别圆与直线以获取目标点和障碍物坐标这一过程并未取得特别良好的效果。为了后面的路径规划算法顺利开展，我们最终采用人工识别的方式，分别给出了起点、障碍物以及目标点的大致坐标，并顺利实现了利用人工势场法进行路径规划的算法，合理规划出了从起点避开障碍物到达目标点停下的最优路径，并通过STM32单片机编程成功驱动了小车按照规划好的路径进行运动，顺利完成开环测试。 五、实验结果及分析 经过几次测试，在进行4至5个位置的扫描之后，通过将数据进行变换与拼接，可以得到一张较为完整的二维地图，再将地图中通过RANSAC算法识别出的特定点位数据读入程序运行，可以得到一条较为合理的最优路径。 事实上，在前面的嵌入式控制系统设计部分，我们计划采用PID方式对于小车与电机进行反馈调节控制，但在实际的测试中，PID的控制方式实现的效果并不尽如人意，无法合理利用MATLAB路径规划所得到的数据结果顺利完成测试。于是我们果断选择了重新使用PWM的方式，依托于MATLAB程序运行规划出的路径对应的相关数据计算所需要的PWM以及延时的时间。最终采用的代码如下图5-1所示（具体KEIL工程内容详见Run.zip附件)。 图5-1 PWM电机驱动部分实现代码 通过调整PWM的方式对小车进行开环运动控制，最终可以较好达到项目要求。（实现效果见下图5-2及视频附件“测试.mp4”） 图5-2 静态路径规划实现效果实地测试 虽然静态路径规划部分完成情况相对较好，但遗憾的是，由于对于C语言编程不是特别熟悉，包括受限于对库的了解、算法的时间复杂度较高、实现繁琐以及对于STM32内部利用效率的不完全开发等因素，最终并没有能够成功完成动态部分的路径规划。事实上，动态情况下的路径规划更符合我们在日常生活中常见的应用场景，不论是扫地机器人还是汽车导航，本身所应对的环境都在时刻发生着改变，因此动态的路径规划问题仍然值得在课程结束之后继续进行深挖和探索。希望在未来的工程实践中，我们能够以更加定量化的思维去分析和思考问题，同时更加熟练的掌握相关的算法设计，提高自己的硬件嵌入式编程能力。 六、个人总结 在路径规划这一阶段的课程中，我在前半段主要负责的是STM32单片机的一些基础开发，对于其基本的开发流程以及GPIO等基本的功能模块有了一定的了解并能进行一些简单的32单片机编程；在后半段，我主要负责整体路径规划项目的思路整理与算法设计，结合课堂上介绍的RANSAC识别算法以及人工势场法规划路径，课下积极结合概念的巩固以及相关资料的查询，阅读了相关的示例代码，并根据算法的整体思路自己动手实现了RANSAC算法对于直线与圆的识别拟合以及在建立的势场中利用梯度下降法实现路径规划的MATLAB程序，积极将自己的算法实现与队友编写的STM32 C语言程序融合在一起，在与队友的充分交流沟通与合作的基础上共同完成了该项目。在死亡之桥的测试项目中，我在一个人调试了单片机程序许久未果后，与队友进行了积极的沟通与合作，也基本确定了由我负责编写MATLAB算法程序给队友的单片机编程提供数据支持的合作模式，对于我们团队的所有人来说都是一次难忘的经历。在利用激光雷达扫描地图的过程中，我们也充分信任彼此，在他们编写好了读取雷达数据的相关程序后，我结合着MATLAB程序的需求对于KEIL代码的输出格式部分进行了一定的修改，在通力合作下最终圆满完成了该项任务。除此之外，也非常感谢整个课程阶段过程中凌睿老师在算法思路方面对我们进行的一系列教学与指导以及助教学长们在答疑时的倾力相助。","link":"/2023/06/25/QEA-Radar-Car/"},{"title":"20230610","text":"好久好久没在空间写过长文了。老实说最近一段时间状态一直不是很好，持续性混吃等死，间歇性踌躇满志，踌躇满志完了就只是满志然后接着混吃等死。好像也怪不了别人，但自控力缺乏确实让自己的生活变得混乱而失去条理，调整作息保持节奏也不是什么至关重要的大事。课程的压力与挑战性压得我们气喘吁吁，缺乏合理的规划和随波逐流最终逼迫我们牺牲自己的作息与效率与现实妥协。一路坎坷也算是跌跌撞撞走了过来，却又急着赶往下一个路口。所幸热爱可抵岁月漫长。唱歌总能让我短暂的忘却当下的烦恼，坚持自己喜欢的事情也远没有在一筹莫展的课上拼死拼活还一无所获来得痛苦。但短暂的忘却换来的是回归现实的剧痛。当众表演的机会甚至也变得没有那么神圣珍贵，从观众不在意到自己也不太纠结于细节乃至基本的背词，歌声和舞台一起变得廉价。可是我还是好感谢，合唱队有一群志同道合的伙伴。我们从来不是一个人在战斗，所以每一次排练和登台也都全力以赴。520专场第一次让大家看到了我们的努力与能力，也是给我们自己的一个交代。和一群人一起坚持自己的热爱真的是一件很酷都事情。可时光匆匆，转眼间又到了夏天。某一天推开门走到阳台，离开空调房的一瞬便紧接着热浪袭来，于是在恍惚之间，夏天真的来了，伴随着希望和遗憾。离乡的人还是逃不开乡愁，忘不掉的总是那些人那些事，虽然所有人都不再是当时的自己，却总是忍不住幻想那些如果和如果。可是离别的时刻仿佛就在眼前，此时却已经远在千里之外了。尽管知道命运冥冥之中捉弄着你我，可旧事重提之时只剩故作镇定之下的满腔遗憾。来到全新的环境但心永远留在了过去，总是喜欢将自己抽离用旁观者的视角去观察甚至经历现在的一切。于是也不可能再有那般的快乐与肆意。又是一年毕业季。彼时用一曲《入海》试图和过去告别，此时却再次唱响了这段相隔一整个盛夏的旋律试图宽慰另一群人。我分明记得，那个傍晚的天空与今日又有何异。但我们却渐行渐远，直到我们不再是我们。那么祝贺你们，即将奔赴新的人生阶段，不论结局是好是坏，起码它总不是现在。那是一个名为未来的光明前程。我也从来没有后悔过自己的选择，在间歇的迟疑中还是坚定了自己的热爱。可有些遗憾注定无法释怀。也祝贺我，决定奔赴每一个现在，不问过往和未来。总说人不能同时拥有青春和对青春的感受。曾经的我不信这个邪，于是深陷回忆的泥沼无法自拔。但事实上，无论当时的情感体验多么丰富而复杂，回首之时总会领悟到当时绝对无法参悟的感受。又何必挣扎，遗憾不需要填补，当阳光穿透阴霾，我们才真正成为自己。返程的校车穿过隧道，死寂的黑暗又重新笼罩。可我们依旧前行，追寻下一处光亮。翻山越岭之后，迎接自己的新生。","link":"/2023/06/10/20230610/"},{"title":"生命是什么","text":"看到一段很有趣的问答：“跨年的时候，烟花在想什么？”“我生如夏花之绚烂，死如秋叶之静美。” 谈到生命是什么、生命的意义这一类话题的时候，气氛总会没来由地变得郑重起来，总觉得这是一个很宏大的问题，我们穷尽一生可能也找不到答案。但我们仔细想想，即使是生命高等如人类，也逃不过生死的命运。于是“生命”的第一个要素就自然而然地出现了——生与死。如果把时间看作一条轴，每一个生命的过程都占据了其中的一段，那么生就意味着开端，而死自然意味着终结。而不管这段过程中发生了什么，生与死这两个概念始终都伴随着每一个生命，绽放后再慢慢走向凋零。但显然这样的描述不够准确，事实上绝大部分事物都有自己诞生与消逝的一刻，小到草木大至太阳都无一幸免。生命之所以是生命，正是因为他们有另一些特质，使得他们的生与死富有更多的意义。 我们不妨通过一些实例来加快我们思考的进度：在人们的固有印象中，石头不是生命，而参天大树是生命；水流不是生命，而凶禽猛兽是生命……在这样的枚举之中，我们不难发现，在我们的认知中，生命具有的另一个显著特征是，他们能够通过某种方式，从自己诞生的那一刻起，自发地从外界汲取资源，以维持自己的生存。乍一看这好像并无特别之处，但关键在“维持”二字。花草需要光合作用获取养分，猛兽需要捕食猎物获取食物，生命总需要依靠自己的能力获取些什么不断成长，这本身无可厚非。但我们不妨从另一面再次看待生命：花草如果一直生长在阴暗的环境与贫瘠的土壤中，获取不到足够的养分，会迅速枯萎而无法生长，甚至从一开始就无法萌芽；猛兽如果始终捕食不到足够的猎物，获取不到足够的营养，也会发育不良，饥饿至死。生命区别于其他事物的一大特征就在于，他们必须时刻依靠自己的能力从外界获取资源以维系自身生存，否则就会被环境淘汰而死去。石头在风化分崩离析之前依然是石头，太阳在聚变燃烧殆尽之前也依旧是太阳，他们不需要为了自己的生存去自发地做些什么，但生命需要。生命之所以是生命，即是因为他们必须时刻为了生存而奋斗，为了避免终结的那一刻过早地到来。 但仅仅将生命与其他的非生命体区分开来是远远不够的，尽管实际上具有以上两大特征的我们都可以称之为生命。如果我们再进入更深层的观察与思考，不难发现，其实对于大多数生命来说，假设没有其他因素的干扰且外界资源无限多，只需要通过能力维系生存这件事情本身并没有太大的难度，可这条假设显然并不成立。我们生活在同一个地球上，地球上的资源就这么多，太阳也总会有衰竭殆尽的那一天，作为生命的每一个个体也无时不刻不在彼此的交互中影响着各自的命运。在这样一个资源极其有限的混沌系统中，每一个生命个体都并非彼此割裂独立，这就导致了看似简单的维系生存事实上绝非易事。作为人类的我们，也是在经历了不断的进化以及社会演化发展后，才步入了如今衣食无忧的生活。但我们不妨回过头去观照我们的先辈，他们也曾经因寻找食物与安定的家园而四处奔波，时至今日仍然需要与随时可能发生的地震、台风、海啸等自然灾害作斗争。人类的生存维系远远没有我们日常生活中所遇到的那么简单，一些看似简单的行为也不过是长期进化而来的习以为常罢了。在人类发展的漫长历程中，我们始终与周遭的环境不断地做着一遍又一遍的斗争才从夹缝中觅得了如今的生存空间，在这个过程中，我们习惯把我们所抗争的事物称作“大自然”，也逐渐从与大自然斗争到从大自然索取再到如今的与大自然和谐共生。这个过程无疑是曲折而充满艰辛的，人类之所以伟大也正是因为我们在不断地运用自己的智慧克服无穷的艰难险阻，通过自己的努力为自己赢得更美好的明天。而事实上也不仅人类如此，无论是植物还是动物都在一代代的演化中无论是从脑力水平还是从生理结构功能上都在不断地适应着、改变着这个世界，用不懈的坚持为自己和族群赢得更长远的未来。正是因为这不对现实与自然力量屈服的毅力与勇气，生命才能称之为生命，而这样顽强不屈的抗争与奋斗精神以及不断向上成长迸发的精神活力，才是生命的魅力所在，也是生命的真正本质。因此，在我们的语言体系中，也将这样的精神本质赋予为“生命力”的体现。在与自然抗争的过程中，生命也在不断为适应环境而发生着一次又一次的进化，也因此生命与生命之间的差别越来越大，分化出了不同的种群，又在数千百年的发展中锻炼出了分工合作的可贵品格，产生了一定的社会性，这自然也是生命的一大特质，在彼此的交互之中生命才显得更有活力。 在分析完如上三个生命特质之后，我们不妨再回到“生与死”的概念上来，再结合后面两条，生命的另一层意义也呼之欲出。作为一个生命个体，我们自诞生以来，出于本能而不断为了自己的生存利用自己的智慧与生理能力不断拼搏奋斗，从外界环境中汲取养分，为的就是逃离那根随时可能到来的死亡之线，逃得越远越好。可似乎是命运冥冥之中已经注定，无论生命多么拼命的抗争，自然规律永远是我们无法逾越的天堑，就像光速永远是三乘十的八次方米每秒一样，我们终究会归于死亡。 可是，明知结局是无尽的死寂，太阳也会有熄灭的那一天，但所有的生命，都不约而同的选择在命运的洪流之中逆流而上，即使是本着“能多活一秒是一秒”的心态，也在不断地尽自己所能为自己和其他的生命赢得哪怕一丝生的希望。于是，生命才真正成为生命。 你无法阻止波涛汹涌，但你可以学会踏浪而行。 如果已经拼尽全力绚烂过，死亡又有何惧？ 谁又知道死亡何尝不是又一次的新生？ 生命要么是一场伟大的冒险，要么什么都不是。 生命的意义，就是即使知晓痛苦的结局，依然向着命运抗争。 生如远舟，向死而生。","link":"/2023/05/28/life/"},{"title":"具有一定扶正能力的船舶设计","text":"本项目定量分析部分Matlab代码已同步上传至Github,仓库链接：Asgard-Tim/QEA-Boat: 重庆大学明月科创实验班定量工程设计方法课程项目 (github.com) 一、项目介绍 在该项目中，我们需要设计制造一艘小船，该小船需要满足以下条件：该艘船的倾覆角度须满足在120°至140°的范围之内，即在倾斜角度到达120°之前都能够回正，同时在超过140°之后不再具有扶正的能力；此外，船体具备一定的载重能力（两罐听装可乐），不会沉没或者有太大（平衡位置甲板与水面夹角超过10°的倾斜）。为了达到以上的指标要求，我们将使用Matlab软件进行相应的定量分析设计，并以木板为材料进行加工制作。具体的呈现详见下文。 二、第一性原理分析 在明确需要达成的指标之后，我们需要使用第一性原理对需要解决的问题进行回归、逐层拨开，回到基本的数学物理公式之中，以便进行较为精确的定量化设计。深入过程见上图。 三、船体设计 3.1设计方向3.1.1第一性原理的实现倾覆角度（120°~140°）实现： 设计灵感来源于鱼漂（鱼漂主要分为漂尾、漂身、漂脚，三部分。漂脚大致分为碳脚、竹脚、钢脚等，漂脚的材质不同，自身的重量就不相同，漂脚越重整支鱼漂的重心就会偏下，使鱼漂入水后翻身站立的时间缩短，也就是我们常说的翻身快。）鱼漂的结构恰好可以很好地解决90°以上倾覆角回正的问题，即“头轻脚重”。通过为船体加装舰岛等提供浮力的模块以及合理调节船体各部分高度来进一步精确化满足倾覆角区间。 载重能力（约700g）实现： 除去船体本身的重量将实现700g左右的载重。船体设计将在船体舰岛中为所载货物预留空间，并且预留出排水体积（即预留最大吃水深度），以满足载重要求。 稳定性实现： 当船舶受到外力倾斜时，其重力的大小位置不发生变化，浮力的大小也不变，但浮力的中心位置会发生偏移。我们知道浮力作用的中心是水下体积的中心，当船舶倾斜时，水下体积形状发生改变，倾斜下沉一侧的水下体积会增加，此时浮力的作用中心会向倾斜的一侧移动，浮力和重力不在同一条直线上，他们形成的力矩和倾斜力矩相反，这就是船舶的复原力矩。只要船舶倾斜，船舶的复原力矩就必然出现，方向永远和船舶的倾斜方向相反，这就是船舶拥有稳性的原因。我们将船舶这种受到外力矩（如风浪等）的作用而发生倾斜，在外力矩消失后自行恢复到原来平衡位置的能力，称为船舶的稳性。 我们对船的剖面演示分析可以发现。当船发生倾斜时，浮心位置改变，我们将浮心所在的垂线于船体中心线交点称为稳心。当稳心在船舶的重心之上时，船舶可以回正。当稳心在重心之下，船舶就发生了倾覆。那么船舶横摇的角度达到多大的时候，我们的船会发生倾覆呢？我们分析研究稳性力臂随着船身倾斜角度变化的曲线。当稳心与重心等高时，也就是这条曲线由正变为负的时候，所对应的船身倾斜角度叫做稳性消失角。当船体的倾斜超过了这个角度，船就会翻。也就是说船舶倾斜在稳性消失角之前，稳心的位置比重心高，稳性力臂为正，复原力矩值也就为正，这时即使船体倾斜，也会回复到船舶原有的平衡位置。当船舶倾斜角度超过了这个稳性消失角，稳心位置就比重心低，稳性力臂比为负，复原力矩值也就为负数，那么这个时候就会发生翻船。这样就解释了船受到外力作用会在海中左右摇摆，随着外力的增加摇摆的更加激烈，船的横摇由于复原力矩的存在，能使其回正，但若超过了稳定消失角这个值，就会发生倾覆。 提高船体稳定性一是降低船体的重心来提高船舶的稳性。例如比赛帆船，通过加中竖龙骨的方法来降低它的重心，使其稳性消失角能够达到150度~170度的角度，接近于永不颠覆的船。另外，增加船宽也可以使船舶获得更高的稳性。例如对安全性要求较高的原油运输船，船体会比较宽，船型比较的矮胖。其他还有多种方式可以抵御船舶倾覆的风险。 动力实现： 动力大致分为驱动和电控两个模块，以及电池，螺旋桨的装配，选取适当控制模块来实现。 3.1.2船体造型与其他功能的实现本次项目设计船舶计划设计类似军舰外形的船体，并且达到船体轻巧，航速较快的目标，在此基础上可以实现节能，造价低廉的非硬性目标。 3.2船体初步设计方案 根据本次项目要求以及船型设计初衷（类军舰）采用了以上减小阻力的第一种设计类型，即通过收窄船体且前尖后宽的方式。 船头借鉴了05式两栖装甲突击车前减阻板的结构，并与上图传统船型结合的联合减租模型。 关于中国05式两栖装甲突击车 新型国产高速两栖突击车首先列装海军陆战队，已经成为海军利器。它不但能在摇摆的海上，精准摧毁敌方阵地工事，而且其强大的威力足以摧毁各型主战坦克。中国05式两栖突击车，操作简单，已没有离合器，具备浮渡精准射击能力。 简介 ZBD-05两栖步兵战车又被称为05式两栖步兵战车，是中华人民共和国研制的”05式两栖装甲车族“一员，装备中国人民解放军海军陆战队和陆军两栖机械化部队的滑水型高速两栖装甲车辆，部分言论称它与美国海军陆战队的”远征战斗车”(Expeditionary Fighting Vehicle, EFV)在概念上相似。 评价 该车外形新颖，车体前部的防浪板是带加强筋的，不但外形宽大而且具有液压伸直调节功能，可以根据海浪的高低和需要的航速自行调节其前倾角度，这就使得整个车体具有了滑行板的功能，在水中行驶时，通过滑行板将水的浮力和速度转化为上抬的力量，类似快艇一样，可以将整个车体短时抬离水面，降低阻力，提高速度。车体前后的防浪板再加上车体两侧打开的侧裙板，可以使得整个车体和水的接触面积大大增加，既增加了该型车在航渡中的稳定性和安全性，还能使得大口径武器如轻型坦克上的105mm火炮具有了在航渡过程中随时可以开火而不致翻沉。在正常陆战使用中，防浪板和后调节板收回车体，还能起到装甲防护的作用。 总结 05式两栖突击车独特巧妙的外形设计是它能快速机动的重要原因。车体前后部的防浪板外形宽大，能根据海浪的高低和需要的航速自行调节前倾角度。突击车在水中行驶时，防浪板将水的浮力转化为向上的力量，再配合车体两侧打开的侧裙板，将突击车短时抬离水面，从而大大降低阻力，提高速度。 舰岛部分以空心提供浮力为主，辅助来进行大角度回调。 驱动控制部分设计为电路模块，包括信号揭发部分，电动机控制部分；驱动模块包括电子调速器，电动机，螺旋桨模块以及锂电池。行进方式采用双桨无舵型，以两个推进器的差速法控制船体行进方向。 ※具体实现以及其他细节后续介绍这里不再给出 四、程序定量设计 4.1 量化指标的数学物理分析基于上述对实际问题的第一性原理分析后，我们不难得出，要使得负有一定载重的船体呈现出满足要求的扶正能力，关键在于对于船体稳定性的量化考察与计算。具体而言，我们可以通过重心、浮心、扶正力矩与稳性消失角等一系列量化参数对于船体的扶正能力进行进一步的定量描述，并根据定量分析结果调整船体设计使其具有相应的扶正能力。 4.1.1 重心重心（Centroids）即为重力中心，本质上是物体在重力场中所受重力作用的等效作用点。在对于船体扶正能力的定量分析中，我们需要通过物体重心与浮心的位置关系判断扶正力矩的正负从而得到稳性消失角以衡量船体的扶正能力。 事实上，由于实验环境处于重力场相对均匀的地表，重心和质心(Center of Mass)在误差允许范围之内可视为重合，因此在定量计算时，我们实际上是将重心等效于质心，通过对于船体质量中心的计算间接得到重力中心的三维坐标。 在上述理论事实的支撑下，我们成功地将问题转化为“如何求取物体质量中心”。不可忽略的一点是，在实际定量计算中，对于物体质量中心的求取首先要将整个物体进行离散化处理，即将物体视作由许多质点组成的质点系，再对这些离散的点进行处理；同时，由于项目中的船体负有载重，离散化的质点系处理过程还便于额外添加船体外壳之外的其他额外质量点（如配重的质心等）。因此，控制物体离散化（本质上是从x,y,z三个方向进行微分）的精度是使得质心坐标结果更为精确的重要一环。在离散化的基础之上，对于N（该项目中N=3）维空间中的质点系而言，在坐标系中有以下质量中心坐标计算公式： 其中X表示某一坐标轴；mi表示物质系统中，某i质点的质量；xi表示物质系统中，某i质点的坐标。 而具体到本项目中所处的三维环境下，又有如下更为细化的公式： 其中，x(y,z)为各坐标轴下质点分布的方程，ρ为船体材料的密度，dA为微分后每一小块的体积。 通过这一公式，就可以得出三维空间中物体离散化后的质点系的质量中心坐标。当离散化程度足够（微分步长足够小）时，在地表实验环境下，这一坐标同时也就是物体重心的坐标。 4.1.2 浮心浮心（Center of Buoyancy）是指浮体或潜体水下部分体积的形心，本质上是浮力的等效作用点。当浮体方位在铅直面内发生偏转时，其水下部分的体积虽保持不变，但其形状却发生变化，因而浮心的位置也相应的移动。在对于船体扶正能力的定量分析中，我们需要通过物体重心与浮心的位置关系判断扶正力矩的正负从而得到稳性消失角以衡量船体的扶正能力。 当物体放入流体中时，由于物体与流体的上下接触面受到流体的压强不等，上小下大，故会产生压强差，进而物体会受到流体竖直向上的压力，即受到流体的浮力。依据阿基米德定律，可得出物体受浮力大小为物体排开那部分流体所受到的重力。自然的，浮心的位置即为被排开流体部分的重心位置。若被排开流体的几何形状是规则的，那么浮心就在被排开的流体原先的几何中心。 事实上，在不同的倾斜角度情况下，物体在水下部分的形状都各不相同，因此随着倾斜角度的改变，浮心也在时刻发生着改变。而在某一固定倾斜角度时，对于浮心的求取本质上即为对于物体排开部分的水的重心求取。在上一节中我们详细阐述了如何计算物体的重心，只是在这里我们需要在不同的倾斜角度下分别求取水下部分的重心，具体计算原理完全一致，在此不过多赘述。但在浮心求取中涉及到的另一个问题是，应该如何确定船体水下部分的船体形状呢？在这里，我们引入水线的概念，即对于船体截面而言，水下部分与水上部分的分界线。上面提到，随着倾斜角度的改变，尽管排开水体部分的形状不尽相同，但提供的浮力大小一致，由阿基米德原理不难得出，即排开水的体积始终不变。因此，我们可以依据这条原理，得到各倾斜角度下水线的方程，与船体截面方程在水线之下的部分共同框定水下部分的形状，从而进行浮心的计算。 4.1.3 扶正力臂（矩）与稳性消失角船的稳性消失角(AVS)是角度θ，当船体的倾斜角度达到该角度后，船体就会倾覆而不再能够自动回倾。利用前两节给出的方法，我们可以得到船体的重心与浮心坐标，它们同时也是重力与浮力作用在船体上的等效作用点。而在这两个力的作用下，会对船体产生一个由重心与浮心之间的距离创建的力矩臂，浮力作用在该臂上以产生扭矩。随着倾斜角度的改变，扭矩的大小与正负也在不断改变，这里不妨规定船体扶正的力矩方向为正。在倾斜角度增大的过程中，力矩臂从正到负，而船体则在力矩臂由正转负的转折点时达到其AVS从而倾覆。当这一浮力产生的扭矩能够使得船体回到稳定平衡的原始位置时，它就是扶正力矩。为此，重心与浮心必须大致满足垂直对齐。如果这两个点稍微偏离对齐状态，则会产生一个扶正扭矩，将两个点推回到对齐状态。两点对齐的下一个可能角度是不稳定的平衡，这意味着如果稍微偏移，系统将无法恢复到其原始状态。当系统稍微偏离不稳定的平衡状态时，所产生的扭矩将改变角度，以使两点变得更加偏离对齐状态。 基于上述对于扶正力矩的定义阐述与分析，我们可以得出以下公式： 式中的GZ为重力作用线与浮力作用线的垂直距离，称为扶正力臂；而MR则为扶正力矩。 扶正力矩与扶正力臂在受力分析图中的呈现如下图所示： 上述分析中提到，稳性消失角仅仅与扶正力矩由正转负的过程有关。通过对于上述式子的观察，不难发现，由于船体扶正或倾覆仅仅取决于扶正力矩的正负，而该计算式中扶正力矩的正负仅仅由扶正力臂的正负所决定，因此基于我们的分析需求，要得到稳性消失角以衡量扶正能力，只需要关注扶正力臂的正负而不关心具体的数值大小，事实上由公式可知扶正力矩只是在扶正力臂的基础上乘上了恒为正的系数（浮力大小）。于是，关键即在于对于坐标系中扶正力臂的求取。具体到坐标系中扶正力臂的计算公式会在后续Matlab程序仿真实现时详细推导与阐述，在此不详细展开。 对于不同的倾斜角度而言，由于淹没部分的形状不同导致浮心位置不同，扶正力臂的大小和正负自然也不同。因此，为了得到稳性消失角，我们可以通过绘制不同倾斜角度下的扶正力臂数值图像，从而得出图像零点处的倾斜角度（横坐标）即为稳性消失角（如下图)。 4.2船体模型构建与仿真模拟4.2.1设计思路基于以上数学物理分析，结合定量分析的需求，我们制定如下设计流程： 具体到实际的设计流程中，我们考虑到如下事实：当船底形状越平，该船的重心越低，船在载重的时候越不容易倾斜，船的平衡性更好。因此，我们基于以上原理，首先通过设计手绘图纸（见附件：切片.docx）的形式确定每一个切片（即船体沿长度方向的横截面）的轮廓形状，然后将切片以草图的形式在Fusion360建模软件中进行绘制，再对各切片草图进行放样操作即可得到船体外壳建模模型；在建模的草图绘制过程中，同时又在y(宽度)方向以一定步长进行采样，得到一系列离散坐标点，从而导入Matlab中进行进一步的仿真定量分析，最终得到符合要求的稳性消失角。 4.2.2基于Fusion 360软件实现船体建模具体实现步骤如下： 将绘制的切片曲线草图依次插入作为画布，并根据草图轮廓（适当修正）利用多点曲线拟合工具得到每一个切片的草图（如下图），各切片之间相隔特定的长度。 在绘制草图曲线的过程中，对于拟合后的放样曲线在宽度方向上以0.5cm为步长进行采样，结合各切片所在的长度坐标可得到船体的点云数据(详见附件our boat.xlsx)，以供后续Matlab仿真处理。 切换至曲面工具，对得到的每一个切片草图的曲线轮廓进行放样操作，得到船体模型大致的表面曲线；再修改选择使用曲面切线，使得曲线更加符合设计草图并更加自然流畅；最后进行封顶，完成船体外形的大致建构。 4.2.3基于Matlab软件构造船体外壳曲面数学模型通过上述利用Fusion360进行的建模过程，我们成功地将切片的草图实体化成了3D模型，并在这一过程中获得了点云数据坐标。接下来，我们将记录在excel表格中的x、y、z点云坐标分别导入Matlab中的mat文件并命名为“X.mat”、“Y.mat”和“Z.mat”存储下来。随后，通过load命令将三个数据文件导入Matlab中的工作区，并利用cftool指令使用曲线拟合器，分别选择X、Y、Z数据，通过多项式对点云数据进行拟合，效果如下图所示。（详情见文件”ourboat.sfit”） 值得注意的是，在点云的获取过程中，我们以船体最下方的点在船体前端的投影作为坐标原点，以船体的长度方向作为x轴，由船头向船尾延伸；船体的宽度方向为y轴，以船的中轴线为分界线，沿x正方向看去左边y值为负，右边y值为正；船底到船顶为z轴正方向。 将所得到的拟合图与建构出的3D模型进行对比，除去比例尺的因素外，外壳形状基本一致，说明模型建构有效，数据与拟合函数可信度高，可以进行下一步仿真。在验证数据有效性的同时，我们也得到了拟合出的曲面函数（如图中右下“结果”框图所示），将其存于函数文件“calculate.m”中，便于后续仿真验证时进行调用。 除此之外，在仿真验证的程序中，我们在导入点集数据之外还需要对船体的各项参数进行定义，并给出微分步长，同时对已有的点集数据进行适当的处理使结果更加合理。 下面给出船体数学模型建立部分的Matlab实现代码： 123456789101112131415161718192021222324252627282930%Step1:船体数学模型建立%导入船体点集数据load('X.mat');load('Y.mat');load('Z.mat');%定义船体参数 单位：cm g%以下参数都基于对于船体实物的测量给出boat.L =39.9; %长boat.W = 17.4; %宽boat.HB = boat.W / 2; %半宽boat.D = 5.4; %深density_water = 1; % g / cm^3boat.mass = 2000; %船体外壳总质量%x为长，y为宽，z为深，做切片（微分）；切片数量为num%dx,dy,dz即为三个方向的微分步长num=100;dy = boat.W/num; dz = boat.D/num; dx = boat.L/num;%构建船体外壳曲面模型mesh.xs = 0:dx:boat.L;mesh.ys = -boat.HB:dy:boat.HB; mesh.zs = 0:dz:boat.D;[mesh.ygrid,mesh.zgrid] = meshgrid(mesh.ys,mesh.zs);[Xi,Yi]=meshgrid(mesh.xs,mesh.ys);Zi=griddata(X,Y,Z, Xi,Yi);%griddata:对二维或三维散点数据插值——增加有效数据量，减少误差surf(Xi,Yi,Zi);shading flat;axis('equal'); 在这里，我们运用了griddata插值函数，对于取样的点云进行了进一步的补充，使得拟合的函数模型曲面更接近于实际情况。所得到的船体曲面模型如下图所示。 至此，我们成功地在Matlab中对我们设计的船体进行了数学函数的拟合，并通过对于函数图像的绘制模拟出船体的外壳模型，同时在程序中对于船体的点云数据以及宏观参数与微分步长都进行了导入与定义，为后续的仿真过程做好准备。 4.2.4船体重心与浮心三维坐标计算及其Matlab实现重心计算：在前面的原理分析部分，我们已经给出物体重心的详细计算方法。 下面给出了Matlab中的实现代码： 123456789101112131415161718192021222324252627282930313233343536373839%Step2:计算船体重心的三维坐标:COM_x=0;%x轴上的重心COM_y=0;%y轴上的重心COM_z=0;%z轴上的重心tnt=0;%有效点个数i=find(isnan(Zi));Zi(i)=0;%去掉NaN点的影响for i=1:num for j=1:num COM_x=COM_x+Xi(i,j); COM_y=COM_y+Yi(i,j); COM_z=COM_z+Zi(i,j); tnt=tnt+1; endend%加入除船壳外的结构，数据均通过实际测量得出%可乐1m1=500;boat.finalmass=boat.mass+m1;x1=10;y1=0;z1=1;%可乐2m2=500;boat.finalmass=boat.finalmass+m2;x2=30;y2=0;z2=1;%桅杆m3=1000;boat.finalmass=boat.finalmass+m3;x3=20;y3=0;z3=8;%最终的重心三维坐标：COM_x, COM_y, COM_zdensity=boat.mass/tnt;COM_x=(COM_x*density+m1*x1+m2*x2+m3*x3)/boat.finalmass;COM_y=(COM_y*density+m1*y1+m2*y2+m3*y3)/boat.finalmass;COM_z=(COM_z*density+m1*z1+m2*z2+m3*z3)/boat.finalmass; 通过运行上述程序，我们可以得到我们设计的船在加上配重与桅杆后的最终重心坐标为： 各倾角下浮心计算：在原理分析部分我们提到，船体的浮心位置会随倾斜角度的改变而不断改变。结合我们在获取稳性消失角时的绘图需求，我们采用循环结构，对从0度到180的所有倾斜角度进行遍历，分别求出各角度下的浮心坐标。 以下是浮心三维坐标计算的Matlab实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243%Step3:计算船体浮心三维坐标%初始化：COB_x,COB_y,COB_z记录每个切片的浮心（2D）COB_x=[];COB_y=[];COB_z=[];MMass=[];%每个浮心点的权重（质量）tot_mass=0;%总质量Y=[];%遍历1-180度的所有theta值for theta=1:1:180 for i=1 :num %对每个x积分 ZZ=[];%记录该X下的Z轴坐标 for j=1 :num+1 %讨论y从-boat.HB到boat.HB t=calculate(i*dx,mesh.ys(1,j)); ZZ=[ZZ t]; end boat.hull = mesh.zgrid &gt; ZZ; %在所计算的Z的值之上的就是船的截面 %不同theta下的水线表示 %确定重力浮力平衡以迭代调整水线 d =water_line(mesh,theta,boat,dx,dy,dz,num);%寻找函数零点 y = mesh.ys; z = -tand(theta).*y+d; if theta&gt;90 &amp;&amp; theta&lt;=180 water = (mesh.zgrid-boat.D/2) &lt; z; elseif theta&lt;=90 &amp;&amp; theta&gt;=0 water = (mesh.zgrid-boat.D/2) &gt; z; end %定义淹没区域 sub_region = flipud(boat.hull)&amp;water;%矩阵交集,求取排水体积;&amp;位与运算（都是1才得1） %计算船体浮心 COB = centerOfMass2(sub_region,mesh); COB_z=[COB_z COB(1,2)]; COB_y=[COB_y COB(1,1)]; COB_x=[COB_x i*dx]; MMass=[MMass matrixSum(sub_region)]; tot_mass=tot_mass+matrixSum(sub_region); end %得出三维浮心坐标 ANS=centerOfMass3(COB_x,COB_y,COB_z,MMass,tot_mass,num);%计算三维浮心 COB_x=ANS(1,1); COB_y=ANS(1,2); COB_z=ANS(1,3); 从而我们可以得到不同倾斜角度theta下的浮心三维坐标。 在上述计算浮心的程序实现中，事实上我们是对于整个船体的浮心进行了整体的求取，具体而言是将船体沿x轴（长度）方向以一定步长微分为num（船体模型建构程序段中有给出定义，是微分的分数）份切片，每一片都分别求取重心的y-z坐标并最终沿x轴方向叠加得到整个船体的浮心。 具体到对于每一个切片的浮心求取，虽然实际情况中是船体在水中倾斜，但为了方便计算，我们不妨处理成船体不动而水线不断改变，当船体的倾斜角度为theta时，水线的斜率应为-tan(theta)；同时在计算时，基于浮力大小不变的原则，即船体淹没部分的体积不变，可以通过函数water_line进行迭代从而得到水线在船体切片的二维y-z坐标系的截距（在数据处理上对于迭代次数与精度进行限制以节约计算时间）。经过上述处理，我们可以得到各倾斜角度theta下各个切片平面中的水线方程。值得注意的是，这里为了使结果更加精确，我们将各点的x,y坐标重新带入了建构模型时所得到的calculate函数从而得到与实际更加接近的z值坐标，并以此来框定各个切片下的函数方程描述。在原理分析部分提到，在某一切片平面中，水线与水线之下的船体函数共同框定了水体淹没面积，对这一部分进行重心的求取即为切片的浮心。 下面给出water_line函数的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839function D_line = water_line(mesh,theta,boat,dx,dy,dz,num) number = 1; i=1; d = -0.02; d_gap = 0.07; density_water = 1000; while number&lt;100 y = mesh.ys; z = -tand(theta).*y+d; if theta&gt;90 &amp;&amp; theta&lt;=180 water = (mesh.zgrid-boat.D/2) &lt; z; elseif theta&lt;=90 &amp;&amp; theta&gt;=0 water = (mesh.zgrid-boat.D/2) &gt; z; end %水线下的水体矩阵 sub_region = flipud(boat.hull)&amp;water; %矩阵交集，求取排水体积 force=sub_region.*density_water*dz*dy*dx; %计算单个微分方块的力 lift= matrixSum(force); %整体浮力 up_force=lift-(boat.finalmass/num); %浮力剩余值 if up_force&lt;0 d=d+d_gap/i; elseif up_force&gt;0 d=d-d_gap/i; else break; end if up_force&gt;-0.01&amp;&amp;up_force&lt;0.01 %判断阈值，水线收敛 break; end i=i*2; %缩短步长 number=number+1;end D_line = d; End 此处同时展示部分功能函数： 12345678910111213141516171819202122232425262728293031323334353637383940function COM = centerOfMass2(masses,mesh) % centerOfMass2: computes center of mass in 2D % masses: matrix of masses % mesh: structure containing ygrid and zgrid % returns: Vector [ycom,zcom] M = matrixSum(masses); ycom = matrixSum(masses .* mesh.ygrid) / M; zcom = matrixSum(masses .* mesh.zgrid) / M; COM = [ycom,zcom];endfunction plotMatrix(A,mesh,cmap) % plotMatrix: plots a matrix using image % A: matrix % mesh: srtruct containing ys and zs % cmap: Colormap colormap(cmap); image(mesh.ys,mesh.zs,flipud(A),'AlphaData',0.5);endfunction M = matrixSum(masses) % matrixSum: returns total of all elements in the matrix % normally sum(m) computes the sums of the columns % selecting m(:) flattens the matrix and computes the sum of all elements % see https://stackoverflow.com/questions/1721987/what-are-the-ways-to-sum-matrix-elements-in-matlab M = sum(masses(:));endfunction ANS=centerOfMass3(XMass,YMass,ZMass,MMass,m,num)x=0;y=0;z=0; for i=1:num x=x+XMass(1,i)*MMass(1,i)/m; y=y+YMass(1,i)*MMass(1,i)/m; z=z+ZMass(1,i)*MMass(1,i)/m; end ANS=[x,y,z];end 4.2.5 船体扶正力臂计算与图像绘制扶正力臂计算原理与公式推导： 在原理分析部分中，我们给出了扶正力矩的定义与扶正力臂的图示，并揭示了只需要计算扶正力臂即可通过判断其正负来获得稳性消失角，但并没有给出具体在坐标系中的计算公式。在这里，将进行计算方法的推导并给出扶正力臂的计算公式。 在上述对于浮心坐标求取的代码实现阐述中，我们提出可以将水中船体的倾斜等效为以船体为参考系下水线的旋转。基于这样的分析思路，我们给出了如下左图所示的示意图，以对于扶正力臂的计算进行进一步的推导。 值得注意的是，尽管图中所表示的仅仅是船体的一个截面，但在实际情况中，若船体在无干扰情况下能稳定在水中平稳漂浮，船体重心与浮心的x坐标在误差允许范围内应可以视为一致，因此在仿真计算中，我们暂时忽略重心与浮心的x坐标而仅仅关心两者的位置关系及这一关系在y-z坐标上的体现。 基于这样的分析，结合上述图示，我们不难得出如上右图所示公式。 另外，所谓扶正力矩必然能够使得船体回正而非倾覆，这就要求力矩的方向应与倾斜角度theta增加的方向相反，因此我们不妨规定这一方向为正方向，在图中第二种情况中显示为船体向右（顺时针方向）倾斜，于是扶正力矩（臂）则以逆时针方向为正。基于这一原理，我们给出了如下方法以判定其正负性，这也是得到最终稳性消失角的关键一环。 在完成了上述推导之后，即可根据推导分析结果设计Matlab程序实现仿真验证。 该部分的程序实现代码如下： 12345678910%Step4:求恢复力臂 k1 = -tand(theta); if ((k1*COB_z+COB_y-COM_y)/k1)-COM_z&lt;0 flag1=1; else flag1=-1; end l = flag1*abs(COB_y+k1*COB_z-k1*COM_z-COM_y)/(k1^2+1)^0.5;%恢复力臂 Y=[Y,l];end 扶正力臂-倾斜角度图像绘制与稳性消失角： 在扶正力臂的求取部分，我们在不同的theta情况下用矩阵Y来存储各角度下的扶正力臂值，以便于绘制θ-l图像，从而根据观察图像得出稳性消失角。 以下为该部分代码实现： 12345%Step5:绘制扶正力臂曲线x=1:1:180;x1=1:1:180;y1=interp1(x,Y,x1,'spline');plot(x1,y1); 最终得到的图像如下图所示。通过观察图像，可以得到我们的船体模型的稳性消失角大致在120-140度之间，满足稳定性要求。 4.2.6误差分析(1)采样点云、拟合曲线与实际船体模型的误差： 由于采样的点云坐标是在对于手绘草图的建模刻画过程中进行读取的，与手绘出的供船体加工的切片草图仍然存在一定的差距，这会带来一定的误差；而在对于点云数据的插值与函数拟合过程中也存在着一定的误差。除此之外，载重的测量误差以及船体在实际加工建造时产生的误差也不可忽略。但由于缺乏一定的工具对于我们建造出的船体实体进行精确的测量与3D模型建构，在数据处理的过程中我们已经对于一些偏差较大的离散点数据进行了纠正或删除处理，使得最终的结果仍然在预期范围之内，并与实际情况相一致。 (2)Matlab仿真时微分步长不足够细分而引起的误差： 在程序仿真设计过程中，我们对于船体从x、y、z三个方向按一定步长分割为若干份，并重点研究沿x轴方向进行切分的各切片以求得船体的重心与浮心坐标。但在实际程序实现的过程中，考虑到运算速度与准确度等多方面因素，各个方向进行分割的份数num不可能做到逼近于现实的无穷大，在上述程序中我们经过测试得到的一个较为合适的num值为100，这导致我们的仿真计算与实际的情况仍然存在一定的误差。但由于采样点的数量也较为有限，num的有限选取也不会对最终的结果造成致命的影响，仍然可以使得船体的稳性消失角最终呈现在可控的目标范围。 五、初代船体制造与实现效果 5.1船型外壳5.1.1结构设计实现为了减轻船体重量，采用了木制板材作为船体材料，通过骨架搭建，外层包裹来实现船模外壳的搭建，过程中主要用到了实木板，白乳胶等材料，加工过程使用绳锯，切割机，打磨机以及电钻等工具。 首先，我们根据最初的船体建模，对模型进行切片处理，以此来获得设计船的肋骨图纸和甲板图纸的必要参数，并根据设计出的肋骨图纸以及甲板图纸加工船体骨架，并进行拼装（详见下图）。 然后利用乳胶，热熔胶和木板，将船体外构型粘贴以达到塑性目的。 5.1.2舰岛设计同样利用模板拼接的方式，构筑舰岛模型。此设计中舰岛的上半部分与下半部分并未粘接，属于分体，用于装载货物使用。 5.2 动力装置 电池：3.5V锂电池 130电机：3.5V 0.7W 双发推力约1.5N 电路板含有电机控制模块（MX1919H实现）与信号接收处理模块。此外设计了对水的感应电路，螺旋桨触水可以遥控发动，离水则发生断路不可发动 螺旋桨部分采用万向结构，这样来减弱偏移对传动的影响。 5.3 防水设计对于船体设计采用了报纸与乳胶混合贴合加固船体的方法，使船体表面硬化并做到初步防水，在彩绘之后涂刷丙烯酸透明防水胶达到更高水平的防水效果。 *船舶防水涂料的应用止水胶防水施工技术。止水胶是一种单组分，无溶剂，遇水膨胀的聚氨酯类无定型膏体，在隧道二次初砌施工缝处设止水胶防水带，以及在钢筋，管线等周围设置止水胶，当接缝中有水渗入时，止水胶的弹性压缩应力和遇水膨胀压力双重作用填塞缝隙，可以有效的防止因接缝不密封出现的渗漏情况，具有较好的密封止水性能，能抗大的水压力。 在舰岛可拆卸部分的设计中，我们采用了轮廓加橡塑胶带的方法，一方面使舱盖固定，另一方面填充缝隙达到防水的效果。 5.4 实现效果在额外载重约700g时，“冲浪者号”吃水过深，并且行进速度大幅降低，全速只有约0.15m/s，而且倾覆角度区间难以满足，于是我们对船体进行了进一步的改进与升级，以达到最初的设计要求。 六、基于定量分析的迭代 6.1 迭代方案思路基于上述的实验效果并结合Matlab建模仿真的结果进行比照，尽管从船型设计上来讲我们所设计的初代船体外形已经达到了额定的稳性消失角要求，具有一定的扶正能力，但在实际的工程测试过程中我们发现，由于船型设计得过小，在装载上配重后整体的吃水深度较大导致船舶在水中航行的稳定性与扶正力矩相关指标的实际表现并不尽如人意；除此之外，在Matlab仿真过程中给出的除船体外壳外的离散质量点的坐标数据也较为模糊，对于稳性消失角模拟的结果造成了一定程度上的印象。通过以上的分析，我们初步设想在迭代过程中尽可能对船体进行再加工，通过延长船体长度的方式扩大相同吃水深度下排开水的体积以提供更大的浮力，从而控制船体满载情况下的吃水深度仍然在可控范围内；同时在仿真模拟的过程中增加对于电力驱动模块中的电机、电池等具有相当质量的组件的坐标导入与运算，并对于各离散质量点的坐标进行精细化处理使其更接近于实际情况，以提高仿真模拟的准确度与有效性。 6.2 迭代方案的定量分析6.2.1 船体外形的修正基于上述的分析结果与初步迭代思路，我们初步定下了延长船体长度的再加工方案，结合对于已有船体的加工现状分析与船体的稳定性考虑，最终决定将船体长度延长至74cm。以下代码给出了对于重新设计的船体的基本参数的定义与设置： 12345678%定义船体参数 单位：cm g%以下参数都基于对于船体实物的测量给出boat.L = 74; %长boat.W = 16.5; %宽boat.HB = boat.W / 2; %半宽boat.D = 7; %深density_water = 1; % g / cm^3boat.mass = 653.8; %船体外壳总质量 除了船体的宏观参数调整之外，相应的，我们还需要在原有的点集数据基础之上对于延长后的部分进行数据的补充，并将新的点云数据集存储在Matlab文件中，再利用cftool曲线拟合器工具获得新的拟合函数表达式并导入函数文件calculate.m中以在后续的仿真模拟中重复调用。下图展示了新点云数据集所拟合出的函数曲面图像以及对应拟合函数的表达式： 在仿真验证的程序中，我们在导入新的点云数据后，为了进一步验证数学模型建构的准确性，仍然需要通过插值函数griddata补充数据并绘制函数曲面图像与fusion 360建模结果进行一定的比对，效果图如下: 6.2.2 离散数量点数据的校准与补充在第一代船的仿真模拟数据中，我们在船体外壳的点云数据之外仅补充了配重与桅杆两部分的质心坐标数据及其质量，而忽略了电控模块其余组件的相关数据，且显然由于电控模块中电池与电机的重量相对于船体整体重量来说并不可忽略不计，所以在本次迭代过程中，在Matlab仿真程序的代码实现中对于这一部分进行了补充，同时对于船体中各零散组件的质心坐标及其质量进行了相对精准的测量与估算，从而提高仿真模拟的准确度，使其更加贴近实际情况。补充调整后船体内的离散质量点的相关数据如下列程序段所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384%加入除船壳外的结构%可乐1m1=356;boat.finalmass=boat.mass+m1;x1=34;y1=0;z1=9.8;%可乐2m2=356;boat.finalmass=boat.finalmass+m2;x2=44;y2=0;z2=9.5;%桅杆m3=116;boat.finalmass=boat.finalmass+m3;x3=39;y3=0;z3=49.5;%上层外壳m4=116.1;boat.finalmass=boat.finalmass+m4;x4=0;y4=39;z4=12.5;%尾部甲板m5=49.4;boat.finalmass=boat.finalmass+m5;x5=64.5;y5=0;z5=6.2;%电池m6=185.1;boat.finalmass=boat.finalmass+m6;x6=12;y6=0;z6=5.5;%电机1m7=190.4;boat.finalmass=boat.finalmass+m7;x7=53;y7=4;z7=3;%电机2m8=191.6;boat.finalmass=boat.finalmass+m8;x8=53;y8=-4;z8=3;%电调1m9=49.4;boat.finalmass=boat.finalmass+m9;x9=20.5;y9=6;z9=7;%电调2m10=49.6;boat.finalmass=boat.finalmass+m10;x10=20.5;y10=-6;z10=7;%船桨1m11=43.5;boat.finalmass=boat.finalmass+m11;x11=73.5;y11=3.8;z11=1;%船桨2m12=40.3;boat.finalmass=boat.finalmass+m12;x12=73.5;y12=-3.8;z12=1;%前端甲板m13=18.2;boat.finalmass=boat.finalmass+m13;x13=20.5;y13=0;z13=6.3;%最终的重心三维坐标density=boat.mass/tnt;COM_x=(COM_x*density+m1*x1+m2*x2+m3*x3+m4*x4+m5*x5+m6*x6+m7*x7+m8*x8+m9*x9+m10*x10+m11*x11+m12*x12+m13*x13)/boat.finalmass;COM_y=(COM_y*density+m1*y1+m2*y2+m3*y3+m4*y4+m5*y5+m6*y6+m7*y7+m8*y8+m9*y9+m10*y10+m11*y11+m12*y12+m13*y13)/boat.finalmass;COM_z=(COM_z*density+m1*z1+m2*z2+m3*z3+m4*z4+m5*z5+m6*z6+m7*z7+m8*z8+m9*z9+m10*z10+m11*z11+m12*z12+m13*z13)/boat.finalmass; 在获得了更加精准的离散质量点的相关数据后，我们可以利用上述程序段的最后部分来计算整个船体在装载了配重与电力驱动模块后的重心在x、y、z轴上的坐标，结果如下图所示： 6.2.3 稳性消失角的最终呈现经过上述结合实际情况后对于点云与离散质量点的数据补充与完善，我们将新的数据导入Matlab程序并再次运行，最终得到了如下图所示的l-θ图像以反映船体倾斜角度与扶正力臂之间的函数关系： 该图也成功体现了改进后的船型设计仍然能够使得稳性消失角维持在120-140度之间，能够满足对于船体稳定性与扶正能力的相关要求，可以进行下一步的迭代加工操作。 七、迭代产品制造过程与实现效果 7.1 迭代产品制造7.1.1 船体再制造为解决原有船体载重后吃水过深的问题，第二代的“刃海级”加长了“冲浪者号”船体长度，本次船体长度在制造前进行了较为周密的运算（各模块重量数据见程序部分），通过对各模块质量的初步掌握，以及配重块和所载重物的估计重量，结合原船型截面面积，计算出额在不改变原有船模外形的前提下，所需加长船身的长度以及大致的吃水情况(船体加长至74cm，空载预估吃水2.87cm，满载预估吃水4.56cm，后经实验实际情况与估计值差距不超过10%) 7.1.2 电控系统改进由于船体整体加大增重以及为解决之前动力不足的问题，更换了另外一套控制系统（功率更大的电机，螺旋桨，电池，电子调速器以及信号接收发遥控系统），改进后的推力更强，满足了设计要求中对动力的需求。 电机参数情况： 实际安装情况： 7.1.3 驱动优化以及节能设计在更换大功率电机之后，电机发热明显增加，为了提高船舶的安全性，可靠性，在迭代过程中，加入了水冷却系统。除此之外为了合理利用船体空间并节约一定能源，在船舶顶部加装了与冷却系统相连的供电装置。 太阳能板与内置电池串联，同时并联水泵与控制板，达到水冷与控制喷水的效果。 额定发电电压：6V 发电最大：150mA 尺寸：60mm*110mm 7.2 迭代产品实现效果7.2.1 实验效果 空载条件下，倾覆角150° 载有饮料的条件下倾覆角大约为130° 7.2.2 微调满足设计要求船舶下水后未调整前倾覆角明显大于140°，于是在船体舰岛舱内加装配重块（仓顶左右两侧各25g），空载倾覆角135°左右，满载倾覆角125°左右。 八、最终成品与总结 8.1 “刃海级” 8.2 项目总结与感悟本次项目历经两次迭代，最后基本实现了项目设计要求，产品还存在需要改进的地方。第一代“冲浪者号”设计中在定量化设计步骤中有疏忽掉配重块的问题，帮助我们发现了我们定量化设计方法的问题所在，总结了第一代的经验之后第二代“刃海级”较为成功地实现了项目设计地要求。 产品的研发设计离不开严格的定量化分析，更离不开多次地迭代更新，在这个过程中我们可以不断学习用到的相关知识，包括电路，控制，材料，结构，力学，软件等等一系列的相关知识，给了我们更开阔的眼界，也锻炼了我们的能力和意志。最重要的是教会了我们定量化分析的思想，为以后项目及产品的开发提供了极大的帮助！","link":"/2023/05/19/boat/"},{"title":"进销存管理系统","text":"本项目全部代码已同步上传至Github,仓库链接：Asgard-Tim/Vendition: 重庆大学明月科创实验班软件设计课程作业 (github.com) 一、需求分析 1.1 进销存管理业务概述随着近年来世界各方面的发展进步和物联网时代的到来及其不断发展，货物销售行业发生了翻天覆地的巨大变革，随着从卖方市场向买方市场的转变，我国的零售行业迅速崛起，并且时时刻刻面临着日益激烈并不断变化的竞争环境。因此，提高进销存管理水平，探索降低成本的方法成为提高企业竞争力的必然选择[1]。 伴随着企业规模的不断扩大和企业效益的进一步发展，原先的管理已经不能跟上企业的发展步伐，更无法满足企业对管理工作快速、准确的要求。在销售业务不断增长的同时，公司日常所需要处理的数据量不断增长，公司内部运转周转的中间传递环节也逐渐增多，进而发展到非常的复杂的经营管理模式，同时，现在复杂多变的市场，人工管理等传统的方法方式在相关方面已无法应对。更为重要的是商品的进销存方面缺乏实时处理的相关分析，管理人员对及时传递资料和命令的需求得无法实现。最后发现如果能够在面对不同种类的货物信息时，能够让管理人员实时掌握销售流程及销售情况，进而支持管理人员对相关商品销售的运营并且可以有效地加速的周转率，从而可以进一步提高行业的服务质量。这时可以组建一个记录、更新、保存数据信息的数据库以建立和支持一个合理高效的软件项目[2]。 具体而言，进销存管理业务的核心是对于商品流动信息的储存与管理，主要涉及到商品品类的新增与删除、进货、商品销售与盘点、平库等相互关联的诸多业务流程。因此，在进销存管理系统中，我们需要让这些业务流程在系统中有所体现，从而达到高效管理的目的。 1.2 功能性需求1.2.1 商品信息管理在进销存管理系统中，需要提供渠道给操作管理人员以录入或删除商品信息，同时对于日常的进货与销售过程予以记录，并在需要的时候对库存中已有的商品种类与数量进行盘点，必要时还需要进行平库操作。这些流程会涉及到公司内的诸多部门，诸如采购部、市场部、财务部等，组织架构的复杂性也对软件系统设计的联动能力与处理效率提出了较高的要求。因此，我们不仅需要通过程序设计实现与实际操作对应的相关功能，对于操作人员在系统中输入的文本信息进行读取与必要的处理以模拟上述诸多对于商品实体的实际操作流程，同时还需要建立与实际仓库所对应的商品的数据库，通过对于所有商品的编号、名称、单价、库存数量与计量单位等具体信息进行存储，并在管理人员进行操作的过程中对库中存储的商品信息进行与实际情况同步的改动，实现更加高效的管理。 1.2.2 系统安全对于公司而言，系统的安全性是软件系统设计过程中一个至关重要的考虑因素，由于系统缺乏维护管理与必要的保护措施所造成的损失与影响将是不可估量且难以弥补的。在进销存管理系统中，系统安全的问题主要可能出现在操作权限与非法输入等方面。基于这样的考虑，软件系统在处理数据时，需要对于非法的输入进行区分并给予用户一定的操作提示；在功能上，需要通过账户密码匹配的机制以对于操作人员的权限进行一定的限制从而保证系统的安全性；在存储数据时，应对于存入的数据在写入文件的同时进行一定的加密操作，防止外部人员盗取或进行修改；同时在用户进行操作时，需要同步保留用户的操作记录，在必要时以供核查。 1.3 非功能性需求1.3.1 性能需求 1.系统必须具备高可用性，能够保证系统长时间连续运行的需求； ​ 2.系统的响应时间应尽可能的短，系统登陆、信息保存等操作响应时间小于1.5秒，信息查询等复杂操作时间小于2秒； ​ 3.数据库容量要大，能够满足商品采购、销售、库存管理等详细信息长时间保存的需求； ​ 4.可供多个用户分时使用该系统平台。 1.3.2 易用性需求 1.系统的相关提示信息一致，如进货、销售、删除、查询等操作功能，应尽可能使人容易理解； ​ 2.有明确的输入限制提示信息； ​ 3.中英文对应正确。 1.3.3 可扩展性需求 在系统底层设计时，需要强化系统的配置和扩展能力，主要体现在以下方面： ​ 1.系统底层支持的可扩展性； ​ 2.系统数据结构可搭建； ​ 3.系统信息展示的可配置性。 二、系统设计 2.1 系统开发方案进销存系统需要在简单快速，并且容易维护的、安全性强的开发环境中进行设计[3]。 2.1.1 系统开发技术事实上，进销存管理的过程，本质上是由操作人员对货物信息进行的一系列操作，而不论是操作人员还是货物，都是系统中的对象，操作人员具有账户和密码等属性，货物则具有编号、名称、数量的属性。基于这样的考量，本进销存管理系统基于命令行界面进行设计，利用面向对象的思想，选用Microsoft Visual Studio Code 作为系统开发工具，后台数据库采用txt格式的文本文件，开发语言选择C++语言。 2.2 技术架构设计系统技术架构上，从上往下分为表示层、业务逻辑层和数据层。系统对每一层定义功能明确的功能接口，同时在层次内实现组件化的接口实现。层次化、模块组件化的实现，使系统具备了最大程度的灵活度，从而能对业务需求的变化作出快速的反应，使系统具有很好的扩展性。 表现层主要是调用业务逻辑层的功能与用户直接进行交互。 业务逻辑层包含了所有业务逻辑的设计与实现，如用户登录、新增商品种类、删除商品种类、商品进货、商品销售、浏览商品信息、显示操作记录、盘点等。 数据层指具体存储系统各种业务数据的数据库系统，在本进销存管理系统中，选用了txt格式的文本文件作为数据库，以便于数据的快速读写。 本进销存管理系统的总体架构如图2.1所示。 图2.1 系统体系架构图 2.3 功能结构与模块设计2.3.1 系统管理该系统包括系统界面初始化、用户注册账户、用户登录等相关功能。系统管理模块主要具体实现以下功能： 1.系统界面初始化 用户进入系统，为用户显示操作功能菜单，提示用户进行相应操作；在用户完成一项操作后，刷新界面并重新初始化当前界面。 2.用户注册账户 若用户第一次使用该系统，需要注册自己的账号并设置密码，不符合规定的密码无效，需要重新注册；完成注册操作后，系统会自动将输入的账号与密码配对并存入数据库中，供登录时进行比对。 3.用户登录 若用户已有账号或已完成注册，可输入自己的账号、密码进行登录操作，若与数据库中的已有条目相一致，则说明该用户具有操作权限，可进入进销存系统内部模块进行下一步操作；若输入的账号与密码不匹配或输入有误，会提示用户重新进行输入。 2.3.2 商品采购、销售与库存管理商品采购、销售与库存管理系统主要包括新增商品种类、删除商品种类、商品进货、商品销售、浏览商品信息、显示操作记录、盘点与平库等相关功能。商品信息管理模块主要具体实现以下功能： 1.新增商品种类 输入需要录入系统的商品的编号、名称、单价、计量单位与库存数量等基本信息，增加商品种类，并同步在数据库中存入该商品的相关信息与操作记录。 2.删除商品种类 输入需要删除的商品种类的编号，即可在系统数据库删除该商品的所有条目信息，并在数据库中留下操作记录；若输入的商品编号无法在数据库中检索到，则该操作无效并给予用户反馈提示。 3.商品进货 对于数据库中已有的商品种类可以进行该操作，否则提示操作失败；输入需要进货的商品种类的编号，界面中会出现数据库中该商品的所有信息，再输入需要进货的数量，若进货的数量有效（为正数），会对应增加该商品的数量并存入数据库中，同时留下操作记录。 4.商品销售 对于数据库中已有的商品种类可以进行该操作，否则提示操作失败；输入需要销售的商品种类的编号，界面中会出现数据库该商品的所有信息，再输入需要销售出去的货物数量，若销售的数量有效（小于等于库存量且为正数），会对应减少该商品的数量并存入数据库中，同时留下操作记录。 5.浏览商品信息 可以将数据库中已有的所有商品的编号、名称、单价、计量单位与库存数量等基本信息以表格的形式展示在界面中以供操作人员进行核对查验。 6.显示操作记录 可以显示改变商品数量的所有操作的操作记录，包括每一次操作的操作类型、操作参数（输入的库存改变量）、操作人员账号和操作时间；其中平库操作进行标红处理。 7.盘点与平库 可以将数据库中已有的所有商品的编号、名称、单价、计量单位与库存数量等基本信息以表格的形式展示在界面中以供操作人员进行核对查验；在盘点完成后，若数据库中的商品数量与实际情况存在出入，在确认原因后可以选择进行平库操作，对于特定商品进行额外的出库或入库操作；平库操作会进行标红处理。 8.数据存储 为了保留已有的操作结果与操作记录，在每一次对于数据库中的商品进行操作时，都会从数据库中重新读取商品信息数据，并在操作完成后将改动之后的商品数据重新存入磁盘的数据库中，并在数据库中保留操作的记录以供日后查验；这也有利于不同操作人员在该系统平台上的协同操作，同时重新启动系统时程序的状态也不会发生改变。 2.4 设计目的与优势2.4.1 设计目的在系统界面与整体功能架构的设计上，对于两个模块均采取了先初始化界面显示操作列表、再根据用户的操作指令给予对应的提示、完成相应操作的模式进行设计，并在各个功能的完成过程中贯穿了对于数据库的读写操作以实时修改，以功能实现为导向，希望帮助操作用户更加高效地实现商品信息的读取与写入。 2.4.2 设计优势1.界面简洁自然，各项功能列表一目了然，方便操作人员迅速完成操作，减少误操作的概率； 2.对于所有输入的位点都进行了规范化处理，保证输入的数据格式都是合乎要求的，同时对于非法的输入操作都给予了反馈警告，便于用户快速上手； 3.设计功能齐全，可以满足大多数情况下商品的采购、销售与库存管理操作； 4.运用数据库实时储存用户信息、商品信息与操作记录，方便必要时进行查询，同时也有利于保存数据，支持多用户对于系统进行操作； 5.用户登录机制与操作记录保存机制为系统的安全性提供了一定的保障。 三、系统实现 本系统的具体框架如下图3.1所示。当成功登录窗口后，用户即进入到主界面中，此时用户可以通过模块选择在自己操作权限范围内的操作，并可在各个功能模块之间进行切换。 图3.1 系统功能流程图 3.1 命令行界面的初始化实现在设计时，我们根据需求，希望系统的界面能够在完成一项指令操作后刷新并重新加载操作功能菜单以使用其他功能。因此，在登录窗口与系统内部商品处理两个模块的界面加载中，采用了相同的实现逻辑以达到这一效果。具体实现逻辑如下图3.2所示。最终实现效果符合预期。 图3.2 命令行界面初始化流程图 3.2 登录界面——用户权限管理实现在登录界面，系统为用户提供了三个选项卡：用户登录、用户注册与退出系统，并分别有与之对应的操作代码。具体实现时，采用了选择分支结构，对于用户输入的功能编号进行检测，并对非法的输入给予反馈，提示需要重新输入正确的功能编号（本系统中所有需要输入操作代码的地方均采用了该流程，后面不再赘述）。 对于文件的读写，在程序中创建了相应的文件操作对象以进行相应的读写操作，并在每一次操作完成后关闭文件并重新打开以重置读写指针，防止影响到后续的操作。（进销存模块的文件读写操作与这里方式相同，后面不再赘述）。 对于用户的个人信息，设计了类user，具有用户名和密码两个私有属性，并设计了一系列公有函数对其进行读写，随后在用户注册与登录环节对该类进行实例化，并对实例化后的对象进行一系列的读写操作以实现功能。（在进销存模块中，对于商品类goods与操作记录类operations也采取了相同的方式进行处理，后面不再赘述）。 若选择“退出系统”选项卡，会提示用户是否确认退出：若确认推出，则立刻自动关闭窗口，反之则重新加载界面。效果图如图3.3。 若选择“用户注册”选项卡，会提示用户输入自己想要设置的用户名与密码（会提示用户用户名和密码只能包含字母和数字；用户名若与库中已有的用户名重复，会提示注册失败；密码还限制了位数不得少于六位，若不足六位也会提示注册失败，需要重新注册）；注册成功后，用户的信息会自动存入用户数据库文件“userinformation.txt”，同时重新加载界面。效果图如图3.4。 若选择“用户登录”选项卡，会提示用户输入用户名和密码，输入完成后与数据库中的对应文件进行匹配，若匹配成功则进入进销存系统模块（在程序编写过程中具体体现为进入函数login），反之则提示输入有误，请重新输入，并重新加载界面。效果图如图3.5。 该模块的详细实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;class user{private: string username; string password;public: void putusername(){cin&gt;&gt;username;} void putpassword(){cin&gt;&gt;password;} string getusername(){return username;} string getpassword(){return password;}};void initialize(){ cout&lt;&lt;&quot;********************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 欢迎您使用进销存系统 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 1.用户登录 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 2.用户注册 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 0.退出系统 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;********************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入您需要执行的功能编号:&quot;;}int main(){ while(true) { fstream userinformation; userinformation.open(&quot;userinformation.txt&quot;,ios::in|ios::app); initialize();//初始化界面 //账号注册与登录模块 string op1; cin&gt;&gt;op1; if(op1==&quot;1&quot;) { //用户登录，先让用户输入账号和密码 user user1; int flagin=0; cout&lt;&lt;&quot;请输入您的用户名:&quot;; user1.putusername(); cout&lt;&lt;&quot;请输入您的用户密码:&quot;; user1.putpassword(); //将用户录入的与文件中保存的账号密码进行比对 string use=user1.getusername()+&quot; &quot;+user1.getpassword(); while(true) { string inform; getline(userinformation,inform); if(inform==&quot;&quot;) break; if(use==inform) { cout&lt;&lt;&quot;亲爱的用户&quot;&lt;&lt;user1.getusername()&lt;&lt;&quot;,欢迎您登录本系统&quot;&lt;&lt;endl; Sleep(1000); system(&quot;cls&quot;); login(user1.getusername());//进入进销存系统 flagin=1; break; } } if(flagin==0) { cout&lt;&lt;&quot;您输入的账号或密码错误,请检查后重新输入&quot;; Sleep(1000); } } else if(op1==&quot;2&quot;) { //用户注册，输入用户名与密码 user user1; cout&lt;&lt;&quot;请输入您的用户名(仅可使用数字与字母):&quot;; user1.putusername(); //判断用户名是否已经存在 int flag=0; while(true) { string name; userinformation&gt;&gt;name; string empty; getline(userinformation,empty); if(name==&quot;&quot;) break; if(user1.getusername()==name) { cout&lt;&lt;&quot;您输入的用户名已经存在,注册失败,请重新输入&quot;&lt;&lt;endl; Sleep(1000); flag=1; break; } } userinformation.close(); userinformation.open(&quot;userinformation.txt&quot;,ios::in|ios::app); if(flag==0) { cout&lt;&lt;&quot;请输入您的用户密码(仅可使用数字或字母,不小于6位):&quot;; user1.putpassword(); //判断用户输入的密码是否符合要求，若符合要求则录入文件 string pass=user1.getpassword(); if(pass.length()&lt;6) { cout&lt;&lt;&quot;您输入的密码小于6位,请重新输入&quot;&lt;&lt;endl; Sleep(1000); } else { cout&lt;&lt;&quot;您已成功注册,请进行登录&quot;&lt;&lt;endl; userinformation&lt;&lt;user1.getusername()&lt;&lt;&quot; &quot;&lt;&lt;user1.getpassword()&lt;&lt;endl; Sleep(1000); } } } else if(op1==&quot;0&quot;) { int fl=0; while(fl==0) { cout&lt;&lt;&quot;您确认要退出该系统吗?(是请按1,否请按0)&quot;; int opp; cin&gt;&gt;opp; if(opp==1) exit(0); else if(opp==0) fl=1; else cout&lt;&lt;&quot;您输入有误,请重新输入&quot;&lt;&lt;endl; } } else { cout&lt;&lt;&quot;您输入了无效的操作代码,请重新输入&quot;; Sleep(1000); } userinformation.close(); system(&quot;cls&quot;); } return 0;} 图3.3 “退出系统”功能效果图 图3.4 “用户注册”功能效果图 图3.5 “用户登录”功能效果图 3.3 商品进销存功能实现进入进销存模块界面，系统为用户提供了八个选项卡：新增商品种类、删除商品种类、商品进货、商品销售、浏览商品信息、显示操作记录、盘点、退出登录，并分别有与之对应的操作代码。 若选择“退出登录”选项卡，会直接退出登录，停顿一秒后回到登录主界面。效果图如图3.6。 若选择“新增商品种类”选项卡，会提示用户输入需要新增种类的商品编号（不得与数据库中已有的商品编号相同，否则会提示重新输入），并依次提示输入商品的名称、单位、价格与库存数量；提示添加成功后，该商品的信息会自动存入商品数据库文件“goodsinformation.txt”，而相应的操作记录（包括操作编号、操作的商品编号、操作的种类、操作的商品数量、操作人的用户名与操作时间等详细信息）会被录入操作数据库文件“operationinformation.txt”(“删除商品种类”、“商品进货”、“商品销售”、“盘点”等操作也会在操作完成后录入该数据库，后面不再赘述)，同时重新加载界面。效果图如图3.7。 若选择“删除商品种类”选项卡，会提示用户输入需要删除的商品编号（必须是库中已有的商品种类，否则会提示重新输入）；提示删除成功后，数据库中该商品的条目信息也会一并删除，同时留下操作记录，并重新加载界面。效果图如图3.8。 若选择“商品进货”选项卡，会提示用户输入需要进货的商品编号（必须是库中已有的商品种类，否则会提示重新输入），并相应显示该商品的详细信息；用户还需要输入进货量（不可以为负数，否则提示重新输入）。提示进货成功后，数据库中该商品的库存量也会相应增加，同时留下操作记录，并重新加载界面。效果图如图3.9。 若选择“商品销售”选项卡，会提示用户输入需要销售的商品编号（必须是库中已有的商品种类，否则会提示重新输入），并相应显示该商品的详细信息；用户还需要输入销售量（不可以为负数或小于库存量，否则提示重新输入）。提示销售成功后，数据库中该商品的库存量也会相应减少，同时留下操作记录，并重新加载界面。效果图如图3.10。 若选择“浏览商品信息”选项卡，将会把数据库中所有货物的详细信息列举出来以供查看。效果图如图3.11。 若选择“显示操作记录”选项卡，将会把数据库中所有操作记录的具体信息列举出来以供查看。其中，平库过程中的出库与入库操作均会被标红。效果图如图3.12。 若选择“盘点”选项卡，将会把数据库中所有货物的详细信息列举出来以供查看，并在下方提示是否需要平库。若选择不需要平库，则会直接重新加载界面；若选择需要平库，则需选择需要出库或者入库（此行会被标红以示警告），出库操作与商品销售类似，而入库操作则与商品进货类似，在此不再重复。效果图如图3.13。 该模块的详细实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;#include&lt;ctime&gt;#include&lt;iomanip&gt;using namespace std;string gettime(){ time_t t=time(NULL); tm *now=localtime(&amp;t); int year=1900+now-&gt;tm_year; int mon=1+now-&gt;tm_mon; int day=now-&gt;tm_mday; int hour=now-&gt;tm_hour; int min=now-&gt;tm_min; int sec=now-&gt;tm_sec; string to_year=to_string( year ); string to_month=to_string( mon ); string to_day=to_string( day ); string to_hour=to_string( hour ); string to_min=to_string( min ); string to_sec=to_string( sec ); return to_year+&quot;-&quot;+to_month+&quot;-&quot;+to_day+&quot; &quot;+to_hour+&quot;:&quot;+to_min+&quot;:&quot;+to_sec;}class goods{private: string no; string name; string count; string price; int num;public: void putno(){cin&gt;&gt;no;} void putname(){cin&gt;&gt;name;} void putcount(){cin&gt;&gt;count;} void putprice(){cin&gt;&gt;price;} void putnum(){cin&gt;&gt;num;} void putnum(int input){num=input;} void putno(string input){no=input;} void putname(string input){name=input;} void putcount(string input){count=input;} void putprice(string input){price=input;} string getno(){return no;} string getname(){return name;} string getcount(){return count;} string getprice(){return price;} int getnum(){return num;}};class operations{private: string no; string kinds; int num; string acount; string date; int flag;public: void putno(string input){no=input;} void putkinds(string input){kinds=input;} void putnum(int input){num=input;} void putacount(string input){acount=input;} void putdate(){date=gettime();} string getno(){return no;} string getkinds(){return kinds;} int getnum(){return num;} string getacount(){return acount;} string getdate(){return date;} int putflag(int input){flag=input;} int getflag(){return flag;}};void systeminitialize(string username){ cout&lt;&lt;&quot;******************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 功能菜单 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 1.新增商品种类 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 2.删除商品种类 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 3.商品进货 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 4.商品销售 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 5.浏览商品信息 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 6.显示操作记录 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 7.盘点 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 0.退出登录 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;******************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;亲爱的用户&quot;&lt;&lt;username&lt;&lt;&quot;,欢迎进入进销存管理平台&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入您需要执行的功能编号:&quot;;}string CharToStr(char * contentChar){ string tempStr; for (int i=0;contentChar[i]!='\\0';i++) { tempStr+=contentChar[i]; } return tempStr;}void DelLineData(char* fileName, int lineNum){ ifstream in; in.open(fileName); string strFileData = &quot;&quot;; int line = 0; char lineData[1024] = {0}; while(in.getline(lineData, sizeof(lineData))) { line++; if (line == lineNum) continue; else { strFileData += CharToStr(lineData); strFileData += &quot;\\n&quot;; } } in.close(); //写入文件 ofstream out; out.open(fileName); out.flush(); out&lt;&lt;strFileData; out.close();}void login(string username){ while(true) { fstream goodsinformation; goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); fstream operationinformation; operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); systeminitialize(username);//初始化界面 //进销存系统内部操作 string op2; cin&gt;&gt;op2; if(op2==&quot;1&quot;) { goods good1; cout&lt;&lt;&quot;请输入商品编号:&quot;; good1.putno(); //检测输入商品的编号，若编号与之前的一致，则需要重新输入 int flag1=0; while(true) { string no; goodsinformation&gt;&gt;no; string empty1; getline(goodsinformation,empty1); if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(good1.getno()==no) { cout&lt;&lt;&quot;您输入的商品种类已经存在,本次录入操作失败,请重新输入&quot;&lt;&lt;endl; Sleep(1000); flag1=1; break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag1==0) { cout&lt;&lt;&quot;请输入商品名称:&quot;; good1.putname(); cout&lt;&lt;&quot;请输入商品单位:&quot;; good1.putcount(); cout&lt;&lt;&quot;请输入商品价格:&quot;; good1.putprice(); cout&lt;&lt;&quot;请输入商品库存数量:&quot;; good1.putnum(); cout&lt;&lt;&quot;添加商品种类成功&quot;&lt;&lt;endl; goodsinformation&lt;&lt;setw(10)&lt;&lt;good1.getno()&lt;&lt;setw(10)&lt;&lt;good1.getname()&lt;&lt;setw(10)&lt;&lt;good1.getcount()&lt;&lt;setw(10)&lt;&lt;good1.getprice()&lt;&lt;setw(10)&lt;&lt;good1.getnum()&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(good1.getno()); operate1.putkinds(&quot;新增商品种类&quot;); operate1.putnum(good1.getnum()); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } } else if(op2==&quot;2&quot;) { cout&lt;&lt;&quot;请输入您需要删除的商品编号:&quot;; string no1; cin&gt;&gt;no1; int flag2=0; int line=1; while(true) { string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { //删除商品信息 DelLineData(&quot;goodsinformation.txt&quot;, line); cout&lt;&lt;&quot;删除商品种类成功&quot;&lt;&lt;endl; flag2=1; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;删除商品种类&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } line++; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,删除商品失败,请检查后再试&quot;&lt;&lt;endl; system(&quot;pause&quot;); } else if(op2==&quot;3&quot;) { cout&lt;&lt;&quot;请输入需要进货的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //显示该商品在系统中的信息 cout&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; cout&lt;&lt;no2&lt;&lt;setw(10)&lt;&lt;name2&lt;&lt;setw(10)&lt;&lt;count2&lt;&lt;setw(10)&lt;&lt;price2&lt;&lt;&quot; &quot;&lt;&lt;setw(10)&lt;&lt;num2&lt;&lt;endl; //进货 cout&lt;&lt;&quot;请输入进货量：&quot;; int num1; cin&gt;&gt;num1; //判断非负 if(num1&lt;0) { cout&lt;&lt;&quot;进货量不能小于零,输入有误,请重新输入&quot;&lt;&lt;endl; break; } good2.putnum(num1+num2); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;进货成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;商品进货&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品进货失败,请检查后再试&quot;&lt;&lt;endl; system(&quot;pause&quot;); } else if(op2==&quot;4&quot;) { cout&lt;&lt;&quot;请输入需要售出的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //显示该商品在系统中的信息 cout&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; cout&lt;&lt;no2&lt;&lt;setw(10)&lt;&lt;name2&lt;&lt;setw(10)&lt;&lt;count2&lt;&lt;setw(10)&lt;&lt;price2&lt;&lt;&quot; &quot;&lt;&lt;setw(10)&lt;&lt;num2&lt;&lt;endl; //进货 cout&lt;&lt;&quot;请输入销售量：&quot;; int num1; cin&gt;&gt;num1; if(num1&lt;0) { cout&lt;&lt;&quot;销售量不能小于零,输入有误,请重新输入&quot;&lt;&lt;endl; break; } int out=num2-num1; if(out&lt;0) { cout&lt;&lt;&quot;库存量不足,无法销售,请核对后重新输入&quot;&lt;&lt;endl; break; } good2.putnum(out); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;商品销售成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;商品销售&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(0); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品销售失败,请检查后再试&quot;&lt;&lt;endl; system(&quot;pause&quot;); } else if(op2==&quot;5&quot;) { cout&lt;&lt;setw(10)&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; while(!goodsinformation.eof()) { string informate; getline(goodsinformation,informate); if(goodsinformation.fail()) break; cout&lt;&lt;informate&lt;&lt;endl; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } else if(op2==&quot;6&quot;) { int optime=1; cout&lt;&lt;setw(15)&lt;&lt;&quot;编号&quot;&lt;&lt;setw(15)&lt;&lt;&quot;商品编号&quot;&lt;&lt;setw(15)&lt;&lt;&quot;所作操作&quot;&lt;&lt;setw(15)&lt;&lt;&quot;数量&quot;&lt;&lt;setw(15)&lt;&lt;&quot;操作人账户&quot;&lt;&lt;setw(25)&lt;&lt;&quot;操作时间&quot;&lt;&lt;endl; while(!operationinformation.eof()) { int flag; operationinformation&gt;&gt;flag; string empty; getline(operationinformation,empty); if (flag==0) { string informate; getline(operationinformation,informate); if(operationinformation.fail()) break; cout&lt;&lt;setw(15)&lt;&lt;optime&lt;&lt;informate&lt;&lt;endl; optime++; } else if (flag==1) { string informate; getline(operationinformation,informate); if(operationinformation.fail()) break; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED); cout&lt;&lt;setw(15)&lt;&lt;optime&lt;&lt;informate&lt;&lt;endl; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED |FOREGROUND_GREEN | FOREGROUND_BLUE); optime++; } } operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } else if(op2==&quot;7&quot;) { cout&lt;&lt;setw(10)&lt;&lt;&quot;编号&quot;&lt;&lt;setw(10)&lt;&lt;&quot;名称&quot;&lt;&lt;setw(10)&lt;&lt;&quot;单位&quot;&lt;&lt;setw(10)&lt;&lt;&quot;价格&quot;&lt;&lt;setw(10)&lt;&lt;&quot;库存量&quot;&lt;&lt;endl; while(!goodsinformation.eof()) { string informate; getline(goodsinformation,informate); if(goodsinformation.fail()) break; cout&lt;&lt;informate&lt;&lt;endl; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); cout&lt;&lt;&quot;---------------------------------------------&quot;&lt;&lt;endl; int flagx=0; while(flagx==0) { cout&lt;&lt;&quot;是否需要平库?(是请按1,否请按0)&quot;; int op3; cin&gt;&gt;op3; if(op3==1) { int flagy=0; while(flagy==0) { //设置红色字体 SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED); cout &lt;&lt; &quot;您需要出库还是入库?(出库请按1,入库请按0):&quot; ; int op4; cin&gt;&gt;op4; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED |FOREGROUND_GREEN | FOREGROUND_BLUE);//把颜色换回来 if(op4==0) { flagy=1; cout&lt;&lt;&quot;请输入需要入库的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //入库 cout&lt;&lt;&quot;请输入入库量：&quot;; int num1; cin&gt;&gt;num1; //判断非负 if(num1&lt;0) { cout&lt;&lt;&quot;入库量不能小于零,输入有误,请重新输入入库量:&quot;; break; } good2.putnum(num1+num2); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;商品盘点成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;盘点入库&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(1); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品盘点失败,请检查后再试&quot;&lt;&lt;endl; } else if(op4==1) { flagy=1; cout&lt;&lt;&quot;请输入需要出库的商品编号:&quot;; goods good2; string no1; cin&gt;&gt;no1; int flag2=0; int line=0; while(true) { line++; string no2; goodsinformation&gt;&gt;no2; string name2; goodsinformation&gt;&gt;name2; string count2; goodsinformation&gt;&gt;count2; string price2; goodsinformation&gt;&gt;price2; int num2; goodsinformation&gt;&gt;num2; if(goodsinformation.eof())//判断是否读取到文件末尾 break; if(no2==no1) { flag2=1; //出库 cout&lt;&lt;&quot;请输入出库量：&quot;; int num1; cin&gt;&gt;num1; if(num1&lt;0) { cout&lt;&lt;&quot;出库量不能小于零,输入有误,请重新输入出库量:&quot;; break; } int out=num2-num1; if(out&lt;0) { cout&lt;&lt;&quot;库存量不足,无法完成出库操作,请核对后重新输入出库量:&quot;; break; } good2.putnum(out); good2.putno(no2); good2.putname(name2); good2.putcount(count2); good2.putprice(price2); DelLineData(&quot;goodsinformation.txt&quot;, line); goodsinformation&lt;&lt;setw(10)&lt;&lt;good2.getno()&lt;&lt;setw(10)&lt;&lt;good2.getname()&lt;&lt;setw(10)&lt;&lt;good2.getcount()&lt;&lt;setw(10)&lt;&lt;good2.getprice()&lt;&lt;setw(10)&lt;&lt;good2.getnum()&lt;&lt;endl; cout&lt;&lt;&quot;商品盘点成功&quot;&lt;&lt;endl; //保留操作记录 operations operate1; operate1.putno(no2); operate1.putkinds(&quot;盘点出库&quot;); operate1.putnum(num2); operate1.putacount(username); operate1.putdate(); operate1.putflag(1); operationinformation&lt;&lt;operate1.getflag()&lt;&lt;endl; operationinformation&lt;&lt;setw(15)&lt;&lt;operate1.getno()&lt;&lt;setw(15)&lt;&lt;operate1.getkinds()&lt;&lt;setw(15)&lt;&lt;operate1.getnum()&lt;&lt;setw(15)&lt;&lt;operate1.getacount()&lt;&lt;setw(25)&lt;&lt;operate1.getdate()&lt;&lt;endl; operationinformation.close(); operationinformation.open(&quot;operationinformation.txt&quot;,ios::in|ios::app); break; } } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); if(flag2==0) cout&lt;&lt;&quot;系统中没有编号为&quot;&lt;&lt;no1&lt;&lt;&quot;的商品信息,商品进货失败,请检查后再试&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;输入有误,请重新输入&quot;&lt;&lt;endl; } flagx=1; } else if(op3==0) flagx=1; else cout&lt;&lt;&quot;输入有误,请重新输入&quot;&lt;&lt;endl; } goodsinformation.close(); goodsinformation.open(&quot;goodsinformation.txt&quot;,ios::in|ios::app); system(&quot;pause&quot;); } else if(op2==&quot;0&quot;) { cout&lt;&lt;&quot;正在为您登出中……&quot;; Sleep(1000); return; } else { cout&lt;&lt;&quot;您输入了无效的操作代码,请重新输入&quot;; Sleep(1000); } goodsinformation.close(); operationinformation.close(); system(&quot;cls&quot;); }} 图3.6 “退出登录”功能效果图 图3.7 “新增商品种类”功能效果图 图3.8 “删除商品种类”功能效果图 图3.9 “商品进货”功能效果图 图3.10 “商品销售”功能效果图 图3.11 “浏览商品信息”功能效果图 图3.12 “显示操作记录”功能效果图 图3.13 “盘点”功能效果图 四、总结 本文首先对进销存管理业务的现状进行归纳，通过分析目前的进销存管理流程，找出存在的问题和原因，对信息化手段给进销存管理带来的好处进行评估，并制订流程以改进管理方案，从系统功能、性能、运行环境等方面提出进销存管理系统的需求，确定开发方案，本着面向对象编程的核心思想，根据数据结构，找到实体间的关系，细化设计思路，并最终依托命令行界面完成了整个进销存管理系统的设计与实现。 根据需要，本进销存管理系统采用三层架构设计，功能模块涵盖了系统管理与商品信息管理两大板块，采用文本文件作为整个系统的数据库，具有实用性、通用性、使用性、扩充性、安全性能高，维护成本低等优点。 在完成了初版的整体设计以及程序实现之后，又对其各项功能进行了多方面的测试，针对其中不足的方面以及小的漏洞进行了进一步的调试、修正、完善与迭代，目前已经能够正常运行。在整个项目的完成过程中，一方面是对于C++编程语言的掌握在实践中进行又一次的巩固加强，另一方面也是对于面向对象这一重要的程序设计思想的深入体会。 总而言之，个人对于本次进销存管理系统项目的完成度是比较满意的，但目前的系统程序仍然存在着许多问题有待于进一步深入研究与学习。一方面是模块化的程度并没有达到预期的效果，整个程序结构仍然稍显冗长。事实上在整个程序设计过程中，受限于不断要对文件进行读写，很难将每一个选项卡单独拆分出来作为独立的函数，同时对于面向对象过程中类的使用仅仅停留在对于其内部私有成员的封装与访问，而并没有涉及到更进一步的针对于特定对象的函数编写与使用 ，希望之后可以进行进一步的迭代与改进。另一方面，虽然在界面设计时本着简洁实用的思想，但很多流程上以及设计上的细节仍然可以进一步深挖改进，这也需要基于一定的实际投放测试并收集反馈来进行；同时受限于时间紧迫，对于QT图形界面无法进行详细的学习以应用在本项目中，希望如果之后有机会可以基于QT界面对于本进销存管理系统进行进一步的重塑与迭代。 参考文献 [1] 郭宁 , 郑小玲.管理信息系统[M].北京 : 人民邮电出版社 , 2009. [2] 刘俊 , 钱瑞明 , 基于 B/S 结构、面向供应链的供销管理系统设计[J] , 微计算机管理 , 2004 ( 1 ) : 42-43 [3] 吴雪海.食品公司进销存系统设计与实现[D].导师：赫枫龄;张雪松.吉林大学,2015.","link":"/2023/05/02/vendition/"},{"title":"20230320","text":"“十九岁的憔悴朋友 生活从不搭理心结啤酒 笑声和烟朋友 和我聊聊疲倦”——蔡维泽《十九》十四岁的时候第一次听到这首歌，或许那时的我从来不会想到，五年后的自己，会来到这座陌生的城市，开启自己新的生活。可是弹指一挥间，我们就已经长大了。不知道下一次再听到这首歌，想起那个和那些如烟火般绚烂的夏天，又会是谁的十九岁呢？小的时候，觉得大人总是忘记自己的生日是一件特别不可思议的事情。可是，直到一两周之前，我才猛然发现，被忙碌的生活裹挟着的我们，竟也一步步沦为这样的可悲。忙里偷闲，在快节奏的学习生活里学会享受生活的美好与“慢乐”，或许是之后很长一段时间内的人生课题吧。很久没有发过说说了。很大一部分原因是，在经历了那些值得纪念的盛大之后，往往都已经精疲力竭了；而等到精力回复好的时候，却早已失去那股新鲜劲，分享的欲望已不在了。虽然事实上，生活中许多琐碎而有趣的美好瞬间，似乎比那些精彩的活动更加值得纪念。生活着的每一分每一秒，都在真实地塑造着我们每一个人。但是。尽管数不清的琐事和艰巨的项目让空闲显得那么难能可贵，尽管学习的压力逐渐消磨着我们分享与记录的欲望与能力，可值得庆幸的是，当我们还想同感彼此的悲欢，倾诉彼此的心声的时候，你们依然在我的身边，依然是那些最值得分享与信赖的朋友。所以，我仍然觉得我是幸运的。起码，比十九岁的蔡维泽，要幸运很多。希望，在遍体鳞伤之时，我们都能迎来，属于自己的浴火重生。去看更大的世界，体验更缤纷的人生。无限风光在险峰，无限伟岸雄伟壮观，有些路或许一生也难以用脚丈量。那么，就勇敢的向前走吧。再见了，我的十八岁。终究和你迎来告别。你好，十九岁。十九岁的你，应该会比十八岁更厉害吧。但还是希望你，和你的朋友们，健康而快乐地，度过未来的每一天。“我们仍是唱着歌的，不论悲喜的明天。”","link":"/2023/03/20/20230320/"},{"title":"寻迹小车","text":"一、绪论 1.1 实验背景1.1.1 问题的情景长期以来，由于我国是人口大国而且工业基础薄弱，因此早期在我国机器人的发展受到一定的限制。然而随着制造业工人的人力成本的不断上升与社会自动化程度的不断提高，我国也开始着重于发展机器人，并且也取得了较大的进步。在 1995 年，我国沈阳自动化所开始研制HT—100A点焊机器人，是我国较早的机器人了，如图1所示；此后，沈阳新松公司研发出了6 kg弧焊机器人，此机器人不仅实用，而且轻便，如图 2 所示；之后，哈尔滨工业大学机器 人研究所也研发出了便携式机器人，此机器人具有 6 自由度，增强了焊接能力，成为在恶劣环境中实现焊接功能的重要设备。总之，在国家“863 计划”与“十一五”计划的指导下，我国机器人的设计取得了飞速发 展，甚至在机器人的某些关键部件的设计已经接近于世界先进水平，并在世界工业机器人领域已经占有一席之地了。 1.1.2 实验的目的目前，机器人的发展趋势非常的迅猛，机器人可以替代人类去从事高危险的工作，减轻了人类的劳动强度。本文通过对机器人的发展史进行简要的介绍，阐明了我国发展机器人的必要性。同时，对于我国的发展而言，我国正处于工业化进程的关键时期，将来的高强度、高危险行业的工人数量将会急剧的下降，机器人将会迎来新的“春天”，所以机器人的发展仍拥有巨大的发展空间。同时，由于我国各机器人的厂商对于机器人的研发能力与金钱投资的不同，在我国的机器人市场上的竞争也会愈演愈烈，最终也将形成我国的机器人研发市场。总之，在未来的几十年里，相信重点发展机器人将会成为社会的发展趋势，不久机器人将会引领未来，加入到我国现代化建设的行列中。小车，也就是轮式机器人，作为以学科交叉、产品创新为特色的明月班同学，切入这个产业不失为优秀的选择，故而选取小车为切入点了解相关知识。 1.2 实验内容1.2.1 使用51单片机控制及其元器件STC89C52控制板芯片、1.5V干电池x4、L298N电机驱动板x1、红外循迹模块、直流电机x2以及搭建材料若干； 1.2.2使用FPGA开发板控制及其元器件Cyclonell EP2C5T144控制板芯片1.5V干电池x4、L298N电机驱动板x1、红外循迹模块、直流电机x2以及搭建材料若干； 二、实现过程 2.1 总体工作原理简释2.1.2 红外循迹模块第一步，位于小车前端的红外模块会释放红外线探测下方是否为黑色区域，并将相应的高低电平信号传递至控制模块（51单片机/FPGA开发板）处理，控制模块随后将发送信息至L298N电机驱动的控制模块，并由此控制左右两轮的转动速度以及转动方向，从而实现对黑线的反应和循迹。 作为电机的驱动模块，该模块对控制小车移动有着重要且直接的作用。 利用红外发射器向地面发射红外线，并用传感器接收由地面反射的红外线。当红外接收模块下方为黑色轨迹时，红外线被黑色轨迹吸收，传感器没有接收到红外线，红外循迹模块输出低电平到单片机。反之，传感器接收到红外线，红外循迹模块输出高电平到单片机。可通过红外循迹模块输出的信号来判断小车是否偏离轨迹。可调电阻可以调节传感器的灵敏度，易于调试。使用红外循迹模块方案也易于实现，红外循迹方案相比于摄像循迹成本更加便宜，软件设计更加简单，设计制作周期短，具备一定可靠性。 对于左电机，共有输入ENA、IN1、IN2，输出OUT1（黑线）、OUT2（红线）、其信号与运动对应如下：（0,X,X）停止、（1,0,0）停止、（1,1,0）正传、（1,0,1）反转、（1,1,1）停止； 对于右电机，共有输入ENB、IN3、IN4，输出OUT3（黑线）、OUT4（红线），其信号与运动对应如下：（0,X,X）停止、（1,0,0）停止、（1,1,0）反传、（1,0,1）正转、（1,1,1）停止。 2.1.3 L298N电机驱动模块 L298N是ST公司的一款电机驱动芯片，也是集成了双H桥，但与上面两个略有不同。电机驱动电压3~48V；可持续工作的输出电流为2A，峰值可达3A。如上图，L298N模块明显有较多的外接元件，这与L298N的内部结构有关。如上图，由于该芯片在H桥上的损耗严重发热较明显（饱和压降大），需要加装散热片，因此在使用上比前两个芯片复杂，体积也相对较大。其各引脚如下图所示。 2.2 使用51单片机部分2.2.1 硬件接线 1为电源输入，与电池盒的输出线相连；2为电源输出，3为驱动板输入，两者需要相连，注意红线为VCC，黑线为GND；4 为单片机IO口引脚，5为驱动板的IN1到 IN4以及ENA和ENB，按照器件上的标注对应连接即可。 6 为与循迹模块的对应接口，按照器件上的标注对应连接即可。 7 和 8 为驱动板与两个电机之间的连线，按照上图所示连接即可。 到这里，基本完成了小车的硬件组装与线路连接，小车要完成循迹进行这些连线就够了，不过在烧录程序到单片机中时还需要 额外的连线，这个将在后面进行说明。 供电上使用四节5号电池。 2.2.2 程序设计首先是如何处理红外模块的探测结果。我们需要先对结果进行编码。我们记没有识别到黑线为0，识别到为1，则我们需要一个算式来囊括左右传感器结果并能对不同情况进行表示。在这里，我们记data2为左边的结果，data3为右边的结果，现给出算式data1=data2*10+data3，data1即检测结果。根据data2、data3不同组合：（1,1）在黑线上；（1,0）略向右偏离；（0,1）略向左偏离；（0,0）完全偏离轨道，分别对应了data1的四个取值，即11、10、1、0，亦即四种情况。相应的，我们需要做出四种反馈，即“前进”、“左转”、“右转”、“停下”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;reg52.h&gt;//51头文件unsigned char pwm\\_val\\_left, pwm\\_val\\_right; //中间变量unsigned char pwm\\_left, pwm\\_right; //定义PWM输出高电平的时间的变量（用户操作PWM的变量）#define PWM\\_DUTY 100 //定义PWM的周期，数值为定时器0溢出周期，假如定时器溢出时间为100us，则PWM周期为10ms。#define PWM\\_HIGH\\_MIN 35 //限制PWM输出的最小占空比#define PWM\\_HIGH\\_MAX PWM\\_DUTY //限制PWM输出的最大占空比/\\*电机驱动IO定义\\*/sbit leftMotorPwm = P1^5; //为1 左电机使能sbit IN1 = P1^4; //为1 左电机正转sbit IN2 = P1^3; //为1 左电机反转sbit IN3 = P1^2; //为1 右电机反转sbit IN4 = P1^1; //为1 右电机正转sbit rightMotorPwm = P1^0; //为1 右电机使能sbit leftSensor = P3^4;//左传感器：为0没有识别到黑线，为1识别到黑线sbit rightSensor = P3^5;//右传感器：为0没有识别到黑线，为1识别到黑线void Timer0\\_Init(void); //定时器初始化void LoadPWM(void);//装入PWM输出值void forward(unsigned char LeftSpeed, unsigned char RightSpeed);//前进void left\\_run(unsigned char LeftSpeed, unsigned char RightSpeed);//左转void right\\_run(unsigned char LeftSpeed, unsigned char RightSpeed);//右转void back(void);//后退修正void Tracking(){//为0 没有识别到黑线 为1识别到黑线char data1, data2 = leftSensor,data3 = rightSensor;data1 = data2\\*10+data3;if(data1 == 11)//在黑线上，前进{//forward(120,120);//前进forward(70,70);//前进}else{if(data1 == 10)//小幅偏右，左转{//left\\_run(80,160);//左转left\\_run(70,70);//左转}if(data1 == 1)//小幅偏左，右转{//right\\_run(160,80);//右转right\\_run(70,70);//右转}if(data1 == 0)//大幅偏左或偏右，已脱离轨道{back();//后退校正}}}/\\*主函数\\*/void main(void){Timer0\\_Init();//定时0初始化while(1){Tracking();}}void forward(unsigned char LeftSpeed,unsigned char RightSpeed){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 1;IN2 = 0;IN3 = 0;IN4 = 1;}void left\\_run(unsigned char LeftSpeed, unsigned char RightSpeed){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 1;IN2 = 0;IN3 = 1;IN4 = 0;}void right\\_run(unsigned char LeftSpeed, unsigned char RightSpeed){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 0;IN2 = 1;IN3 = 0;IN4 = 1;}void back(void){pwm\\_left = LeftSpeed,pwm\\_right = RightSpeed;//设置速度IN1 = 0;IN2 = 1;IN3 = 1;IN4 = 0;}/\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\* Timer0初始化\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/void Timer0\\_Init(void){TMOD |= 0x02;//定时器0，8位自动重装模块TH0 = 164;TL0 = 164;//11.0592M晶振，12T溢出时间约等于100微秒TR0 = 1;//启动定时器0ET0 = 1;//允许定时器0中断EA = 1;//总中断允许}/\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\* Timer0中断函数\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/void timer0\\_int (void) interrupt 1{pwm\\_val\\_left++;pwm\\_val\\_right++;if(pwm\\_left &gt; PWM\\_HIGH\\_MAX) pwm\\_left = PWM\\_HIGH\\_MAX; //如果左输出写入大于最大占空比数据，则强制为最大占空比。if(pwm\\_left &lt; PWM\\_HIGH\\_MIN) pwm\\_left = PWM\\_HIGH\\_MIN; //如果左输出写入小于最小占空比数据，则强制为最小占空比。if(pwm\\_right &gt; PWM\\_HIGH\\_MAX) pwm\\_right = PWM\\_HIGH\\_MAX; //如果右输出写入大于最大占空比数据，则强制为最大占空比。if(pwm\\_right &lt; PWM\\_HIGH\\_MIN) pwm\\_right = PWM\\_HIGH\\_MIN; //如果右输出写入小于最小占空比数据，则强制为最小占空比。if(pwm\\_val\\_left&lt;=pwm\\_left) leftMotorPwm = 1; //装载左PWM输出高电平时间else leftMotorPwm = 0; //装载左PWM输出低电平时间if(pwm\\_val\\_left&gt;=PWM\\_DUTY) pwm\\_val\\_left = 0; //如果左对比值大于等于最大占空比数据，则为零if(pwm\\_val\\_right&lt;=pwm\\_right) rightMotorPwm = 1; //装载右PWM输出高电平时间else rightMotorPwm = 0; //装载右PWM输出低电平时间if(pwm\\_val\\_right&gt;=PWM\\_DUTY) pwm\\_val\\_right = 0; //如果右对比值大于等于最大占空比数据，则为零} 2.3 使用FPGA开发板部分2.3.1 硬件接线系统时钟和复位信号必须为PIN17和PIN_90，不过这两个引脚在开发板上已经连接上了，无须手动连接。其它的引脚可以在下表中“FPGA引出I/O”部分选择即可，然后参照之间的51单片机进行连接。 此处附上接线实物图，需要注意的是，FPGA需要独立的接线供电，如充电宝等等。 2.3.2程序设计逻辑上大体与51相同，此处附上代码部分以及引脚的设置图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687LIBRARY ieee;USE ieee.std\\_logic\\_1164.all;ENTITY cartracking ISGENERIC (--时钟为50MHz，为了产生100Hz的PWM波，设置计数值为500000cnt\\_meta : INTEGER := 500000;--对应了停止、前进、左转、右转状态IN4到IN1的输出Back : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;0110&quot;;Forward : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;1001&quot;;Left\\_Go : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;0101&quot;;Right\\_Go : STD\\_LOGIC\\_VECTOR(3 DOWNTO 0) := &quot;1010&quot;);--\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*输入输出端口\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*PORT (sys\\_clk : IN STD\\_LOGIC;sys\\_rst\\_n : IN STD\\_LOGIC;infrared : IN STD\\_LOGIC\\_VECTOR(1 DOWNTO 0);pwm\\_left : OUT STD\\_LOGIC;pwm\\_right : OUT STD\\_LOGIC;in\\_motor : OUT STD\\_LOGIC\\_VECTOR(3 DOWNTO 0));END cartracking;ARCHITECTURE trans OF cartracking ISSIGNAL cnt : INTEGER;SIGNAL duty\\_left : INTEGER;SIGNAL duty\\_right : INTEGER;BEGINPROCESS (sys\\_rst\\_n, infrared)BEGINIF (sys\\_rst\\_n = '0') THENduty\\_right &lt;= 60;duty\\_left &lt;= 60;ELSECASE infrared ISWHEN &quot;00&quot; =&gt;in\\_motor &lt;= Back;--后退WHEN &quot;01&quot; =&gt;in\\_motor &lt;= Right\\_Go;--右转--PWM波的占空比，应设置合适的值来控制小车的转速，为了在仿真时可以对比，特将左右轮设置了不同的占空比。duty\\_left &lt;= 35;duty\\_right &lt;= 55;WHEN &quot;10&quot; =&gt;in\\_motor &lt;= Left\\_Go;--左转duty\\_left &lt;= 55;duty\\_right &lt;= 35;WHEN OTHERS =&gt;in\\_motor &lt;= Forward;--前进duty\\_left &lt;= 50;duty\\_right &lt;= 50;END CASE;END IF;END PROCESS;PROCESS (sys\\_clk, sys\\_rst\\_n)BEGINIF (sys\\_rst\\_n = '0') THENcnt &lt;= 0;ELSIF (sys\\_clk'EVENT AND sys\\_clk = '1') THENIF (cnt = cnt\\_meta) THENcnt &lt;= 0;ELSEcnt &lt;= cnt + 1;END IF;END IF;END PROCESS;PROCESS (sys\\_clk, sys\\_rst\\_n)BEGINIF (sys\\_rst\\_n = '0') THENpwm\\_left &lt;= '0';pwm\\_right &lt;= '0';ELSIF (sys\\_clk'EVENT AND sys\\_clk = '1') THENIF (cnt &gt;= (cnt\\_meta / 100)\\* duty\\_left) THENpwm\\_left &lt;= '0';ELSEpwm\\_left &lt;= '1';END IF;IF (cnt &gt;= (cnt\\_meta / 100) \\* duty\\_right) THENpwm\\_right &lt;= '0';ELSEpwm\\_right &lt;= '1';END IF;END IF;END PROCESS;END trans; 3调试及优化 3.1简单优化由于在测试时需要在保证小车前进速度的同时兼顾其转弯的效率和稳定性，特别是如果直行时转速过快会导致小车在转弯时直接冲出赛道而无法循迹。在原本的设计中，我们将未识别到黑线的反应设置为电机停转而使得小车停止，而这会使得小车无法在冲出赛道后进行自我校正。因此，我们将未识别到黑线时的输出信号由“0000”改为“0110”，即使得左右电机均由原本的停转改为反转，从而实现循迹过程中对于轨道循迹的自我修正。 在 PWM 频率设置的时候， PWM 的频率太低可能导致电机转动不稳定，不 是匀速转动，而 PWM 频率过高可能导致电机反应不过来或者超过电路的上限截止频率。事实上，考虑到转弯过程的稳定性与速度问题，包括与直行过程的速度以及传感器的灵敏度调节配合，我们需要通过实际测试来进一步确定在直行、左转、右转和倒退过程中设定的PWM占空比与转速。具体在调试之后所得到的合适参数已经在上面的代码中有所体现，在此不过多赘述。 3.2调试过程考虑到验收时的重要评判标准是小车循迹一周的时间，且小车本身运动缓慢，我们首先将目光放在了转速的提高上。修改参数大幅提高了轮子的转速后，我们进行了一次实验：结果出乎意料，小车非但没有预想的那样，反而在行进的过程中持续摇摆。分析原因是行进角度不平行于轨道时容易冲出轨道，后续针对此原因，在红外灵敏度以及直行、左转、右转和倒退过程中设定的PWM占空比与转速多次调试与测试。中途红外模块损坏，经过排查确定后更换了新的。此外，我们注意到行进中的不稳定性还来自于万向轮的松散，我们尝试了不限于胶带、缠绳等各种方式加以限制，效果均不理想，虽然直道可以稳定快速行进，转弯却尤为吃力。 最后51的部分取得了第二名的不错成绩。但是FPGA部分却难遂人意。我们一直将注意力放在数据的调试上却忽略了时间的把控，以至于直到最后快结束才仓促进行测试，测试时还发生了接线断开等突发状况。我们本着希望更加灵活的愿望想别的同学借来充电宝供电，没想到这成为了测试失败的最大缘由——充电宝供电严重不足，导致小车行进乏力，但等到我们重新接上电脑供电确认可以正常运行时，却被告知时间已到，不允许再次测试以保证公平。最后无奈接受这个最慢的成绩。 参考文献 [1] 默默无闻小菜鸡. 电机驱动芯片（H桥、直流电机驱动方式）——DRV8833、TB6612、A4950、L298N的详解与比较[EB/OL]. https://blog.csdn.net/qq_44897194/article/details/105524808, 2020-5-11. [2] 周海,叶兵. 机器人的发展现状及应用前景[J]. https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C44YLTlOAiTRKibYlV5Vjs7iAEhECQAQ9aTiC5BjCgn0Rn5ykE3W8_mbbrKtMuQk3r9gP-p4derKJErhs1XrNO9Y&amp;uniplatform=NZKPT, 2017-6-18. 致谢 感谢老师们在本课程中的精心准备与付出。在数电和模电部分得到了曾正教授和袁刚教授的悉心教诲，在后续的项目部分得到了李敏教授和凌睿教授的认真指导，最终得以基本实现预定目标，特此鸣谢！","link":"/2023/03/05/car/"},{"title":"人脸识别项目","text":"本项目全部代码已同步上传至Github,仓库链接：Asgard-Tim/face_recoginition: 重庆大学明月科创实验班线性代数课程项目 (github.com) 使用方法与识别效果如下。","link":"/2023/02/11/facerecognition/"},{"title":"20230101","text":"“天空不留下我的痕迹，但我已经飞过。”我们或许都只是漫漫岁月长河之中的过客罢了。好像是在重庆的某个瞬间，看到手机上苏州地铁S1线23年底有望开通的时候，才突然想起来，好像已经是2022年了。小的时候看新闻夜班车说十年之后苏州会有一条地铁叫S1，可以直接从苏州乘到上海，那个时候觉得这是多么的不可思议，而十年又是多么漫长。却是一眨眼就来到。即使是现在，想想这一年过来仍然是做梦一般。零模之后是为了HanYu而疯狂的一整个冬天和4A＜的遗憾收场，然后是疫情打乱了所有人的步伐顺便毁掉了最后的春天和最后的樱花。昙花一现之后是低谷，站起来之后再倒下然后再是拼命爬起，高考最终还是猝不及防地如期而至。接着就是混乱之夏。兴奋、焦急、离别、泪水、遗憾、愤怒、纠结、不甘与沉沦，这些词语交织在一起，连同着记忆中的那片园子和那些这辈子都不会忘记的好朋友，共同埋葬了整个夏天和整个青春。但时光从不让我们做好准备，金秋九月大学的生活依旧虽迟但到，我们被迫分别，终究还是离开了这个学习生活了十余载的故乡，来到了陌生的城市，对于新的生活与新的世界充满了美好的幻想，却仍然被最后的疫情击得粉碎碎。所有的尝试与冲撞终究败给了现实，所幸热爱可抵岁月漫长。国庆节的二次选拔充满了戏剧性，从满怀期待到心慌意乱再到欣喜若狂却终究败兴而归然后是重整行装东山再起最终还是不负众望，一切都是命运最好的安排。紧接着迎来的就是一段“痛并快乐着”的忙碌生活，充实快乐与疲惫不堪裹挟着我们每一个人，最后还是被返乡的风吹回县城，小阳人终于迎来了久违的安逸与平静。把这一年的故事讲完，我的内心静如止水。或者是释怀，或许是淡然，但所有的轰轰烈烈都是那么刻骨铭心，我们也终究要告别热烈的过去，奔赴更加美好的未来。没有遗憾是不可能的，但过往的挫败从来不妨碍我们继续向前奋力奔跑，不是吗？朝着更美好的明天。生命的意义，就是即使知晓痛苦的结局，依然向着命运抗争。“你无法阻止波涛汹涌，但你可以学会踏浪而行。”卑微的起点会促使你开始一件事，但是让你坚持下来的，一定是热情和使命。生命要么是一场伟大的冒险，要么什么都不是。All in, or nothing.悟已往之不谏，知来者之可追。钟表能回到原点，但不再是昨天。所以我们从不后悔，也从不停止向前。没有借口。下次人山人海，我会站上去。“祝愿祖国繁荣昌盛、国泰民安！祝愿世界和平美好、幸福安宁！祝愿大家新年快乐、皆得所愿！”那么，就是2023了。这一年，又会发生些什么呢？我也不知道。但我唯一知道的是，你们肯定还在，还在我的身边。岂曰无衣，与子同袍。兄弟们天下无敌！新年快乐！","link":"/2023/01/01/20230101/"},{"title":"20221009","text":"“热爱可抵岁月漫长。”生命要么是一场伟大的冒险，要么什么都不是。生命的意义，就是即使知晓痛苦的结局，依然向着命运抗争。“你无法阻止波涛汹涌，但你可以学会踏浪而行。”努力终会有回报，我用歌声来证明！","link":"/2022/10/09/20221009/"},{"title":"20221004","text":"昂首阔步向前走，向着过去挥挥手。当然这远远不够，往前走之后你还要跳跃，这个跳跃就是信仰。荒谬就是理性遇到了终点，但理性的终点就是信仰的起点。人类社会一路走来，过去我们看到雷鸣电闪，我们有了神话；后来我们看到战争，我们遇到了宗教；现代人遭遇了生活的荒谬，我们有了哲学。我们从来没有放弃过信仰，尤其是对苦难的信仰。多难兴邦，天将降大任于斯人也。这跟享受荒谬一样，是多么反直觉的答案，但这个答案就叫做信仰。我们必须从苦难中汲取营养，因为只有享受苦难，我们才能享受生活。","link":"/2022/10/04/20221004/"},{"title":"20220925","text":"年轻的躯体里充斥着自由的空气，随着血液氤氲扩散，遍布每一个细胞。它们贪婪地吮吸着，破晓前最后的黑暗。他们知道，走过这漫漫长夜，明天曙光就会照耀整个大地。#重启线下课#谁能想到，半个下午找完了所有要上课的教结果室发现才走了学校的一半还不到谁又能想到，从教学楼的二楼走楼梯上楼，楼上居然还是二楼但宿舍楼下就有钢琴我是真的会爱住那我们就明天见咯","link":"/2022/09/25/20220925/"}],"tags":[{"name":"XJH","slug":"XJH","link":"/tags/XJH/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"C51","slug":"C51","link":"/tags/C51/"},{"name":"FPGA","slug":"FPGA","link":"/tags/FPGA/"},{"name":"单片机","slug":"单片机","link":"/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"小车","slug":"小车","link":"/tags/%E5%B0%8F%E8%BD%A6/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"定量分析","slug":"定量分析","link":"/tags/%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"船","slug":"船","link":"/tags/%E8%88%B9/"},{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"路径规划","slug":"路径规划","link":"/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"},{"name":"RANSAC","slug":"RANSAC","link":"/tags/RANSAC/"},{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"碎碎念","slug":"碎碎念","link":"/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"CQU","slug":"CQU","link":"/tags/CQU/"},{"name":"年终总结","slug":"年终总结","link":"/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"小作文","slug":"小作文","link":"/tags/%E5%B0%8F%E4%BD%9C%E6%96%87/"},{"name":"生日","slug":"生日","link":"/tags/%E7%94%9F%E6%97%A5/"},{"name":"军训","slug":"军训","link":"/tags/%E5%86%9B%E8%AE%AD/"},{"name":"MATLAB，线性代数，图像识别","slug":"MATLAB，线性代数，图像识别","link":"/tags/MATLAB%EF%BC%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%8C%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"}],"categories":[{"name":"About XJH","slug":"About-XJH","link":"/categories/About-XJH/"},{"name":"课程项目","slug":"课程项目","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/"},{"name":"工程原理","slug":"课程项目/工程原理","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"name":"软件设计","slug":"课程项目/软件设计","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"},{"name":"定量工程设计方法I","slug":"课程项目/定量工程设计方法I","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95I/"},{"name":"碎碎念","slug":"About-XJH/碎碎念","link":"/categories/About-XJH/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"CQU","slug":"About-XJH/碎碎念/CQU","link":"/categories/About-XJH/%E7%A2%8E%E7%A2%8E%E5%BF%B5/CQU/"},{"name":"线性代数","slug":"课程项目/线性代数","link":"/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"pages":[]}