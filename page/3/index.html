<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>Homepage of Jinghua Xu</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Homepage of Jinghua Xu"><meta name="msapplication-TileImage" content="/img/photo.jpg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Homepage of Jinghua Xu"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="/img/photo.jpg"><meta name="description" content="重庆大学2022级明月科创实验班人工智能专业本科在读"><meta property="og:type" content="blog"><meta property="og:title" content="Homepage of Jinghua Xu"><meta property="og:url" content="http://asgard-tim.github.io/"><meta property="og:site_name" content="Homepage of Jinghua Xu"><meta property="og:description" content="重庆大学2022级明月科创实验班人工智能专业本科在读"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://asgard-tim.github.io/img/og_image.png"><meta property="article:author" content="Tim"><meta property="article:tag" content="Blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://asgard-tim.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://Asgard-Tim.github.io"},"headline":"Homepage of Jinghua Xu","image":["http://asgard-tim.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tim"},"publisher":{"@type":"Organization","name":"Homepage of Jinghua Xu","logo":{"@type":"ImageObject","url":"http://asgard-tim.github.io/img/title1.png"}},"description":"重庆大学2022级明月科创实验班人工智能专业本科在读"}</script><link rel="icon" href="/img/photo.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/xt256.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/title1.png" alt="Homepage of Jinghua Xu" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Contect me on GitHub" href="https://github.com/Asgard-Tim"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2025-06-20T20:02:03.000Z" title="2025/6/21 04:02:03">2025-06-21</time>发表</span><span class="level-item"><time datetime="2025-07-01T15:15:34.499Z" title="2025/7/1 23:15:34">2025-07-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/">微电路设计</a></span><span class="level-item">2 小时读完 (大约15611个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/21/sweeping/">SmartRobot扫地机器人</a></p><div class="content"><div id="postchat_postcontent"><h2 id="1-项目需求分析"><a href="#1-项目需求分析" class="headerlink" title="1 项目需求分析"></a>1 项目需求分析</h2><h3 id="1-1-项目背景介绍"><a href="#1-1-项目背景介绍" class="headerlink" title="1.1 项目背景介绍"></a>1.1 项目背景介绍</h3><p>随着科技的快速发展和人们生活水平的不断提高，智能家居设备正逐渐成为现代家庭的重要组成部分。在快节奏的生活中，人们对于家务自动化的需求日益增长，尤其是日常清洁工作，既耗时又费力。传统的清洁方式（如手动扫地、拖地）已无法满足现代家庭对高效、便捷生活的追求。扫地机器人作为智能清洁领域的代表性产品，凭借其自主导航、智能避障、自动回充等先进功能，能够有效减轻用户的清洁负担，提升生活品质。近年来，随着人工智能（AI）、传感器技术、路径规划算法以及物联网（IoT）技术的进步，扫地机器人的性能与智能化水平显著提升，市场需求持续扩大。</p>
<p>本项目基于市场上成熟的海尔扫地机器人硬件方案，通过复刻和优化现有设计，重点研究其核心功能模块，包括运动控制、传感器数据处理、路径规划算法等。在复刻过程中，我们将深入分析现有扫地机器人的优缺点，并结合实际应用场景进行针对性改进，例如优化清洁路径、提升避障精度、降低功耗等。该项目的实施不仅有助于深入理解扫地机器人的关键技术，还能为后续的二次开发和功能拓展奠定基础。通过复刻与优化，我们期望在降低研发成本的同时，提升产品的稳定性和用户体验，为智能家居设备的本地化应用提供参考方案。</p>
<p><img src="/images/sweeping/6f41a090cacab9adfdce2eda82e33be4.jpg" alt="图1.1：项目用海尔扫地机器人产品效果图"></p>
<h3 id="1-2-设计需求与相关指标确定"><a href="#1-2-设计需求与相关指标确定" class="headerlink" title="1.2 设计需求与相关指标确定"></a>1.2 设计需求与相关指标确定</h3><p>基于以上项目背景，结合硬件实机情况与初步调研结果，总结出了以下几条功能设计需求，并本着定量化的思想，在每一条功能需求上都提出了对应的指标：</p>
<ol>
<li><p>良好的避障功能：扫地机器人应集成有效传感器，以实现对障碍物的检测和避让，确保在复杂环境中的自主导航。除此之外，为保证最大程度的清洁，不放过任何一个清洁死角，我们希望机器人在触碰到墙体后，能够尽可能地以低速（不超过0.1m/s）贴近墙体行进。</p>
<p>具体而言，在碰撞传感器触发时，机器人需要在50ms内作出反应，先后退离开墙体区域，在原地进行小角度旋转后继续向前行进，再次碰到墙体时继续做出这样的反应。</p>
</li>
<li><p>防坠落能力：设备应具备悬崖检测传感器（本项目中硬件设备为红外传感器），以识别楼梯边缘或高度差，防止从高处坠落。</p>
<p>具体而言，我们希望在悬崖传感器检测到机器人位于高度垂直落差大于5cm的界面时，能够在50ms内作出反应，先紧急制动，接着低速后退离开悬崖区域，在原地旋转改变运动方向后继续行进，以最大限度地保护机器人地工作安全，避免损坏。</p>
</li>
<li><p>运动功能：扫地机器人应能根据家庭环境尺寸，实现高精度的运动控制。</p>
<p>具体而言，我们希望基于编码器利用PID控制器实现高精度的电机调控与运动控制，在直线行驶1m距离的测试中总偏角应不超过5°、距离误差不超过2cm.</p>
</li>
<li><p>用户通讯控制：设备应配备直观的用户界面，包括按键和指示灯，以便用户轻松启动、暂停和控制扫地机器人。应支持通过蓝牙连接，实现电脑端应用程序的远程控制，包括启动/停止自动清扫、遥控机器人（基于实时遥控信号调整运动状态）、监控电池状态等。</p>
<p>具体而言，希望在中低速运动条件下（0.05~0.15m/s）实现频率至少10Hz的实时位置坐标与姿态（偏转角度）的数据解算（位置坐标各方向误差&lt;5cm、偏转角度误差&lt;5°），并将数据传至用户界面，根据已有的行进位姿数据进行实时路径可视化，基于已有建图结果实现全覆盖路径规划。</p>
</li>
</ol>
<h3 id="1-3-项目分工"><a href="#1-3-项目分工" class="headerlink" title="1.3 项目分工"></a>1.3 项目分工</h3><table>
<thead>
<tr>
<th>PCB设计及硬件维护：余虹鋈</th>
<th>学号：20222957</th>
</tr>
</thead>
<tbody><tr>
<td>嵌入式程序：王冲</td>
<td>学号：20224841</td>
</tr>
<tr>
<td>上位机及嵌入式程序：肖范熠</td>
<td>学号：20223984</td>
</tr>
<tr>
<td>算法及嵌入式程序：许晶华</td>
<td>学号：20224546</td>
</tr>
</tbody></table>
<h3 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h3><p>本章对于扫地机器人项目的应用背景进行了介绍，并基于实机测试与调研结果确定了产品的功能需求指标，这为后续的项目开发起到了良好的引领和指导作用，后续的项目功能研发也将紧密围绕这些功能需求点与性能指标进行展开。</p>
<h2 id="2-PCB电路设计"><a href="#2-PCB电路设计" class="headerlink" title="2 PCB电路设计"></a>2 PCB电路设计</h2><h3 id="2-1-设计目标"><a href="#2-1-设计目标" class="headerlink" title="2.1 设计目标"></a>2.1 设计目标</h3><p>本次PCB设计面向智能扫地机器人控制系统，目标是实现电源管理、电机驱动、传感器输入处理、MCU外围支持、IMU通信等功能模块的稳定集成，并兼顾成本控制、布局合理性与后期调试便利性。</p>
<h3 id="2-2-PCB总体布局与功能划分"><a href="#2-2-PCB总体布局与功能划分" class="headerlink" title="2.2 PCB总体布局与功能划分"></a>2.2 PCB总体布局与功能划分</h3><p>PCB采用双面布局，充分利用板面空间，模块化划分如下：</p>
<ul>
<li><p>电源管理区：提供从锂电池到各类电压等级（如5V/3.3V）的转换；</p>
</li>
<li><p>单片机核心区：部署STM32及其基本外围电路；</p>
</li>
<li><p>电机驱动区：负责控制左右驱动电机及各个毛刷电机和吸尘电机；</p>
</li>
<li><p>传感器接口区：用于悬崖、碰撞等传感器信号接入与处理；</p>
</li>
<li><p>辅助保护与调试区：如状态指示灯、串口接口等。</p>
</li>
</ul>
<p><img src="/images/sweeping/842df3c716920bc6766d19be87d6d3de.png" alt="图2.1：单片机外围电路"></p>
<p><img src="/images/sweeping/ccea90d75a09c6393317ea73580e6f14.png" alt="图2.2：传感器、电机电路"></p>
<p><img src="/images/sweeping/f7b956f6904e8aa0d40741d71cabb130.png" alt="图2.3：电源相关电路"></p>
<h3 id="2-3-电源管理电路设计"><a href="#2-3-电源管理电路设计" class="headerlink" title="2.3 电源管理电路设计"></a>2.3 电源管理电路设计</h3><h4 id="2-3-1-充电电路设计"><a href="#2-3-1-充电电路设计" class="headerlink" title="2.3.1 充电电路设计"></a>2.3.1 充电电路设计</h4><p>电源模块采用多级稳压设计，满足不同子系统电压需求。在芯片选型方面，我们选择使用SLM6900降压模块，其特性如下：</p>
<ul>
<li><p>输出固定16.8V，无需外围分压，适合三到四节锂电池充电；</p>
</li>
<li><p>高效率（5A负载），封装易焊，适配性好；</p>
</li>
<li><p>可通过ADC分压获得充电状态，便于MCU监控；</p>
</li>
<li><p>NCHRG（充电中低电平）和NSTDBY（充满低电平）引脚可直接驱动LED简化状态监控，红绿LED指示灯直观反馈。</p>
</li>
</ul>
<p>相较于另一常见的充电芯片BQ24610RGER而言，拥有更易焊接的封装方式和更便宜的价格。</p>
<p><img src="/images/sweeping/7445217fe4e3348a8d55ad6a333ea0a2.png" alt="图2.4：充电保护电路"></p>
<p><img src="/images/sweeping/d59ef7f0fc613e0f9d324112397c062a.png" alt="图2.5：降压模块选型：SLM6900"></p>
<p><img src="/images/sweeping/5bf3b8df9b15c2d671def154d4880972.png" alt="图2.5：降压模块选型：BQ24610RGER"></p>
<h4 id="2-3-2-降压电路设计"><a href="#2-3-2-降压电路设计" class="headerlink" title="2.3.2 降压电路设计"></a>2.3.2 降压电路设计</h4><p>在降压电路设计中，我们选择采用TPS54531作为降压芯片，该芯片具有以下优点：</p>
<ul>
<li><p>支持从低至锂电池单节电压到24V工业电源的广泛输入，适配多种电源场景（如车载系统、分布式电源）；</p>
</li>
<li><p>轻载时自动切换至脉冲跳跃模式，静态电流低至1μA（关断状态），显著提升电池供电设备的待机时长；</p>
</li>
<li><p>逐周期电流限制、频率折返、热关断（165℃触发）三重保护。过压瞬态保护抑制启动电压过冲；</p>
</li>
<li><p>封装焊接简易；</p>
</li>
<li><p>成本低，三元一个，单个可售。</p>
</li>
</ul>
<p><img src="/images/sweeping/7fc94f286389c4ebfe91ea884abe197e.png" alt="图2.6：16.8v降5v电路"></p>
<p>在选型时，我们还考虑了其他型号的降压芯片，其中TPS56637适用于4.5V至28V，价格五元一个，与选用的TPS54531价格相近，但是其封装在焊接过程中出问题的概率更大，综合考虑不予选用；而LM2679S性能强悍，但是价格高昂，五十元一个，不予选用。</p>
<p><img src="/images/sweeping/64b87f623b35ffe246bcd3d3fd65adab.png" alt="图2.7：降压芯片选型：TPS54531"></p>
<p><img src="/images/sweeping/cc16e0b16b7c1f6654340431892a2b3c.png" alt="图2.7：降压芯片选型：TPS56637"></p>
<p><img src="/images/sweeping/4faad79f17d078c167d22a0eaeb45781.png" alt="图2.7：降压芯片选型：LM2679S"></p>
<p>线性稳压器方面，由于在这一步仅需5v降到3.3v压差小，因此选用合适、最廉价的芯片即可，不必追求过高性能。这里我们选用AMS1117-3.3线性稳压器，其主要特性如下：</p>
<ul>
<li><p>为MCU提供3.3V电压；</p>
</li>
<li><p>精度±1%，外围电路极简，仅需输入/输出电容。</p>
</li>
</ul>
<p><img src="/images/sweeping/0ca84a5cae4c5192ca6cb15e1bc0fb5c.png" alt="图2.8：15v降3.3v电路"></p>
<h3 id="2-4-电机驱动与控制逻辑设计"><a href="#2-4-电机驱动与控制逻辑设计" class="headerlink" title="2.4 电机驱动与控制逻辑设计"></a>2.4 电机驱动与控制逻辑设计</h3><h4 id="2-4-1-运动电机驱动芯片选型对比"><a href="#2-4-1-运动电机驱动芯片选型对比" class="headerlink" title="2.4.1 运动电机驱动芯片选型对比"></a>2.4.1 运动电机驱动芯片选型对比</h4><p>由于驱动直流电机需要的电流很大，单片机I/O的驱动能力是远远达不到的。因此需要使用专用的电机驱动芯片。芯片驱动能力及使用复杂度简单对比如下：</p>
<ul>
<li><p>A4950：8~40V，高压大电流，外围适中；</p>
</li>
<li><p>DRV8833：2.7~10.8V，体积小，适合低压，使用简单；</p>
</li>
<li><p>TB6612FNG：2.5~13.5V，性能稳定，体积小；</p>
</li>
<li><p>L298N：3~48V，体积大，驱动强，但外围复杂。</p>
</li>
</ul>
<p><img src="/images/sweeping/32de6c21efb33b86f369846795e9c34b.png" alt="图2.9：DRV8833芯片"></p>
<p>DRV8833电机驱动芯片是基于H桥电路的，芯片中共有两个全H桥，因此最多可以同时驱动两个直流电机或一个步进电机。电源供电电压2.7~10.8V，每个H桥输出的均方根（RMS）电流为1.5A，峰值可达2A。内置过热保护和用户可调的限流保护电路。</p>
<p><img src="/images/sweeping/37a3b8d65c9851b923351cb4ac54daa3.png" alt="图2.10：DRV8833芯片功能框图"></p>
<p>框图中也包含了DRV8833芯片外部所需要的元件，主要是三个电容以及两个电流检测电阻（电阻可不接）。当温度过高，温度检测保护模块会使nFAULT所接的FET导通拉到低电平,同时H桥转成衰减模式，不再给电机供电。</p>
<p><img src="/images/sweeping/bef4b8ec06824c07505ae1747f4cdb43.png" alt="图2.11：TB6612FNG芯片"></p>
<p>TB6612FNC是东芝半导体公司的一款电机驱动芯片，也是集成了两个全H桥。在应用上基本与DRV8833相似，但性能更好，价格也相对较高。电源供电电压2.5~13.5V，H桥输出的平均电流1.2A，最大可到3.2A。（可见驱动能力比DRV8833略强）内置过热保护和低压检测关断电路，PWM控制的频率可达100kHZ。</p>
<p><img src="/images/sweeping/fc194b9db1661bf8395cd77ad12af7db.png" alt="图2.12：TB6612FNG芯片功能框图"></p>
<p>上面框图中画出了使用该芯片需要外接的元件（4个滤波电容）。从中可发现，其与DRV8833最大不同即在输入控制上，除了输入1和输入2，还有一个PWM输入脚。</p>
<p><img src="/images/sweeping/396c3e3d8a82400f9c5a9a2a1f2c3b8d.png" alt="图2.13：A4950芯片"></p>
<p>A4950是美国埃戈罗公司生产的一款单H桥电机驱动芯片。因此网上卖的模块多是使用两块芯片以达到可以控制两个直流电机的能力。电机驱动电压：8~40V，输出最大电流可达3.5A；内置过温保护，短路保护和可选择的过流保护。</p>
<p><img src="/images/sweeping/7eaae14263a3da080733a84a46346428.png" alt="图2.14：A4950芯片功能框图"></p>
<p>通过引脚说明和功能框图可看出，此芯片不同之处有：只有单H桥，因此引脚较少；限流比较的参考电压由外部给出（VREF脚）；因此限流值Isense=Vref/10/Rsense。如上面的模块中，Vref接5V，Rsense为R250精密检测电阻（0.25Ω），因此限流值为2A。当IN1和IN2均保持低电平1ms，芯片进入待机模式。而不是通过引脚直接控制。经过对比发现，此芯片的驱动逻辑与上述的DRV8833PWP芯片完全一致。</p>
<p><img src="/images/sweeping/28480a5db9c42d3645541967ab92cc98.png" alt="图2.15：L298N电机驱动模块"></p>
<p>L298N是ST公司的一款电机驱动芯片，也是集成了双H桥，但与上面两个略有不同。该芯片适配的电机驱动电压为3~48V；可持续工作的输出电流为2A，峰值可达3A。如上图，L298N模块明显比前两个芯片模块外接的元件多，这与L298N的内部结构有关。如上图，由于该芯片在H桥上的损耗严重发热较明显（饱和压降大），需要加装散热片，因此在使用上比前两个芯片复杂，体积也相对较大。</p>
<p><img src="/images/sweeping/6ae452737fa09e8a560c6c4940e6b04b.png" alt="图2.16：L298N芯片功能框图"></p>
<p>如上图所示：L298N的内部功能很多都类似，比如电流检测，H桥驱动，外接电容等。主要区别在于L298N的H桥采用了BJT而不是MOSFET。这就直接导致没有寄生二极管，无法像前两个芯片一样实现续流。因此需要外接8个续流二极管。因为频率不高，选用普通的整流二极管即可（如1N4007）。如下图所示：</p>
<p><img src="/images/sweeping/d8cebd2f5cb0293060442dfbd579157a.png" alt="图2.17：L298N芯片连接示意图"></p>
<p>此芯片的电流检测脚Sense-X并不像前面的芯片，其没有在内部进行电压比较从而限流，从数据手册上看，需要一个L297芯片配合进行限流。因此一般直接接地，不进行限流。</p>
<p>综上所述，对比四款常用的电机驱动芯片，可以得到如下结论：</p>
<ul>
<li><p>三款芯片的内部原理和控制方式大同小异；</p>
</li>
<li><p>可通过两个H桥输出的并联控制一个直流电机，这样最大驱动电流可翻倍，这在芯片的数据手册中均有说明；</p>
</li>
<li><p>以上三种芯片驱动能力排序：DRV8833&lt;BT6612&lt;A4950≈L298N；</p>
</li>
<li><p>DRV8833、TB6612和A4950的体积小，外接元件少，使用简单；L298N体积大，外接元件多，使用相对复杂；</p>
</li>
</ul>
<p>在选择这种集成H桥芯片时，需要考虑的参数有：可承受的工作电流要大于电机的堵转电流，防止堵转时驱动芯片烧毁；导通电阻尽可能小，减少芯片的发热损耗。综合这些因素考虑，本项目最终选用<strong>A4950</strong>作为主驱动芯片，其适配性与功率支持表现均较为优异。</p>
<h4 id="2-4-2-其余电机驱动控制逻辑设计"><a href="#2-4-2-其余电机驱动控制逻辑设计" class="headerlink" title="2.4.2 其余电机驱动控制逻辑设计"></a>2.4.2 其余电机驱动控制逻辑设计</h4><p>在刷子电机和风机驱动方面，选择使用74HC14D来对单片机信号进行增强，从而达到控制的目的，因为这些电机不需要特别精细的控制，这样的选择可以最低限度实现功能的同时，减少PCB版面空间的消耗。</p>
<p>这一部分的驱动电路设计主要有以下要点：</p>
<ul>
<li><p>74HC14D 施密特反相器用于整形PWM信号，防抖处理；</p>
</li>
<li><p>NCE6020AK MOSFET 用作电机功率开关管；</p>
</li>
<li><p>二极管续流保护，防止感性反冲。</p>
</li>
</ul>
<p><img src="/images/sweeping/bfe9f947cef03a4fbbf9ae843ed7e25c.png" alt="图2.18：74HC14D驱动电机电路"></p>
<p>在上述电路中，MCU输出的PWM信号经R178/R188限流后输入74HC14D，整形后的反相信号驱动NCE6020AK栅极。同时，74HC14D输出端应通过栅极电阻（典型值10-100Ω）连接MOSFET栅极，连接形式为：VCC15V→ MOSFET漏极 → 源极 → 100mΩ采样电阻 → 电机 →GND。当电机停转时，电感能量经B340A续流二极管释放。该电路还包含过流保护与电压尖峰抑制的功能，将采样电阻压差送ADC6，MCU触发关断，B340A续流二极管吸收反向电动势。</p>
<p>2.5 单片机外围电路</p>
<p>本项目的MCU采用STM32系列芯片，外围电路主要包括以下几个部分：</p>
<ul>
<li><p>晶振电路（8MHz或16MHz）；</p>
</li>
<li><p>上拉/下拉电阻；</p>
</li>
<li><p>下载接口（SWD）；</p>
</li>
<li><p>启动配置引脚；</p>
</li>
<li><p>调试指示LED、UART通讯接口等。</p>
</li>
</ul>
<p><img src="/images/sweeping/842df3c716920bc6766d19be87d6d3de.png" alt="图2.19：单片机外围电路"></p>
<h3 id="2-6-PCB布局设计说明"><a href="#2-6-PCB布局设计说明" class="headerlink" title="2.6 PCB布局设计说明"></a>2.6 PCB布局设计说明</h3><h4 id="2-6-1-正面布局"><a href="#2-6-1-正面布局" class="headerlink" title="2.6.1 正面布局"></a>2.6.1 正面布局</h4><p>以MCU为核心，周边辐射式布局传感器与电源模块，整体走线遵循横平竖直的原则，下半区集中走线，保证PCB美观。</p>
<p><img src="/images/sweeping/c37e75a4da76546bc7a8d641c7913dd0.png" alt="图2.20：PCB正面布局"></p>
<h4 id="2-6-2-反面布局"><a href="#2-6-2-反面布局" class="headerlink" title="2.6.2 反面布局"></a>2.6.2 反面布局</h4><p>主电源走线、地平面铺铜，布线优化短路径，增强抗干扰能力，布局1206封装的电阻，充分保证正面的布局空间。</p>
<p><img src="/images/sweeping/6a8b0bf9829d772ea0c2eedbcc056eac.png" alt="图2.21：PCB反面布局"></p>
<h4 id="2-6-3-实物图展示"><a href="#2-6-3-实物图展示" class="headerlink" title="2.6.3 实物图展示"></a>2.6.3 实物图展示</h4><p>实际焊接效果良好；各模块标识清晰，便于调试。</p>
<p><img src="/images/sweeping/45e3df7f22ad3ac9bfbbdfa2e8efcbcc.jpg" alt="图2.22：PCB实物图"></p>
<h3 id="2-7-本章小结"><a href="#2-7-本章小结" class="headerlink" title="2.7 本章小结"></a>2.7 本章小结</h3><p>本次PCB设计实现了功能完备、结构合理的控制系统硬件支持。后续根据产品实际需要，若需要进一步改进，可以从如下方面入手：</p>
<p>1、优化板面尺寸，提升布局紧凑性；</p>
<p>2、考虑EMC设计与测试，提升抗干扰性能；</p>
<p>3、引入模块化可插拔接口，便于维护升级。</p>
<h2 id="3-硬件外设程序设计"><a href="#3-硬件外设程序设计" class="headerlink" title="3 硬件外设程序设计"></a>3 硬件外设程序设计</h2><h3 id="3-1-设计目标"><a href="#3-1-设计目标" class="headerlink" title="3.1 设计目标"></a>3.1 设计目标</h3><p>本章节内容主要介绍PCB上的硬件外设的程序设计以及功能接口的使用方法，包含LED、按键、IMU、电机驱动、编码器、悬崖传感器、电压读取以及碰撞传感器的相关内容。</p>
<h3 id="3-2-LED"><a href="#3-2-LED" class="headerlink" title="3.2 LED"></a>3.2 LED</h3><p>项目中共有四颗可供使用的空闲LED（LED0~1），为方便使用、扩展进行了统一的封装。目前四颗均为上拉连接低电平触发。</p>
<p><img src="/images/sweeping/4bfebb2e06f8e65fa843e12ade9d76c8.png" alt="图3.1：LED部分电路原理图"></p>
<h4 id="3-2-1-硬件描述"><a href="#3-2-1-硬件描述" class="headerlink" title="3.2.1 硬件描述"></a>3.2.1 硬件描述</h4><p>为了程序的规范性和可拓展性，我们需要在main文件中使用上述函数对LED进行硬件描述：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    GPIO_TypeDef \*GPIOx;   <span class="comment">// GPIO 端口</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;    <span class="comment">// GPIO 引脚</span></span><br><span class="line">    LED_ActiveMode ActiveMode; <span class="comment">// LED 工作模式（主动低或主动高）</span></span><br><span class="line">} LED_HandleTypeDef;</span><br></pre></td></tr></tbody></table></figure>

<p>其中工作模式如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">    LED_ACTIVE_LOW = <span class="number">0</span>, <span class="comment">// LED 在低电平时点亮（即连接到 VCC）</span></span><br><span class="line">    LED_ACTIVE_HIGH   <span class="comment">// LED 在高电平时点亮（即连接到 GND）</span></span><br><span class="line">} LED_ActiveMode;</span><br></pre></td></tr></tbody></table></figure>

<p>示例：LED0连接在PD端口0号引脚，低电平触发，则如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LED_HandleTypeDef LED0 = {</span><br><span class="line">    .GPIOx = GPIOD,</span><br><span class="line">    .GPIO_Pin = GPIO_PIN_0,</span><br><span class="line">    .ActiveMode = LED_ACTIVE_LOW</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-2-2-初始化"><a href="#3-2-2-初始化" class="headerlink" title="3.2.2 初始化"></a>3.2.2 初始化</h4><p>效果为根据描述的硬件连接匹配对应的电平输出。对应函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LED 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(LED_HandleTypeDef *led)</span> {</span><br><span class="line">  <span class="comment">// 根据LED的工作模式（主动低或主动高）初始化LED</span></span><br><span class="line">  <span class="keyword">if</span> (led-&gt;ActiveMode == LED_ACTIVE_LOW) {</span><br><span class="line">  <span class="comment">// 如果是主动低模式，初始化时将LED设置为关闭（对应的GPIO引脚输出高电平）</span></span><br><span class="line">    HAL_GPIO_WritePin(led-&gt;GPIOx, led-&gt;GPIO_Pin, GPIO_PIN_SET);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// 如果是主动高模式，初始化时将LED设置为关闭（对应的GPIO引脚输出低电平）</span></span><br><span class="line">    HAL_GPIO_WritePin(led-&gt;GPIOx, led-&gt;GPIO_Pin, GPIO_PIN_RESET);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：初始化LED0，则可直接调用该函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LED_Init (&amp;LED0);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-2-3-点亮LED"><a href="#3-2-3-点亮LED" class="headerlink" title="3.2.3 点亮LED"></a>3.2.3 点亮LED</h4><p>效果为点亮LED。对应函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 点亮LED */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_On</span><span class="params">(LED_HandleTypeDef *led)</span> {</span><br><span class="line">  <span class="keyword">if</span> (led-&gt;ActiveMode == LED_ACTIVE_LOW) {</span><br><span class="line">    <span class="comment">// 如果是主动低模式，点亮LED需要将GPIO引脚输出低电平</span></span><br><span class="line">    HAL_GPIO_WritePin(led-&gt;GPIOx, led-&gt;GPIO_Pin, GPIO_PIN_RESET);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 如果是主动高模式，点亮LED需要将GPIO引脚输出高电平</span></span><br><span class="line">    HAL_GPIO_WritePin(led-&gt;GPIOx, led-&gt;GPIO_Pin, GPIO_PIN_SET);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：点亮LED0，则可直接调用该函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LED_On (&amp;LED0);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-2-4-熄灭LED"><a href="#3-2-4-熄灭LED" class="headerlink" title="3.2.4 熄灭LED"></a>3.2.4 熄灭LED</h4><p>效果为熄灭LED。对应函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 熄灭LED */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Off</span><span class="params">(LED_HandleTypeDef *led)</span> {</span><br><span class="line">  <span class="keyword">if</span> (led-&gt;ActiveMode == LED_ACTIVE_LOW) {</span><br><span class="line">    <span class="comment">// 如果是主动低模式，熄灭LED需要将GPIO引脚输出高电平</span></span><br><span class="line">    HAL_GPIO_WritePin(led-&gt;GPIOx, led-&gt;GPIO_Pin, GPIO_PIN_SET);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 如果是主动高模式，熄灭LED需要将GPIO引脚输出低电平</span></span><br><span class="line">    HAL_GPIO_WritePin(led-&gt;GPIOx, led-&gt;GPIO_Pin, GPIO_PIN_RESET);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：初始化LED0，则可直接调用该函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LED_Off (&amp;LED0);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-2-5-翻转LED"><a href="#3-2-5-翻转LED" class="headerlink" title="3.2.5 翻转LED"></a>3.2.5 翻转LED</h4><p>效果为转换当前LED的亮灭状态。对应函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 切换LED状态（开/关） */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Toggle</span><span class="params">(LED_HandleTypeDef *led)</span> {</span><br><span class="line">  <span class="comment">// 切换LED状态（如果是开就关，反之亦然）</span></span><br><span class="line">  HAL_GPIO_TogglePin(led-&gt;GPIOx, led-&gt;GPIO_Pin);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：初始化LED0，则可直接调用该函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LED_Toggle (&amp;LED0);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-按键"><a href="#3-3-按键" class="headerlink" title="3.3 按键"></a>3.3 按键</h3><p>如下图所示，项目有两个可供使用的微动按键（KEY0、KEY1），均为上拉连接低电平触发，配置为GPIO的Input模式。</p>
<p><img src="/images/sweeping/9eaae0a1416f54279ab99d7d34cce491.png" alt="图3.2：按键部分电路原理图"></p>
<h4 id="3-3-1-硬件描述"><a href="#3-3-1-硬件描述" class="headerlink" title="3.3.1 硬件描述"></a>3.3.1 硬件描述</h4><p>硬件描述结构体如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    GPIO_TypeDef *GPIOx;          <span class="comment">// GPIO端口（如GPIOD）</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;            <span class="comment">// GPIO引脚（如GPIO_PIN_11）</span></span><br><span class="line">    Key_ActiveMode ActiveMode;    <span class="comment">// 有效电平模式</span></span><br><span class="line">    Key_State CurrentState;       <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="type">uint32_t</span> LastTick;            <span class="comment">// 最后一次状态变化时的时间戳</span></span><br><span class="line">} Key_HandleTypeDef;</span><br></pre></td></tr></tbody></table></figure>

<p>其中，按键状态又有如下枚举：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">    KEY_STATE_RELEASED = <span class="number">0</span>,      <span class="comment">// 松开状态</span></span><br><span class="line">    KEY_STATE_PRESSED,           <span class="comment">// 按下状态</span></span><br><span class="line">    KEY_STATE_JUST_PRESSED,      <span class="comment">// 刚刚按下（边沿）</span></span><br><span class="line">    KEY_STATE_JUST_RELEASED      <span class="comment">// 刚刚松开（边沿）</span></span><br><span class="line">} Key_State;</span><br></pre></td></tr></tbody></table></figure>

<p>示例：直接描述两个按钮如下，均为低电平触发：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Key_HandleTypeDef key[] = {</span><br><span class="line">    {  </span><br><span class="line">		<span class="comment">// KEY0(PD11)</span></span><br><span class="line">        .GPIOx = GPIOD,</span><br><span class="line">        .GPIO_Pin = GPIO_PIN_11,</span><br><span class="line">        .ActiveMode = KEY_ACTIVE_LOW </span><br><span class="line">    },</span><br><span class="line">    {   </span><br><span class="line">		<span class="comment">// KEY1(PE15)</span></span><br><span class="line">        .GPIOx = GPIOE,</span><br><span class="line">        .GPIO_Pin = GPIO_PIN_15,</span><br><span class="line">        .ActiveMode = KEY_ACTIVE_LOW</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-2-按键初始化"><a href="#3-3-2-按键初始化" class="headerlink" title="3.3.2 按键初始化"></a>3.3.2 按键初始化</h4><p>效果为重置按键状态，并且更新时间戳。对应函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按键初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(Key_HandleTypeDef *key)</span> {</span><br><span class="line">    key-&gt;CurrentState = KEY_STATE_RELEASED;</span><br><span class="line">    key-&gt;LastTick = HAL_GetTick();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：初始化key0：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key_Init (&amp;key[<span class="number">0</span>]);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-3-按键更新"><a href="#3-3-3-按键更新" class="headerlink" title="3.3.3 按键更新"></a>3.3.3 按键更新</h4><p>效果为检测并更新按键的按下状态。对应函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按键更新（需要定期调用） */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Update</span><span class="params">(Key_HandleTypeDef *key)</span> {</span><br><span class="line">    <span class="type">uint32_t</span> current_tick = HAL_GetTick();</span><br><span class="line">    <span class="comment">// 读取当前按键引脚状态</span></span><br><span class="line">    GPIO_PinState pin_state = HAL_GPIO_ReadPin(key-&gt;GPIOx, key-&gt;GPIO_Pin);</span><br><span class="line">    <span class="type">uint8_t</span> is_pressed = (key-&gt;ActiveMode == KEY_ACTIVE_LOW) ? </span><br><span class="line">                         (pin_state == GPIO_PIN_RESET) : </span><br><span class="line">                         (pin_state == GPIO_PIN_SET);</span><br><span class="line">    <span class="comment">// 按键状态机</span></span><br><span class="line">    <span class="keyword">switch</span> (key-&gt;CurrentState) {</span><br><span class="line">        <span class="keyword">case</span> KEY_STATE_RELEASED:</span><br><span class="line">            <span class="keyword">if</span> (is_pressed) {</span><br><span class="line">                <span class="keyword">if</span> (current_tick - key-&gt;LastTick &gt; DEBOUNCE_DELAY_MS) {</span><br><span class="line">                    key-&gt;CurrentState = KEY_STATE_JUST_PRESSED;</span><br><span class="line">                    key-&gt;LastTick = current_tick;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_STATE_JUST_PRESSED:</span><br><span class="line">            key-&gt;CurrentState = KEY_STATE_PRESSED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_STATE_PRESSED:</span><br><span class="line">            <span class="keyword">if</span> (!is_pressed) {</span><br><span class="line">                <span class="keyword">if</span> (current_tick - key-&gt;LastTick &gt; DEBOUNCE_DELAY_MS) {</span><br><span class="line">                    key-&gt;CurrentState = KEY_STATE_JUST_RELEASED;</span><br><span class="line">                    key-&gt;LastTick = current_tick;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_STATE_JUST_RELEASED:</span><br><span class="line">            key-&gt;CurrentState = KEY_STATE_RELEASED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：检测并更新key0：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key_Update (key[<span class="number">0</span>]);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-4-获取按键状态"><a href="#3-3-4-获取按键状态" class="headerlink" title="3.3.4 获取按键状态"></a>3.3.4 获取按键状态</h4><p>效果为配合按键状态更新函数，会返回Key_State中的状态，进行逻辑编写。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取当前按键状态 */</span></span><br><span class="line">Key_State <span class="title function_">Key_GetState</span><span class="params">(Key_HandleTypeDef *key)</span> {</span><br><span class="line">	<span class="keyword">return</span> key-&gt;CurrentState;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：读取key1：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key_State state = Key_GetState(&amp;key[<span class="number">1</span>]);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-4-IMU"><a href="#3-4-IMU" class="headerlink" title="3.4 IMU"></a>3.4 IMU</h3><p>本次项目采用JY901S九轴姿态传感器，连接到USART2与单片机通信，使用中断的方式来接收数据，配置如下，根据与算法同学沟通，共需用到加速度、角速度、欧拉角每组三个共九个数据。</p>
<p><img src="/images/sweeping/c2d26057de7d68871d63e3b437cf0836.png" alt="图3.3：MCU与IMU间连接示意图"></p>
<h4 id="3-4-1-IMU初始化"><a href="#3-4-1-IMU初始化" class="headerlink" title="3.4.1 IMU初始化"></a>3.4.1 IMU初始化</h4><p>功能为配置缓冲区并开启首次接收中断。对应函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">JY901S_Init</span><span class="params">(UART_HandleTypeDef *huart)</span>{</span><br><span class="line">    jy_uart = huart;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> rx_buf[FRAME_LEN];</span><br><span class="line">    HAL_UART_Receive_IT(jy_uart, rx_buf, FRAME_LEN); <span class="comment">// 开启首次接收中断</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：初始化IMU：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JY901S_Init(&amp;huart2);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-4-2-IMU数据解析"><a href="#3-4-2-IMU数据解析" class="headerlink" title="3.4.2 IMU数据解析"></a>3.4.2 IMU数据解析</h4><p>功能为根据官方文档解算IMU回传的数据。对应函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">JY901S_UART_RxHandler</span><span class="params">(<span class="type">uint8_t</span> *data)</span>{</span><br><span class="line">    <span class="keyword">if</span> (data[<span class="number">0</span>] == <span class="number">0x55</span>) {</span><br><span class="line">        <span class="keyword">switch</span> (data[<span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x51</span>: <span class="comment">// 加速度</span></span><br><span class="line">                imu_data.ax = (<span class="type">short</span>)(data[<span class="number">3</span>] &lt;&lt; <span class="number">8</span> | data[<span class="number">2</span>]) / <span class="number">32768.0f</span> * <span class="number">16</span>;</span><br><span class="line">                imu_data.ay = (<span class="type">short</span>)(data[<span class="number">5</span>] &lt;&lt; <span class="number">8</span> | data[<span class="number">4</span>]) / <span class="number">32768.0f</span> * <span class="number">16</span>;</span><br><span class="line">                imu_data.az = (<span class="type">short</span>)(data[<span class="number">7</span>] &lt;&lt; <span class="number">8</span> | data[<span class="number">6</span>]) / <span class="number">32768.0f</span> * <span class="number">16</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x52</span>: <span class="comment">// 角速度</span></span><br><span class="line">                imu_data.gx = (<span class="type">short</span>)(data[<span class="number">3</span>] &lt;&lt; <span class="number">8</span> | data[<span class="number">2</span>]) / <span class="number">32768.0f</span> * <span class="number">2000</span>;</span><br><span class="line">                imu_data.gy = (<span class="type">short</span>)(data[<span class="number">5</span>] &lt;&lt; <span class="number">8</span> | data[<span class="number">4</span>]) / <span class="number">32768.0f</span> * <span class="number">2000</span>;</span><br><span class="line">                imu_data.gz = (<span class="type">short</span>)(data[<span class="number">7</span>] &lt;&lt; <span class="number">8</span> | data[<span class="number">6</span>]) / <span class="number">32768.0f</span> * <span class="number">2000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x53</span>: <span class="comment">// 欧拉角</span></span><br><span class="line">                imu_data.roll  = (<span class="type">short</span>)(data[<span class="number">3</span>] &lt;&lt; <span class="number">8</span> | data[<span class="number">2</span>]) / <span class="number">32768.0f</span> * <span class="number">180</span>;</span><br><span class="line">                imu_data.pitch = (<span class="type">short</span>)(data[<span class="number">5</span>] &lt;&lt; <span class="number">8</span> | data[<span class="number">4</span>]) / <span class="number">32768.0f</span> * <span class="number">180</span>;</span><br><span class="line">                imu_data.yaw   = (<span class="type">short</span>)(data[<span class="number">7</span>] &lt;&lt; <span class="number">8</span> | data[<span class="number">6</span>]) / <span class="number">32768.0f</span> * <span class="number">180</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    HAL_UART_Receive_IT(jy_uart, data, FRAME_LEN); <span class="comment">// 重新开启下一次接收中断</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：定义中断回调</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>{</span><br><span class="line">    <span class="keyword">if</span> (huart-&gt;Instance == USART2) {</span><br><span class="line">		JY901S_UART_RxHandler(jy_rx_buf);</span><br><span class="line">        HAL_UART_Receive_IT(&amp;huart2, jy_rx_buf, <span class="number">11</span>); </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-4-3-获取IMU数据"><a href="#3-4-3-获取IMU数据" class="headerlink" title="3.4.3 获取IMU数据"></a>3.4.3 获取IMU数据</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMU_Data_t* <span class="title function_">JY901S_GetData</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">	<span class="keyword">return</span> &amp;imu_data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：在主循环中获取数据：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imu = JY901S_GetData();</span><br></pre></td></tr></tbody></table></figure>

<p>此处imu作全局变量定义（IMU_Data_t *imu;），便于debug监视。</p>
<h3 id="3-5-电机驱动"><a href="#3-5-电机驱动" class="headerlink" title="3.5 电机驱动"></a>3.5 电机驱动</h3><p>左右电机分别由一个A4950电机驱动来进行驱动，该芯片需要两路PWM来差值控制，左右驱动分别接至TIM1和TIM9的两路通道，设置如图所示。</p>
<p><img src="/images/sweeping/97afcc2cc628be801fb36c1d986f5883.png" alt="图3.4：电机驱动部分电路原理图"></p>
<h4 id="3-5-1-电机初始化"><a href="#3-5-1-电机初始化" class="headerlink" title="3.5.1 电机初始化"></a>3.5.1 电机初始化</h4><p><img src="/images/sweeping/32bb40104d51169ef61d394a97aef017.png" alt="图3.5：CubeMX中对两路PWM的配置"></p>
<p>基于以上配置的两路PWM通道，编写如下函数进行左右电机驱动的初始化：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">A4950_Init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">// 启动左电机 PWM（TIM1_CH1=PE9, TIM1_CH2=PE11）</span></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_1);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_2);</span><br><span class="line">    <span class="comment">// 启动右电机 PWM（TIM9_CH1=PE5, TIM9_CH2=PE6）</span></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim9, TIM_CHANNEL_1);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim9, TIM_CHANNEL_2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-5-2-左（右）轮驱动"><a href="#3-5-2-左（右）轮驱动" class="headerlink" title="3.5.2 左（右）轮驱动"></a>3.5.2 左（右）轮驱动</h4><p>根据CubeMX的设置，PWM调速绝对值上限为99。分别编写左轮与右轮的PWM驱动函数如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左轮</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">A4950_SetLeft</span><span class="params">(<span class="type">int16_t</span> speed)</span>{</span><br><span class="line">    <span class="type">uint16_t</span> duty;</span><br><span class="line">    <span class="keyword">if</span> (speed &gt;= <span class="number">0</span>) {</span><br><span class="line">        duty = (speed &gt; A4950_PWM_MAX ? A4950_PWM_MAX : speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_2, duty);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_1, <span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        duty = ((-speed) &gt; A4950_PWM_MAX ? A4950_PWM_MAX : -speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_1, duty);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右轮</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">A4950_SetRight</span><span class="params">(<span class="type">int16_t</span> speed)</span>{</span><br><span class="line">    <span class="type">uint16_t</span> duty;</span><br><span class="line">    <span class="keyword">if</span> (speed &gt;= <span class="number">0</span>) {</span><br><span class="line">        duty = (speed &gt; A4950_PWM_MAX ? A4950_PWM_MAX : speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim9, TIM_CHANNEL_1, duty);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim9, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        duty = ((-speed) &gt; A4950_PWM_MAX ? A4950_PWM_MAX : -speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim9, TIM_CHANNEL_1, <span class="number">0</span>);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim9, TIM_CHANNEL_2, duty);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-5-3-制动"><a href="#3-5-3-制动" class="headerlink" title="3.5.3 制动"></a>3.5.3 制动</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">A4950_Brake</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">// 两输入同时高 → 主动制动</span></span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_1, A4950_PWM_MAX);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_2, A4950_PWM_MAX);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim9, TIM_CHANNEL_1, A4950_PWM_MAX);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim9, TIM_CHANNEL_2, A4950_PWM_MAX);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-6-编码器"><a href="#3-6-编码器" class="headerlink" title="3.6 编码器"></a>3.6 编码器</h3><h4 id="3-6-1-结构体关联句柄"><a href="#3-6-1-结构体关联句柄" class="headerlink" title="3.6.1 结构体关联句柄"></a>3.6.1 结构体关联句柄</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    TIM_HandleTypeDef *htim;  <span class="comment">///&lt; 关联的定时器句柄（如 &amp;htim2 或 &amp;htim5）</span></span><br><span class="line">    <span class="type">int32_t</span>            count; <span class="comment">///&lt; 累计脉冲计数（带符号，可正可负）</span></span><br><span class="line">} Encoder_HandleTypeDef;</span><br></pre></td></tr></tbody></table></figure>

<p>示例：在主程序中定义如下结构体，分别代表左编码器与右编码器：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Encoder_HandleTypeDef encL, encR;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-6-2-编码器初始化"><a href="#3-6-2-编码器初始化" class="headerlink" title="3.6.2 编码器初始化"></a>3.6.2 编码器初始化</h4><p>效果为关联定时器的编码器接口。对应函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(Encoder_HandleTypeDef *enc, TIM_HandleTypeDef *htim)</span>{</span><br><span class="line">    enc-&gt;htim = htim;</span><br><span class="line">    enc-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 启动 TIM 的 TI1 和 TI2 通道以进入编码器模式</span></span><br><span class="line">    HAL_TIM_Encoder_Start(enc-&gt;htim, TIM_CHANNEL_1 | TIM_CHANNEL_2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：绑定左右编码器并启动对应的接口，可按照如下方式调用该函数，需输入对应的编码器结构体与相关联的定时器句柄：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Encoder_Init(&amp;encL, &amp;htim2);</span><br><span class="line">Encoder_Init(&amp;encR, &amp;htim5);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-6-3-获取计数"><a href="#3-6-3-获取计数" class="headerlink" title="3.6.3 获取计数"></a>3.6.3 获取计数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">Encoder_GetCount</span><span class="params">(Encoder_HandleTypeDef *enc)</span>{</span><br><span class="line">    <span class="type">int16_t</span> raw = __HAL_TIM_GET_COUNTER(enc-&gt;htim);</span><br><span class="line">    <span class="comment">// 计算与上次读取的差值（考虑 16 位上下溢出）</span></span><br><span class="line">    <span class="type">int32_t</span> delta = (<span class="type">int32_t</span>)raw - (<span class="type">int32_t</span>)(enc-&gt;count &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    <span class="keyword">if</span> (delta &gt;  <span class="number">32767</span>) delta -= <span class="number">65536</span>;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">-32768</span>) delta += <span class="number">65536</span>;</span><br><span class="line">    enc-&gt;count += delta;</span><br><span class="line">    <span class="keyword">return</span> enc-&gt;count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftCountGlobal = Encoder_GetCount(&amp;encL);</span><br><span class="line">rightCountGlobal = Encoder_GetCount(&amp;encR);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-6-4-编码器清零"><a href="#3-6-4-编码器清零" class="headerlink" title="3.6.4 编码器清零"></a>3.6.4 编码器清零</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Reset</span><span class="params">(Encoder_HandleTypeDef *enc)</span>{</span><br><span class="line">    __HAL_TIM_SET_COUNTER(enc-&gt;htim, <span class="number">0</span>);</span><br><span class="line">    enc-&gt;count = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Encoder_Reset(&amp;encL);</span><br><span class="line">Encoder_Reset(&amp;encR);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-7-悬崖传感器"><a href="#3-7-悬崖传感器" class="headerlink" title="3.7 悬崖传感器"></a>3.7 悬崖传感器</h3><p>共有四个悬崖传感器（0~3），使用ADC和DMA进行读取并由TIM3定时触发，ADC的配置，TIM3配置如下图所示：</p>
<p><img src="/images/sweeping/199ddcda12ad6a107ae417b5d0cb4fcc.png" alt="图3.6：CubeMX中对TIM3的配置"></p>
<p><img src="/images/sweeping/f3cae215a22a5eff131ca7634ac819ef.png" alt="图3.7：CubeMX中对ADC的配置"></p>
<h4 id="3-7-1-初始化"><a href="#3-7-1-初始化" class="headerlink" title="3.7.1 初始化"></a>3.7.1 初始化</h4><p>编写以下函数，以启动定时器3的定时触发以及DMA：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CliffSensor_Init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    HAL_TIM_Base_Start(&amp;htim3);  <span class="comment">// 启动 TIM3 基本定时器</span></span><br><span class="line">    HAL_ADC_Start_DMA(&amp;hadc1, (<span class="type">uint32_t</span>*)adc_values, CLIFF_SENSOR_COUNT);  <span class="comment">//启动 ADC + DMA，读取 CLIFF_SENSOR_COUNT 个通道</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-7-2-读取四个传感器值"><a href="#3-7-2-读取四个传感器值" class="headerlink" title="3.7.2 读取四个传感器值"></a>3.7.2 读取四个传感器值</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CliffSensor_GetValues</span><span class="params">(<span class="type">uint16_t</span> *out)</span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLIFF_SENSOR_COUNT; i++)</span><br><span class="line">		out[i] = adc_values[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CliffSensor_GetValues(sensor_vals);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-7-3-判断单个传感器的状态"><a href="#3-7-3-判断单个传感器的状态" class="headerlink" title="3.7.3 判断单个传感器的状态"></a>3.7.3 判断单个传感器的状态</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CliffSensor_IsCliff</span><span class="params">(<span class="type">uint8_t</span> idx)</span>{</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= CLIFF_SENSOR_COUNT) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 越界保护</span></span><br><span class="line">    <span class="keyword">return</span> (adc_values[idx] &lt; cliff_thresholds[idx]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用时传入对应传感器编号（0~3）即可。</p>
<h4 id="3-7-4-用掩码返回所有传感器状态编码器清零"><a href="#3-7-4-用掩码返回所有传感器状态编码器清零" class="headerlink" title="3.7.4 用掩码返回所有传感器状态编码器清零"></a>3.7.4 用掩码返回所有传感器状态编码器清零</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">CliffSensor_GetMask</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="type">uint8_t</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (CliffSensor_IsCliff(<span class="number">0</span>)) mask |= CLIFF_1;</span><br><span class="line">    <span class="keyword">if</span> (CliffSensor_IsCliff(<span class="number">1</span>)) mask |= CLIFF_2;</span><br><span class="line">    <span class="keyword">if</span> (CliffSensor_IsCliff(<span class="number">2</span>)) mask |= CLIFF_3;</span><br><span class="line">    <span class="keyword">if</span> (CliffSensor_IsCliff(<span class="number">3</span>)) mask |= CLIFF_4;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mask == <span class="number">0</span>) {</span><br><span class="line">    LED_Toggle(&amp;LED0);</span><br><span class="line">    LED_Toggle(&amp;LED1);</span><br><span class="line">    LED_Toggle(&amp;LED2);</span><br><span class="line">    LED_Toggle(&amp;LED3);</span><br><span class="line">    HAL_Delay(<span class="number">200</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; CLIFF_1) LED_On(&amp;LED0);</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; CLIFF_2) LED_On(&amp;LED1);</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; CLIFF_3) LED_On(&amp;LED2);</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; CLIFF_4) LED_On(&amp;LED3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-8-碰撞传感器"><a href="#3-8-碰撞传感器" class="headerlink" title="3.8 碰撞传感器"></a>3.8 碰撞传感器</h3><p>机器人左前方右前方各有一个碰撞传感器，为数字器件，采用与按钮类似的逻辑编写即可，此处和悬崖一样使用了掩码方式来进行统一的封装：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CrashSensor_Left</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">// 微动开关闭合时将GPIO拉低，读取GPIO_PIN_RESET表示碰撞</span></span><br><span class="line">	<span class="keyword">return</span> (HAL_GPIO_ReadPin(CRASH_L_GPIO_Port,CRASH_L_Pin)==GPIO_PIN_RESET);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CrashSensor_Right</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">	<span class="keyword">return</span> (HAL_GPIO_ReadPin(CRASH_R_GPIO_Port,CRASH_R_Pin)==GPIO_PIN_RESET);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">CrashSensor_GetStatus</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="type">uint8_t</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (CrashSensor_Left())		</span><br><span class="line">        status |= (<span class="number">1U</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (CrashSensor_Right())		</span><br><span class="line">        status |= (<span class="number">1U</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-9-电压读取"><a href="#3-9-电压读取" class="headerlink" title="3.9 电压读取"></a>3.9 电压读取</h3><p>如下图所示，R124和R128阻值分别为18kΩ和1kΩ，根据分压原理，电池电压为连接ADC处的19倍，据此我们只需要用ADC读取该处模拟值还原为电压值再乘19就可以得到电池电压。此处ADC也为ADC1，与悬崖传感器一同读取。用于读取电压值的回调函数如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">BT15V_GetVoltage</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">	<span class="comment">// BT15V通道采样值（最后一个）</span></span><br><span class="line">    <span class="type">uint16_t</span> raw = adc_values[CLIFF_SENSOR_COUNT];</span><br><span class="line">    <span class="type">float</span> v_adc = ((<span class="type">float</span>)raw) * ADC_REF_VOLTAGE / ADC_RESOLUTION;</span><br><span class="line">    <span class="type">float</span> v_battery = v_adc * DIVIDER_RATIO;</span><br><span class="line">    <span class="type">float</span> battery = (v_battery - MIN_V) / V_Range * <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span> (battery &gt; <span class="number">100</span>)	</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">return</span> (v_battery - MIN_V) / V_Range * <span class="number">100</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-10-本章小结"><a href="#3-10-本章小结" class="headerlink" title="3.10 本章小结"></a>3.10 本章小结</h3><p>至此完成了单片机所需调用的所有外设的基础配置工作，并已经过基本的功能验证测试，确认各外设配置与调用均正常。负责嵌入式开发的成员将上述内容整合成使用文档，提供给负责算法的成员进行控制算法等的二次开发工作。此外，为方便版本管理，将嵌入式程序推至远程Github仓库以便于远程协同工作，仓库地址：<a target="_blank" rel="noopener" href="https://github.com/PyConqueror-16/Sweeping">PyConqueror-16/Sweeping</a>。</p>
<h2 id="4-上位机监控系统开发"><a href="#4-上位机监控系统开发" class="headerlink" title="4 上位机监控系统开发"></a>4 上位机监控系统开发</h2><h3 id="4-1-系统架构"><a href="#4-1-系统架构" class="headerlink" title="4.1 系统架构"></a>4.1 系统架构</h3><h4 id="4-1-1-模块化设计思路"><a href="#4-1-1-模块化设计思路" class="headerlink" title="4.1.1 模块化设计思路"></a>4.1.1 模块化设计思路</h4><p>本系统采用”核心-功能-接口”三级模块化架构（如图1所示），各模块通过标准化接口进行通信。</p>
<p>具体设计原则如下：</p>
<ol>
<li>   功能解耦设计</li>
</ol>
<ul>
<li><p>ControlProtocol：模块独立处理指令编码，不依赖具体通信方式；</p>
</li>
<li><p>KeyboardController：将输入事件转换为标准速度指令；</p>
</li>
<li><p>BluetoothProtocol：输出结构化数据，界面模块负责可视化；</p>
</li>
</ul>
<ol start="2">
<li>   接口标准化</li>
</ol>
<ul>
<li><p>控制协议接口</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContrilProtocol</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_command</span>(<span class="params">mode: <span class="built_in">int</span>, speed_left: <span class="built_in">int</span>, speed_right: <span class="built_in">int</span></span>) -\&gt; <span class="built_in">bytes</span>:</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>键盘控制接口</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KeyboardController</span>(<span class="title class_ inherited__">QObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eventFilter</span>(<span class="params">self, obj: QObject, event, QEvent</span>) -\&gt; <span class="built_in">bool</span>:</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>数据解析接口</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BluetoothProtocol</span>:	</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_data</span>(<span class="params">self, raw_data: <span class="built_in">bytes</span></span>) -\&gt; <span class="type">List</span>[<span class="type">Dict</span>]:</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>串口通信接口</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SerialThread</span>(<span class="title class_ inherited__">QThread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_command</span>(<span class="params">self, command: <span class="built_in">bytes</span></span>):</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<ol start="3">
<li>   状态管理机制</li>
</ol>
<ul>
<li><p>采用”发布-订阅”模式处理模块间状态同步；</p>
</li>
<li><p>关键状态变更通过PyQt信号通知相关模块；</p>
</li>
<li><p>共享数据通过队列实现线程安全访问。</p>
</li>
</ul>
<ol start="4">
<li>   异常隔离设计</li>
</ol>
<ul>
<li><p>通信异常限制在SerialThread模块内处理；</p>
</li>
<li><p>界面卡顿不影响后台数据处理；</p>
</li>
<li><p>协议解析错误自动触发数据重传机制。</p>
</li>
</ul>
<h4 id="4-1-2-主要功能组件划分"><a href="#4-1-2-主要功能组件划分" class="headerlink" title="4.1.2 主要功能组件划分"></a>4.1.2 主要功能组件划分</h4><p>系统功能组件及其相互关系：</p>
<p>表4.1 系统功能组件及其相互关系</p>
<table>
<thead>
<tr>
<th>组件类型</th>
<th>核心组件</th>
<th>功能描述</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody><tr>
<td>控制核心</td>
<td>ControlCenter</td>
<td>协调各模块运行，维护系统状态机</td>
<td>依赖所有功能组件</td>
</tr>
<tr>
<td>通信链</td>
<td>SerialThread</td>
<td>管理串口连接，实现数据收发多线程处理</td>
<td>→BluetoothProtocol</td>
</tr>
<tr>
<td></td>
<td>BluetoothProtocol</td>
<td>解析原始数据帧，校验数据完整性</td>
<td>← SerialThread</td>
</tr>
<tr>
<td>人机交互</td>
<td>KeyboardController</td>
<td>将键盘事件转换为标准控制指令</td>
<td>→ ControlProtocol</td>
</tr>
<tr>
<td></td>
<td>GUIComponents</td>
<td>提供速度调节、模式切换等交互控件</td>
<td>→ ControlCenter</td>
</tr>
<tr>
<td>数据处理</td>
<td>DataProcessor</td>
<td>提供速度调节、模式切换等交互控件</td>
<td>←BluetoothProtocol</td>
</tr>
<tr>
<td>可视化</td>
<td>TrajectoryVisualizer</td>
<td>实时绘制机器人轨迹和姿态</td>
<td>← DataProcessor</td>
</tr>
<tr>
<td></td>
<td>StatusDashboard</td>
<td>显示速度、电量等实时参数</td>
<td>← DataProcessor</td>
</tr>
<tr>
<td>高级功能</td>
<td>PathPlanner</td>
<td>实现牛耕式覆盖路径规划算法</td>
<td>→ ControlProtocol</td>
</tr>
<tr>
<td></td>
<td>DataRecorder</td>
<td>支持轨迹记录与回放功能</td>
<td>← DataProcessor</td>
</tr>
</tbody></table>
<p><img src="/images/sweeping/3a7b4d4df98c054822a5604dd3a2eb99.png" alt="图4.1 组件交互图"></p>
<h4 id="4-1-3-数据流与控制流分析"><a href="#4-1-3-数据流与控制流分析" class="headerlink" title="4.1.3 数据流与控制流分析"></a>4.1.3 数据流与控制流分析</h4><p>表4.2 通信数据流一览表</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>方向</th>
<th>频率</th>
<th>数据量</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>控制指令</td>
<td>上位→下位</td>
<td>5-10Hz</td>
<td>6Byte</td>
<td>立即发送</td>
</tr>
<tr>
<td>状态数据</td>
<td>下位→上位</td>
<td>10Hz</td>
<td>14Byte</td>
<td>队列缓冲+定时处理</td>
</tr>
<tr>
<td>轨迹坐标</td>
<td>内部传输</td>
<td>5Hz</td>
<td>12Byte</td>
<td>环形缓冲区存储</td>
</tr>
<tr>
<td>配置参数</td>
<td>双向</td>
<td>事件触发</td>
<td>≤1KB</td>
<td>JSON序列化</td>
</tr>
</tbody></table>
<p>实时控制流（周期≤100ms）为：</p>
<ol>
<li><p>键盘输入 → KeyboardController生成标准化速度值(-100~100)</p>
</li>
<li><p>ControlProtocol将速度值编码为机器指令(0xAA 0x01…)</p>
</li>
<li><p>SerialThread通过串口发送指令</p>
</li>
<li><p>下位机响应指令并返回状态数据</p>
</li>
<li><p>BluetoothProtocol校验解析数据帧</p>
</li>
<li><p>DataProcessor进行数据平滑处理</p>
</li>
<li><p>GUI线程定时获取处理后的数据更新界面</p>
</li>
</ol>
<p>此外，我们还针对多线程任务进行了线程安全设计，采用”生产者-消费者”模式处理串口数据，并使用QTimer实现跨线程定时触发。其中的共享资源通过QMutex进行保护。</p>
<h3 id="4-2-技术选型"><a href="#4-2-技术选型" class="headerlink" title="4.2 技术选型"></a>4.2 技术选型</h3><h4 id="4-2-1-开发框架：Python-PyQt5"><a href="#4-2-1-开发框架：Python-PyQt5" class="headerlink" title="4.2.1 开发框架：Python+PyQt5"></a>4.2.1 开发框架：Python+PyQt5</h4><p>本系统选用Python 3.8 + PyQt5作为基础技术栈，主要基于以下考量：</p>
<ul>
<li><p>Python原型能够快速开发，具有很强的开发效率优势;</p>
</li>
<li><p>Python动态特性支持实时调试，界面修改可热更新；</p>
</li>
<li><p>Python具有丰富的标准库，os/sys/json等模块简化文件操作和数据处理；</p>
</li>
<li><p>PyQt5有特有完善的GUI组件，提供超过620个可直接使用的类，对比Tkinter仅约150个；</p>
</li>
<li><p>PyQt5的信号槽机制能实现低耦合的模块通信；</p>
</li>
<li><p>PyQt5样式定制能力支持CSS语法美化界面。</p>
</li>
</ul>
<h4 id="4-2-2-Matplotlib用于数据可视化"><a href="#4-2-2-Matplotlib用于数据可视化" class="headerlink" title="4.2.2 Matplotlib用于数据可视化"></a>4.2.2 Matplotlib用于数据可视化</h4><p>采用FigureCanvasQTAgg后端实现与PyQt5无缝集成。优化后的轨迹绘制可处理10000+数据点无卡顿。</p>
<p>表4.3 Matplotlib功能实现方案与性能需求对应一览表</p>
<table>
<thead>
<tr>
<th>需求</th>
<th>Matplotlib实现方案</th>
<th>性能指标</th>
</tr>
</thead>
<tbody><tr>
<td>机器人位姿显示</td>
<td><strong>Arrow</strong>+<strong>Circle</strong>补丁组合</td>
<td>渲染耗时&lt;15ms</td>
</tr>
<tr>
<td>历史轨迹覆盖</td>
<td><strong>fill_between</strong>+透明度控制</td>
<td>支持5000点实时绘制</td>
</tr>
<tr>
<td>动态坐标轴</td>
<td>**set_xlim()**智能缩放</td>
<td>自适应刷新率</td>
</tr>
</tbody></table>
<h4 id="4-2-3-PySerial串口通信库"><a href="#4-2-3-PySerial串口通信库" class="headerlink" title="4.2.3 PySerial串口通信库"></a>4.2.3 PySerial串口通信库</h4><p>选用PySerial作为串口通信解决方案，主要基于其简洁高效的API设计以及稳定的通信性能。通过非阻塞读取和双缓冲机制优化，有效避免了数据堆积问题，配合定时发送控制策略（100ms间隔），在Windows平台上保持稳定表现。相较于Qt原生QSerialPort，PySerial虽然与Qt集成度稍逊，但其更简洁的异常处理机制和无需额外依赖的特性，使其成为本项目中平衡性能与开发效率的最佳选择，最终实现了与STM32下位机10Hz稳定通信、500ms内快速校正的优异表现。</p>
<h3 id="4-3-用户界面设计"><a href="#4-3-用户界面设计" class="headerlink" title="4.3 用户界面设计"></a>4.3 用户界面设计</h3><h4 id="4-3-1-主界面布局"><a href="#4-3-1-主界面布局" class="headerlink" title="4.3.1 主界面布局"></a>4.3.1 主界面布局</h4><p>在主界面布局上，采用经典的”三明治”布局设计，如下图所示：</p>
<p><img src="/images/sweeping/43a402949388b42fc8a0aee2a9e4e700.png" alt="图4.2：整体界面结构"></p>
<p>可以看到，界面中主要包含以下三块主要的功能区域：</p>
<ul>
<li><p>顶部控制区（设备连接组、控制设置组）</p>
</li>
<li><p>中部数据显示区（左侧实时数据面板、右侧轨迹图）</p>
</li>
<li><p>底部功能区（辅助控制按钮组、帮助信息栏）</p>
</li>
</ul>
<h4 id="4-3-2-交互设计"><a href="#4-3-2-交互设计" class="headerlink" title="4.3.2 交互设计"></a>4.3.2 交互设计</h4><p>本项目用户GUI界面的交互设计主要体现在以下几个板块：</p>
<ul>
<li>控制面板交互：主要包含速度调节交互（滑块与数值标签联动）与设备连接（流程图如下图所示）</li>
</ul>
<p><img src="/images/sweeping/f110ade6282a9e4a7201de18f07e34cf.png" alt="图4.3：设备连接流程"></p>
<ul>
<li>数据可视化：</li>
</ul>
<p><img src="/images/sweeping/9d7caeab092192989c467468641dd624.png" alt="图4.4：轨迹可视化示意图"></p>
<ul>
<li>状态反馈机制：</li>
</ul>
<p><img src="/images/sweeping/85baaef52f77c32c854f2674852eab87.png" alt="图4.5：状态反馈图"></p>
<p>在评价交互的响应性能时，我们设定了以下指标，保证用户在界面交互过程中能够得到即时且准确的反馈：</p>
<p>表4.4 交互性能响应指标</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>响应延迟</th>
<th>视觉反馈方式</th>
</tr>
</thead>
<tbody><tr>
<td>按钮点击</td>
<td>&lt;50ms</td>
<td>按钮下沉动画</td>
</tr>
<tr>
<td>滑块拖动</td>
<td>即时</td>
<td>数值标签实时更新</td>
</tr>
<tr>
<td>键盘控制</td>
<td>&lt;30ms</td>
<td>轨迹即时更新</td>
</tr>
<tr>
<td>数据加载</td>
<td>&lt;200ms</td>
<td>进度条+旋转等待图标</td>
</tr>
</tbody></table>
<h3 id="4-4-核心功能模块"><a href="#4-4-核心功能模块" class="headerlink" title="4.4 核心功能模块"></a>4.4 核心功能模块</h3><h4 id="4-4-1-通讯协议模块（ControlProtocol）"><a href="#4-4-1-通讯协议模块（ControlProtocol）" class="headerlink" title="4.4.1 通讯协议模块（ControlProtocol）"></a>4.4.1 通讯协议模块（ControlProtocol）</h4><p>实现上下位机通讯时，我们采用帧通讯的方式实现即时通讯。其中，协议帧具有双极性速度编码（正/负方向独立处理），校验和简化算法（求和取低8位），固定6字节帧长保证传输效率等特点。</p>
<p><img src="/images/sweeping/a7fa844c057dc00af204e5cff1c7c620.png" alt="图4.6：协议帧结构示意图"></p>
<h4 id="4-4-2-键盘控制模块（KeyboardController）"><a href="#4-4-2-键盘控制模块（KeyboardController）" class="headerlink" title="4.4.2 键盘控制模块（KeyboardController）"></a>4.4.2 键盘控制模块（KeyboardController）</h4><p>在该模块中定义并实现了基本的按键与遥操作功能，并引入了防抖机制。</p>
<p><img src="/images/sweeping/5a5f42e1f3f3a93762e4ae9cf7dc2caa.png" alt="图4.7：按键控制模块"></p>
<h4 id="4-4-3-蓝牙协议解析（BluetoothProtocol）"><a href="#4-4-3-蓝牙协议解析（BluetoothProtocol）" class="headerlink" title="4.4.3 蓝牙协议解析（BluetoothProtocol）"></a>4.4.3 蓝牙协议解析（BluetoothProtocol）</h4><p><img src="/images/sweeping/04ceacbbd25d8292cdb37e3613cb237f.png" alt="图4.8：蓝牙协议解析器"></p>
<h4 id="4-4-4-串口通信线程（SerialThread）"><a href="#4-4-4-串口通信线程（SerialThread）" class="headerlink" title="4.4.4 串口通信线程（SerialThread）"></a>4.4.4 串口通信线程（SerialThread）</h4><p><img src="/images/sweeping/ba152d8c01473e9a3d32279c92826c11.png" alt="图4.9：通信线程工作流程图"></p>
<p><img src="/images/sweeping/cf9aea1a664a9ec5da07a0815e15c37f.png" alt="图4.10 串口通信"></p>
<h3 id="4-5-高级功能实现"><a href="#4-5-高级功能实现" class="headerlink" title="4.5 高级功能实现"></a>4.5 高级功能实现</h3><h4 id="4-5-1-轨迹记录与回放"><a href="#4-5-1-轨迹记录与回放" class="headerlink" title="4.5.1 轨迹记录与回放"></a>4.5.1 轨迹记录与回放</h4><p><img src="/images/sweeping/e95e1c3a8f4122a52ec60e0a43e204c9.png" alt="图4.11 记录回放系统架构"></p>
<p><img src="/images/sweeping/e0675fb42f5b329c770e6b9a6fcaf9f6.png" alt="图4.12 回放JSON数据示例"></p>
<p>数据中包含：记录动作创建时间，传送指令总量，总持续时间，控制模式；时间，指令间时间差，指令，模式。</p>
<h4 id="4-5-2-地图数据管理"><a href="#4-5-2-地图数据管理" class="headerlink" title="4.5.2 地图数据管理"></a>4.5.2 地图数据管理</h4><p>JSON文件具有加载速度快、压缩率高、可读性强的特点，所以地图存储同样使用JSON文件的不同格式来保存地图信息。</p>
<p><img src="/images/sweeping/9d7caeab092192989c467468641dd624.png" alt="图4.13：加载地图控制面板UI及效果"></p>
<h4 id="4-5-3-路径规划功能"><a href="#4-5-3-路径规划功能" class="headerlink" title="4.5.3 路径规划功能"></a>4.5.3 路径规划功能</h4><p>此处仅展示路径规划算法可视化效果，具体算法细节在第五章详细阐述。</p>
<p><img src="/images/sweeping/49e15d8e58c26e495a87d5a66ec55210.png" alt="图4.14：路径规划效果"></p>
<h3 id="4-6-本章小结"><a href="#4-6-本章小结" class="headerlink" title="4.6 本章小结"></a>4.6 本章小结</h3><p>本章详细介绍了上位机监测与控制系统的设计流程，从整体架构到功能实现效果，有效实现了上下位机间的相互通信，并能成功进行遥控功能与数据可视化。界面交互设计上充分考虑人因学因素，布局合理，简单易用，能够方便用户实现对机器人即时而准确的移动控制与状态监测。</p>
<h2 id="5-控制逻辑与算法设计"><a href="#5-控制逻辑与算法设计" class="headerlink" title="5 控制逻辑与算法设计"></a>5 控制逻辑与算法设计</h2><h3 id="5-1-下位机整体底盘控制逻辑"><a href="#5-1-下位机整体底盘控制逻辑" class="headerlink" title="5.1 下位机整体底盘控制逻辑"></a>5.1 下位机整体底盘控制逻辑</h3><p>根据需求分析部分提出的设计需求与性能指标，在下位机的底盘控制上主要分为如下几个控制功能逻辑模块：</p>
<ul>
<li><p>模式指令读取/基于按键切换</p>
</li>
<li><p>基于编码器获取实时电机转速并利用PID控制器调节电机转速</p>
</li>
<li><p>机器人实时位姿解算与惯导定位</p>
</li>
<li><p>针对碰撞/悬崖等传感器感知数据做出实时响应</p>
</li>
</ul>
<p>这些模块间的交互关系如下面的逻辑框图所示。接下来将依次介绍各模块的实现细节。</p>
<p><img src="/images/sweeping/ce7555b459e932906d3bd4319d4528a9.png" alt="图5.1：下位机整体底盘控制逻辑"></p>
<p>接下来将依次介绍各模块的实现细节。</p>
<h4 id="5-1-1-开-关机按键与模式指令接受逻辑设计"><a href="#5-1-1-开-关机按键与模式指令接受逻辑设计" class="headerlink" title="5.1.1 开/关机按键与模式指令接受逻辑设计"></a>5.1.1 开/关机按键与模式指令接受逻辑设计</h4><p>在开关机按键与模式切换逻辑设计上，我们采用了如下图所示的框图逻辑，充分利用电路板上预留的两个按键，实现机器人的开关机：</p>
<p><img src="/images/sweeping/c52760362365fd0b46ccccac6151cb66.png" alt="图5.2：模式切换逻辑"></p>
<p>扫地机器人一共具有三种状态模式，模式代码及其对应功能如下：</p>
<ul>
<li><p>0 ROBOT_OFF：关机状态，位姿和里程均重置为0</p>
</li>
<li><p>1 REMOTE_CONTROL：遥控模式，左右轮速度通过上位机指令获取</p>
</li>
<li><p>2 AUTO_MAPPING：自主建图模式，按设定速度（左轮15cm/s，右轮3cm/s）结合碰撞传感器实现贴墙行进</p>
</li>
</ul>
<p>其中，模式1和模式2由接收到的上位机数据包经函数解析后得到的模式码决定，上位机GUI中可自由切换。同时，为便于用户日常使用，我们将PCB电路板上预留的两个按钮KEY0与KEY1使能，通过上述逻辑使得：按下KEY0后为关机状态，此时置为模式0且不会接收上位机发送的模式信息；按下KEY1后为开机状态，此时开始接收上位机发送的模式信息，并按照上位机指令进行后续运动。</p>
<p>该模块实现的主要代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新按键状态</span></span><br><span class="line">Key_Update(&amp;key[<span class="number">0</span>]); <span class="comment">// 检测KEY0：按下关机</span></span><br><span class="line">Key_Update(&amp;key[<span class="number">1</span>]); <span class="comment">// 检测KEY1：按下开机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模式切换</span></span><br><span class="line"><span class="keyword">if</span> (Key_GetState(&amp;key[<span class="number">0</span>]) == KEY_STATE_JUST_PRESSED){</span><br><span class="line">    robot_mode = ROBOT_OFF;</span><br><span class="line">    start_get_mode = <span class="number">0</span>;</span><br><span class="line">    current_mode = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Key_GetState(&amp;key[<span class="number">1</span>]) == KEY_STATE_JUST_PRESSED)		</span><br><span class="line">    start_get_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start_get_mode)			</span><br><span class="line">    robot_mode = HC05_GetControlMode();</span><br></pre></td></tr></tbody></table></figure>

<p>其中调用了用于重置机器人状态的函数ResetRobotState，在关机时会运行该函数，重置当前存储的偏角、里程等数据：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置机器人状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ResetRobotState</span><span class="params">(<span class="type">float</span>* x, <span class="type">float</span>* y, <span class="type">float</span>* distance_all, <span class="type">uint32_t</span>*round, <span class="type">int</span> crash_flag)</span> {</span><br><span class="line">    imu = JY901S_GetData();</span><br><span class="line">    *x = *y = *distance_all = <span class="number">0</span>;</span><br><span class="line">    *round = <span class="number">0</span>;</span><br><span class="line">    A4950_SetLeft(<span class="number">0</span>);</span><br><span class="line">    A4950_SetRight(<span class="number">0</span>);</span><br><span class="line">    target_speed_left = <span class="number">0</span>;</span><br><span class="line">    target_speed_right = <span class="number">0</span>;</span><br><span class="line">    crash_flag = <span class="number">0</span>;</span><br><span class="line">    cliff_flag = <span class="number">0</span>;</span><br><span class="line">    memory_deg = imu-&gt;yaw;</span><br><span class="line">    yaw_deg = imu-&gt;yaw - memory_deg;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>5.1.2 基于编码器的电机转速PID控制算法设计</p>
<p>针对电机转速的精准控制，我们选择采用PID控制器，基于经编码器解析而来的实时转速信息实现反馈调节，使得电机转速能够在较短的时间响应达到设定的速度。</p>
<p>在电机转速的获取上，我们基于编码器的读取数据进行解算，换算关系如下：</p>
<p>查阅电机的产品手册，可以获得该电机与编码器对应的相关参数：</p>
<ul>
<li><p>减速比𝑀𝑂𝑇𝑂𝑅_𝑅𝐸𝐷𝑈𝐶𝑇𝐼𝑂𝑁_𝑅𝐴𝑇𝐼𝑂 = 1 : 63</p>
</li>
<li><p>每转过一圈的脉冲数𝑃𝑈𝐿𝑆𝐸_𝑃𝐸𝑅_𝑅𝑂𝑈𝑁𝐷 = 20</p>
</li>
<li><p>单位时间𝑡𝑖𝑚𝑒 = 50ms</p>
</li>
<li><p>轮子周长CIRCLES_OF_TIRE = 34 * 2 * 3.14 mm</p>
</li>
</ul>
<p><img src="/images/sweeping/4927c06774daf1851f036731e80f46b7.png" alt="图5.3：项目中使用的电机与编码器"></p>
<p>基于上述公式，编写以下函数代码，用于计算电机实时转速：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">getLeftSpeed</span><span class="params">(Encoder_HandleTypeDef *enc)</span>{</span><br><span class="line">    leftCount = leftCountGlobal;</span><br><span class="line">    leftCountGlobal = Encoder_GetCount(enc);</span><br><span class="line">    leftCount -= leftCountGlobal;</span><br><span class="line">    leftSpeed = leftCount / time / PULSE_PRE_ROUND / MOTOR_REDUCTION_RATIO * CIRCLES_OF_TIRE / <span class="number">10</span>; <span class="comment">// cm/s</span></span><br><span class="line">	<span class="keyword">return</span> leftSpeed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">getRightSpeed</span><span class="params">(Encoder_HandleTypeDef *enc)</span>{</span><br><span class="line">    rightCount = rightCountGlobal;</span><br><span class="line">    rightCountGlobal = - Encoder_GetCount(enc);</span><br><span class="line">    rightCount -= rightCountGlobal;</span><br><span class="line">    rightSpeed = rightCount/ time / PULSE_PRE_ROUND / MOTOR_REDUCTION_RATIO * CIRCLES_OF_TIRE / <span class="number">10</span>; <span class="comment">// cm/s</span></span><br><span class="line">    <span class="keyword">return</span> rightSpeed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在电机转速控制器上，我们选择最为经典的PID控制器用于实现电机转速的实时反馈调节，PID控制器主要具有以下几个特点：</p>
<ul>
<li><p>为系统指定一个目标值；</p>
</li>
<li><p>PID将目标值与被控对象当前的反馈量作差得到误差；</p>
</li>
<li><p>PID将误差值分别经过三个环节计算得到输出分量，再将三个分量加起来得到PID的输出；</p>
</li>
<li><p>将PID的输出施加到被控对象上，使反馈量向目标值靠拢。</p>
</li>
</ul>
<p><img src="/images/sweeping/3f11aaf72ac4e951387a4d4e81659741.png" alt="图5.4：PID控制算法流程框图与对应数学公式"></p>
<p><img src="/images/sweeping/53f7c75bcc6f0ac7d22d7982a0f0a4af.png" alt="图5.4：PID控制算法流程框图与对应数学公式"></p>
<p>基于上述PID算法原理，我们将其封装成了如下的函数，实现对指定转速的快速动态响应：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PID_Control_Left</span><span class="params">(<span class="type">float</span> target_speed_left)</span>{</span><br><span class="line">    error_left = target_speed_left - leftSpeed;</span><br><span class="line">    integral_left += error_left;</span><br><span class="line">    <span class="keyword">if</span> (integral_left &gt; <span class="number">99.0f</span>)	</span><br><span class="line">        integral_left = <span class="number">99.0f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (integral_left &lt; - <span class="number">99.0f</span>)		</span><br><span class="line">        integral_left = <span class="number">-99.0f</span>;</span><br><span class="line">    derivative_left = error_left - previous_error_left;</span><br><span class="line">    pid_output_left = kp_left * error_left + ki_left * integral_left + kd_left * derivative_left;</span><br><span class="line">    <span class="keyword">if</span> (pid_output_left &gt; <span class="number">99.0f</span>)		</span><br><span class="line">        pid_output_left = <span class="number">99.0f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid_output_left &lt; - <span class="number">99.0f</span>)		</span><br><span class="line">        pid_output_left = <span class="number">-99.0f</span>;</span><br><span class="line">    A4950_SetLeft(pid_output_left * <span class="number">7</span>); <span class="comment">//驱动电机		</span></span><br><span class="line">    previous_error_left = error_left;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PID_Control_Right</span><span class="params">(<span class="type">float</span> target_speed_right)</span>{</span><br><span class="line">    error_right = target_speed_right - rightSpeed;</span><br><span class="line">    integral_right += error_right;</span><br><span class="line">    <span class="keyword">if</span> (integral_right &gt; <span class="number">99.0f</span>)		</span><br><span class="line">        integral_right = <span class="number">99.0f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (integral_right &lt; - <span class="number">99.0f</span>)		</span><br><span class="line">        integral_right = <span class="number">-99.0f</span>;</span><br><span class="line">    derivative_right = error_right - previous_error_right;</span><br><span class="line">    pid_output_right = kp_right * error_right + ki_right * integral_right + kd_right * derivative_right;</span><br><span class="line">    <span class="keyword">if</span> (pid_output_right &gt; <span class="number">99.0f</span>)		</span><br><span class="line">        pid_output_right = <span class="number">99.0f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid_output_right &lt; - <span class="number">99.0f</span>)		</span><br><span class="line">        pid_output_right = <span class="number">-99.0f</span>;</span><br><span class="line">    A4950_SetRight(pid_output_right * <span class="number">7</span>); <span class="comment">//驱动电机	</span></span><br><span class="line">    previous_error_right = error_right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在main函数中，我们可以根据接收到的上位机速度指令，直接调用上述函数读取实时转速并利用PID控制器进行速度调节：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运动控制</span></span><br><span class="line">left_speed = getLeftSpeed(&amp;encL);</span><br><span class="line">right_speed = getRightSpeed(&amp;encR);</span><br><span class="line">PID_Control_Left(target_speed_left);</span><br><span class="line">PID_Control_Right(target_speed_right);</span><br></pre></td></tr></tbody></table></figure>

<p>其中，经过实机测试与调整，我们最终采用的PID控制器参数为：KP=0.1，KI=0.1，KD=0.001。经测试，该组参数在目标电机转速为5至15cm/s时具有高灵敏度与高精度的动态响应特性。</p>
<h4 id="5-1-3-机器人实时位姿解算与惯导定位"><a href="#5-1-3-机器人实时位姿解算与惯导定位" class="headerlink" title="5.1.3 机器人实时位姿解算与惯导定位"></a>5.1.3 机器人实时位姿解算与惯导定位</h4><p>在机器人的位姿解算上，我们采用了综合电机实时转速与IMU惯导模块的方式，通过电机转速计算单个时间步内的分段里程（根据时间步长可以累加得到总里程），同时结合IMU直接读取到当前机器人的面朝偏角（启动时标志为0，范围为-180°~180°），可以得到单个时间步内机器人的近似位移，进而计算出机器人的实时位置坐标（相对于摁下开机键后的起始点而言，起始点坐标（0，0），面朝方向为y轴正方向）。</p>
<p>在实际计算与调试时，为降低调速过程中的距离计算误差，对达到指定速度前后的距离计算进行不同倍率的调整，以尽可能保证距离计算的精准度。</p>
<p>基于以上思想，编写如下代码实现机器人的实时位姿解算与惯导定位：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位姿计算（融合IMU+编码器）</span></span><br><span class="line">imu = JY901S_GetData();</span><br><span class="line"><span class="keyword">if</span> (rounds == <span class="number">10</span>) 		</span><br><span class="line">    memory_deg = imu-&gt;yaw;</span><br><span class="line">yaw_deg = imu-&gt;yaw - memory_deg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left_speed &lt; target_speed_left - <span class="number">1.0f</span>) <span class="comment">// 调速过程优化</span></span><br><span class="line">    distance = (left_speed + right_speed) / <span class="number">2</span> * ROUND_TIME / <span class="number">1000.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 通过轮速获取位移</span></span><br><span class="line">    distance = ((left_speed + right_speed) / <span class="number">2</span> * <span class="number">1.25</span>) * ROUND_TIME / <span class="number">1000.0f</span>;</span><br><span class="line"><span class="keyword">if</span> (target_speed_left == -target_speed_right)		</span><br><span class="line">    distance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">x += distance * <span class="built_in">sin</span>(-yaw_deg * M_PI / <span class="number">180.0f</span>);</span><br><span class="line">y += distance * <span class="built_in">cos</span>(-yaw_deg * M_PI / <span class="number">180.0f</span>);</span><br><span class="line">distance_all += <span class="built_in">fabs</span>(distance);</span><br></pre></td></tr></tbody></table></figure>

<p>后续可将实时总里程、位置坐标与偏角等数据发送至上位机，进行进一步的建图可视化处理。</p>
<h4 id="5-1-4-碰撞-悬崖传感器感知数据处理逻辑设计"><a href="#5-1-4-碰撞-悬崖传感器感知数据处理逻辑设计" class="headerlink" title="5.1.4 碰撞/悬崖传感器感知数据处理逻辑设计"></a>5.1.4 碰撞/悬崖传感器感知数据处理逻辑设计</h4><p>在碰撞与悬崖传感器反馈的感知数据的处理上，我们设计了如下图所示的框图逻辑（以碰撞为例，逻辑上设置碰撞传感器的处理优先级高于悬崖，事实上两者往往互斥），让机器人实现贴墙/悬崖行进，以尽可能地清扫到所有的清洁死角：</p>
<ul>
<li><p>在<strong>遥控</strong>模式下，为避免机器人进入视野盲区（如床底等区域）而产生误操作，设定该模式下机器人遇到障碍物时（即碰撞传感器触发）先后退再原地掉头。</p>
</li>
<li><p>在<strong>自主运动（建图）</strong>模式下，为使得机器人尽可能稳定地贴墙行进，针对两侧碰撞传感器共三种不同的触发状态，分别设置了不同的转角提供给turning_left函数执行左转，并在达到指定转角后重置碰撞状态。</p>
</li>
</ul>
<p><img src="/images/sweeping/5f4ad02320b02c9a50eae0e7af4213c5.png" alt="图5.5：碰撞传感器感知数据处理逻辑设计"></p>
<p>显然，处于保护机器人自身安全的原则，其对于传感器的感知数据做出的任何反应的优先级均应高于上位机的控制命令。</p>
<p>为对于不同的碰撞情形进行区分，我们对碰撞状态码进行了区分，并设定了机器人在不同碰撞状态下应该做出的反应，以尽可能完成贴墙行走的任务：</p>
<ul>
<li><p>crash_status = 1 ：左侧碰撞 —— 左转60°</p>
</li>
<li><p>crash_status = 3 ：两侧均碰撞 —— 左转40°</p>
</li>
<li><p>crash_status = 2 ：右侧碰撞 —— 持续左转直至不再碰撞（直行）</p>
</li>
<li><p>crash_status = 0 ：无碰撞，按照上位机发送速度或设定速度继续行进</p>
</li>
</ul>
<p>针对悬崖传感器，其感知数据的处理逻辑与碰撞类似，均为先后退再原地掉头（偏转一定角度后继续行进）。不同的是，由于悬崖传感器本质上是红外传感器，因此我们需要事先测定其阈值（由于不同传感器的性能差异，其阈值也有所不同）为{245，145，190，130}。本项目使用的扫地机器人硬件设备上共有四个悬崖传感器，其中任一触发时（大于阈值）其对应的二进制掩码cliff_mask均不为0，此时可认为机器人已到达悬崖边缘，需要做出对应的响应。</p>
<p>针对遥控模式，处理碰撞与悬崖传感器感知数据的代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先处理碰撞</span></span><br><span class="line"><span class="keyword">if</span> (crash_status == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (crash_flag == <span class="number">1</span>) </span><br><span class="line">        turning_left(<span class="number">175</span>);</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    imu = JY901S_GetData();</span><br><span class="line">    <span class="keyword">if</span> (crash_flag == <span class="number">0</span>) {</span><br><span class="line">        turn_start_deg = imu-\&gt;yaw;</span><br><span class="line">        target_speed_left = <span class="number">-5</span>;</span><br><span class="line">        target_speed_right = <span class="number">-5</span>;</span><br><span class="line">        crash_flag = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次处理悬崖</span></span><br><span class="line"><span class="keyword">if</span> (cliff_mask == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> (cliff_flag == <span class="number">1</span>) </span><br><span class="line">        turning_left(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    imu = JY901S_GetData();</span><br><span class="line">    <span class="keyword">if</span> (cliff_flag == <span class="number">0</span>) {</span><br><span class="line">        turn_start_deg = imu-\&gt;yaw;</span><br><span class="line">        A4950_SetLeft(<span class="number">0</span>);</span><br><span class="line">        A4950_SetRight(<span class="number">0</span>);</span><br><span class="line">        target_speed_left = <span class="number">-5</span>;</span><br><span class="line">        target_speed_right = <span class="number">-5</span>;</span><br><span class="line">        cliff_flag = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>针对自主运动（建图）模式，处理碰撞与悬崖传感器感知数据的代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先处理碰撞</span></span><br><span class="line"><span class="keyword">if</span> (crash_status == <span class="number">0</span>){</span><br><span class="line">	<span class="keyword">if</span> (crash_flag == <span class="number">0</span>){</span><br><span class="line">		target_speed_left = <span class="number">15.0f</span>;</span><br><span class="line">		target_speed_right = <span class="number">3.0f</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (crash_flag == <span class="number">1</span>) 	</span><br><span class="line">        turning_left(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (crash_flag == <span class="number">2</span>) {</span><br><span class="line">        target_speed_left = <span class="number">-5.0f</span>;</span><br><span class="line">    	target_speed_right = <span class="number">5.0f</span>;</span><br><span class="line">           crash_flag = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (crash_flag == <span class="number">3</span>) 	</span><br><span class="line">    	turning_left(<span class="number">40</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">	imu = JY901S_GetData();</span><br><span class="line">	<span class="keyword">if</span> (crash_flag == <span class="number">0</span>){</span><br><span class="line">		turn_start_deg = imu-&gt;yaw;</span><br><span class="line">		<span class="keyword">if</span> (crash_status == <span class="number">1</span>)		</span><br><span class="line">            crash_flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (crash_status == <span class="number">2</span>) {</span><br><span class="line">			target_speed_left = <span class="number">-5.0f</span>;</span><br><span class="line">			target_speed_right = <span class="number">5.0f</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (crash_status == <span class="number">3</span>)		</span><br><span class="line">            crash_flag = <span class="number">3</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (crash_flag == <span class="number">1</span>) 	</span><br><span class="line">        turning_left(<span class="number">60</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (crash_flag == <span class="number">2</span>) {</span><br><span class="line">		target_speed_left = <span class="number">-5.0f</span>;</span><br><span class="line">		target_speed_right = <span class="number">5.0f</span>;</span><br><span class="line">		crash_flag = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (crash_flag == <span class="number">3</span>) 	</span><br><span class="line">        turning_left(<span class="number">40</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次处理悬崖</span></span><br><span class="line"><span class="keyword">if</span> (cliff_mask != <span class="number">0</span>) {</span><br><span class="line">	target_speed_left = <span class="number">-5</span>;</span><br><span class="line">	target_speed_right = <span class="number">-5</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-2-全覆盖路径规划算法设计：牛耕式扫描Boustrophedon"><a href="#5-2-全覆盖路径规划算法设计：牛耕式扫描Boustrophedon" class="headerlink" title="5.2 全覆盖路径规划算法设计：牛耕式扫描Boustrophedon"></a>5.2 全覆盖路径规划算法设计：牛耕式扫描Boustrophedon</h3><p>针对扫地这一具体应用场景，希望尽可能不放过区域内的每一个清洁死角，这实际是一个全覆盖路径规划(Complete Coverage Path Planning, CCPP)任务，需要确定一条路径，在避开障碍物的情况下通过该区域范围内的所有点。</p>
<p>我们选择采用离线式的牛耕式扫描法，基于静态环境信息，通过不断地覆盖分割后的子区域实现整个区域的全覆盖。牛耕式扫描（Boustrophedon Coverage）是一种高效的全覆盖路径规划算法，其核心思想是模拟农耕时的犁地模式，通过往复式运动实现无遗漏覆盖。算法首先将工作区域划分为若干条带，条带宽度w由机器人清扫半径（经测量机器人机身直径为32cm）决定，相邻条带间距通常取d≤w以确保覆盖连续性。机器人沿初始方向（y轴）移动，到达边界后垂直偏移d并反向移动，形成如下的路径模式：<br>$$<br>\begin{cases}x_{k+1}=x_k+(-1)^k\cdot L\y_{k+1}=y_k+d&amp;\end{cases}<br>$$<br>其中L为条带长度，k为往返计数。当遇到障碍物时，算法会将区域分解为若干子多边形，在每个子区域内独立执行牛耕式扫描。该方法的覆盖率理论上可达100%，其路径总长度可表示为：<br>$$<br>D\approx\frac{A}{w}\cdot(L+2t)<br>$$<br>式中A为区域面积，t为转向损耗距离。</p>
<p>实际应用中，该算法常结合SLAM技术动态调整w，并通过匈牙利算法优化子区域访问顺序以提升效率。这种平衡了覆盖率和能耗的特性，使其成为扫地机器人等清洁设备的首选方案。</p>
<p><img src="/images/sweeping/47515061bfcc65dc0ce386fcf1d6ddc1.jpg" alt="图5.6 牛耕式扫描全覆盖路径规划算法效果示意图"></p>
<p>在建图过程中，由于没有采用激光雷达（电路板上未预留对应接口），我们通过机器人自主巡航模式下的贴墙碰撞，实现对封闭区域边界的建图。</p>
<p>基于以上算法原理，编写如下Python函数，根据建图过程中采集到的边界点云数据，调用牛耕式扫描算法规划全覆盖路径与关键节点：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_coverage_path</span>(<span class="params">x_coords, y_coords, robot_width</span>):</span><br><span class="line">    <span class="comment"># 生成覆盖路径：矩形区域 + Y方向牛耕式扫描，从右下角开始</span></span><br><span class="line">    min_x, max_x = <span class="built_in">min</span>(x_coords), <span class="built_in">max</span>(x_coords)</span><br><span class="line">    min_y, max_y = <span class="built_in">min</span>(y_coords), <span class="built_in">max</span>(y_coords)</span><br><span class="line">    path = []</span><br><span class="line">    path.append((max_x, min_y))  <span class="comment"># 起点</span></span><br><span class="line">    path.append((max_x, max_y))  <span class="comment"># 起点后的第一个点，先沿y轴正方向直行到底</span></span><br><span class="line">    <span class="comment"># 计算条带位置（沿X方向从右往左移动），排除已经走过的最右侧条带</span></span><br><span class="line">    num_strips = <span class="built_in">int</span>((max_x - min_x) / robot_width) + <span class="number">1</span></span><br><span class="line">    x_strips = np.linspace(max_x, min_x, num_strips)</span><br><span class="line">    <span class="comment"># 第一个条带（x = max_x - robot_width/2）已经部分覆盖，直接跳过第一条带</span></span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(x_strips[<span class="number">1</span>:], start=<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:	 <span class="comment"># 奇数条带：从上到下走</span></span><br><span class="line">            path.append((x, max_y))</span><br><span class="line">            path.append((x, min_y))</span><br><span class="line">        <span class="keyword">else</span>:	 <span class="comment"># 偶数条带：从下到上走</span></span><br><span class="line">            path.append((x, min_y))</span><br><span class="line">            path.append((x, max_y))</span><br><span class="line">    path.append((max_x, min_y))  <span class="comment"># 回到起点</span></span><br><span class="line">    <span class="keyword">return</span> path</span><br></pre></td></tr></tbody></table></figure>

<p>基于这些关键节点，可以进一步生成各时间步的左右轮速度：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_wheel_velocities</span>(<span class="params">x_path, y_path, robot_diameter, dt</span>):</span><br><span class="line">    <span class="comment"># 计算左右轮速度和时间步</span></span><br><span class="line">    v_left, v_right = [], []</span><br><span class="line">    time_steps = []</span><br><span class="line">    straight_speed = <span class="number">10</span>  <span class="comment"># cm/s</span></span><br><span class="line">    turn_speed = <span class="number">5</span>      <span class="comment"># cm/s</span></span><br><span class="line">    current_time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(x_path)):</span><br><span class="line">        dx = x_path[i] - x_path[i-<span class="number">1</span>]</span><br><span class="line">        dy = y_path[i] - y_path[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> dx != <span class="number">0</span> <span class="keyword">and</span> dy == <span class="number">0</span>:</span><br><span class="line">            dist = dx</span><br><span class="line">        <span class="keyword">elif</span> dy != <span class="number">0</span> <span class="keyword">and</span> dx == <span class="number">0</span>:</span><br><span class="line">            dist = dy</span><br><span class="line">        duration = dist / straight_speed</span><br><span class="line">        num_steps = <span class="built_in">int</span>(duration / dt) + <span class="number">1</span>  <span class="comment"># 计算该段的时间步数</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(x_path)-<span class="number">1</span>:  <span class="comment"># 开始或结束段 直行</span></span><br><span class="line">            vl = straight_speed</span><br><span class="line">            vr = straight_speed</span><br><span class="line">        <span class="keyword">elif</span> i % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 转弯段</span></span><br><span class="line">            <span class="comment"># 左右轮速度相反</span></span><br><span class="line">            vl = -turn_speed</span><br><span class="line">            vr = turn_speed</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 直行段</span></span><br><span class="line">            direction = <span class="number">1</span> <span class="keyword">if</span> dy &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span>  <span class="comment"># 判断方向</span></span><br><span class="line">            vl = direction * straight_speed</span><br><span class="line">            vr = direction * straight_speed</span><br><span class="line">        <span class="comment"># 为该段添加速度值和时间步</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_steps):</span><br><span class="line">            v_left.append(vl)</span><br><span class="line">            v_right.append(vr)</span><br><span class="line">            time_steps.append(current_time)</span><br><span class="line">            current_time += dt</span><br><span class="line">    <span class="keyword">return</span> v_left, v_right, time_steps</span><br></pre></td></tr></tbody></table></figure>

<p>以上所有的计算均在上位机完成，将这些速度信息按照时间步顺序依次发送至下位机，从而可以实现规划路径的运动控制。由于建图时仅扫描边界，下位机实际控制时仍然需要结合传感器反馈做出响应。</p>
<h3 id="5-3-本章小结"><a href="#5-3-本章小结" class="headerlink" title="5.3 本章小结"></a>5.3 本章小结</h3><p>本章主要介绍了机器人下位机整体底盘控制的基本逻辑框架，并对其中主要的功能模块实现细节进行介绍。该部分为基于已配置好各种外设的单片机工程的二次开发，由负责运动控制算法开发的成员从负责嵌入式的成员建立的Github仓库中Fork出来并在Algorithm分支中进行后续算法部分的开发更新，仓库地址：<a target="_blank" rel="noopener" href="https://github.com/Asgard-Tim/Sweeping">微电路设计课程项目</a>。</p>
<p>除此之外，本章还介绍了我们采用的全覆盖路径规划算法——牛耕式扫描算法的基本原理与部分实现细节，这也与扫地机器人这一实际应用场景相契合。</p>
<h2 id="6-项目实现效果与总结"><a href="#6-项目实现效果与总结" class="headerlink" title="6 项目实现效果与总结"></a>6 项目实现效果与总结</h2><p>演示视频链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HkKNzDEjV">https://www.bilibili.com/video/BV1HkKNzDEjV</a></p>
<h3 id="6-1-项目实现效果"><a href="#6-1-项目实现效果" class="headerlink" title="6.1 项目实现效果"></a>6.1 项目实现效果</h3><p>项目最终圆满完成了第一章需求分析中给出的所有功能设计需求，并基本达到了设定的需求指标。下面将给出部分主要功能的测试结果。</p>
<h4 id="6-1-1-直线行驶精度测试"><a href="#6-1-1-直线行驶精度测试" class="headerlink" title="6.1.1 直线行驶精度测试"></a>6.1.1 直线行驶精度测试</h4><p>结合高精度的位姿解算与电机转速调节，我们可以对扫地机器人的运动实现高精度的控制。下图为扫地机器人直线行驶固定距离100cm的精度测试情况：</p>
<p><img src="/images/sweeping/d393d919a63ea278d1345f2c60548afe.png" alt="图6.1：机器人行进固定距离100cm精度测试"></p>
<p>可以看到，在该测试中无论是距离精度还是行驶偏角均满足设定的性能需求（偏角&lt;5°，距离偏差&lt;2cm），这一方面说明PID控制器对于电机转速的控制具有良好的动态响应特性，另一方面也说明了位姿解算补偿算法的高精度。</p>
<h4 id="6-1-2-指定转角精度测试"><a href="#6-1-2-指定转角精度测试" class="headerlink" title="6.1.2 指定转角精度测试"></a>6.1.2 指定转角精度测试</h4><p><img src="/images/sweeping/7177b0eb2d265a4831806442b32906f7.png" alt="图6.2：机器人原地旋转固定角度90°精度测试"></p>
<p>为便于应对碰撞/悬崖等突发情况，编写了固定转角旋转函数以根据不同情形做出灵活反应：</p>
<p>void turning_left(float CONTROL_DEG){</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">turning_left</span><span class="params">(<span class="type">float</span> CONTROL_DEG)</span>{</span><br><span class="line">    target_speed_left = <span class="number">-5.0f</span>;</span><br><span class="line">    target_speed_right = <span class="number">5.0f</span>;</span><br><span class="line">    imu = JY901S_GetData();</span><br><span class="line">    <span class="keyword">if</span> ((imu-&gt;yaw + <span class="built_in">fabs</span>(imu-&gt;gy) &gt; (CONTROL_DEG + turn_start_deg)) ||((imu-&gt;yaw + <span class="built_in">fabs</span>(imu-&gt;gy) &gt; (turn_start_deg + CONTROL_DEG - <span class="number">360</span>)) &amp;&amp; (imu-&gt;yaw + <span class="built_in">fabs</span>(imu-&gt;gy) &lt; (CONTROL_DEG - <span class="number">180</span>)) &amp;&amp; (turn_start_deg &gt; (<span class="number">180</span> -CONTROL_DEG)))){</span><br><span class="line">        crash_flag = <span class="number">0</span>;</span><br><span class="line">        cliff_flag = <span class="number">0</span>;</span><br><span class="line">        target_speed_left = <span class="number">0</span>;</span><br><span class="line">        target_speed_right = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，基于当前角度制，根据几何关系指定如下规则，判定机器人是否转过指定角度（需记录开始旋转时偏角turn_start_deg）【满足以下任一条即可】：</p>
<ul>
<li><p>当前偏角 &gt; 起始偏角 + 指定转角</p>
</li>
<li><p>起始偏角 &gt; 180° - 指定转角 且 当前偏角 &gt; 起始偏角 + 指定转角 – 360° 且 当前偏角 &lt; 指定转角 – 180°</p>
</li>
</ul>
<p>为提高旋转角度精度，考虑响应滞后性与运动惯性等问题，还在角度判标中加入转动加速度gy。</p>
<p>调用该函数进行测试，结果如上图所示。可以看到，在设定旋转角度为90°的情况下，机器人转过了91.7°，与实际设定角度相差小于2°，说明在基于IMU的偏角位姿结算上也具有较高的精度。当然，若增大原地旋转时的左右轮速度，该偏差值会由于惯性而有所增大，因此后续优化时可以考虑进一步采用高阶的转动加速度函数对转角控制进行修正。</p>
<h4 id="6-1-3-贴墙行进与建图效果测试"><a href="#6-1-3-贴墙行进与建图效果测试" class="headerlink" title="6.1.3 贴墙行进与建图效果测试"></a>6.1.3 贴墙行进与建图效果测试</h4><p><img src="/images/sweeping/0c9ca142c80746ccde051fd86d54a57c.png" alt="图6.3：机器人贴墙行进与建图效果测试（完整过程见演示视频）"></p>
<p>可以看到，在自制的约150cm*100cm的封闭多边形区域内，机器人能够很好地完成贴墙行进的任务，同时在上位机客户端的建图精度也较高，基本还原了整个封闭区域的地形轮廓。</p>
<h4 id="6-1-4-全覆盖路径规划效果测试"><a href="#6-1-4-全覆盖路径规划效果测试" class="headerlink" title="6.1.4 全覆盖路径规划效果测试"></a>6.1.4 全覆盖路径规划效果测试</h4><p><img src="/images/sweeping/9ee774c87ec721dc765e211d5c74a245.png" alt="图6.4：全覆盖路径规划效果演示"></p>
<p>基于上述贴墙建图的测试结果，将路径点云数据以JSON文件形式导出存储。在路径规划测试时，将点云数据再次导入至客户端，并点击“路径规划”，效果如上图所示。可以看到，生成的路径与算法原理相一致。在实机部署实现的过程中，结合路径规划的关键点与实时的碰撞感知数据，机器人能够良好地扫过地图内的所有区域并避开障碍物，这进一步说明了路径规划与运动控制算法的有效性。</p>
<h3 id="6-2-总结与收获"><a href="#6-2-总结与收获" class="headerlink" title="6.2 总结与收获"></a>6.2 总结与收获</h3><p>在本次微电路设计课程项目中，我们组的四位成员合理分工、通力合作，成功完成了SmartRobot扫地机器人的设计与开发工作。从项目需求分析、PCB电路设计、硬件外设程序设计，到上位机监控系统开发、控制逻辑与算法设计，再到最终的测试与优化，每一个环节都凝聚了团队成员的心血与智慧。通过复刻和优化现有扫地机器人的硬件方案，我们深入研究了其核心功能模块，包括运动控制、传感器数据处理、路径规划算法等，并结合实际应用场景进行了针对性改进。</p>
<p>在项目过程中，我们不仅掌握了PCB设计、嵌入式编程、传感器集成、电机控制等核心技术，还深刻体会到团队协作的重要性。通过分工合作，每位成员充分发挥了自己的专长，共同攻克了技术难题。例如，PCB设计中的电源管理优化、电机驱动选型，嵌入式程序中的PID控制算法实现，上位机系统的模块化设计与交互优化，以及全覆盖路径规划算法的开发与部署，都是团队智慧的结晶。</p>
<p>此外，项目还锻炼了我们的工程实践能力和问题解决能力。从理论到实践，我们学会了如何将课堂知识应用于实际项目，如何通过调试与测试不断优化系统性能。最终，扫地机器人实现了良好的避障功能、防坠落能力、高精度运动控制以及用户远程监控等设计目标，圆满完成了各项性能指标。</p>
<p>通过这次项目，我们不仅提升了专业技能，还增强了团队协作与沟通能力，为未来的工程实践与科研工作积累了宝贵经验。我们深刻认识到，技术创新需要扎实的理论基础、严谨的工程态度和高效的团队合作。这段经历将成为我们成长道路上难忘的一课，激励我们在未来的学习和工作中继续追求卓越。</p>
<h3 id="6-3-本章小结"><a href="#6-3-本章小结" class="headerlink" title="6.3 本章小结"></a>6.3 本章小结</h3><p>本章对于机器人功能与性能指标的测试结果进行了展示与分析，并对于项目成果与收获进行了总结。</p>
</div></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">上一页</a></div><div class="pagination-next"><a href="/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><span class="pagination-ellipsis">…</span></li><li><a class="pagination-link" href="/page/37/">37</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/head2.png" alt="Jinghua Xu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jinghua Xu</p><p class="is-size-6 is-block">明月科创实验班人工智能专业 本科大三在读</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>重庆 重庆大学国家卓越工程师学院</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">37</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">102</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Asgard-Tim" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Asgard-Tim"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://www.weibo.com/u/6315188431"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/171895120"><i class="fab fa-bilibili"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:20224546@stu.cqu.edu.cn"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Phone" href="tel:+86 19132050174"><i class="fas fa-phone"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2025/06/29/manufac/"><img src="/images/manufac/b99d7042c32e0662693c9051eb8316a5.jpg" alt="小提琴自动演奏机器人中的齿轮系统设计与制造"></a></figure><div class="media-content"><p class="date"><time datetime="2025-06-29T08:40:43.000Z">2025-06-29</time></p><p class="title"><a href="/2025/06/29/manufac/">小提琴自动演奏机器人中的齿轮系统设计与制造</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E4%BA%A7%E5%93%81%E5%88%B6%E9%80%A0/">产品制造</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/06/21/sweeping/"><img src="/images/sweeping/0c9ca142c80746ccde051fd86d54a57c.png" alt="SmartRobot扫地机器人"></a></figure><div class="media-content"><p class="date"><time datetime="2025-06-20T20:02:03.000Z">2025-06-21</time></p><p class="title"><a href="/2025/06/21/sweeping/">SmartRobot扫地机器人</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/">微电路设计</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/06/10/project3/"><img src="/images/project3/9.png" alt="常微分方程反演的机器学习方法"></a></figure><div class="media-content"><p class="date"><time datetime="2025-06-09T18:59:03.000Z">2025-06-10</time></p><p class="title"><a href="/2025/06/10/project3/">常微分方程反演的机器学习方法</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">工程数值分析</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/05/15/Survey/"><img src="/images/survey/2.png" alt="A Survey on Vision-Language-Action Models for Embodied AI"></a></figure><div class="media-content"><p class="date"><time datetime="2025-05-15T15:32:03.000Z">2025-05-15</time></p><p class="title"><a href="/2025/05/15/Survey/">A Survey on Vision-Language-Action Models for Embodied AI</a></p><p class="categories"><a href="/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">具身智能论文阅读</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/05/09/PaLM-E/"><img src="/images/palm-e/0.png" alt="PaLM-E：An Embodied Multimodal Language Model"></a></figure><div class="media-content"><p class="date"><time datetime="2025-05-09T11:57:03.000Z">2025-05-09</time></p><p class="title"><a href="/2025/05/09/PaLM-E/">PaLM-E：An Embodied Multimodal Language Model</a></p><p class="categories"><a href="/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">具身智能论文阅读</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/About-XJH/"><span class="level-start"><span class="level-item">About XJH</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/About-XJH/%E6%98%8E%E6%85%B5/"><span class="level-start"><span class="level-item">明慵</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/About-XJH/%E6%98%8E%E8%AF%9A/"><span class="level-start"><span class="level-item">明诚</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">个人项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"><span class="level-start"><span class="level-item">具身智能论文阅读</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">动手学深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"><span class="level-start"><span class="level-item">算法基础课</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">课程项目</span></span><span class="level-end"><span class="level-item tag">26</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E4%BA%A7%E5%93%81%E5%88%B6%E9%80%A0/"><span class="level-start"><span class="level-item">产品制造</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">产品设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95I/"><span class="level-start"><span class="level-item">定量工程设计方法I</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95II/"><span class="level-start"><span class="level-item">定量工程设计方法II</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E6%95%88%E5%AD%A6/"><span class="level-start"><span class="level-item">工效学</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">工程原理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">工程数值分析</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">工程设计</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">微电路设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"><span class="level-start"><span class="level-item">数学物理方法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"><span class="level-start"><span class="level-item">智能图像处理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">机器人基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"><span class="level-start"><span class="level-item">概率论与数理统计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"><span class="level-start"><span class="level-item">线性代数</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">自动控制原理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">软件设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/06/"><span class="level-start"><span class="level-item">六月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">七月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"><span class="tag">单片机</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STM32/"><span class="tag">STM32</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VLA/"><span class="tag">VLA</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD/"><span class="tag">具身智能</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B/"><span class="tag">多模态大模型</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%91%E5%8A%A8%E6%9C%BA/"><span class="tag">斯特林发动机</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MATLAB/"><span class="tag">MATLAB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Matlab/"><span class="tag">Matlab</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">动手学深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="tag">学习笔记</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E8%BD%A6/"><span class="tag">小车</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"><span class="tag">信号与系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/"><span class="tag">频谱分析</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%BE%AA%E7%8E%AF/"><span class="tag">斯特林循环</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F/"><span class="tag">动力学仿真</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%89%E9%99%90%E5%85%83%E4%BB%BF%E7%9C%9F/"><span class="tag">有限元仿真</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">算法与数据结构</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/3D-VLA/"><span class="tag">3D-VLA</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PaLM-E/"><span class="tag">PaLM-E</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="tag">路径规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RANSAC/"><span class="tag">RANSAC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"><span class="tag">数据处理分析</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/title1.png" alt="Homepage of Jinghua Xu" height="28"></a><p class="is-size-7"><span>© 2025 Tim</span>&nbsp;&nbsp;Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>&nbsp;&amp;&nbsp;<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© Copyright by Jinghua Xu</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Asgard-Tim"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer=""></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer=""></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer=""></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer=""></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer=""></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer=""></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer=""></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer=""></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script>
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = 'S-TA3IX28M1ZT7TILW';
        let tianliGPT_postSelector = '#postchat_postcontent';
        let tianliGPT_Title = '文章摘要';
        let tianliGPT_postURL = '/^https?://[^/]+/[0-9]{4}/[0-9]{2}/[0-9]{2}/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '1000';
        let tianliGPT_typingAnimate = true;
        let tianliGPT_theme = 'default';
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: true,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "PostChat",
          userDesc: "如果你对网站的内容有任何疑问，可以来问我哦～",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://ai.tianli0.top/static/img/PostChat.webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };
    </script>
    <script data-postchat_key="S-TA3IX28M1ZT7TILW" src="https://ai.tianli0.top/static/public/tianli_gpt.min.js"></script>
  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/chitose.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>