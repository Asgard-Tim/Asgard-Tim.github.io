<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>标签: STM32 - Homepage of Jinghua Xu</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Homepage of Jinghua Xu"><meta name="msapplication-TileImage" content="/img/photo.jpg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Homepage of Jinghua Xu"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="/img/photo.jpg"><meta name="description" content="重庆大学2022级明月科创实验班人工智能专业本科在读"><meta property="og:type" content="blog"><meta property="og:title" content="Homepage of Jinghua Xu"><meta property="og:url" content="http://asgard-tim.github.io/"><meta property="og:site_name" content="Homepage of Jinghua Xu"><meta property="og:description" content="重庆大学2022级明月科创实验班人工智能专业本科在读"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://asgard-tim.github.io/img/og_image.png"><meta property="article:author" content="Tim"><meta property="article:tag" content="Blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://asgard-tim.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://Asgard-Tim.github.io"},"headline":"Homepage of Jinghua Xu","image":["http://asgard-tim.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tim"},"publisher":{"@type":"Organization","name":"Homepage of Jinghua Xu","logo":{"@type":"ImageObject","url":"http://asgard-tim.github.io/img/title1.png"}},"description":"重庆大学2022级明月科创实验班人工智能专业本科在读"}</script><link rel="icon" href="/img/photo.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/xt256.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/title1.png" alt="Homepage of Jinghua Xu" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Contect me on GitHub" href="https://github.com/Asgard-Tim"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">STM32</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-12-30T18:02:03.000Z" title="2024/12/31 02:02:03">2024-12-31</time>发表</span><span class="level-item"><time datetime="2025-03-02T17:27:56.470Z" title="2025/3/3 01:27:56">2025-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95II/">定量工程设计方法II</a></span><span class="level-item">2 小时读完 (大约13620个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/12/31/ecg/">心电信号采集与处理</a></p><div class="content"><div id="postchat_postcontent"><h2 id="1-实验需求分析"><a href="#1-实验需求分析" class="headerlink" title="1 实验需求分析"></a>1 实验需求分析</h2><h3 id="1-1-项目背景介绍"><a href="#1-1-项目背景介绍" class="headerlink" title="1.1 项目背景介绍"></a>1.1 项目背景介绍</h3><p>心电信号（Electrocardiogram, ECG）是反映心脏活动电生理变化的重要生物电信号，其特征包括心率、节律、波形等参数，能够直观反映心脏健康状况，在临床医学、健康监测和疾病预防中具有不可替代的作用。通过心电信号的测量与分析，可以检测心律失常、心肌缺血、心脏传导阻滞等异常，为心脏疾病的诊断和治疗提供关键支持；借助便携式和可穿戴设备，实时心电监测已成为健康管理的重要手段，为心血管疾病高危人群提供预警，有助于降低发病率和致死率。此外，心电信号还是生物医学研究的重要工具，为心血管药物开发、人工心脏研究等领域提供了基础数据。在当前人口老龄化加剧和心血管疾病高发的背景下，心电信号测量与分析技术显得尤为重要。本项目旨在开发高精度的心电信号采集系统，结合课程中介绍的数字信号处理等专业知识，为心脏健康提供更加便捷和智能的监测方案，推动精准医疗与个性化健康管理的发展。</p>
<h3 id="1-2-心电信号特征与设计需求"><a href="#1-2-心电信号特征与设计需求" class="headerlink" title="1.2 心电信号特征与设计需求"></a>1.2 心电信号特征与设计需求</h3><p>心脏内部产生的一系列非常协调的电刺激脉冲，使得心脏肌肉细胞有节奏的舒张和收缩，这些信号传递到人体表面的不同部位形成不同的电位差。通过仪器设备可以从体表检测到这些微弱的电位差信号，称之为心电信号。换言之，心电信号即为人体心脏细胞细胞膜产生的电势差。在医学上，医生往往需要通过心率与幅值等参数来初步判断患者的健康状况，因此实现高精度的心率与幅值测量是本项目中设计的心电信号采集与处理系统的核心功能。</p>
<p><img src="/images/ecg/media/image2.png" alt="图1.1：心电信号简介"></p>
<p>正常的心电信号频率范围为0.05Hz－100Hz，其能量集中在低频段，其中99％的能量集中在0Hz－35Hz。在其采集过程中容易受到各种干扰，主要分为三种：</p>
<ul>
<li><p>工频和工频的谐波频率干扰，工频频率在我国为50Hz；</p>
</li>
<li><p>肌颤噪声和采样电路参考电压引入的电源纹波等高频噪声，频率通常在100Hz以上；</p>
</li>
<li><p>呼吸基线漂移和采样引入的直流分量，频率一般分布在0-0.7Hz。</p>
</li>
</ul>
<p>以上的各种干扰会对心电信号采集结果产生较大的影响，使得采集到的心电信号中出现许多杂波与噪声，这是我们所不希望看到的。因此，为提高心电信号的测量精度，需要设计相应的滤波器对传感器采集到的信号进行滤波，从而减小信号中的噪声震荡，提高心率与幅值测量的准确程度。特别的，由于参考电压受环境温度变化会产生一定的温漂，以及人的呼吸活动和电极滑动也导致基线漂移。这些干扰的频率很低，通常在几Hz以内，但和心电信号的有效频谱非常接近，因此需要过渡带较窄的IIR直流陷波器来消除干扰。</p>
<p>基于心电信号的以上特性，对于该心电信号采集与处理系统，提出如下的技术指标需求：</p>
<ul>
<li><p>0频处的缓变直流衰减不低于30dB；</p>
</li>
<li><p>降噪滤波器以35Hz为3dB通带截止频率，过渡带不超过10Hz，阻带衰减不低于40dB；</p>
</li>
<li><p>心率估算误差不超过10%。</p>
</li>
</ul>
<h2 id="2-实现方案论证"><a href="#2-实现方案论证" class="headerlink" title="2 实现方案论证"></a>2 实现方案论证</h2><h3 id="2-1-系统框架设计"><a href="#2-1-系统框架设计" class="headerlink" title="2.1 系统框架设计"></a>2.1 系统框架设计</h3><p>本项目的核心目标是实现心电信号的采集与滤波以及心率测量，同时需要在屏幕上绘制时域波形与频谱图。具体而言，细分的功能如下：</p>
<ul>
<li><p>实现ADS1292获取心电信号原始数据，并通过串口传输至PC电脑；</p>
</li>
<li><p>实现PC电脑中通过MATLAB对原始数据进行时域和频域分析；</p>
</li>
<li><p>实现PC电脑中通过MATLAB对原始数据进行降噪和提取心率；</p>
</li>
<li><p>实现STM32单片机中对原始数据进行降噪和提取心率；</p>
</li>
<li><p>TFT屏幕中绘制心电信号曲线和显示心率数值。</p>
</li>
</ul>
<p>为实现以上功能，采用如下的系统设计流程：</p>
<ol>
<li><p>调试ADS1292R_PowerOnInit函数中的ADS1292芯片读取，通过读取芯片device_id验证硬件功能正常且连接正确；</p>
</li>
<li><p>在中断驱动下，读取ADS1292的原始数据，并存储在单片机的存储器中；</p>
</li>
<li><p>把原始数据传输到PC；</p>
</li>
<li><p>在PC中分析原始数据的时域和频域；</p>
</li>
<li><p>在PC中设计滤波器对原始数据进行处理，并提取心率等；</p>
</li>
<li><p>把PC中的滤波器移植到单片机中；</p>
</li>
<li><p>在单片机中把心电波形和心率等数据显示到TFT屏幕。</p>
</li>
</ol>
<p><img src="/images/ecg/media/image3.png" alt="图2.1：系统设计流程"></p>
<p>根据如上设计流程，结合目前提供的材料，设计了如下图所示的心电信号采集与分析系统：</p>
<p><img src="/images/ecg/media/image4.png" alt="图2.2：系统框架"></p>
<p>系统的工作流程如下：</p>
<ol>
<li><p>首先，STM32控制器向心电传感器发送采集指令，传感器随后采集来自人体或模拟信号源的心电信号，并将数据反馈至控制器；</p>
</li>
<li><p>接着，控制器将采集到的数据传输至PC端，供进一步分析处理；</p>
</li>
<li><p>然后，根据PC端的分析结果，控制器会调整参数并优化心电信号处理；</p>
</li>
<li><p>最终，处理后的结果将在TFT屏幕上实时显示，供用户查看。</p>
</li>
</ol>
<p>可以看到，该系统主要涉及到STM32主控芯片、ADS1292R传感器、TFT显示屏、心电信号模拟器以及PC端分析软件MATLAB等关键组件。接下来将对于本项目涉及的各硬件组件进行介绍。</p>
<h3 id="2-2-STM32主控芯片"><a href="#2-2-STM32主控芯片" class="headerlink" title="2.2 STM32主控芯片"></a>2.2 STM32主控芯片</h3><p>本项目选用的微控制器STM32F407ZG是系统的核心控制单元，负责协调各个模块的工作。其不仅负责信号的采集，还管理信号传输、滤波器应用、以及与TFT屏幕的显示操作。其强大的处理能力和灵活的控制方式使其成为整个系统的”大脑”。该控制器目前搭载在”正点原子”探索者STM32F407开发板V3上，负责完成系统的信号采集、处理与传输任务。</p>
<p><img src="/images/ecg/media/image5.jpeg" alt="图2.3：STM32F407探索者开发板V3实物图正面"></p>
<p>该单片机具备高性能的ARM Cortex-M4内核，主频高达168MHz，同时集成了丰富的外设接口，包括多个ADC通道、DMA（直接存储器访问）、定时器以及USART串口等，为心电信号的实时采集、处理与传输提供了强有力的硬件支持。它通过SPI协议与ADS1292传感器进行数据交换，采集来自人体或模拟信号源的心电信号，并进行初步处理。</p>
<h3 id="2-3-心电信号模拟器"><a href="#2-3-心电信号模拟器" class="headerlink" title="2.3 心电信号模拟器"></a>2.3 心电信号模拟器</h3><p>在实验的过程中，无法总是以人体作为心电信号源，因此在缺乏人体数据的情况下，本项目采用SKX-2000心电信号模拟仪作为测试时的模拟信号源。它能够生成不同类型的心电波形，广泛用于测试系统性能和验证心电信号采集、处理的稳定性。此设备对确保系统在实际使用前达到预期的性能标准至关重要。</p>
<p><img src="/images/ecg/media/image6.png" alt="图2.4：SKX-2000心电信号模拟仪"></p>
<p><img src="/images/ecg/media/image7.png" alt="图2.5：SKX-2000心电信号模拟仪使用说明书"><img src="/images/ecg/media/image8.png" alt="图2.5：SKX-2000心电信号模拟仪使用说明书"></p>
<p>在本项目中，主要使用到的是正常的心电波形与标准的心率信号，可以通过操作该模拟仪控制其产生心电信号的心率以及幅度。在连接方面，如图2.3所示，采用三导联接法，RA连接右手（红色），LA连接左手（黄色），LL连接左脚（绿色）；通过3.5耳机动态导联线，将模拟仪产生的心电信号输入ADS1292S传感器中以供进一步采集。</p>
<h3 id="2-3-信号采集传感器：ADS1292R"><a href="#2-3-信号采集传感器：ADS1292R" class="headerlink" title="2.3 信号采集传感器：ADS1292R"></a>2.3 信号采集传感器：ADS1292R</h3><p>ADS1292R作为一款多通道同步采样的24位模数转换器（ADC），被广泛应用于生物电势测量领域，其独特的设计集成了可编程增益放大器、内部基准源和板载振荡器，确保了心电信号的精准采集。在本系统中，ADS1292R作为信号采集模块的核心组件，负责从心电电极捕获原始心电信号。这些信号随后通过SPI接口传输至STM32微控制器，供后续处理和分析。</p>
<p><img src="/images/ecg/media/image9.jpeg" alt="图2.6：ADS1292R传感器实物图与电路原理图"><br><img src="/images/ecg/media/image10.png" alt="图2.6：ADS1292R传感器实物图与电路原理图">该模块共有12个输出引脚（传感器模块右侧)，各引脚接口功能说明如下：</p>
<ul>
<li><p>GND：接供电电源地；</p>
</li>
<li><p>CLK：提供给ADS1292R工作的外部时钟，由于本项目采用内部时钟，故该引脚无需连接；</p>
</li>
<li><p>GPIO1、GPIO2：本项目中未使用，无需连接</p>
</li>
<li><p>SPI_SCK：接入由STM32单片机提供的SPI时钟信号；</p>
</li>
<li><p>SPI_MISO：向STM32单片机发送SPI数据输入信号；</p>
</li>
<li><p>SPI_MOSI：接收STM32单片机发出的数据输出信号；</p>
</li>
<li><p>SPI_CS0：接入STM32单片机GPIO，为ADS1292R提供片选选中信号；</p>
</li>
<li><p>ADS_DRDY：向STM32单片机发送外部中断输入，告知单片机可以通过SPI接收采集信号；</p>
</li>
<li><p>ADS_START：接入STM32单片机GPIO，为ADS1292R提供开始采集信号；</p>
</li>
<li><p>ADS_PWDN：接入STM32单片机GPIO，为ADS1292R提供复位信号RESET；</p>
</li>
<li><p>+5V：接供电电源+5V（由STM32输出）。</p>
</li>
</ul>
<p>除此之外，由于选用的STM32单片机只允许接收0~3.3V的输出电压，故单片机通过SPI通信接收的信号电压必须限制在该范围内，因此需要将ADS1292R传感器模块中间的VDD与3.3V引脚通过跳线帽相连以实现电压转换（与图2.5中左图的连接方式相反）。</p>
<h3 id="2-4-SPI通信读取采集数据"><a href="#2-4-SPI通信读取采集数据" class="headerlink" title="2.4 SPI通信读取采集数据"></a>2.4 SPI通信读取采集数据</h3><p>在本系统中，传感器将数字化后的原始心电信号数据通过SPI接口传输到STM32微控制器。SPI通信具有高速度、全双工传输的优势，非常适合用于实时性要求较高的应用场景。SPI接口确保了心电信号数据的快速、稳定传输，保证了信号的实时处理和准确性。通过SPI，ADS1292R和STM32微控制器能够高效地交换数据，从而提升系统的整体性能和响应速度。</p>
<p>SPI通信采用主从结构，其中STM32微控制器作为主设备，ADS1292R作为从设备。具体来说，SPI通信包括四个主要信号线：时钟信号（SCK）、主输出从输入（MOSI）、主输入从输出（MISO）和片选信号（CS）。时钟信号由STM32微控制器提供，用于同步数据传输。数据通过MOSI线从ADS1292R传输到STM32微控制器，而传感器通过MISO线将必要的反馈信息传回STM32。</p>
<p><img src="/images/ecg/media/image11.png" alt="图2.7：SPI内部结构简图"></p>
<p>为了提高系统的响应速度和处理效率，在单片机端选择了基于中断驱动的数据采集机制。当ADS1292R传感器完成一组心电数据的采集后，通过中断信号通知STM32F407进行数据读取和处理。这种机制有效减少了CPU的空闲时间，提高了系统的整体效率。</p>
<p><img src="/images/ecg/media/image12.png" alt="图2.8：中断驱动SPI通信采集数据的系统框架简图"></p>
<p>在单片机程序工程中，通过调用驱动库文件中的ADS1292_Read_Data函数，可以实现单片机与ADS1292R的数据交互以进行实时数据监测，并通过函数ADS1292_Send_CMD将信号数据通过UART串口以115200的波特率传输至PC端并保存。在此过程中，原始信号数据被保存为.dat格式的文件，后续将通过MATLAB读取和显示这些信号数据，并针对这些数据进行滤波器等模块的设计，对信号进行进一步验证与调试。</p>
<p><img src="/images/ecg/media/image13.png" alt="图2.9：单片机实现读取原始信号数据的函数ADS1292_Read_Data"></p>
<p><img src="/images/ecg/media/image14.png" alt="图2.10：单片机实现串口输出原始信号数据的函数ADS1292_Send_CMD"></p>
<p><img src="/images/ecg/media/image15.png" alt="图2.11：PC端可视化软件中显示采集到的原始心电信号（解码后）"></p>
<h2 id="3-理论推导与MATLAB计算"><a href="#3-理论推导与MATLAB计算" class="headerlink" title="3 理论推导与MATLAB计算"></a>3 理论推导与MATLAB计算</h2><p>PC端分析软件（本项目中使用MATLAB）用于对采集到的原始心电信号进行深入分析。为验证滤波器对心电信号的作用和效果，可以先在MATLAB上设计算法对心电信号进行一系列处理，包括数据读取、绘制原始数据时域波形、分析原始数据的频谱、设计数字直流陷波器、设计FIR数字低通滤波器、分析并比较滤波前后数据的频谱以及估算心率。通过这些分析，系统能够设计出合适的滤波器以去除噪声并提取出心率等重要参数，为后续移植到单片机上提供理论验证。</p>
<h3 id="3-1-原始心电信号数据的读取与频谱分析"><a href="#3-1-原始心电信号数据的读取与频谱分析" class="headerlink" title="3.1 原始心电信号数据的读取与频谱分析"></a>3.1 原始心电信号数据的读取与频谱分析</h3><p>为了研究信号特征和评估处理效果，首先需要导入心电信号数据并进行基本分析。当心电信号传入单片机后，根据ADS1292R的数据手册，还需在单片机中对数据进行解码处理。在2.4节中，直接存入.dat文件的是未经过解码的原始数据，而图2.11展示的则是经过解码转换后的波形数据可视化结果（由单片机内部程序完成解码转换，将在4.2节中详细展开）。</p>
<p><img src="/images/ecg/media/image16.png" alt="图3.1：MATLAB从串口读取信号数据并写入.dat文件的程序代码"></p>
<p>本章中的MATLAB分析均基于未解码的.dat文件，因此要想获得真实的波形数据（电压值），需要先根据以下规则对数据进行解码（4.2中的解码基于同样的原理，后续不再赘述）：</p>
<p>由于原始数据格式是24bits的二进制补码（7FFFFF对应的模拟信号是2.4V。800000对应的模拟信号是-2.4V），若考虑保留高16bits，需要注意此时为补码，同时也要考虑到16bits相比于24bits相当于右移了8位。所以此时7FFF的数值对应模拟信号相当于2.4V，8000对应模拟信号-2.4V。</p>
<p><img src="/images/ecg/media/image17.png" alt="图3.2：原始信号电压与读取信号数据间的关系"></p>
<p>基于这样的规则，可以在MATLAB编写对应的接收数据代码，从文件中读取数据（注意把负数的二进制补码转换为原码），其中Off可以为0或1（因为MATLAB接收的起始数据可能是16bits的高8位或者低8位，用off作为偏移调整，这样组合的数据才不会出现错位）；同时通过plot函数绘制出原始心电信号的时域波形，并使用快速傅里叶变换（FFT）分析信号频谱，绘制出频谱图。</p>
<p><img src="/images/ecg/media/image18.png" alt="图3.3：原始心电信号数据解码读取、时域波形绘制与频谱分析绘制MATLAB代码"></p>
<p><img src="/images/ecg/media/image19.png" alt="图3.4：原始心电信号时域波形与频谱"><img src="/images/ecg/media/image20.png" alt="图3.4：原始心电信号时域波形与频谱"></p>
<p>从频谱图（上右图）中可以明显观察到信号中的低频基线漂移和工频干扰（与1.2节中的分析基本一致），这些成分需要通过滤波器加以去除。</p>
<h3 id="3-2-IIR数字直流陷波器设计与滤波效果"><a href="#3-2-IIR数字直流陷波器设计与滤波效果" class="headerlink" title="3.2 IIR数字直流陷波器设计与滤波效果"></a>3.2 IIR数字直流陷波器设计与滤波效果</h3><p>工程中使用高精度传感器采集动态信号，采集的原始数据会因为环境变化、量化字长和参考电压等因素，包含较强的缓变直流分量，如果不予以消除，会导致在降噪等处理中出现运算饱和溢出。由于在采集心电信号时，人的呼吸活动和电极滑动会导致基线漂移，而这些干扰的频率又与心电信号的有效频谱非常接近，因此需要设计窄带IIR直流陷波器来消除该干扰。</p>
<p>直流陷波器的传递函数Η(z)为：<br>$$<br>Η(z) = \frac{z - 1}{z - a}<br>$$<br>该数字系统的极点为z = a，零点为z=1，其中参数a决定了陷波器的过渡带宽和衰减性能，为接近1的正实数。因为零点对应的幅角ω = 0，所以数字系统在零频处的增益显著衰减（如图3.5所示），其衰减的程度与过渡带的宽度和极点a的数值有关：a越大衰减变小，同时过渡带变窄，反之则衰减增大和过渡带增宽。通过实验调整，选择a=0.992可在基线漂移和信号完整性之间取得平衡。</p>
<p><img src="/images/ecg/media/image21.png" alt="图3.5：a=0.992时直流陷波器H(z)的增益和相位特性"></p>
<p><img src="/images/ecg/media/image22.png" alt="图3.6：IIR数字直流陷波器设计及滤波后频谱分析绘制MATLAB代码及其运行结果"><br><img src="/images/ecg/media/image23.png" alt="图3.6：IIR数字直流陷波器设计及滤波后频谱分析绘制MATLAB代码及其运行结果"></p>
<p>可以看到，在加入了直流陷波器进行滤波后，0频处的基线漂移基本被消除，说明该滤波器的设计有效并起到了很好的效果。</p>
<h3 id="3-3-FIR数字低通滤波器设计与滤波效果"><a href="#3-3-FIR数字低通滤波器设计与滤波效果" class="headerlink" title="3.3 FIR数字低通滤波器设计与滤波效果"></a>3.3 FIR数字低通滤波器设计与滤波效果</h3><p>根据阻带衰减不低于40dB且过渡带不超过10Hz的要求，利用MATLAB中自带的filterDesigner滤波器设计工具对于FIR数字低通滤波器进行设计。在该滤波器中，采用固定窗口，通过对当前点及其前160个点的加权求和来计算输出（指定滤波器阶数为160）。</p>
<p>在固定窗口的选择上，由于不同窗函数的阻带最小衰减各不相同，过渡带应与对应窗函数的”精确过渡带宽”相等。以下是常用窗函数的对比表：</p>
<p>表3.1 不同窗函数的阻带最小衰减</p>
<table>
<thead>
<tr>
<th>窗函数</th>
<th>第一旁瓣衰减A/dB</th>
<th>近似过渡带宽Bw</th>
<th>精确过渡带宽</th>
<th>旁瓣峰值衰减/(dB * oct^(- 1))</th>
</tr>
</thead>
<tbody><tr>
<td>矩形窗</td>
<td>-13</td>
<td>4π/N</td>
<td>1.8π/N</td>
<td>21</td>
</tr>
<tr>
<td>汉宁窗</td>
<td>-31</td>
<td>8π/N</td>
<td>6.2π/N</td>
<td>44</td>
</tr>
<tr>
<td>海明窗</td>
<td>-41</td>
<td>8π/N</td>
<td>6.6π/N</td>
<td>53</td>
</tr>
<tr>
<td>布莱克曼窗</td>
<td>-57</td>
<td>12π/N</td>
<td>11π/N</td>
<td>74</td>
</tr>
<tr>
<td>凯泽窗(β = 7.865)</td>
<td>-57</td>
<td></td>
<td>10π/N</td>
<td>80</td>
</tr>
</tbody></table>
<p>在实际设计中，选择Chebyshev（切比雪夫）窗，其主要特点为：在给定窗口长度的情况下，能够提供最小的主瓣宽度。因此，通过选用Chebyshev窗，在频域上最小化主瓣的振幅波动，以实现滤波器的设计。</p>
<p>除此之外，设计时还指定采样频率为500Hz，阻带频率设计为35Hz，确定好参数后可在filterDesigner工具中导出为MATLAB函数：</p>
<p><img src="/images/ecg/media/image24.png" alt="图3.7：基于filterDesigner工具的FIR数字低通滤波器设计及其生成的MATLAB代码"><img src="/images/ecg/media/image25.png" alt="图3.7：基于filterDesigner工具的FIR数字低通滤波器设计及其生成的MATLAB代码"></p>
<p>在主程序中调用生成的滤波器函数构造一个FIR数字低通滤波器实例，并利用filter函数对于直流陷波后的波形数据进行FIR滤波并通过plot函数绘制滤波后的频谱，代码与结果如下所示：</p>
<p><img src="/images/ecg/media/image26.png" alt="图3.8：信号经FIR数字低通滤波后频谱分析绘制MATLAB代码及其运行结果"><img src="/images/ecg/media/image27.png" alt="图3.8：信号经FIR数字低通滤波后频谱分析绘制MATLAB代码及其运行结果"></p>
<p>可以看到，在加入了数字低通滤波器进行滤波后，50Hz处的工频干扰完全被消除，说明该滤波器的设计有效并起到了很好的效果。</p>
<h3 id="3-4-滤波结果综合分析"><a href="#3-4-滤波结果综合分析" class="headerlink" title="3.4 滤波结果综合分析"></a>3.4 滤波结果综合分析</h3><p>通过IIR和FIR滤波器的级联处理，最终获得了较为清晰的心电信号波形（如图3.9所示）。此过程有效去除了干扰，为后续心率计算和信号分析提供了可靠的基础。</p>
<p><img src="/images/ecg/media/image28.png" alt="图3.9 滤波后心电图结果"><img src="/images/ecg/media/image29.png" alt="图3.9 滤波后心电图结果"></p>
<p><img src="/images/ecg/media/image30.png" alt="图3.10 信号频谱对比图"><img src="/images/ecg/media/image31.png" alt="图3.10 信号频谱对比图"></p>
<p>为了更直观地展示信号处理过程的效果，对心电信号在各个处理阶段的频谱进行了对比分析。图3.10中显示了原始心电信号以及经过直流陷波器和FIR低通滤波器联合处理后的信号频谱图。</p>
<p>从原始心电信号频谱可以看出，信号中存在显著的工频干扰（约50Hz）和低频基线漂移（频率较低）。此外，信号还包含较多高频噪声，影响了心电信号的质量。经过直流陷波器处理后，低频基线漂移明显被抑制，低频成分显著减少但同时工频干扰和高频噪声依然存在，但其幅值未发生明显变化，表明直流陷波器主要对低频干扰起到作用；在应用FIR低通滤波器后，信号中50Hz附近的工频干扰被有效抑制，同时高频噪声也显著减弱。</p>
<p>最终处理后的频谱显示出清晰的心电信号主频成分（低于30Hz），为后续的R波检测与心率计算提供了可靠的基础。</p>
<h3 id="3-5-心率计算"><a href="#3-5-心率计算" class="headerlink" title="3.5 心率计算"></a>3.5 心率计算</h3><p>在对原始心电信号完成滤波处理后，可进一步估算心率这一关键生理参数。心率的计算基于心电信号中的R波峰值检测，通过分析相邻R波之间的R-R间期推算心率值。R波的检测是心率估算的关键环节。在此实验中，采用MATLAB函数findpeaks来检测心电信号中的峰值。为提高检测精度，将滤波后的信号进行缩放，并设置峰值检测的阈值为信号均值加一倍标准差。</p>
<p>检测到R波位置后，可通过计算相邻峰值位置之间的时间间隔（R-R间期）来估算心率。使用diff函数计算相邻R波的时间间隔并计算R-R间期的平均值，并根据如下公式计算出心率：</p>
<p>$$<br>心率 = \frac{60}{平均R - R间期}<br>$$<br><img src="/images/ecg/media/image32.png" alt="图3.11 MATLAB心率计算代码"></p>
<p>最终得出结果为60.29bpm，对比实际信号发生仪60bmp的心率，可以较为准确地估算心率，其结果符合误差小于10%的预期。</p>
<h2 id="4-STM32程序设计与参数选择"><a href="#4-STM32程序设计与参数选择" class="headerlink" title="4 STM32程序设计与参数选择"></a>4 STM32程序设计与参数选择</h2><p>项目代码已推送至Github远程仓库：<a target="_blank" rel="noopener" href="https://github.com/Asgard-Tim/ECG_Final_Project">Asgard-Tim/ECG_Final_Project</a></p>
<h3 id="4-1-单片机程序架构设计"><a href="#4-1-单片机程序架构设计" class="headerlink" title="4.1 单片机程序架构设计"></a>4.1 单片机程序架构设计</h3><p>为实现2.1节所提出的基本功能，除了要采集心电数据并对其进行滤波、显示时域波形外，还需要对滤波后的波形进行频谱分析并显示。为了更高效地完成这一过程，系统引入了快速傅里叶变换（FFT）算法，用于将时域信号转化为频域信号，便于分析信号的频谱特性。然而，由于FFT计算量较大，尤其是在较高采样率下，需要处理大量的点，因此为了加快运行速度，程序采用了FreeRTOS实时操作系统，分别对信号滤波和频谱分析进行任务划分和并行处理。</p>
<p><img src="/images/ecg/media/image33.png" alt="图4.1 单片机程序工程基本工作框架"></p>
<p>在系统的实现中，FreeRTOS将任务分为信号采集与滤波任务ECG和FFT计算任务。如上图所示，信号采集任务负责从ADS1292R中读取原始心电信号，并完成IIR和FIR滤波的处理，将滤波后的数据存储到循环缓冲区中，通过中断驱动的方式与传感器交互，确保数据的实时性和可靠性；而FFT计算任务则专注于对缓冲区中的数据进行频谱分析，每当缓冲区填满指定数量的数据点时，FFT计算任务将被启动，这虽然会导致实际运行时FFT频谱更新会产生一定的延时，但这样的设计将使得整个系统的工作更加稳定可控。</p>
<p>通过引入FreeRTOS，系统充分利用了单片机的多任务并行能力，使信号滤波和频谱分析的运行效率大幅提升，同时保证了心电信号处理的实时性。滤波和频谱分析的结合，不仅提高了信号的可用性，还为后续的心率计算和心电异常检测提供了更加丰富和可靠的数据支持。</p>
<h3 id="4-2-采集原始数据解码"><a href="#4-2-采集原始数据解码" class="headerlink" title="4.2 采集原始数据解码"></a>4.2 采集原始数据解码</h3><p>通过SPI接口，STM32微控制器不断与ADS1292R传感器进行交互，读取其输出的24位数字信号数据。基于3.1节提到的价码规则，将读取到的数据经过必要的解码和处理后，可将其转换为实际的电压值，并进一步用于实时显示与分析。其核心代码如下所示：</p>
<p><img src="/images/ecg/media/image34.png" alt="图4.2 ADS1292R原始数据解码核心代码"><img src="/images/ecg/media/image35.png" alt="图4.2 ADS1292R原始数据解码核心代码"></p>
<p>在具体实现中，通过将ADS1292R的24位原始数据解码为32位有符号整数，消除了符号位可能引起的误差。随后，将解码后的信号根据增益和参考电压转换为实际的电压值。这一过程中，左导联和右导联的连接状态也会被实时检测，以确保数据采集的可靠性。如果导联连接异常（如电极松动），系统会发出提示并暂停后续的采集。</p>
<h3 id="4-3-处理算法移植：滤波器"><a href="#4-3-处理算法移植：滤波器" class="headerlink" title="4.3 处理算法移植：滤波器"></a>4.3 处理算法移植：滤波器</h3><p>经过STM32接收心电信号后，系统根据PC端设计好的滤波器方案对原始信号进行双重滤波处理，先通过IIR滤波器消除直流分量，然后利用FIR滤波器进一步去除高频噪声，从而得到更为清晰的心电信号。经过IIR和FIR滤波后的信号显著改善，直流漂移、工频干扰以及高频噪声均被有效抑制，这一改进不仅提高了信号的可分析性，也为后续的特征提取与心率计算打下了坚实基础。</p>
<p>滤波后，处理得到的心电信号被传输至PC端，并通过可视化工具显示其改进的波形。如下图所示，信号的基线漂移已完全消除，高频噪声也显著减弱。滤波后的心电信号为后续的心率估算和其他心电特征分析提供了高质量的数据输入，从而提升了系统的整体性能和实用性。</p>
<p><img src="/images/ecg/media/image36.png" alt="图4.3：PC端可视化软件中显示采集到的滤波后心电信号（解码后）"></p>
<h4 id="4-3-1-IIR数字直流陷波器"><a href="#4-3-1-IIR数字直流陷波器" class="headerlink" title="4.3.1 IIR数字直流陷波器"></a>4.3.1 IIR数字直流陷波器</h4><p>在IIR滤波阶段，STM32程序参考了PC端的滤波器设计，实现了高效的实时滤波。IIR滤波器的核心算法通过递归关系计算当前输出值，其中参数a=0.992控制直流分量的衰减程度。算法以较少的存储空间完成了对信号直流漂移的有效抑制，使用上一输入与上一输出值的递归关系更新当前输出值，从而达到实时滤波的目的。</p>
<p><img src="/images/ecg/media/image37.png" alt="图4.4：IIR数字直流陷波器单片机C语言代码"></p>
<h4 id="4-3-2-FIR数字低通滤波器"><a href="#4-3-2-FIR数字低通滤波器" class="headerlink" title="4.3.2 FIR数字低通滤波器"></a>4.3.2 FIR数字低通滤波器</h4><p>经过IIR滤波后，信号中的直流分量被有效去除，但仍可能含有工频干扰和其他高频噪声。因此，信号会进一步通过FIR滤波器进行处理。FIR滤波器利用一个固定长度的滑动队列实现，其滤波系数矩阵B由MATLAB中的filterDesigner工具生成并导出到C代码中。该滤波运算采用定点方式，在初始化时需要将滤波器系数乘以66536（如图4.5中右图所示），再取整保存为16bits整数。该部分的核心算法是，通过遍历队列数据与滤波器系数进行逐项乘积累加，实现对信号的精准滤波。代码设计充分考虑了队列操作的效率，通过队列循环的方式减少内存消耗并保证实时性。</p>
<p><img src="/images/ecg/media/image38.png" alt="图4.5：filterDesigner导出系数矩阵B的部分结果及FIR滤波器参数初始化"><br><img src="/images/ecg/media/image39.png" alt="图4.5：filterDesigner导出系数矩阵B的部分结果及FIR滤波器参数初始化"></p>
<p><img src="/images/ecg/media/image40.png" alt="图4.6：FIR数字低通滤波器核心算法单片机C语言代码"></p>
<h3 id="4-4-处理算法移植：心率与幅值计算"><a href="#4-4-处理算法移植：心率与幅值计算" class="headerlink" title="4.4 处理算法移植：心率与幅值计算"></a>4.4 处理算法移植：心率与幅值计算</h3><p>系统的心跳检测功能基于心电信号的峰谷变化，通过heartbeat_check函数实现对R波峰值的实时检测。该函数采用简单高效的阈值法，以波峰和波谷之间的差值判断是否发生心跳事件。函数的核心逻辑包括记录当前波形的上升和下降趋势，以及动态调整波峰（up_value）和波谷（down_value）的值。</p>
<p>具体来说，当检测到波形从下降趋势转为上升趋势，且波峰与波谷的差值超过设定的阈值（经过调试设置为0.55较为合适），即判定为一次心跳事件。此时，波峰和波谷会重新初始化，为下一次心跳检测做好准备。如果当前波形变化幅度未达到阈值，则认为是噪声或非心跳波形，函数返回0。</p>
<p>在实际应用中，该函数与DWT模块配合使用，每次心跳事件发生时记录时间戳，通过计算相邻两次事件的时间间隔（R-R间期）估算心率。高精度的DWT计数器和简洁的心跳检测算法相结合，使得系统能够在保证实时性的同时，准确识别心跳并计算心率。</p>
<p><img src="/images/ecg/media/image41.png" alt="图4.7：单次心跳检测函数heartbeat_check代码"></p>
<p><img src="/images/ecg/media/image42.png" alt="图4.8：心率计算函数calc_heartbeat_rate代码（基于单次心跳的检测结果）"></p>
<p>为衡量心率信号的幅值范围，编写函数 Cal_PeakToPeak 以计算一组浮点数数据的峰峰值，即数据中的最大值与最小值之间的差值，用以反映数据的动态范围或振幅。函数通过接收一个浮点数数组 samples 和数组中的元素个数 sample_count 作为输入，首先将数组的第一个元素初始化为当前的最大值和最小值，然后从第二个元素开始逐一遍历整个数组。在遍历过程中，函数逐步更新最大值 max 和最小值 min，确保能够捕获数据中的真实极值。遍历完成后，函数通过计算 max - min 得到峰峰值，并将结果作为返回值。整个过程采用单次遍历的方法，计算效率较高，适合处理较大规模的采样数据。</p>
<p><img src="/images/ecg/media/image43.png" alt="图4.9：幅值检测函数Cal_PeakToPeak代码"></p>
<h3 id="4-5-TFT屏幕绘制采集波形"><a href="#4-5-TFT屏幕绘制采集波形" class="headerlink" title="4.5 TFT屏幕绘制采集波形"></a>4.5 TFT屏幕绘制采集波形</h3><p>TFT屏幕是系统的重要输出模块，负责实时显示处理后的心电波形和心率数据。通过高分辨率和快速刷新率，TFT屏幕能够清晰呈现心电信号的变化，供用户随时监控自己的心脏健康状况。它不仅显示心电波形，还提供当前的心率和可能的异常信号提示，帮助用户及时发现问题。</p>
<p><img src="/images/ecg/media/image44.png" alt="图4.10 2.8寸TFT LCD电阻触摸屏模块320\*240实物图"></p>
<p>对于已经滤波后的心电信号，在移植并调用原有LCD驱动库的基础上，编写了drawCurve函数实现实时的波形显示。该函数根据输入的心电信号数值，将其映射到屏幕的像素坐标，并绘制出连续的曲线。</p>
<p><img src="/images/ecg/media/image45.png" alt="图4.11：TFT屏幕波形绘制函数drawCurve代码"></p>
<p>可以看到，对于滤波后的心电信号值，除了基本的指定区域绘制波形外，为避免波形超出屏幕边界，还对计算得到的y坐标进行上下限约束，使其始终位于屏幕的有效显示区域内：如果y坐标超过屏幕范围，则自动截断至边界位置；当x坐标超出屏幕宽度时，程序清空屏幕并从起始位置重新开始绘制新的波形。通过这种循环显示方式，确保波形在屏幕上以滚动形式连续更新，为实时心电信号的监测提供直观的显示效果。</p>
<h3 id="4-6-频谱分析及其TFT屏幕绘制"><a href="#4-6-频谱分析及其TFT屏幕绘制" class="headerlink" title="4.6 频谱分析及其TFT屏幕绘制"></a>4.6 频谱分析及其TFT屏幕绘制</h3><p>在频谱FFT计算的具体实现中，程序使用CMSIS-DSP库提供的高效FFT算法，首先将心电信号数据打包为复数输入，其中实部为滤波后的心电数据，虚部置为零。随后调用arm_cfft_radix4_f32函数完成快速傅里叶变换，并通过arm_cmplx_mag_f32函数计算复数频谱的幅值。计算结果存储在FFT输出缓冲区中，用于后续的频谱绘制。</p>
<p><img src="/images/ecg/media/image46.png" alt="图4.12：频谱计算（FFT）函数FFT_Calculate代码"></p>
<p>对于频域波形，系统通过FFT算法计算心电信号的频率分量，并将其可视化为频谱图。频谱图的x轴代表频率，y轴代表频率分量的幅值，能够直观反映心电信号的频率特性。频域波形的可视化主要依赖Draw_Spectrum函数：</p>
<p><img src="/images/ecg/media/image47.png" alt="图4.13：频谱绘制函数Draw_Spectrum代码"></p>
<p>由于屏幕高度有限，为避免绘图时坐标溢出，函数将FFT输出的幅值限制在合理范围内（0到150，其余位置留给时域波形）。当幅值超过上限或低于下限时，进行截断处理。每个频率分量对应一条垂直线，从屏幕底部开始绘制到计算得到的y坐标。</p>
<h2 id="5-程序测试方法"><a href="#5-程序测试方法" class="headerlink" title="5 程序测试方法"></a>5 程序测试方法</h2><h3 id="5-1-ADS1292R驱动移植及引脚配置"><a href="#5-1-ADS1292R驱动移植及引脚配置" class="headerlink" title="5.1 ADS1292R驱动移植及引脚配置"></a>5.1 ADS1292R驱动移植及引脚配置</h3><p>首先，在通过STM32CubeMX创建工程时，需要配置单片机的时钟速率，SPI接口，中断以及UART串口通信等。为实现与ADS1292R传感器的数据传输，选用SPI1并对引脚进行如下配置：</p>
<p><img src="/images/ecg/media/image48.png" alt="图5.1：SPI1引脚与参数配置"></p>
<p>其中与ADS1292R传感器通信的SPI接口配置为主模式，时钟极性为CPOL=LOW，时钟相位为CPHA=2EDGE，数据帧格式为8位，通信速率依据传感器要求设置在8MHz以下，此处设置为656.25Kbit/s。</p>
<p>此外，还需要根据ADS1292R库文件中的说明，对UART通信进行设置，其中波特率设置为115200，8位数据位，1位停止位，无校验。</p>
<p><img src="/images/ecg/media/image49.png" alt="图5.2：UART引脚与参数配置"></p>
<p>完成引脚配置后就可以进行初始代码生成。在生成的初始代码工程中，引入ADS1292R的相关库文件（ADS1292R.c与ADS1292R.h），根据对应的配置代码将STM32F407开发板与ADS1292R传感器模块进行连线：</p>
<p><img src="/images/ecg/media/image50.png" alt="图5.3：ADS1292R.h与spi.c代码文件中关于连线的相关说明"><img src="/images/ecg/media/image51.png" alt="图5.3：ADS1292R.h与spi.c代码文件中关于连线的相关说明"></p>
<p><img src="/images/ecg/media/image52.jpeg" alt="图5.4：连线实物图"><br><img src="/images/ecg/media/image53.jpeg" alt="图5.4：连线实物图"></p>
<p>连线完成后，要通过SPI接口实现与ADS1292R的数据交互，还需要在主程序中完成相应的初始化，即调用ADS1292R驱动库中的相关函数，由单片机向ADS1292R发送相应的命令以启动数据采集，并配置工作模式、采样速率、增益等参数。根据ADS1292R数据手册及项目要求，以下是对ADS1292R的主要配置过程：</p>
<p><img src="/images/ecg/media/image54.png" alt="图5.5：函数ADS1292_PowerOnInit中对于ADS1292R的基本配置代码"></p>
<p>首先，将ADS1292R的CONFIG2寄存器配置为0xA3，以启用内部参考电压。内部参考电压的稳定性对于后续心电信号的准确采集至关重要，因此在配置完成后需通过DWT_Delay_ms(10)添加延时，确保内部参考电压稳定。随后，将CONFIG1寄存器设置为0x02，配置心电采集的采样速率为500SPS（Samples Per Second），这一速率能够兼顾信号的时域分辨率和数据量。</p>
<p>接下来，对通道1和通道2进行配置。其中，通道1的CH1SET寄存器设置为0x00，表示通道1工作于正常采集模式，且未启用测试信号输入。通道2的CH2SET寄存器配置为0x05，用于指定通道2采集来自内部测试信号的方波，方便在调试阶段验证系统的采集和传输功能。</p>
<p>此外，为了进一步优化信号的质量，对右腿驱动（RLD）电极进行了配置，通过将RLD_SENS寄存器设置为0x2C，使右腿驱动电极同时连接到通道1和通道2，增强了共模信号的抑制能力。在呼吸阻抗测量相关功能中，将RESP1和RESP2寄存器分别配置为0x02和0x03，根据手册要求开启适当的工作模式。</p>
<p>通过上述配置，ADS1292R可以稳定运行于双通道心电采集模式，通道1用于实时采集患者的心电信号，通道2可用于采集ADS1292R传感器的测试信号以验证该传感器模块是否被正常驱动。</p>
<h3 id="5-2-ADS1292R驱动移植验证：读取传感器设备ID"><a href="#5-2-ADS1292R驱动移植验证：读取传感器设备ID" class="headerlink" title="5.2 ADS1292R驱动移植验证：读取传感器设备ID"></a>5.2 ADS1292R驱动移植验证：读取传感器设备ID</h3><p>事实上，在ADS1292_PowerOnInit函数中，图5.5所示初始化代码之前还有一段代码：</p>
<p><img src="/images/ecg/media/image55.png" alt="图5.6：ADS1292_PowerOnInit初始化函数部分代码"></p>
<p>可以看到，要实现5.1节中对于ADS1292R传感器模块的正确驱动，就必须要顺利运行该段代码，其中调用了ADS1292_ReadDeviceID这一函数并设置了判断条件，若读取到的设备ID不为83（ADS1292）或115（ADS1292R）则会一直循环读取ID而不进行后续的初始化，以确保读取的心电信号不会出现无效数据且采集数据符合预期格式。由于本次项目使用的传感器芯片为ADS1292R，故成功读取到并在串口助手中打印的device_id为115，这也证明驱动库文件的移植是正确的且能正常驱动该传感器模块。</p>
<h3 id="5-3-ADS1292R驱动移植验证：测试信号采集及其TFT屏幕绘制"><a href="#5-3-ADS1292R驱动移植验证：测试信号采集及其TFT屏幕绘制" class="headerlink" title="5.3 ADS1292R驱动移植验证：测试信号采集及其TFT屏幕绘制"></a>5.3 ADS1292R驱动移植验证：测试信号采集及其TFT屏幕绘制</h3><p>在ADS1292R的芯片数据手册中，给出了其内置测试信号的相关参数：</p>
<p><img src="/images/ecg/media/image56.png" alt="图5.7：ADS1292R芯片手册测试信号部分"></p>
<p>可以看到，当PGA增益倍数设置为1时，芯片将输出测试方波信号，通过MATLAB读取并解码原始数据，得到（含直流）范围在-20到8；而去除直流后，该方波动态范围为-14到14。由于参考电压为2.4V（16bits），此时14/32768*2400mv<br>约等于1mv，说明此时方波动态范围转换为电压是正负1mv，和数据手册说明一致。方波测试信号的成功读取也进一步验证了ADS1292R驱动库移植的正确性且能正常驱动该传感器模块。</p>
<p><img src="/images/ecg/media/image57.png" alt="图5.8：MATLAB读取测试方波结果"></p>
<p>图5.8：MATLAB读取测试方波结果</p>
<h2 id="6-实验数据记录与分析"><a href="#6-实验数据记录与分析" class="headerlink" title="6 实验数据记录与分析"></a>6 实验数据记录与分析</h2><p>演示视频链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HWCkYzETe/">https://www.bilibili.com/video/BV1HWCkYzETe/</a></p>
<h3 id="6-1-测试信号采集"><a href="#6-1-测试信号采集" class="headerlink" title="6.1 测试信号采集"></a>6.1 测试信号采集</h3><p>在测试ADS1292的内部方波信号时，设置PGA增益为1，测试结果显示方波波形良好，基本无误差。系统能够准确读取方波信号的峰峰值和幅度值，其效果如图所示：</p>
<p><img src="/images/ecg/media/image58.jpeg" alt="图6.1：采集测试信号在LCD屏幕上的显示效果（测量幅度值为155）"></p>
<p>此外，系统新增了按键功能，按压KEY_0即可实现在显示测试信号波形与显示心电信号波形间切换。</p>
<h3 id="6-2-模拟器心电信号采集"><a href="#6-2-模拟器心电信号采集" class="headerlink" title="6.2 模拟器心电信号采集"></a>6.2 模拟器心电信号采集</h3><p>在实际运行中，drawCurve函数结合系统滤波模块的输出数据和心跳检测结果，将心电信号时域与频域的动态变化以实时曲线的形式绘制在屏幕上。同时，在屏幕上显示心率、波幅等关键参数，进一步增强了系统的直观性和信息量。其效果如下图所示：</p>
<p><img src="/images/ecg/media/image59.jpeg" alt="图6.2：BPM为60的心电信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p>经过测试，测算出的心率值与心电模拟仪中给出的心率值误差不超过3 BPM（每分钟心跳数），满足系统设计需求；但此时滤波器的滤波效果有点过度，也可能是显示的波形幅度调整的不好，导致最终显示的波形丢失了过多的有用信息。</p>
<h3 id="6-3-模拟器心率信号采集"><a href="#6-3-模拟器心率信号采集" class="headerlink" title="6.3 模拟器心率信号采集"></a>6.3 模拟器心率信号采集</h3><p>将模拟器调至2档（心率档），产生的心率信号默认为75BPM，此时时域与频域波形的显示效果如下：</p>
<p><img src="/images/ecg/media/image60.jpeg" alt="图6.3：BPM为75的心率信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p>可以看到，此时测得的心率基本准确，与心电模拟仪中给出的心率值误差不超过3 BPM，满足系统设计需求，且频谱图也有较明显的尖峰且噪声较少；此时滤波器的滤波效果虽然也有点过度了，但效果明显由于6.2节中对于心电信号的测量，有明显的波峰。</p>
<p>心跳检测功能的设计不仅能够适应动态变化的心电信号，还通过灵活的阈值调整提高了对不同信号幅度的适应性。将模拟器调至8档，以调整产生心率信号的幅值（心率BPM仍为75），采集与显示效果如下：</p>
<p><img src="/images/ecg/media/image61.jpeg" alt="图6.4：幅值为1mV的心率信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p><img src="/images/ecg/media/image62.jpeg" alt="图6.5：幅值为2mV的心率信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p><img src="/images/ecg/media/image63.jpeg" alt="图6.6：幅值为3mV的心率信号（模拟器产生）在LCD屏幕上的显示效果"></p>
<p>可以看到，随着心率信号幅值的成倍变化，测量出的波形幅值也在成倍变化，且频谱较为干净，这说明该心电信号采集系统对于不同的信号幅度具有较高的灵敏性，但未对测量的幅值数值进行对应电压的换算导致结果并不直观；同时由于测量心率程序中对于检测跳变幅度的阈值设置较小，导致此时当幅值明显增大时，震荡信号的跳变幅度也随之增加，导致心率测量出现一定程度的偏差。</p>
<h3 id="6-4-人体心电信号采集与测量"><a href="#6-4-人体心电信号采集与测量" class="headerlink" title="6.4 人体心电信号采集与测量"></a>6.4 人体心电信号采集与测量</h3><p>未接入人体心电信号时，采集到信号的时域波形与频谱如下：</p>
<p><img src="/images/ecg/media/image64.jpeg" alt="图6.7：未接入任何心率信号时LCD屏幕上显示的时域与频域波形（白板）"></p>
<p>对于人体心电信号检测，由于心电电极对接触状态的敏感性，最佳效果仅在涂抹酒精并佩戴三分钟内获得，因此系统仅能在心电电极贴附于人体的短时间内实现精确检测</p>
<p>在实际测试时，邀请室友将电极片分别贴于手腕和脚部，并分别与数据线连接，此时系统采集到的心电波形如下所示（详细测试过程在演示视频中）：</p>
<p><img src="/images/ecg/media/image65.jpeg" alt="图6.8：人体心电信号测试过程掠影"><br><img src="/images/ecg/media/image66.jpeg" alt="图6.8：人体心电信号测试过程掠影"></p>
<p><img src="/images/ecg/media/image67.png" alt="图6.9：采集到的人体心电信号时域与频域波形显示结果"></p>
<p>从图中可以看出，检测人体心电信号时，波形与心电信号模拟仪的输出相比仅存在轻微差别，整体表现良好，但仍然存在滤波过度的问题。</p>
<p>除了将电极贴于手腕和脚部进行测试外，系统还测试了将电极贴在左右锁骨中线第一肋间和胸骨左缘第四肋间的位置。测试结果显示，这些位置的信号稳定性优于手脚部位，并且能够维持更长时间的良好效果。</p>
<h2 id="7-实验结果总结和心得体会"><a href="#7-实验结果总结和心得体会" class="headerlink" title="7 实验结果总结和心得体会"></a>7 实验结果总结和心得体会</h2><h3 id="7-1-实验结果"><a href="#7-1-实验结果" class="headerlink" title="7.1 实验结果"></a>7.1 实验结果</h3><p>在本项目中，基于 STM32F407ZG 主控芯片和 ADS1292R 传感器模块，成功实现了人体心电信号的采集与分析功能。针对心电信号易受工频干扰和低频基线漂移影响的问题，设计并实现了 IIR 数字直流陷波器 和 FIR 数字低通滤波器，有效消除了干扰并获得了较为清晰的心电波形。</p>
<p>在开发过程中，利用心电信号模拟仪对单片机程序进行了调试，使系统能够稳定采集和显示心电波形。尽管滤波器在MATLAB仿真中效果良好，但移植到单片机工程中后，出现了滤波过度的问题。初步分析认为，这可能与信号采样频率、显示波形的幅度比例调节以及滤波算法的具体实现有关，仍需进一步优化。然而，系统总体性能令人满意，其采集效果、频域分析结果、心电峰峰值及心率测算结果均较为准确。</p>
<p>此外，系统还实现了对 ADS1292R模块自带测试方波信号的读取、显示以及峰峰值测量功能，基本满足了所有的设计需求。最终也成功采集并显示了实际人体心电信号的时域波形与频谱。</p>
<h3 id="7-2-心得体会"><a href="#7-2-心得体会" class="headerlink" title="7.2 心得体会"></a>7.2 心得体会</h3><p>通过本次项目的实践，我对数字信号的采集与处理以及滤波器的设计与实现有了更加深刻的理解。这不仅加深了我对数字信号处理理论知识的掌握，还让我在理论与实践的结合中得以进一步巩固相关技能。在单片机的编程实践与调试过程中，我对STM32尤其是F4系列开发板的硬件和软件开发有了更深入的认识，这大大提升了我的开发效率和调试能力。</p>
<p>本项目也是我首次尝试使用 FreeRTOS操作系统搭建整个工程框架。在此过程中，我学习并掌握了实时操作系统的基本原理和任务调度机制，初步理解了如何优化系统资源管理，成功地将操作系统的使用融入到嵌入式项目开发中。这一尝试不仅丰富了我的开发经验，也让我更好地认识到实时操作系统在复杂工程中的价值。</p>
<p>尽管最终心电信号的显示结果并未完全达到预期，但我从问题中发现了自身在信号采集频率、滤波算法实现以及系统显示优化方面的不足，并明确了未来改进的方向。整个项目开发的过程充满了挑战，同时也伴随着大量的收获。我深刻体会到硬件开发与数字信号处理是一个不断探索和优化的过程，而这次项目实践无疑为我在这些领域的技能提升打下了坚实基础。</p>
<p>此外，本次项目还培养了我独立分析和解决问题的能力。从模块功能的实现到整体工程的构建，我逐步熟悉了完整的开发流程，对系统的设计、调试和优化有了更加系统化的认识。我相信，这些经验和能力将在今后的学习和工作中发挥重要作用，为更高层次的开发任务奠定基础。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 朱冰莲,方敏编著.数字信号处理[M].电子工业出版社,2014:276.</p>
<p>[2] 程佩青编著.数字信号处理教程[M].清华大学出版社,2015:524.</p>
<p>[3] 任勇,曾浩编著.单片机原理及应用[M].清华大学出版社,2023.</p>
<p>[4] 德州仪器. ADS1292 数据手册</p>
<p>[5] 任勇. CQU_S12XDEV开发板原理图 微电子与通信工程学院</p>
<p>[6] 任勇. ADS1292-心电信号采集原理图及接口说明-RY</p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-12-21T18:15:03.000Z" title="2024/12/22 02:15:03">2024-12-22</time>发表</span><span class="level-item"><time datetime="2025-03-02T17:56:40.547Z" title="2025/3/3 01:56:40">2025-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/">自动控制原理</a></span><span class="level-item">3 小时读完 (大约30100个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/12/22/control/">基于直流电源调控的自动调光控制设计</a></p><div class="content"><div id="postchat_postcontent"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本项目围绕直流电源调控的自动调光控制系统展开研究与设计，系统性地探讨了Buck变换器的基本原理、建模方法、性能分析及其实验验证过程。在硬件设计方面，基于STM32处理器，选择了高性能的元器件并通过合理的电路拓扑实现高效的能量转换；在软件控制算法方面，采用PID闭环控制，并结合自动控制原理中的经典控制理论，利用PSIM与MWorks等仿真与科学计算工具，对控制系统的时域响应、频域特性和稳定性进行了详尽分析，进而通过参数优化与校正环节设计显著提升了系统的响应速度和稳态性能，同时也验证了闭环控制系统在动态性能、抗干扰能力和输出精度方面的显著优势。此外，通过实验测量与仿真结果对比，探讨了电路寄生参数对系统性能的影响，为后续优化提供了理论依据。在基于光敏电阻的自动调光功能模块中，结合蓝牙通信接口实现了系统的智能化控制，同时对于自动调光系统进行外观设计，赋予产品更多的人文关怀与实用价值；在光伏板最大功率点跟踪（MPPT）功能模块中，根据MPPT的原理与基本思想设计了相应的控制算法，并在实验中成功控制光伏板输出功率，使其约等于负载消耗功率，完成了不同光照强度下最大功率点的跟踪。最后，对于该自动控制系统的设计成果及其在实际应用中的可行性与局限性进行总结，并对未来可能的优化方向和工程实现前景提出了展望。</p>
<p><strong>关键词：</strong>Buck变换器；PID闭环控制；自动调光；光伏MPPT</p>
<h2 id="1-课程涉及理论基础和STM32简介"><a href="#1-课程涉及理论基础和STM32简介" class="headerlink" title="1 课程涉及理论基础和STM32简介"></a>1 课程涉及理论基础和STM32简介</h2><h3 id="1-1-自动控制原理简介"><a href="#1-1-自动控制原理简介" class="headerlink" title="1.1 自动控制原理简介"></a>1.1 自动控制原理简介</h3><p>在科学技术飞速发展的今天，自动控制技术和理论已经成为现代社会不可缺少的组成部分。自动控制技术的应用不仅使生产过程实现自动化，从而提高了劳动生产率和产品质量，降低了生产成本，提高了经济效益，改善了劳动条件，使人们从繁重的体力劳动和单调重复的脑力劳动中解放出来；而且在人类征服大自然、探索新能源、发展空间技术和创造人类社会文明等方面都具有十分重要的意义。</p>
<p>自动控制理论是研究关于自动控制系统组成、分析和综合的一般性理论，是研究自动控制共同规律的技术科学。自动控制是在人不直接参与的情况下，利用外加的自动控制设备或装置（控制装置或控制器），使机器、设备或生产过程（统称为被控对象）的某个工作状态或参数（被控量）自动地按照预定的规律运行，使机器的动作、设备的运转、生产过程的状态能够自动地在一定的精度范围内按照给定的规律变化。学习和研究自动控制理论是为了探索自动控制系统中变量的运动规律和改变这种运动规律的可能性和途径，为建立高性能的自动控制系统提供必要的理论依据。</p>
<h3 id="1-2-本项目所涉及的经典控制理论内容"><a href="#1-2-本项目所涉及的经典控制理论内容" class="headerlink" title="1.2 本项目所涉及的经典控制理论内容"></a>1.2 本项目所涉及的经典控制理论内容</h3><p><img src="/images/control/media/image2.png" alt="图1.1：项目涉及的经典控制理论框图"></p>
<p>本项目从经典控制理论的基本原理与概念出发，以Buck变换器这一单输入-单输出的线性系统作为研究对象，利用微分方程、Laplace变换与传递函数等数学工具建立系统的数学模型，并基于时域分析、频域分析以及根轨迹法等多种分析方法对于系统的稳定性与响应特性进行详细分析，从而针对特定的性能指标进行对应的校正设计，通过引入PID控制器并调控其参数以改变系统的频率特性从而满足给定的各项性能指标，使得整个闭环控制系统能够兼具稳定性、快速性与准确性。</p>
<h3 id="1-3-STM32处理器介绍"><a href="#1-3-STM32处理器介绍" class="headerlink" title="1.3 STM32处理器介绍"></a>1.3 STM32处理器介绍</h3><p>控制核心是控制系统中的重要组成部分，用于计算、解析各种数据，并执行相应的控制算法。芯片选型的设计直接决定了控制板的性能和功能。STM32是由意法半导体公司（ST）推出的基于Arm Cortex-M处理器内核的32位微控制器，专为要求高性能、低成本、低功耗的嵌入式应用设计，集实时功能、数字信号处理、低功耗/低电压操作、连接性等特性于一身，同时还保持了集成度高和易于开发的特点，基于行业标准内核，提供了大量工具和软件选项以支持工程开发，非常适用于小型项目或端到端平台。</p>
<p>本项目选用的处理器STM32F103C8T6作为中等容量高性能系列MCU，集成了工作频率为72MHz的高性能Arm Cortex-M3 32位RISC内核、高速嵌入式存储器（高达128KB的Flash存储器和20KB的SRAM存储器），以及大量连接至2条APB总线的增强型I/O与外设，具有36引脚至100引脚等6种不同的封装类型。所有器件均提供2个12位ADC、3个16位通用定时器、2个PWM定时器以及标准和高级通信接口：多达2个I2C和SPI、3个USART、1个USB和1个CAN。器件的工作电压为2.0V至3.6V。该处理器的工作温度范围为-40℃到+85℃，可扩展至-40℃到+105摄氏度。这些特性使得该处理器成为各种应用的理想之选，也能很好满足本项目对于控制器的性能需求。</p>
<p><img src="/images/control/media/image3.png" alt="图1.2：本项目选用的处理器STM32F103C8T6"></p>
<h3 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h3><p>本章主要介绍了本课程相关的自动控制理论基础，针对本项目涉及到的经典控制理论框架进行了简要概述，同时对于本项目所选用的控制核心——STM32处理器进行简单介绍，重点分析了我们采用的STM32F103C8T6处理器的性能特性并给出选型原因。这为本课程项目提供了整体框架，并从理论上对后续项目的具体实施给出了方向性的指引。</p>
<h2 id="2-直流Buck变换器设计与调试"><a href="#2-直流Buck变换器设计与调试" class="headerlink" title="2 直流Buck变换器设计与调试"></a>2 直流Buck变换器设计与调试</h2><h3 id="2-1-Buck变换器拓扑原理分析"><a href="#2-1-Buck变换器拓扑原理分析" class="headerlink" title="2.1 Buck变换器拓扑原理分析"></a>2.1 Buck变换器拓扑原理分析</h3><p>Buck（降压式）变换器是一种输出电压≤输入电压的非隔离直流DC-DC变换器，其中输入电流为脉冲式的，而输出电流为连续的低纹波直流电压。Buck变换器实现的稳态输入输出关系为：<br>$$<br>U_{0} = DU_{in}<br>$$<br>Buck变换器的主电路由开关管Q，二极管D，输出滤波电感L和输出滤波电容C构成。</p>
<p><img src="/images/control/media/image4.png" alt="图2.1：Buck开关功率变换器基本电路"></p>
<p>可以看到，在能量缓冲变换电路中，主要由如下三个部分组成：</p>
<ol>
<li><p>电感L与电容C实质上构成了一个二阶低通滤波器，通过滤除开关频率交流分量而仅保留其直流分量，得到平直的输出电压U0；</p>
</li>
<li><p>脉冲宽度调制（Pulse Width Modulation，PWM）产生方波电压控制开关管Q的导通；</p>
</li>
<li><p>二极管D为电感电流提供续流回路。</p>
</li>
</ol>
<p>Buck变换器主电路整体的工作逻辑如下：</p>
<ol>
<li>当开关管Q驱动为高电平时，开关管导通，储能电感L被充磁，流经电感的电流线性增加，同时给电容C充电，给负载R提供能量；</li>
</ol>
<p><img src="/images/control/media/image5.png" alt="图2.2：开关管导通时电流环路"></p>
<ol start="2">
<li>当开关管Q驱动为低电平时，开关管关断，储能电感L通过续流二极管D放电，电感电流线性减少，输出电压靠输出滤波电容C放电以及减小的电感电流维持。</li>
</ol>
<p><img src="/images/control/media/image6.png" alt="图2.3：开关管关断时电流环路"></p>
<p>事实上，对于该电能变换器，可以通过更改个别元器件的种类、接入方式与顺序，实现搭建具有不同功能的电能变换电路，即Buck变换器的拓扑原理。下面列举几种常见的拓扑电路：</p>
<ol>
<li>升压变换器：</li>
</ol>
<p><img src="/images/control/media/image7.png" alt="图2.4：Buck变换器拓扑：降压--->升压"></p>
<ol start="2">
<li>降压同步整流变换：采用互补工作模式，可减小损耗</li>
</ol>
<p><img src="/images/control/media/image8.png" alt="图2.5：Buck变换器拓扑：同步整流"></p>
<ol start="3">
<li>H桥DC-AC逆变器：开关管部分串联构成双极性交流电压源</li>
</ol>
<p><img src="/images/control/media/image9.png" alt="图2.6：Buck变换器拓扑：DC-DC --->DC-AC"></p>
<ol start="4">
<li>闭环PWM控制：可以在原有Buck电路基础上增加闭环环路，通过PWM调配开关管Q的导通与否，从而实现对于输出电压的控制，使系统能够更加”稳”、”快”、”准”地得到期望的输出。目前的控制器选择主流为PID控制器，根据不同的指标又可将闭环控制系统分为不同类别：若根据控制对象分类，则可分为电压控制与电流控制；若根据接收调控信息的时间先后分类，又可分为反馈控制与前馈控制；根据其他的分类标准，还可分为线性/非线性控制、平均/纹波控制、模拟/数字控制……在此不一一列举。</li>
</ol>
<h3 id="2-2-Buck变换器元器件参数选择"><a href="#2-2-Buck变换器元器件参数选择" class="headerlink" title="2.2 Buck变换器元器件参数选择"></a>2.2 Buck变换器元器件参数选择</h3><p>在Buck变换主电路中，对电路参数进行如下设定：</p>
<ul>
<li><p>输入电压<br>$$<br>U_{in} = 15V<br>$$</p>
</li>
<li><p>输出电压<br>$$<br>U_{o} = 8V<br>$$</p>
</li>
<li><p>占空比<br>$$<br>d = 50%<br>$$</p>
</li>
<li><p>电源转换电压：12V、15V、5V、5V（隔离）</p>
</li>
<li><p>电感<br>$$<br>L = 100\mu F<br>$$</p>
</li>
<li><p>电容<br>$$<br>C = 660\mu F<br>$$</p>
</li>
<li><p>工作频率<br>$$<br>f = 25kHz<br>$$</p>
</li>
</ul>
<p>首先，为满足电源转换与单片机供电的需求，需要在电源直接引入Buck电路前先接入电源模块，涉及到的元器件及相关参数如下：</p>
<ol>
<li>URB2412YMD-10WR3电源模块：降压模块，将电源提供的输入电压（最大35V，本实验中为15V）转换为12V输出，提供0.83A的电流；</li>
</ol>
<p><img src="/images/control/media/image10.png" alt="图2.7：URB2412YMD-10WR3电源模块原理图与实物图"><img src="/images/control/media/image11.png" alt="图2.7：URB2412YMD-10WR3电源模块原理图与实物图"></p>
<ol start="2">
<li>CW7805线性稳压器：将12V输入电压转换为稳定的5V输出电压，并将输出电流转换成1A，分输入、输出与接地三端，主要用于使线性的输出电压稳定；</li>
</ol>
<p><img src="/images/control/media/image12.png" alt="图2.8：CW7805线性稳压器原理图与实物图"><img src="/images/control/media/image13.png" alt="图2.8：CW7805线性稳压器原理图与实物图"></p>
<ol start="3">
<li>A1215S-2WR3电源模块：升压模块，将12V输入转换为±15V，适合供给双电源运放电路，本实验中主要用于为采样电路（滤波器）供电；</li>
</ol>
<p><img src="/images/control/media/image14.png" alt="图2.9：A1215S-2WR3电源模块原理图与实物图"><img src="/images/control/media/image15.png" alt="图2.9：A1215S-2WR3电源模块原理图与实物图"></p>
<ol start="4">
<li>IB1205S-2W电源模块：降压模块，将12V输入转换为5V，通常用于低功耗电路的供电，本实验中主要用于光耦（与驱动）电路的供电。</li>
</ol>
<p><img src="/images/control/media/image16.png" alt="图2.10：IB1205S-2W电源模块原理图与实物图"><img src="/images/control/media/image17.jpeg" alt="图2.10：IB1205S-2W电源模块原理图与实物图">其次，在Buck变换主电路中，为满足设定元件参数，选取如下元器件：</p>
<ol>
<li>贴片MOS管NCE0130KA：VDS=100V，VGS=10V</li>
</ol>
<p><img src="/images/control/media/image18.png" alt="图2.11： 贴片MOS管NCE0130KA实物图"></p>
<ol start="2">
<li>贴片电感：色环直插型，100uH</li>
</ol>
<p><img src="/images/control/media/image19.png" alt="图2.12：贴片电感实物图"></p>
<ol start="3">
<li>贴片铝电解电容：330uF，±20%，耐压50V，两个并联达到设定660uF</li>
</ol>
<p><img src="/images/control/media/image20.png" alt="图2.13：贴片铝电解电容实物图"></p>
<ol start="4">
<li>电流传感器CC6920SO-5A：初级电流测量范围-5A~5A，供电电压5V</li>
</ol>
<p><img src="/images/control/media/image21.png" alt="图2.14：电流传感器CC6920SO-5A实物图"></p>
<ol start="5">
<li>电压传感器LV25-NP：初级电流测量范围10-500V，供电电压±15V</li>
</ol>
<p><img src="/images/control/media/image22.jpeg" alt="图2.15：电压传感器LV25-NP实物图"></p>
<p>其中，电容与电感均采用贴片形式的原因主要有以下几点：</p>
<p>【1】 体积小且便于贴装，适合电路的高集成度需求；</p>
<p>【2】 贴片元件引线较短，寄生电感和电容较小，可提高电路的高频性能；</p>
<p>【3】 贴片元件的散热性能通常较好，有助于提高电路的可靠性；</p>
<p>【4】 贴片元件可以有效减小电磁干扰，提高电路的稳定性。</p>
<p>除此之外，由于本实验采用的主控STM32输出能力有限，无法直接驱动管子开关，因此还需要采用光耦和驱动电路为管子提供驱动信号，涉及到的元器件及相关参数如下：</p>
<ol>
<li>IR21844S驱动：栅极驱动供电范围10-20V</li>
</ol>
<p><img src="/images/control/media/image23.jpeg" alt="图2.16：IR21844S驱动实物图"></p>
<ol start="2">
<li>光耦-逻辑输出6N135：5V供电，光耦隔离</li>
</ol>
<p><img src="/images/control/media/image24.jpeg" alt="图2.17：光耦-逻辑输出6N135实物图"></p>
<ol start="3">
<li>运算放大器AD823ARZ：最大输入偏置电流25pA，低失真−108dBc</li>
</ol>
<p><img src="/images/control/media/image25.jpeg" alt="图2.18：运算放大器AD823ARZ实物图"></p>
<h3 id="2-3-Buck变换器实物设计与调试"><a href="#2-3-Buck变换器实物设计与调试" class="headerlink" title="2.3 Buck变换器实物设计与调试"></a>2.3 Buck变换器实物设计与调试</h3><p>在Buck变换主电路设计时，选择不对Buck变换器的电路部分进行拓扑，而在闭环PWM控制电路中采用平均电压模式进行控制。本项目采用的实验电路板主要包括Buck电路基本器件、开关管驱动、辅助电源以及采样电路（信号调理电路），实验时将元器件焊接至电路板上并分别调试各模块功能。</p>
<p><img src="/images/control/media/image26.jpeg" alt="图2.19：组员焊接电路板过程"><img src="/images/control/media/image27.jpeg" alt="图2.19：组员焊接电路板过程"></p>
<p><img src="/images/control/media/image28.png" alt="图2.20：焊接后Buck变换器整体电路实物图"><img src="/images/control/media/image29.png" alt="图2.20：焊接后Buck变换器整体电路实物图"></p>
<h4 id="2-3-1-主电路设计与调试"><a href="#2-3-1-主电路设计与调试" class="headerlink" title="2.3.1 主电路设计与调试"></a>2.3.1 主电路设计与调试</h4><p><img src="/images/control/media/image30.png" alt="图2.21：Buck变换器主电路原理图"></p>
<p>该电路是一个典型的降压型 DC-DC 转换器，其工作原理是通过开关管 Q3 的高速开关动作，将输入电压V_IN转换为期望的输出电压V_OUT。当开关管Q3导通时，输入电压通过 L2、L3和负载形成电流回路，电感存储能量，同时为负载供电；当 Q3关断时，续流二极管 D4 提供电流通路，电感释放能量维持负载电流的连续性。控制器 U6根据反馈电压（通过分压电阻 R8 反馈的V_OUT）与参考电压之间的误差，实时调节 Q3的导通时间（占空比），从而实现输出电压的稳定调节。两级电感 L2 和 L3以及滤波电容 C9、C15进一步平滑输出电流和电压，减少高频纹波，确保输出电压的稳定性和低噪声特性。</p>
<p>经过调试，Buck降压模块主电路可正常实现功能，在参考输入方波幅值为8V、占空比为50%的情况下能够输出占空比为50%、幅值在8V左右（实际约为8.5V）的方波。</p>
<p><img src="/images/control/media/image31.png" alt="图2.22：Buck变换器主电路调试过程与调试结果"><img src="/images/control/media/image32.png" alt="图2.22：Buck变换器主电路调试过程与调试结果"><img src="/images/control/media/image33.png" alt="图2.22：Buck变换器主电路调试过程与调试结果"><img src="/images/control/media/image34.png" alt="图2.22：Buck变换器主电路调试过程与调试结果"></p>
<h4 id="2-3-2-控制电路供电设计与调试"><a href="#2-3-2-控制电路供电设计与调试" class="headerlink" title="2.3.2 控制电路供电设计与调试"></a>2.3.2 控制电路供电设计与调试</h4><p><img src="/images/control/media/image35.png" alt="图2.23：STM32主控芯片供电电路及预留引脚接口"></p>
<p>如图所示为STM32主控芯片供电电路（电源模块）以及单片机内部所使用的接口引脚图，同时将大部分未使用的引脚通过排针引出以供后续拓展功能开发。</p>
<p>在STM32主控芯片供电电路中，包含两个级联的线性稳压器，用于将高电压逐级稳压到所需的5V 和 3.3V。上半部分采用 CJ7805稳压器，将输入电压V_IN转换为稳定的5V输出，通过输入电容C2和C1滤波降低输入纹波，稳压器通过内部反馈电路调节输入电压，使输出稳定在5V，同时通过输出电容C3滤除高频噪声，进一步平滑输出电压。下半部分采用<br>AMS1117-3.3 稳压器，将上一级提供的 5V 电压进一步稳压为3.3V，通过输入滤波电容 C5和 C6减少输入噪声，并通过输出滤波电容C4提高输出电压的稳定性。整个电路通过分级稳压设计，既提高了稳压效率，又能为负载提供低噪声、高稳定性的5V和3.3V电压，适用于嵌入式系统和低功耗数字电路的电源需求。</p>
<p>调试流程：取下单片机核心板—&gt;接入负载100欧姆—&gt;单片机输出PWM—&gt;观测PA8端口波形—&gt;观测驱动芯片输出端口波形—&gt;上主电24V—&gt;检测辅助电源输出电压—&gt;检测输出电压—&gt;根据占空比计算输出电压是否正常—&gt;完成</p>
<p>经调试，该部分模块可正常工作，为STM32主控芯片提供稳定的5V电压：</p>
<p><img src="/images/control/media/image36.jpeg" alt="图2.24：控制模块供电电路调试输出结果"><img src="/images/control/media/image37.jpeg" alt="图2.24：控制模块供电电路调试输出结果"></p>
<h4 id="2-3-3-驱动电路设计与调试"><a href="#2-3-3-驱动电路设计与调试" class="headerlink" title="2.3.3 驱动电路设计与调试"></a>2.3.3 驱动电路设计与调试</h4><p><img src="/images/control/media/image38.png" alt="图2.25：光耦隔离（上）与驱动电路（下）原理图"></p>
<p>如图所示，驱动电路为已有的STM32输出提供了合适的电压和电流驱动功率器件，而如果直接使用STM32输出驱动，可能会超出其输出能力或不能实现良好的电气隔离，导致驱动失败或损坏器件，输出信号不稳定。使用光耦和驱动电路则可以更好地实现电气隔离，从而防止高压或大电流对控制电路的干扰或损坏，保护STM32免受高电压或大电流的影响，提高系统工作可靠性。</p>
<p>调试时，先切断仿真器供电，将单片机供电切换为主电路辅助电源供电；单片机烧录输出电压控制程序后，接入后端负载，再上主电，观测输出电压。经调试，驱动电路可正常工作。</p>
<p><img src="/images/control/media/image39.png" alt="图2.26：驱动电路调试后输出结果"><img src="/images/control/media/image40.png" alt="图2.26：驱动电路调试后输出结果"></p>
<h4 id="2-3-4-电压和电流采样调理滤波设计与调试"><a href="#2-3-4-电压和电流采样调理滤波设计与调试" class="headerlink" title="2.3.4 电压和电流采样调理滤波设计与调试"></a>2.3.4 电压和电流采样调理滤波设计与调试</h4><p><img src="/images/control/media/image41.png" alt="图2.27：电感电流（上）与输出电压（下）采样调理滤波电路原理图"></p>
<p>该电路是一个基于运算放大器的电压比较和分压检测电路，主要功能是将输入电压V_OUT通过电阻分压后与基准电压比较，并输出相应的信号V_S。该电路可用于电压监测或过压保护等场景，通过调整R1 和 R2 的比例，可以设置分压电压，从而灵活设定输入电压的触发阈值。</p>
<p>具体工作原理如下：输入电压$V_{OUT}$经由电阻R1和R2分压后，产生一个分压电压，该电压送入运算放大器U5的反相输入端（引脚2）。运算放大器的非反相输入端（引脚 3）通过稳压二极管 D2提供一个固定的基准电压（3.3V）。当分压后的电压低于基准电压时，运算放大器输出高电平；当分压电压高于基准电压时，运算放大器输出低电平。电容C7和C16用于滤除输入和输出的高频噪声，保证比较过程的稳定性。</p>
<p>调试时，使用仿真器给单片机供电，以调试PWM波形输出是否正常；烧录开环测试程序之后，使用示波器或者上位机观测电路板PA8端口是否正常输出PWM波形。经调试，可对输入信号正确采样并输出对应波形，说明采样模块正常工作：</p>
<p><img src="/images/control/media/image42.jpeg" alt="图2.28：采样模块调试后输出结果"><img src="/images/control/media/image43.jpeg" alt="图2.28：采样模块调试后输出结果"></p>
<h3 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h3><p>本章主要介绍了直流Buck变换器的基本工作原理及其拓扑变换，并根据选定的主控芯片STM32F103C8T6以及设定的电路参数进行了基本元器件的选型与电路原理图及PCB电路板的设计，确定电路主要包括Buck降压变换主电路、控制电路供电辅助电源模块、驱动电路以及采样电路（信号调理电路）四个模块；在焊接时对各个模块依次进行焊接与调试，保证各模块均可以正常工作，以便于后续闭环控制实现时STM32主控控制模块与代码的设计与测试。</p>
<h2 id="3-直流Buck变换器建模"><a href="#3-直流Buck变换器建模" class="headerlink" title="3 直流Buck变换器建模"></a>3 直流Buck变换器建模</h2><h3 id="3-1-Buck变换器闭环控制原理分析"><a href="#3-1-Buck变换器闭环控制原理分析" class="headerlink" title="3.1 Buck变换器闭环控制原理分析"></a>3.1 Buck变换器闭环控制原理分析</h3><p>Buck变换器闭环控制系统主要由以下几个部分组成：</p>
<ol>
<li><p>误差放大器：将参考电压V_ref与实际输出电压V_OUT比较，生成误差信号；</p>
</li>
<li><p>补偿网络：对误差信号进行处理（例如，PI或PID控制），以提高系统稳定性和动态性能；</p>
</li>
<li><p>PWM调制器：将补偿后的控制信号转换为开关元件的占空比D;</p>
</li>
<li><p>采样电路：对输出电压 V_OUT进行实时采样。</p>
</li>
</ol>
<p><img src="/images/control/media/image44.png" alt="图3.1：Buck变换器闭环控制电路简图"></p>
<p>整个闭环控制系统的工作过程如下：</p>
<ol>
<li><p>输出电压采样：通过分压电路对输出电压V_OUT进行采样，得到反馈电压V_fb;</p>
</li>
<li><p>误差检测：误差放大器将参考电压V_ref与反馈电压V_fb比较，产生误差信号<br>$$<br>e(t) = V_{ref} - V_{fb}<br>$$</p>
</li>
<li><p>误差调节：误差信号经过补偿网络调节，生成调节信号V_ctrl，此信号决定PWM占空比；</p>
</li>
<li><p>PWM调制：调制器根据调节信号V_ctrl生成控制信号D，驱动开关元件；</p>
</li>
<li><p>电感电流调节：开关元件的导通时间决定电感电流的充电时间，从而控制输出电压。</p>
</li>
</ol>
<p><img src="/images/control/media/image45.png" alt="图3.2：Buck变换器闭环控制系统框图"></p>
<p>从系统传递函数的角度考虑，根据系统框图与元件特性，可计算其开环传递函数与特征方程：</p>
<p>（1）G_c(s)为PI环节， PI调节器为：<br>$$<br>\left{ \begin{aligned}<br> &amp; \dot{x} = K_{I}v \<br> &amp; y = K_{p}v + x<br>\end{aligned} \right.<br>$$<br>可得PI环节传递函数G_c(s)：</p>
<p>$$<br>G_{c}(s) = K_{p} + K_{I}\frac{1}{s} = \frac{K_{p}(\tau s + 1)}{\tau s}，\tau = \frac{K_{p}}{K_{I}}<br>$$<br>（2）PWM脉宽调制环节：由大信号关系<br>$$<br>v_{con}(dT) = v_{ramp}(dT) = V_{M}\frac{dT}{T} = dV_{M}<br>$$<br>做微分可得小信号的线性关系<br>$$<br>\mathrm{\Delta}v_{con} = \mathrm{\Delta}dV_{M}<br>$$<br>从而实现传递函数的线性化：</p>
<p>$$<br>G_{pwm} = \frac{\mathrm{\Delta}d}{\mathrm{\Delta}v_{con}} = 1/V_{M}<br>$$<br>（3）PWM脉宽控制开关电路：由大信号关系<br>$$<br>v_{D} = dv_{g}<br>$$<br>做全微分可得小信号线性关系<br>$$<br>\mathrm{\Delta}v_{D} = \mathrm{\Delta}dV_{g} + \mathrm{\Delta}v_{g}D<br>$$<br>零初始条件下，对应的工作点为<br>$$<br>V_{g} = V_{in}，\mathrm{\Delta}v_{g} = 0<br>$$<br>于是有传递函数：<br>$$<br>G_{vg} = \frac{\mathrm{\Delta}v_{D}}{\mathrm{\Delta}d} = V_{g}<br>$$<br>（4）RLC并联二阶输出滤波器：由电路图与元件特性可得各元件间电流电压关系：</p>
<p>$$<br>\left{ \begin{array}{r}<br>u_{0} = Ri_{2} \<br>u_{L} = L\frac{di}{dt} \<br>i_{1} = C\frac{du_{0}}{dt} \<br>i = i_{1} + i_{2} \<br>u_{D} = u_{L} + u_{0}<br>\end{array} \right.<br>$$<br>从而可得该滤波器对应的微分方程：<br>$$<br>u_{D} = LC{u_{0}}^{‘’} + \frac{L}{R}{u_{0}}^{‘} + u_{0}<br>$$<br>对两边同时进行拉普拉斯变换，化简整理后可得二阶滤波器的传递函数G_vd(s)：</p>
<p>$$<br>G_{vd}(s) = \frac{U_{0}(s)}{U_{D}(s)}V_{in} = \frac{\frac{1}{LC}}{s^{2} + \frac{1}{RC}s + \frac{1}{LC}}V_{in}<br>$$<br>又因输出信号v_0直接接入PI控制器，故<br>$$<br>H(s) = 1<br>$$<br>综上所述：有开环传递函数：</p>
<p>$$<br>T(s) = G_{c}(s)G_{pwm}G_{\text{vd}}H(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{\frac{1}{LC}}{s^{2} + \frac{1}{RC}s + \frac{1}{LC}}V_{in} = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1}<br>$$<br>进而可以得到系统的特征方程<br>$$<br>T(s) + 1 = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{g}}{LCs^{2} + \frac{L}{R}s + 1} + 1 = 0<br>$$<br>化简后可得：<br>$$<br>\Delta(s) = V_{g}K_{p}(\tau s + 1) + \tau sV_{M}\left( LCs^{2} + \frac{L}{R}s + 1 \right) = \tau V_{M}LCs^{3} + \tau V_{M}\frac{L}{R}s^{2} + (V_{g}K_{p} + V_{M})\tau s + V_{g}K_{p} = 0<br>$$</p>
<h3 id="3-2-Buck变换器PSIM仿真（开环-闭环）"><a href="#3-2-Buck变换器PSIM仿真（开环-闭环）" class="headerlink" title="3.2 Buck变换器PSIM仿真（开环+闭环）"></a>3.2 Buck变换器PSIM仿真（开环+闭环）</h3><p>利用PSIM软件进行电路仿真，根据实际电路结构搭建仿真电路图，并将电路各元件实际参数代入（PI控制器参数：K_p = 0.1，tao = 0.004）：</p>
<p><img src="/images/control/media/image46.png" alt="图3.3：Buck变换器开环控制PSIM仿真电路图"></p>
<p><img src="/images/control/media/image47.png" alt="图3.4：Buck变换器闭环控制PSIM仿真电路图"></p>
<p>运行仿真程序，可得到输出电压的仿真结果：</p>
<p><img src="/images/control/media/image48.png" alt="图3.5：Buck变换器开环控制PSIM仿真结果------输出电压"></p>
<p><img src="/images/control/media/image49.png" alt="图3.6：Buck变换器闭环控制PSIM仿真结果------输出电压"></p>
<p>对比开环与闭环控制系统的输出电压仿真结果可以发现，尽管两个系统都能在短时间内达到稳定的输出电压，但显然闭环控制系统到达稳态的速度更快且震荡更小，稳定后的电压也更接近参考电压8V（约为7.95V）。这说明闭环控制系统具有更快的响应速度与更好的稳定性和准确性。</p>
<h3 id="3-3-输出电压纹波计算（仿真-实验）"><a href="#3-3-输出电压纹波计算（仿真-实验）" class="headerlink" title="3.3 输出电压纹波计算（仿真+实验）"></a>3.3 输出电压纹波计算（仿真+实验）</h3><p><img src="/images/control/media/image50.jpeg" alt="图3.7：Buck变换器开环控制实验输出电压纹波波形"><img src="/images/control/media/image51.jpeg" alt="图3.7：Buck变换器开环控制实验输出电压纹波波形"></p>
<p>首先进行Buck变换器的开环控制实验，并通过示波器观察其输出电压的纹波波形。可以看到，输出波形峰值<br>$$<br>V_{omax} = 88mV<br>$$<br>谷值<br>$$<br>V_{omin} = - 76mV<br>$$<br>则波形的震荡幅度为<br>$$<br>\Delta V_{o} = V_{omax} - V_{omin} = 164mV<br>$$<br>随后利用PSIM软件进行电路仿真，根据实际电路结构搭建仿真电路图，并将电路各元件实际参数代入：</p>
<p><img src="/images/control/media/image52.png" alt="图3.8：Buck变换器开环控制PSIM仿真电路图"></p>
<p>可得到输出电压纹波的仿真结果：</p>
<p><img src="/images/control/media/image53.png" alt="图3.9：Buck变换器开环控制PSIM仿真结果------输出电压纹波"></p>
<p>可以看到，输出电压信号的震荡波形与实际电路示波器显示的纹波形状一致且震荡幅度大致相同。</p>
<h3 id="3-4-电容寄生电阻计算（仿真-实验）"><a href="#3-4-电容寄生电阻计算（仿真-实验）" class="headerlink" title="3.4 电容寄生电阻计算（仿真+实验）"></a>3.4 电容寄生电阻计算（仿真+实验）</h3><p>在Buck变换器开环控制实验中，通过万用表测量得到输入电压V_i= 15.304V，输出电压均值V_o = 7.537V：</p>
<p><img src="/images/control/media/image54.jpeg" alt="图3.10：Buck变换器开环控制实验输入、输出电压测量结果"><img src="/images/control/media/image55.jpeg" alt="图3.10：Buck变换器开环控制实验输入、输出电压测量结果"></p>
<p>除了给定的元件参数之外，为对直流Buck变换器进行精确建模，考虑到电容的寄生参数可能对系统有较大影响，故特别计算其寄生电阻阻值ESR：</p>
<p><img src="/images/control/media/image56.png" alt="图3.11：寄生电阻阻值计算理论依据"></p>
<p>结合<br>$$<br>U_{esr} = \Delta I_{L}*ESR<br>$$<br>一式，考虑到电流因流过电容的寄生电阻而产生的压降U_esr应不大于（实际一般处理为等于）波形的震荡幅度，即：<br>$$<br>U_{esr} \leq \Delta V_{o}<br>$$<br>可以得到在同步Buck电路中（V_d = 0）电容寄生电阻阻值ESR的计算公式：</p>
<p>$$<br>ESR \leq \frac{\Delta V_{o}fLV_{i}}{V_{o}\left( V_{i} - V_{o} \right)}<br>$$<br>结合Buck变换器开环控制实验结果，代入参数<br>$$<br>\Delta V_{o} = 164mV，L = 100\mu F，f = 25kHz，V_{i} = 15.304V，V_{o} = 7.537V<br>$$<br>可以计算得出该电路中实际的电容寄生电阻阻值<br>$$<br>ESR \approx 107.185m\Omega<br>$$<br>这里计算的是接入单个电容的寄生电阻阻值，在实际电路中使用了两个330μF的电容等效替代原设计电路中的660μF电容，为使仿真尽可能接近实际，采取了与实际电路相同的结构，因此需要把寄生电阻同样进行等效，根据电阻并联的等效电阻计算可以得到两个330μF电容的寄生电阻值均为<br>$$<br>2ESR \approx 214.371m\Omega<br>$$<br>利用PSIM软件进行电路仿真，根据实际电路结构搭建仿真电路图，并将计算出的寄生电阻结果代入仿真电路中：</p>
<p><img src="/images/control/media/image57.png" alt="图3.12：引入寄生电阻后的Buck变换器开环控制PSIM仿真电路图"></p>
<p>得到的输出电压仿真结果如下图所示：</p>
<p><img src="/images/control/media/image48.png" alt="图3.13：引入寄生电阻后的Buck变换器开环控制PSIM仿真结果------输出电压"></p>
<p><img src="/images/control/media/image53.png" alt="图3.14：引入寄生电阻后的Buck变换器开环控制PSIM仿真结果------输出电压纹波"></p>
<p>可以看到，仿真结果中输出电压的均值约为7.65V，与实际的测量结果<br>$$<br>V_{o} = 7.537V<br>$$<br>较为接近；同时输出电压信号的震荡波形也与实际电路示波器显示的纹波形状一致且震荡幅度大致相同。这也印证了寄生电阻的计算以及电路建模与仿真的正确性。</p>
<h3 id="3-5-本章小结"><a href="#3-5-本章小结" class="headerlink" title="3.5 本章小结"></a>3.5 本章小结</h3><p>本章主要介绍了直流Buck控制器及其闭环控制系统的建模过程，通过分析Buck电路中的元件特性及闭环控制的各个环节，实现控制系统的数学建模，得到系统的开环传递函数与特征方程；同时结合Buck控制器开环控制实验的实际测量结果，关注到电容寄生电阻对于系统输出的重要影响，并通过输出电压纹波的相关特性对其进行计算，搭建PSIM电路仿真模型观察修正前后的仿真结果，发现引入寄生电阻后的仿真结果与实际实验波形输出基本一致从而说明考虑寄生电阻的必要性。除此之外，还分别搭建了Buck变换器的开环与闭环控制系统PSIM仿真电路并对比输出电压仿真结果，可以发现闭环控制系统具有更好的动态响应性能，其稳定性、快速性与准确性均优于开环控制系统。</p>
<h2 id="4-直流Buck变换器控制性能分析"><a href="#4-直流Buck变换器控制性能分析" class="headerlink" title="4 直流Buck变换器控制性能分析"></a>4 直流Buck变换器控制性能分析</h2><h3 id="4-1-直流Buck变换器劳斯稳定判据分析"><a href="#4-1-直流Buck变换器劳斯稳定判据分析" class="headerlink" title="4.1 直流Buck变换器劳斯稳定判据分析"></a>4.1 直流Buck变换器劳斯稳定判据分析</h3><p>基于3.1节得到的开环传递函数与系统特征方程，可利用劳斯判据给出系统稳定的PI控制器比例系数K_p临界条件：</p>
<p>根据系统特征方程可给出如下劳斯表：</p>
<p><img src="/images/control/media/01.png" alt="劳斯表"></p>
<p>根据劳斯判据，要使得系统稳定，需同时满足如下条件：</p>
<p>$$<br>\left{ \begin{array}{r}<br>\ \tau V_{M}LC &gt; 0 \<br>\tau V_{M}\frac{L}{R} &gt; 0 \<br>\left( V_{in}K_{p} + V_{M} \right)\tau - V_{in}K_{p}RC &gt; 0 \<br>{\ \ V}<em>{in}K</em>{p} &gt; 0<br>\end{array} \right.\<br>$$<br>这是关于PI控制器比例系数K_p的不等式组，可解得其边界条件为：</p>
<p>$$<br>0 &lt; K_{p} &lt; \frac{V_{M}\tau}{V_{in}(RC - \tau)}<br>$$<br>若选定控制环路的时间常数<br>$$<br>\tau = 0.004$<br>$$<br>三角载波幅值<br>$$<br>V_{M} = 0.5V<br>$$<br>则可代入数值解得：比例系数K_p的稳定边界为<br>$$<br>\frac{V_{M}\tau}{V_{in}(RC - \tau)} \approx 0.0513<br>$$<br>而在实际情况下，需要考虑电容的寄生电阻<br>$$<br>ESR \approx 107.185m\Omega<br>$$<br>这意味着需要对3.1节建立的数学模型进行修正。显然电路结构中除二阶滤波器外的其他环节没有发生改变，针对考虑电容寄生电阻ESR的RLC并联二阶输出滤波器，由电路图与元件特性可得各元件间电流电压关系：</p>
<p>$$<br>\left{ \begin{array}{r}<br>u_{0} = Ri_{2} \<br>u_{L} = L\frac{di}{dt} \<br>i_{1} = C\frac{du_{C}}{dt} \<br>i = i_{1} + i_{2} \<br>u_{0} = u_{C} + ESRi_{1} \<br>u_{D} = u_{L} + u_{0}<br>\end{array} \right.\<br>$$<br>从而可得该滤波器对应的微分方程，对两边同时进行拉普拉斯变换，化简整理后可得二阶滤波器的传递函数G_vd(s)：</p>
<p>$$<br>G_{vd}(s) = \frac{U_{0}(s)}{U_{D}(s)}V_{in} = \frac{\frac{1}{LC} + \frac{ESR}{L}s}{(1 + \frac{ESR}{R})s^{2} + (\frac{1}{RC} + \frac{ESR}{L})s + \frac{1}{LC}}V_{in}<br>$$<br>其他环节保持不变，于是有开环传递函数：<br>$$<br>T(s) = G_{c}(s)G_{pwm}G_{\text{vd}}H(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{\frac{1}{LC} + \frac{ESR}{L}s}{\left( 1 + \frac{ESR}{R} \right)s^{2} + \left( \frac{1}{RC} + \frac{ESR}{L} \right)s + \frac{1}{LC}}V_{in} \approx \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{1 + C \bullet ESRs}{LCs^{2} + \frac{L}{R}s + 1}V_{in}<br>$$<br>因此近似后系统的特征方程<br>$$<br>T(s) + 1 = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{(1 + C \bullet ESRs)V_{in}}{LCs^{2} + \frac{L}{R}s + 1} + 1 = 0<br>$$<br>化简后可得：</p>
<p>$$<br>\Delta(s) = {(1 + C \bullet ESRs)V}<em>{in}K</em>{p}(\tau s + 1) + \tau sV_{M}\left( LCs^{2} + \frac{L}{R}s + 1 \right) = V_{M}LC\tau s^{3} + (V_{M}\frac{L}{R} + C \bullet ESR \bullet V_{in}K_{p})\tau s^{2} + (V_{in}K_{p}\tau + V_{M}\tau + C \bullet ESR \bullet V_{in}K_{p})s + V_{in}K_{p} = 0<br>$$<br>接下来利用劳斯判据给出系统稳定的PI控制器比例系数K_p临界条件：</p>
<p>根据系统特征方程可给出如下劳斯表：</p>
<p><img src="/images/control/media/03.png" alt="劳斯表"></p>
<p>根据劳斯判据，要使得系统稳定，需同时满足如下条件：</p>
<p>$$<br>\left{ \begin{array}{r}<br>\ \tau V_{M}LC &gt; 0 \<br>\tau V_{M}\frac{L}{R} &gt; 0 \<br>V_{in}K_{p}\tau + V_{M}\tau + C \bullet ESR \bullet V_{in}K_{p} - \frac{V_{M}LCV_{in}K_{p}}{V_{M}\frac{L}{R} + C \bullet ESR \bullet V_{in}K_{p}} &gt; 0 \<br>{\ \ V}<em>{in}K</em>{p} &gt; 0<br>\end{array} \right.\<br>$$<br>这是关于PI控制器比例系数K_p的不等式组，其中第1、2、4个不等式均指向K_p &gt; 0，而第三个不等式是一个关于K_p的一元二次不等式，代入电路元件参数可解得<br>$$<br>K_{p} &lt; - 0.0232或K_{p} &gt; - 0.0067<br>$$<br>因此可得到K_p的稳定边界为：<br>$$<br>K_{p} &gt; 0<br>$$<br>即该情况下系统始终稳定。</p>
<h3 id="4-2-直流Buck变换器系统根轨迹分析（手绘-MWorks绘制）"><a href="#4-2-直流Buck变换器系统根轨迹分析（手绘-MWorks绘制）" class="headerlink" title="4.2 直流Buck变换器系统根轨迹分析（手绘+MWorks绘制）"></a>4.2 直流Buck变换器系统根轨迹分析（手绘+MWorks绘制）</h3><p>基于3.1节得到的开环传递函数，代入数值可得：</p>
<p>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1} = \frac{30K_{p}(s + 250)}{s(6.6*10^{- 8}s^{2} + 10^{- 5}s + 1)}<br>$$<br>根据该开环传递函数可知，该系统：</p>
<p>具有1个零点：<br>$$<br>z_{1} = 250<br>$$<br>具有3个极点：<br>$$<br>p_{0} = 0，p_{1} + p_{2} = \frac{5}{33}*10^{3} \approx 151.5，p_{1} = \frac{5}{66}*10^{3} + a_i，p_{1} + p_{2} = \frac{5}{66}*10^{3} - a_i<br>$$<br>故有3条根轨迹，1条止于开环零点，2条止于无穷远；</p>
<p>根轨迹的渐近线与实轴的夹角<br>$$<br>\varphi_{a} = \pm \frac{2k + 1}{2}\pi(k = 0,1,2\ldots) = \pm 90{^\circ}、180{^\circ}<br>$$<br>渐近线与实轴交点的坐标值<br>$$</p>
<ul>
<li>\delta_{a} = \frac{\sum_{}^{}\left( - p_{i} \right) - \sum_{}^{}\left( - z_{i} \right)}{2} = \frac{- \frac{5}{33}*10^{3} + 250}{2} \approx 49.24<br>$$</li>
</ul>
<p>基于以上结果，可手绘根轨迹草图如下：</p>
<p><img src="/images/control/media/image58.png" alt="图4.1：不考虑寄生电阻------手绘根轨迹草图"></p>
<p>编写如下MWorks代码：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">G=(s+<span class="number">250</span>)/(s*(<span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">8</span>)*s*s+<span class="number">10</span>^(-<span class="number">5</span>)*s+<span class="number">1</span>));</span><br><span class="line">rlocus(G);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码，得到MWorks绘制的根轨迹图如下：</p>
<p><img src="/images/control/media/image59.png" alt="图4.2：不考虑寄生电阻------MWorks绘制根轨迹图"></p>
<p>根轨迹本质上反映的随着比例系数K_p的变化，特征方程根的变化情况；当两个共轭根恰好位于虚轴上时，此时对应的比例系数K_p（可将此时特征根带回特征方程求出）即为其稳定的边界值（大于该值不稳定，小于该值稳定）。</p>
<p>编写如下MWorks程序，寻找根轨迹与虚轴的交点并带回特征方程，求出比例系数K_p稳定边界值：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">% 找寻与虚轴交点</span><br><span class="line">k = linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>); % 增加点数，<span class="number">1000</span>个点</span><br><span class="line">[r, k]=rlocus(G,k);</span><br><span class="line">real_part = real(r);</span><br><span class="line">imag_part = imag(r);</span><br><span class="line">% 查找实部接近零的索引</span><br><span class="line">tolerance = <span class="number">1e-1</span>; % 设定阈值</span><br><span class="line">idx = find(abs(real_part) &lt; tolerance); % 找到所有交点的索引</span><br><span class="line">intersections = r(idx); % 交点的复数值</span><br><span class="line">% 求解临界kp</span><br><span class="line">s = intersections(<span class="number">2</span>);</span><br><span class="line">% 系统参数</span><br><span class="line">tao = <span class="number">0.004</span>;</span><br><span class="line">vm = <span class="number">0.5</span>;</span><br><span class="line">l = <span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">c = <span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">vin = <span class="number">15</span>;</span><br><span class="line">r = <span class="number">10</span>;</span><br><span class="line">syms kp; % 定义符号变量</span><br><span class="line">eq = tao*vm*l*c*s*s*s + tao*vm*l*s*s/r + vin*kp*tao*s + vm*tao*s + vin*kp == <span class="number">0</span>;</span><br><span class="line">solutions = solve(eq, kp); % 求解</span><br><span class="line">real_solutions = real(solutions); % 取实部</span><br><span class="line">decimal_solutions = double(real_solutions); % 转换为小数</span><br><span class="line">disp(decimal_solutions); % 显示结果</span><br></pre></td></tr></tbody></table></figure>

<p>运行上述MWorks代码，得到的比例系数K_p稳定边界值结果为：0.0514，这与先前依据劳斯判据得到的结果<br>$$<br>\frac{V_{M}\tau}{V_{in}(RC - \tau)} \approx 0.0513<br>$$<br>大致一致。</p>
<p>而在实际情况下，需要考虑电容的寄生电阻；基于4.1节修正后的开环传递函数，代入数值可得：</p>
<p>$$<br>T(s) \approx \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{1 + C \bullet ESRs}{LCs^{2} + \frac{L}{R}s + 1}V_{in} \approx \frac{30K_{p}(s + 250)(1 + 7.07<em>10^{- 5}s)}{s(6.6</em>10^{- 8}s^{2} + 10^{- 5}s + 1)}<br>$$<br>根据该开环传递函数可知，该系统：</p>
<p>具有2个零点：<br>$$<br>z_{1} = 250，z_{2} \approx 1.41*10^{5}<br>$$<br>具有3个极点：<br>$$<br>p_{0} = 0，p_{1} + p_{2} = \frac{5}{33}*10^{3} \approx 151.5，p_{1} = \frac{5}{66}*10^{3} + bi，p_{1} + p_{2} = \frac{5}{66}*10^{3} - bi<br>$$<br>故有3条根轨迹，2条止于开环零点，2条止于无穷远；</p>
<p>根轨迹的渐近线与实轴的夹角<br>$$<br>\varphi_{a} = \pm (2k + 1)\pi(k = 0,1,2\ldots) = 180{^\circ}<br>$$<br>基于以上结果，可手绘根轨迹草图如下：</p>
<p><img src="/images/control/media/image60.png" alt="图4.3：考虑寄生电阻------手绘根轨迹草图"></p>
<p>编写MWorks代码如下：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">c = <span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">esr = <span class="number">0.107185</span>;</span><br><span class="line">G=(s+<span class="number">250</span>)*(<span class="number">1</span>+c*esr*s)/(s*(<span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">8</span>)*s*s+<span class="number">10</span>^(-<span class="number">5</span>)*s+<span class="number">1</span>));</span><br><span class="line">rlocus(G);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码，得到MWorks绘制的根轨迹图如下：</p>
<p><img src="/images/control/media/image61.png" alt="图4.4：考虑寄生电阻------MWorks绘制根轨迹图"></p>
<p>可以看到，在考虑电容寄生电阻的情况下，根轨迹完全位于虚轴左侧，这意味着无论比例系数K_p（&gt;0）如何变化，系统特征方程的根均位于虚轴左侧，即此情况下系统始终稳定，这与先前依据劳斯判据得到的结果也是一致的。这样的结果也充分说明，寄生电阻的加入使得系统的稳定性提高。</p>
<h3 id="4-3-直流Buck变换器奈奎斯特稳定判据分析"><a href="#4-3-直流Buck变换器奈奎斯特稳定判据分析" class="headerlink" title="4.3 直流Buck变换器奈奎斯特稳定判据分析"></a>4.3 直流Buck变换器奈奎斯特稳定判据分析</h3><p>在不考虑寄生电阻的情况下，基于3.1节得到的开环传递函数，取负载电阻R = 2欧姆，代入PI控制器参数：<br>$$<br>K_{p} = 0.05、\tau = 1\text{/}5000<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 3V<br>$$<br>可得：</p>
<p>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1} = \frac{0.05 \times \left( \frac{1}{5000}s + 1 \right)}{\frac{1}{5000}s} \cdot \frac{1}{3} \cdot \frac{15 \times 10^{8}}{6.6s^{2} + 5000s + 10^{8}} = \frac{2.5 \times 10^{7}(s + 5000)}{s(6.6s^{2} + 5000s + 10^{8})}<br>$$<br>根据该开环传递函数，编写MWorks代码如下：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">H = tf([<span class="number">2.5</span>*<span class="number">10</span>^<span class="number">7</span> <span class="number">2.5</span>*<span class="number">10</span>^<span class="number">7</span>*<span class="number">5000</span>],[<span class="number">6.6</span> <span class="number">5000</span> <span class="number">10</span>^<span class="number">8</span> <span class="number">0</span>]);</span><br><span class="line">nyquist(H);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码，得到MWorks绘制的奈氏图如下：</p>
<p><img src="/images/control/media/image62.png" alt="图4.5：不考虑寄生电阻------MWorks绘制奈氏图"><img src="/images/control/media/image63.png" alt="图4.5：不考虑寄生电阻------MWorks绘制奈氏图"></p>
<p>观察奈氏图图像可得：正穿越次数N+=1，负穿越次数N- =1</p>
<p>又由系统开环传递函数可知：系统开环右极点数P=0</p>
<p>故由奈奎斯特稳定判据可知：该闭环系统稳定。</p>
<p><img src="/images/control/media/image64.png" alt="图4.6：奈奎斯特稳定判据"></p>
<h3 id="4-4-直流Buck变换器系统波特图分析（MWorks绘制）"><a href="#4-4-直流Buck变换器系统波特图分析（MWorks绘制）" class="headerlink" title="4.4 直流Buck变换器系统波特图分析（MWorks绘制）"></a>4.4 直流Buck变换器系统波特图分析（MWorks绘制）</h3><p>与4.3节使用相同参数，即开环传递函数可写为：</p>
<p>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1} = \frac{2.5 \times 10^{7}(s + 5000)}{s(6.6s^{2} + 5000s + 10^{8})}<br>$$<br>根据该开环传递函数，编写如下MWorks代码绘制波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">G=<span class="number">2.5</span>*<span class="number">10</span>^<span class="number">7</span>*(s+<span class="number">5000</span>)/(s*(<span class="number">6.6</span>*s^<span class="number">2</span>+<span class="number">5000</span>*s+<span class="number">10</span>^<span class="number">8</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码，得到MWorks绘制的波特图如下：</p>
<p><img src="/images/control/media/image65.png" alt="图4.7：不考虑寄生电阻------MWorks绘制波特图"></p>
<p>从图中可读出：剪切频率<br>$$<br>\omega_{c}≈1.49*10^{3}rad/s<br>$$<br>相位裕度<br>$$<br>γ≈102{^\circ}<br>$$<br>根据对数频率特性稳定判据可知：当相位裕度γ与增益裕度Lg同时大于零时，闭环系统稳定；而对于最小相位系统，相位裕度γ&gt;0与增益裕度Lg&gt;0是同时发生或同时不发生的，因此只需通过相位裕度γ即可判定闭环系统稳定情况。显然此时相位裕度大于零，表明闭环系统稳定，且稳定性较好（相位裕度较大）。</p>
<h3 id="4-5-直流Buck变换器闭环负载稳定边界计算及仿真验证"><a href="#4-5-直流Buck变换器闭环负载稳定边界计算及仿真验证" class="headerlink" title="4.5 直流Buck变换器闭环负载稳定边界计算及仿真验证"></a>4.5 直流Buck变换器闭环负载稳定边界计算及仿真验证</h3><p>基于2.2节中的电路元件参数以及输入电压恒为15V的客观事实，在给定PI控制器参数:<br>$$<br>K_{p} = 0.1、\tau = 0.004<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 0.5V<br>$$<br>的情况下，若不考虑电容寄生电阻，根据4.1节劳斯判据化简后的结果：<br>$$<br>RCV_{g}K_{p} \leq (\tau V_{M} + V_{g}K_{p}\tau)<br>$$<br>可推得系统处于稳定状态的电阻值范围应为：<br>$$<br>R \leq \frac{\tau}{C}\left( \frac{V_{M}}{V_{g}K_{p}} + 1 \right) \approx 8.08\Omega<br>$$<br>即直流Buck变换器闭环系统的负载电阻稳定边界约为8.1Ω。</p>
<p>为进一步通过仿真验证计算结果，建立PSIM仿真电路图如下：</p>
<p><img src="/images/control/media/image66.png" alt="图4.8：直流Buck变换器闭环控制负载电阻稳定边界PSIM仿真验证电路图"></p>
<ol>
<li>取负载电阻值R = 5Ω（小于临界值）时：</li>
</ol>
<p><img src="/images/control/media/image67.png" alt="图4.9：负载电阻值R=5Ω时输出电压PSIM仿真结果"></p>
<p><img src="/images/control/media/image68.png" alt="图4.10：负载电阻值R=5Ω时输出电压纹波PSIM仿真结果"></p>
<ol start="2">
<li>取负载电阻值R = 8.1欧姆（约等于临界值）时：</li>
</ol>
<p><img src="/images/control/media/image69.png" alt="图4.11：负载电阻值R=8.1Ω时输出电压PSIM仿真结果"></p>
<p><img src="/images/control/media/image70.png" alt="图4.12：负载电阻值R=8.1Ω时输出电压纹波PSIM仿真结果">取负载电阻值R=10Ω（大于临界值）时：</p>
<p><img src="/images/control/media/image71.png" alt="图4.13：负载电阻值R=10Ω时输出电压PSIM仿真结果"></p>
<p><img src="/images/control/media/image72.png" alt="图4.14：负载电阻值R=10Ω时输出电压纹波PSIM仿真结果"></p>
<p>通过对比三组仿真结果可以发现：取不同的负载电阻值并不会影响系统的响应速度与响应瞬时超调量，而是影响输出电压趋于稳定后的纹波波形：</p>
<ol>
<li><p>当负载电阻值小于临界值时，稳定后的输出电压会有较大的震荡（负载越小，震荡幅度越大），但该震荡上没有纹波，系统处于稳定状态；</p>
</li>
<li><p>当负载电阻接近临界值（实际临界值略小于8.1Ω）时，稳定后输出电压的震荡幅度减小，但开始出现纹波，系统处于临界稳定状态；</p>
</li>
<li><p>当负载电阻大于临界值时，稳定后输出电压的震荡幅度进一步减小，但纹波幅度有所增大，系统处于不稳定状态。</p>
</li>
</ol>
<h3 id="4-6-考虑寄生参数直流Buck变换器波特图分析（MWorks绘制）"><a href="#4-6-考虑寄生参数直流Buck变换器波特图分析（MWorks绘制）" class="headerlink" title="4.6 考虑寄生参数直流Buck变换器波特图分析（MWorks绘制）"></a>4.6 考虑寄生参数直流Buck变换器波特图分析（MWorks绘制）</h3><p>在实际情况下，为实现对直流Buck变换器闭环控制系统更加精准的建模，需要考虑电容的寄生电阻，基于4.1节修正后的开环传递函数（取未近似结果）：</p>
<p>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{\frac{1}{LC} + \frac{ESR}{L}s}{\left( 1 + \frac{ESR}{R} \right)s^{2} + \left( \frac{1}{RC} + \frac{ESR}{L} \right)s + \frac{1}{LC}}V_{in}<br>$$<br>取PI控制器参数:<br>$$<br>K_{p} = 1、\tau = 0.01<br>$$<br>三角载波幅值<br>$$<br>V_{M} = 2V<br>$$<br>负载电阻<br>$$<br>R = 2\Omega<br>$$<br>代入电路各元件参数与3.4节测算得到的寄生电阻<br>$$<br>ESR \approx 107.185m\Omega<br>$$<br>编写如下MWorks程序绘制波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">vm=<span class="number">2</span>;</span><br><span class="line">r=<span class="number">2</span>;</span><br><span class="line">esr=<span class="number">0.107185</span>;</span><br><span class="line">c=<span class="number">6.6</span>\*<span class="number">10</span>\^(-<span class="number">4</span>);</span><br><span class="line">l=<span class="number">10</span>\^(-<span class="number">4</span>);</span><br><span class="line">vg=<span class="number">15</span>;</span><br><span class="line">kp=<span class="number">1</span>;</span><br><span class="line">tao=<span class="number">0.01</span>;</span><br><span class="line">G=kp\*(tao\*s+<span class="number">1</span>)\*(esr\*c\*s+<span class="number">1</span>)\*vg/(tao\*s\*vm\*(l\*c\*(<span class="number">1</span>+esr/r)\*s\*s+(l/r+esr\*c)\*s+<span class="number">1</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该段代码后绘制出的波特图如下：</p>
<p><img src="/images/control/media/image73.png" alt="图4.15：考虑寄生电阻------MWorks绘制波特图"></p>
<p>从图中可读出：剪切频率<br>$$<br>\omega_{c}≈1.29*10^{4}rad/s<br>$$<br>相位裕度<br>$$<br>γ≈50{^\circ}<br>$$<br>根据对数频率特性稳定判据可知，此时相位裕度γ&gt;0，表明闭环系统稳定。</p>
<h3 id="4-7-PSIM仿真扫频波特图"><a href="#4-7-PSIM仿真扫频波特图" class="headerlink" title="4.7 PSIM仿真扫频波特图"></a>4.7 PSIM仿真扫频波特图</h3><p>取与4.6节相同的参数，利用PSIM搭建扫频电路进行仿真得到波特图：</p>
<p><img src="/images/control/media/image74.png" alt="图4.16：考虑寄生电阻------PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image75.png" alt="图4.17：考虑寄生电阻------PSIM扫频仿真结果"></p>
<p>从图中可读出：剪切频率<br>$$<br>\omega_{c} \approx 1997Hz \approx 1.25*10^{4}rad/s<br>$$<br>相位裕度<br>$$<br>γ≈50{^\circ}<br>$$<br>扫频仿真结果与MWorks根据系统开环传递函数绘制的波特图基本一致。</p>
<p>若在仿真电路图中加入锁存器与零阶保持器：</p>
<p><img src="/images/control/media/image76.png" alt="图4.18：考虑寄生电阻------加入锁存器与零阶保持器后PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image77.png" alt="图4.19：考虑寄生电阻------加入锁存器与零阶保持器后PSIM扫频仿真结果"></p>
<p>图4.19：考虑寄生电阻——加入锁存器与零阶保持器后PSIM扫频仿真结果</p>
<p>从图中可读出：剪切频率<br>$$<br>\omega_{c}≈1997Hz<br>$$<br>相位裕度<br>$$<br>γ≈18{^\circ}<br>$$<br>可以发现，在仿真中加入锁存器与零阶保持器后，剪切频率基本未发生改变，图线也大致与MWorks通过传递函数得到的波特图相同，但相位裕度有所降低，系统仍然保持稳定。</p>
<h3 id="4-8-本章小结"><a href="#4-8-本章小结" class="headerlink" title="4.8 本章小结"></a>4.8 本章小结</h3><p>本章主要对于直流Buck变换器闭环控制系统的控制性能进行了详细的分析，特别是针对系统的稳定性问题，从系统的开环传递函数入手，对于考虑电容寄生电阻与否的两种不同情况，在时域上利用劳斯稳定判据与根轨迹法，讨论在负载电阻R与PI控制器时间常数τ给定的情况下，PI控制器比例系数K_p的稳定边界；在频域上依据奈奎斯特稳定判据（基于奈奎斯特图）与对数频率特性稳定判据（基于波特图，由MWorks绘制与PSIM扫频仿真得到，两者结果高度吻合），通过系统相位裕度γ判断闭环系统稳定性，同时在PI控制器参数给定的情况下讨论负载电阻R的稳定边界，并搭建PSIM仿真电路对不同负载电阻下闭环系统的稳定性进行验证，仿真结果与理论推导结论基本一致。</p>
<h2 id="5-直流Buck变换器闭环控制实验"><a href="#5-直流Buck变换器闭环控制实验" class="headerlink" title="5 直流Buck变换器闭环控制实验"></a>5 直流Buck变换器闭环控制实验</h2><h3 id="5-1-KEIL5软件环境安装及创建"><a href="#5-1-KEIL5软件环境安装及创建" class="headerlink" title="5.1 KEIL5软件环境安装及创建"></a>5.1 KEIL5软件环境安装及创建</h3><p>Keil 5是一款集成开发环境（IDE），它以其强大的功能和丰富的特性，在嵌入式系统开发领域占据了重要的地位。在本项目中，需要借助该IDE编写主控代码并烧录至STM32芯片中，使其能够在闭环控制系统中正常发挥控制作用。</p>
<p>下载助教在课程群内上传的安装程序压缩包并解压，文件夹内包含如下文件：</p>
<p><img src="/images/control/media/image78.png" alt="图5.1：Keil5 MDK安装程序压缩包解压结果"></p>
<p>双击安装程序”MDK524a.EXE”，一路点击”NEXT&gt;&gt;“（注意勾选同意许可证条款与指定软件安装位置）即可完成Keil5软件安装；软件安装完成后会自动运行，关闭后需要重新以管理员身份运行Keil5（右键-&gt;以管理员身份运行），随后进入keygen_new2032文件夹，双击运行破解程序”keygen_new2032.exe”，输入Keil5软件内”File-&gt;Licence Management…”里的CID并选择ARM，点击”Generate”并将生成的序列号复制到Keil5软件内”File-&gt;Licence Management…”下方的LIC一栏，点击”ADD LIC”即可完成破解。</p>
<p><img src="/images/control/media/image79.png" alt="图5.2：Keil5 MDK软件破解流程"><img src="/images/control/media/image80.png" alt="图5.2：Keil5 MDK软件破解流程"></p>
<p><img src="/images/control/media/image81.png" alt="图5.2：Keil5 MDK软件破解流程"><img src="/images/control/media/image82.png" alt="图5.2：Keil5 MDK软件破解流程"></p>
<p>除此之外，针对本项目选用的STM32F103C8T6芯片，还需要安装相关芯片库：双击”支持包”文件夹中的”Keil.STM32F1xx_DFP.2.2.0.pack”文件并点击”NEXT&gt;&gt;“即可完成安装。</p>
<p>完成软件环境的安装后，需要进入Keil5软件，点击上侧菜单栏中”Project-&gt;New μVision Project”新建工程，随后会进入到芯片设备的选择环节，选择芯片”STM32F103C8”并点击”OK”，在弹出的Manage Run-Time Environment对话框中再次点击”OK”即可完成工程创建。</p>
<p><img src="/images/control/media/image83.png" alt="图5.3：Keil5中STM32工程创建流程"><img src="/images/control/media/image84.png" alt="图5.3：Keil5中STM32工程创建流程"><img src="/images/control/media/image85.png" alt="图5.3：Keil5中STM32工程创建流程"><img src="/images/control/media/image86.png" alt="图5.3：Keil5中STM32工程创建流程"></p>
<p>当然事实上这样建立的工程仍然无法正常使用，还需要引入一系列启动文件与库函数文件等，具体流程在此不详细赘述，可以参考博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74800695/article/details/132817145">如何在keil中建立一个STM32F10x完整工程</a>。至此Keil5的软件环境安装及工程创建过程已经全部完成，再额外导入一些系统辅助函数文件（如”Delay.c”等），即可在”main.c”文件中进行闭环控制程序的编写了。</p>
<h3 id="5-2-ADC采样及PWM生成原理"><a href="#5-2-ADC采样及PWM生成原理" class="headerlink" title="5.2 ADC采样及PWM生成原理"></a>5.2 ADC采样及PWM生成原理</h3><p>ADC（Analog-to-Digital Converter），即模拟到数字转换器，主要用于将连续传输的模拟信号转换为数字信号，便于数字系统（如中央处理器CPU、微控制器MCU等）对传输信息进行快速处理和分析。</p>
<p><img src="/images/control/media/image87.png" alt="图5.4：STM32F103C8T6芯片参考手册中ADC相关模块"></p>
<p>采样是指ADC在一定时间间隔内对连续变化的模拟信号进行取样，得到一系列离散的样本点，实现在有限采样率条件下，无失真还原信号波形信息。采样率决定了每秒采集的样本量，通常单位为Hz；其必须满足奈奎斯特采样定理（大于信号最高频率的两倍），否则会产生混叠。</p>
<p>由于数字信号本身不具有实际意义，仅仅表示一个相对大小，故任何一个模数转换器都需要一个参考模拟量作为转换的标准，比较常见的参考标准为最大的可转换信号大小，而输出的数字量则表示输入信号相对于参考信号的大小。在STM32单片机中，ADC为12位，即单片机读取的ADC值应在0~4095范围内，这样的ADC值与0~3.3V的输入电压值之间存在线性对应关系（若输入电压范围超出0~3.3V，则需要在输入ADC引脚前加入电阻分压和放大器等外围电路，在2.3.4小节中有详细介绍该部分采样电路）。</p>
<p>PWM（Pulse Width Modulation），即脉冲宽度调制，是一种通过调节脉冲信号的宽度（即占空比，高电平持续时间占整个周期的比例）来控制输出信号平均值的方法。在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量。简单而言，PWM可以视为一种DA（数字-&gt;模拟）转换，通过产生PWM波形这一数字信号等效地实现了模拟信号的输出。</p>
<p><img src="/images/control/media/image88.jpeg" alt="图5.5：PWM信号示意图"></p>
<p>PWM实现的原理是：通过锯齿波/三角波(载波)所需要合成的波形（调制波）进行比较，然后确定PWM所需要输出的极性，锯齿波从比较器的反相端端输入，当大于参考电压时输出与锯齿波相反的极性，而当锯齿波从比较器同相端输入，当大于参考电压时输出与锯齿波相同极性。</p>
<p><img src="/images/control/media/image89.png" alt="图5.6：PWM实现流程：黄色线------计算器溢出频率（ARR），即PWM更新频率；红色线------捕获比较寄存器（CRR）的值；蓝色线------计数器（CNT）的值"></p>
<p>在Keil工程中，基于以上PWM生成原理编写函数文件”PWM.c”，其中包含了生成PWM波形所需的全部函数。实际运行时，PWM波形是通过定时器的计数和输出比较模块的配合生成的，其具体过程如下：</p>
<p>（1）计数器计数：TIM2定时器按照内部时钟驱动，从0计数到ARR（2999），然后重新清零，重复循环。</p>
<p>（2）比较与输出：定时器每次计数到CCR（1500）时，切换PWM输出的电平状态：从计数开始到计数器值为CCR时，输出高电平；从计数器值为CCR到ARR，输出低电平。</p>
<p>（3）占空比：由CCR与ARR的比值决定。程序中初始设定CCR=1500，ARR=2999，故可计算得出占空比为<br>$$<br>\frac{CCR}{ARR + 1} = 50%<br>$$<br>同时在主程序的控制过程中还可通过函数PWM_SetCompare1动态设置CCR值，从而实时改变占空比，进而影响输出的等效电压值。</p>
<h3 id="5-3-基本PI控制理论及程序"><a href="#5-3-基本PI控制理论及程序" class="headerlink" title="5.3 基本PI控制理论及程序"></a>5.3 基本PI控制理论及程序</h3><p>PI控制器是比例-积分控制器的一种，其核心是通过调节控制变量（输出电压），使系统输出接近目标值，是在控制工程中技术成熟、理论完善、应用最为广泛的一种控制策略。</p>
<p>对于PI控制器而言，其控制量的计算公式为：<br>$$<br>u(t) = K_{P} \cdot \mathbb{e}(t) + K_{I}\int\mathbb{e}(t)\mathbb{d}t<br>$$<br>其中：</p>
<p>（1）e(t)：当前时刻系统输出电压与参考电压之间的误差值；</p>
<p>（2）K_P：比例增益系数，用于快速响应；</p>
<p>（3）K_I：积分增益系数，用于消除稳态误差；</p>
<p>（4）u(t)：待控制变量——系统输出电压。</p>
<p>写成微分方程形式则为：<br>$$<br>\left{ \begin{aligned}<br> &amp; \dot{x} = K_{I}v \<br> &amp; y = K_{p}v + x<br>\end{aligned} \right.<br>$$<br>根据传递函数定义，其传递函数可表示为：</p>
<p>$$<br>G_{c}(s) = K_{p} + K_{I}\frac{1}{s} = \frac{K_{p}(\tau s + 1)}{\tau s}<br>$$<br>其中积分时间常数<br>$$<br>\tau = \frac{K_{p}}{K_{I}}<br>$$<br>PI控制器具有以下特点：</p>
<ol>
<li><p>从时域上看，只要存在偏差，积分就会不停对偏差积累，因此稳态时误差一定为零；</p>
</li>
<li><p>比例与积分动作都是对过去控制误差进行操作，不对未来控制误差进行预测，限制了控制性能；</p>
</li>
<li><p>PI调节将比例调节的快速反应与积分调节消除静差的特点结合，主要用于改善控制系统的稳态性能。</p>
</li>
</ol>
<p><img src="/images/control/media/image90.png" alt="图5.7：具有PI控制器的控制系统控制框图"></p>
<p>在Keil工程中的主函数文件”main.c”中，其main函数在进行了PWM、ADC与串口等必要的初始化后，在while循环中反复运行update_voltage_reference与control_buck两个函数，其中前者主要是进行参考电压的动态更新，而后者中则包含了PI控制的主要逻辑，部分核心代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error = voltage_ref \* <span class="number">2500</span> \* <span class="number">1000</span> / <span class="number">1050</span> / <span class="number">20000</span> - voltage_fb;</span><br><span class="line">integral += error;</span><br><span class="line">control_signal = KP \* error + KI \* integral;</span><br><span class="line">last_error = error;</span><br></pre></td></tr></tbody></table></figure>

<p>该段代码主要按照如下流程实现PI控制：</p>
<ol>
<li>误差计算：error<br>$$<br>e(t) = V_{ref} - V_{fb}<br>$$</li>
</ol>
<blockquote>
<p>其中V_ref（voltage_ref）为函数update_voltage_reference中设定的目标电压，而V_fb（voltage_fb）为系统输出并反馈至控制器的实际电压。</p>
</blockquote>
<ol start="2">
<li><p>积分计算：<br>$$<br>integral = \int\mathbb{e}(t)\mathbb{d}t<br>$$<br>为累加误差，用于消除系统的稳态误差（输出电压voltage_fb与参考电压voltage_ref的差值error）。</p>
</li>
<li><p>PI控制量：control_signal<br>$$<br>u(t) = K_{P} \cdot \mathbb{e}(t) + K_{I}\int\mathbb{e}(t)\mathbb{d}t<br>$$<br>为最终控制信号，用于调节PWM占空比。</p>
</li>
</ol>
<p>除此之外，为防止占空比超出合理范围，还对控制信号control_signal进行约束：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (control_signal \&gt; <span class="number">0.8</span>)</span><br><span class="line">	control_signal = <span class="number">0.8</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (control_signal \&lt; <span class="number">0.2</span>)</span><br><span class="line">	control_signal = <span class="number">0.2</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>除了PI控制的核心逻辑外，在主控函数control_buck中还实现了其他功能：</p>
<ol>
<li>模拟信号采集得到系统输出并反馈至控制器的实际电压V_fb（voltage_fb）：</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">voltage_fb = (<span class="type">float</span>)AD_GetValue()\*<span class="number">3.3</span>/<span class="number">4096</span>;</span><br><span class="line">trueVoltage = voltage_fb \* <span class="number">1050</span> \* <span class="number">20000</span> / <span class="number">2500</span> / <span class="number">1000</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>根据PI控制结果，实时更新PWM占空比：</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duty_cycle = control_signal \* PWM_PERIOD;</span><br><span class="line">i = (<span class="type">int</span>)duty_cycle;</span><br><span class="line">PWM_SetCompare1(i);</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>通过串口发送调试信息，用于监控采样值和控制效果：</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serial_Printf(\<span class="string">"%d,%.2f\\r\\n\", sample_index, trueVoltage);</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-4-闭环PI稳压调控输出（8V、10V）"><a href="#5-4-闭环PI稳压调控输出（8V、10V）" class="headerlink" title="5.4 闭环PI稳压调控输出（8V、10V）"></a>5.4 闭环PI稳压调控输出（8V、10V）</h3><p>5.3节中对于主控函数control_buck进行了详细的解析，整个闭环PI调控过程都由此函数完成，在此不重复赘述；而对于函数update_voltage_reference而言，该函数实现了电压的切换：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_voltage_reference</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    time_counter += <span class="number">40</span>; <span class="comment">// 每次调用增加计时器值</span></span><br><span class="line">    <span class="keyword">if</span> (time_counter \&gt;= <span class="number">10000</span>) <span class="comment">// 达到10秒{</span></span><br><span class="line">        time_counter = <span class="number">0</span>; <span class="comment">// 重置计时器</span></span><br><span class="line">        <span class="keyword">if</span> (voltage_state == <span class="number">0</span>){</span><br><span class="line">            voltage_ref = <span class="number">10.0</span>; <span class="comment">// 切换到10V</span></span><br><span class="line">            voltage_state = <span class="number">1</span>; <span class="comment">// 更新状态</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            voltage_ref = <span class="number">8.0</span>; <span class="comment">// 切换到8V</span></span><br><span class="line">            voltage_state = <span class="number">0</span>; <span class="comment">// 更新状态</span></span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，该函数每隔10秒就对于目标电压voltage_ref进行一次切换，由10V切换为8V，再由8V切换回10V，循环往复。该函数主要用于模拟动态负载或参考值变化的情景，以测试控制器再目标电压变化时的响应性能。</p>
<p>事实上，在main函数中，在进行各项初始化（PWM、ADC、串口等）后，while循环中只有参考电压切换函数update_voltage_reference与PI主控函数control_buck反复作用，也正是这两个函数使得该直流Buck变换器闭环控制PI系统能够交替稳压输出8V或10V的电压。</p>
<h3 id="5-5-闭环参考电压8V-10V连续跳变实验与分析（仿真-实验）"><a href="#5-5-闭环参考电压8V-10V连续跳变实验与分析（仿真-实验）" class="headerlink" title="5.5 闭环参考电压8V-10V连续跳变实验与分析（仿真+实验）"></a>5.5 闭环参考电压8V-10V连续跳变实验与分析（仿真+实验）</h3><p>在直流Buck变换器闭环PI控制系统参考电压8V-10V连续跳变实验时，重点对于输出电压分别为8V与10V的两种情况下单片机的PWM输出波形进行测试，通过观察其占空比反映其输出电压情况：</p>
<ol>
<li><p>先使用仿真器给单片机供电，以调试PWM波形输出是否正常；</p>
</li>
<li><p>将上述闭环控制程序放入Keil工程中，成功编译后烧录至单片机内，将单片机（最小系统板）插入电路板上预留的引脚接口处并上电测试，使用示波器或者上位机观测电路板PA8端口输出PWM波形的占空比。</p>
</li>
</ol>
<p><img src="/images/control/media/image91.jpeg" alt="图5.8：参考电压设置为10V时的PWM波形"></p>
<p><img src="/images/control/media/image92.jpeg" alt="图5.9：参考电压设置为8V时的PWM波形"></p>
<p>可以看到，在参考电压设置为8V时，单片机输出的PWM占空比明显小于参考电压为10V时的结果。</p>
<p>为进一步观察参考电压连续跳变时的动态响应过程，进行了对应的PSIM电路仿真（仿真参数：kp=0.12，τ_i=1/5000，R=2Ω），其中跳变效果通过在直流参考电压后接入一个周期方波信号实现，跳变周期为0.1s：</p>
<p><img src="/images/control/media/image93.png" alt="图5.10：参考电压8V-10V连续跳变PSIM仿真电路图"></p>
<p><img src="/images/control/media/image94.png" alt="图5.11：参考电压8V-10V连续跳变PSIM仿真动态响应结果"></p>
<p>可以看到，跳变瞬间系统的动态响应较快（约为0.01s）且输出电压稳定后震荡幅度较小，说明该参数下系统具有较好的动态响应性能。</p>
<h3 id="5-6-本章小结"><a href="#5-6-本章小结" class="headerlink" title="5.6 本章小结"></a>5.6 本章小结</h3><p>本章主要介绍了对于直流Buck变换器PI闭环控制的整体实验流程，从STM32单片机编程环境的搭建，到根据PWM生成原理编写PWM的初始化函数及占空比实时调控函数，再到根据PI控制的基础理论编写对应的主控代码，在参考电压连续跳变（8V-10V）的情况下调控闭环PI的稳压输出，最后将代码烧录进行实际实验，测试单片机的PWM输出调控情况，并通过仿真观察参考电压连续跳变时的动态响应情况。通过该闭环控制实验，充分证明了PI闭环控制系统对于直流Buck变换器具有良好的控制效果。</p>
<h2 id="6-复合PI控制直流Buck变换器"><a href="#6-复合PI控制直流Buck变换器" class="headerlink" title="6 复合PI控制直流Buck变换器"></a>6 复合PI控制直流Buck变换器</h2><h3 id="6-1-PI-超前校正（复合PI）分析设计"><a href="#6-1-PI-超前校正（复合PI）分析设计" class="headerlink" title="6.1 PI+超前校正（复合PI）分析设计"></a>6.1 PI+超前校正（复合PI）分析设计</h3><p>为提高PI闭环控制系统暂态响应速度，可以在原有的控制系统中加入一些其参数可以根据需要而改变的控制器，即对于系统进行校正，从而使整个系统的频率特性发生变化。本项目中针对直流Buck变换器的PI闭环控制系统，采用PI+串联超前校正的复合PI控制器，以进一步提升系统性能指标。</p>
<p><img src="/images/control/media/image95.png" alt="图6.1：串联超前校正环节示意图"></p>
<p>串联超前校正的核心思想是，将补偿中心ω_ m设计为期望剪切频率ω_ c处，从而提升剪切频率(补偿中心)所对应相位，并利用补偿处增益放大(+20)来改善剪切频率处斜率。具体的设计流程如下：</p>
<ol>
<li><p>根据静态性能指标，确定开环增益K</p>
</li>
<li><p>为确定校正环节的设计方向，根据所确定的开环增益，画出系统固有部分G_s(s)的波特图，并计算其剪切频率ω_ c1与相位裕度γ_ 0；</p>
</li>
<li><p>根据要求的相位裕度γ，确定<br>$$<br>\varphi_{m} = \mathrm{\Delta}\varphi = \gamma - \gamma_{0} + \varepsilon，\varepsilon =5° - 25°<br>$$<br>若<br>$$<br>\varphi_{m} &lt; 60{^\circ}<br>$$<br>说明可采用串联超前校正，即<br>$$<br>\varepsilon \approx \varphi（\omega_{c1}）-<br>\varphi（\omega_{c2}），\omega_{c1}为原穿越频率，\omega_{c2}为校正后穿越频率<br>$$</p>
</li>
<li><p>由φ_m确定α：<br>$$<br>$\alpha = \frac{1 + \sin\varphi_{m}}{1 - \sin\varphi_{m}} &gt; 1<br>$$</p>
</li>
<li><p>令校正后剪切频率<br>$$<br>\omega_{c2} = \omega_{m} = \frac{1}{T\sqrt{\alpha}}<br>$$</p>
</li>
<li><p>画出校正后系统的波特图，并验算相位裕度是否满足要求：若满足要求，则需要在原有PI控制器前增加环节<br>$$<br>G_{c}(s) = \frac{\alpha Ts + 1}{Ts + 1}<br>$$<br>若不满足要求，需增大ε的值，从第（3）步重新开始计算。</p>
</li>
</ol>
<p><img src="/images/control/media/image96.png" alt="图6.2：超前校正环节一般设计流程"></p>
<p>对于比例积分PI控制器，一般采用如下的超前校正方式：</p>
<p><img src="/images/control/media/image97.png" alt="图6.3：PI控制器超前校正电路原理图"></p>
<p>图6.3：PI控制器超前校正电路原理图</p>
<p>针对直流Buck变换器的PI闭环控制系统，给定PI控制器参数:<br>$$<br>K_{p} = 0.8、\tau = 1/5000<br>$$<br>负载电阻<br>$$<br>R = 2\Omega<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 1V<br>$$<br>根据3.1节给出的系统开环传递函数（不考虑电容寄生电阻）：<br>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1}<br>$$<br>在MWorks中编写如下代码绘制校正前的波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">vm=<span class="number">1</span>;</span><br><span class="line">r=<span class="number">2</span>;</span><br><span class="line">c=<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">l=<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">vg=<span class="number">20</span>;</span><br><span class="line">kp=<span class="number">0.8</span>;</span><br><span class="line">tao=<span class="number">1</span>/<span class="number">5000</span>;</span><br><span class="line">G=kp*(tao*s+<span class="number">1</span>)*vg/(tao*s*vm*(l*c*s*s+(l/r)*s+<span class="number">1</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p>绘制出校正前的波特图：</p>
<p><img src="/images/control/media/image98.png" alt="图6.4：校正前MWorks绘制波特图"></p>
<p>从图中可读出：校正前系统的剪切频率<br>$$<br>\omega_{c1}≈4.20*10^{4}rad/s<br>$$<br>相位裕度<br>$$<br>\gamma_{0}≈0{^\circ}<br>$$<br>此时系统处于临界稳定状态。</p>
<p>为使得校正后的相位裕度<br>$$<br>\gamma &gt; 30{^\circ}<br>$$<br>可确定需增加的相位裕度<br>$$<br>\varphi_{m} = \mathrm{\Delta}\varphi = \gamma - \gamma_{0} + \varepsilon = 30{^\circ} - 0{^\circ} + 15.5{^\circ} = 45.5{^\circ} &lt; 60{^\circ}<br>$$<br>满足超前校正要求，进而可以确定</p>
<p>$$<br>\alpha = \frac{1 + \sin\varphi_{m}}{1 - \sin\varphi_{m}} \approx 6<br>$$<br>又因为系统周期<br>$$<br>T = \frac{1}{70000}s<br>$$<br>从而可以确定增加的超前校正环节的开环传递函数为：</p>
<p>$$<br>H(s) = \frac{\frac{6}{70000}s + 1}{\frac{1}{70000}s + 1}<br>$$<br>这意味着校正后整个闭环控制系统的传递函数变为<br>$$<br>T^{‘}(s) = T(s)H(s)<br>$$<br>可在上述MWorks代码的基础上增加下列代码以实现对于校正后闭环控制系统波特图的绘制：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">H=(<span class="number">6</span>*s/<span class="number">70000</span>+<span class="number">1</span>)/(s/<span class="number">70000</span>+<span class="number">1</span>);</span><br><span class="line">G1=G*H;</span><br><span class="line">bode(G1);</span><br></pre></td></tr></tbody></table></figure>

<p>绘制出校正后的波特图：</p>
<p><img src="/images/control/media/image99.png" alt="图6.5：校正后MWorks绘制波特图"></p>
<p>从图中可读出：校正后系统的剪切频率<br>$$<br>\omega_{c2}≈8.71*10^{4}rad/s<br>$$<br>相位裕度<br>$$<br>\gamma≈31{^\circ} &gt; 30{^\circ}<br>$$<br>相位裕度较校正前有明显提升且满足系统对品质指标的要求，校正正确。</p>
<h3 id="6-2-复合PI控制PSIM仿真（校正前后参考电压变化时输出电压分析）"><a href="#6-2-复合PI控制PSIM仿真（校正前后参考电压变化时输出电压分析）" class="headerlink" title="6.2 复合PI控制PSIM仿真（校正前后参考电压变化时输出电压分析）"></a>6.2 复合PI控制PSIM仿真（校正前后参考电压变化时输出电压分析）</h3><p>首先通过PSIM扫频仿真对先前波特图的MWorks绘制结果进行验证：</p>
<p><img src="/images/control/media/image100.png" alt="图6.6：超前校正控制PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image101.png" alt="图6.7：校正前PSIM扫频仿真结果"></p>
<p><img src="/images/control/media/image102.png" alt="图6.8：校正后PSIM扫频仿真结果"></p>
<p>从图中可读出：校正前系统的剪切频率<br>$$<br>\omega_{c1}≈6554Hz<br>$$<br>相位裕度<br>$$<br>\gamma_{0}≈0{^\circ}<br>$$<br>校正后系统的剪切频率<br>$$<br>\omega_{c2}≈14126Hz<br>$$<br>相位裕度<br>$$<br>\gamma≈35{^\circ}<br>$$<br>与MWorks绘制的波特图结果基本一致。</p>
<p>为反映超前校正的引入对于系统暂态响应速度的提升效果，搭建PSIM仿真电路，分析校正前后参考电压跳变瞬间的输出电压响应情况：</p>
<p><img src="/images/control/media/image103.png" alt="图6.9：超前校正控制参考跳变PSIM仿真电路图"></p>
<p><img src="/images/control/media/image104.jpeg" alt="图6.10：校正前系统暂态响应PSIM仿真结果"></p>
<p><img src="/images/control/media/image105.jpeg" alt="图6.11：校正后系统暂态响应PSIM仿真结果"></p>
<p>对比校正前后参考电压跳变瞬间的输出电压暂态响应PSIM仿真结果，可以发现：校正前系统暂态响应时间约为0.034s，而加入超前校正环节后系统暂态响应时间为0.0006s，较校正前有显著缩短，说明超前校正的引入有效提升了系统的动态响应特性（快速性）。</p>
<h3 id="6-3-PI-微分环节D（PID）分析设计"><a href="#6-3-PI-微分环节D（PID）分析设计" class="headerlink" title="6.3 PI+微分环节D（PID）分析设计"></a>6.3 PI+微分环节D（PID）分析设计</h3><p>除增加串联超前校正环节设计外，还可以通过在原有PI控制器基础上加入微分环节D实现PID闭环控制来提升系统的稳定性与暂态响应速度。事实上，在PID控制器的三个环节中，比例环节P主要负责动态性能的提升，积分环节I主要负责稳态精度的提升，而引入微分环节D则可进一步改善系统的稳定裕度以提升系统稳定性。</p>
<p><img src="/images/control/media/image106.png" alt="图6.12：PID控制器电路原理图"></p>
<p>与PI控制器类似，通过对PID控制器的微分方程组进行拉普拉斯变换，可以得到其传递函数为：<br>$$<br>G_{c}(s) = \frac{K_{p}(\tau_{i}s + 1)}{\tau_{i}s} + \tau_{d}s<br>$$<br>其中τ_ i为积分时间常数，而τ_ d为微分时间常数。</p>
<p>接下来将通过MWorks绘制波特图，配合PSIM的扫频仿真结果，从相位裕度的角度来反映微分环节D的引入对于系统稳定性的提升：</p>
<p>对于PI控制器，给定控制器参数:<br>$$<br>K_{p} = 0.12、\tau = 1/5000<br>$$<br>负载电阻<br>$$<br>R = 2\Omega<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 1V<br>$$<br>根据3.1节给出的系统开环传递函数（不考虑电容寄生电阻）：<br>$$<br>T(s) = \frac{K_{p}(\tau s + 1)}{\tau s}\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1}$<br>$$<br>在MWorks中编写如下代码绘制波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">vm=<span class="number">1</span>;</span><br><span class="line">r=<span class="number">2</span>;</span><br><span class="line">esr=<span class="number">0.107185</span>;</span><br><span class="line">c=<span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">l=<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">vg=<span class="number">15</span>;</span><br><span class="line">kp=<span class="number">0.12</span>;</span><br><span class="line">tao=<span class="number">1</span>/<span class="number">5000</span>;</span><br><span class="line">G=kp*(tao*s+<span class="number">1</span>)\*(esr*c*s+<span class="number">1</span>)*vg/(tao*s*vm*(l*c*(<span class="number">1</span>+esr/r)*s*s+(l/r+esr*c)*s+<span class="number">1</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/control/media/image107.png" alt="图6.13：PI控制器MWorks绘制波特图"></p>
<p>同时在PSIM中搭建扫频仿真电路，通过扫频仿真结果验证MWorks绘制波特图的正确性：</p>
<p><img src="/images/control/media/image108.png" alt="图6.14：PI控制器PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image109.png" alt="图6.15：PI控制器PSIM扫频仿真结果"></p>
<p>从图中可读出：PI闭环控制系统剪切频率<br>$$<br>\omega_{c}≈6.78*10^{3}rad/s \approx 1105Hz<br>$$<br>相位裕度<br>$$<br>\gamma$≈$10{^\circ}<br>$$<br>且MWorks绘制波特图与PSIM扫频仿真结果基本一致。</p>
<p>对于加入微分环节D后的PID控制器，给定控制器参数:<br>$$<br>K_{p} = 0.12、\tau_{i} = 1/5000、\tau_{d} = 0.00001<br>$$<br>负载电阻<br>$$<br>R = 2\Omega<br>$$<br>与三角载波幅值<br>$$<br>V_{M} = 1V<br>$$<br>根据3.1节给出的系统开环传递函数（不考虑电容寄生电阻）并将其中PI控制器的传递函数替换为PID控制器的传递函数，可得到PID闭环控制系统的开环传递函数：<br>$$<br>T(s) = (\frac{K_{p}(\tau_{i}s + 1)}{\tau_{i}s} + \tau_{d}s)\frac{1}{V_{M}}\frac{V_{in}}{LCs^{2} + \frac{L}{R}s + 1}<br>$$<br>在MWorks中编写如下代码绘制波特图：</p>
<figure class="highlight julia"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TyControlSystems</span><br><span class="line">s=tf(<span class="string">'s'</span>);</span><br><span class="line">vm=<span class="number">1</span>;</span><br><span class="line">r=<span class="number">2</span>;</span><br><span class="line">esr=<span class="number">0.107185</span>;</span><br><span class="line">c=<span class="number">6.6</span>*<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">l=<span class="number">10</span>^(-<span class="number">4</span>);</span><br><span class="line">vg=<span class="number">15</span>;</span><br><span class="line">kp=<span class="number">0.12</span>;</span><br><span class="line">tao=<span class="number">1</span>/<span class="number">5000</span>;</span><br><span class="line">taod=<span class="number">0.00001</span>;</span><br><span class="line">G=(kp*(tao*s+<span class="number">1</span>)+taod*tao*s*s)*(esr*c*s+<span class="number">1</span>)*vg/(tao*s*vm*(l*c*(<span class="number">1</span>+esr/r)*s*s+(l/r+esr*c)*s+<span class="number">1</span>));</span><br><span class="line">bode(G);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/control/media/image110.png" alt="图6.16：PID控制器MWorks绘制波特图"></p>
<p>同时在PSIM中搭建扫频仿真电路，通过扫频仿真结果验证MWorks绘制波特图的正确性：</p>
<p><img src="/images/control/media/image111.png" alt="图6.17：PID控制器PSIM扫频仿真电路图"></p>
<p><img src="/images/control/media/image112.png" alt="图6.18：PID控制器PSIM扫频仿真结果"></p>
<p>从图中可读出：PID闭环控制系统剪切频率<br>$$<br>\omega_{c}≈6.78*10^{3}rad/s \approx 1026Hz<br>$$<br>相位裕度<br>$$<br>\gamma≈36{^\circ}<br>$$<br>且MWorks绘制波特图与PSIM扫频仿真结果基本一致。</p>
<p>通过对比PI和PID控制下的波特图与扫频结果可以发现，相比于PI控制器，PID控制下的直流Buck变换器闭环系统具有更高的相位裕度，这意味着在加入微分环节D之后，系统具有更好的稳定性。</p>
<h3 id="6-4-PID控制PSIM仿真（校正前后R变化时输出电压分析）"><a href="#6-4-PID控制PSIM仿真（校正前后R变化时输出电压分析）" class="headerlink" title="6.4 PID控制PSIM仿真（校正前后R变化时输出电压分析）"></a>6.4 PID控制PSIM仿真（校正前后R变化时输出电压分析）</h3><p>为反映微分环节D的引入对于系统稳定性与响应速度的提升效果，搭建PSIM仿真电路，分析PI与PID控制器在负载电阻R不同时输出电压响应情况：</p>
<p><img src="/images/control/media/image113.png" alt="图6.19：PI控制器动态响应PSIM仿真电路图"></p>
<p><img src="/images/control/media/image114.png" alt="图6.20：PI控制器负载电阻R=2Ω时动态响应PSIM仿真结果"></p>
<p><img src="/images/control/media/image115.png" alt="图6.21：PI控制器负载电阻R=5Ω时动态响应PSIM仿真结果"></p>
<p><img src="/images/control/media/image116.png" alt="图6.22：PID控制器动态响应PSIM仿真电路图"></p>
<p><img src="/images/control/media/image117.png" alt="图6.23：PID控制器负载电阻R=2Ω时动态响应PSIM仿真结果"></p>
<p><img src="/images/control/media/image118.png" alt="图6.24：PID控制器负载电阻R=5Ω时动态响应PSIM仿真结果"></p>
<p>对比PI与PID控制器在负载电阻R不同时的输出电压暂态响应PSIM仿真结果，可以发现：当负载电阻R=2Ω时，在原有的PI控制器闭环控制下，系统的暂态响应时间约为0.008s，而加入微分环节D后，系统在PID控制器的闭环控制下暂态响应时间为0.004s，这意味着在加入微分环节D后，系统的动态响应特性得到一定提升（响应时间缩短50%）；除此之外，在相同的控制器作用下，随着负载电阻阻值由2Ω增大到5Ω，系统的输出电压在稳定后的振荡幅度明显减，但此时暂态响应时间也明显增加（增加近两倍）。</p>
<h3 id="6-5-本章小结"><a href="#6-5-本章小结" class="headerlink" title="6.5 本章小结"></a>6.5 本章小结</h3><p>本章主要介绍了基于PI控制器的校正设计，对于直流Buck变换器的闭环控制而言，分别采用在原有控制系统上增加超前校正环节与微分环节D的两种校正方式实现复合PI控制，通过MWorks绘制波特图与PSIM扫频仿真，反映校正环节的引入对于相位裕度即系统稳定性的提升效果，并结合PSIM电路仿真的输出电压结果，观察校正环节的引入对于系统暂态响应速度即动态响应特性的提升效果。仿真实验结果表明，对于PI控制器的校正设计（超前校正/引入微分环节形成PID控制）在提升系统稳定性与动态响应快速性方面取得了良好的效果。</p>
<h2 id="7-基于直流电源调控的自动调光控制设计"><a href="#7-基于直流电源调控的自动调光控制设计" class="headerlink" title="7 基于直流电源调控的自动调光控制设计"></a>7 基于直流电源调控的自动调光控制设计</h2><p>该系统的主要功能是将灯的电压通过直流Buck变换器完成闭环PID控制，将输出电压控制在0-15V范围内。系统主要包含电量控制与亮度控制两个部分，其中电量控制由STM32数字控制器通过电压控制信号调节Buck变换器输出电压；亮度控制则通过光敏传感器感知外界光强，并将反馈信号传递给STM32，实现对LED灯源亮度的动态调整，从而形成电压与亮度的双闭环调节系统。</p>
<p><img src="/images/control/media/image119.png" alt="图7.1：基于直流电源调控的自动调光系统整体架构"></p>
<p>基于该架构，系统设计的基本流程如下：</p>
<ol>
<li><p>搭建Buck电路控制系统，用于调控LED灯源；</p>
</li>
<li><p>使用开发工具Keil5编写STM32控制程序，实现PWM信号生成和调节；</p>
</li>
<li><p>将光敏传感器的输出连接到STM32的ADC（模数转换器）端口；</p>
</li>
<li><p>设计闭环控制系统并编写主控程序，实现根据光照强度自动调节PWM占空比，从而控制LED灯光的亮度；</p>
</li>
<li><p>调试系统，过程中实时监测电路工作状态，确保电路安全稳定运行且光照强度变化时LED灯亮度能够迅速进行响应调整；</p>
</li>
<li><p>对系统功能进行测试与优化，验证系统的响应速度和调光精度。</p>
</li>
</ol>
<p><img src="/images/control/media/image120.png" alt="图7.2：基于直流电源调控的自动调光系统设计流程"></p>
<p>除此之外，在系统基本功能的设计实现基础上，还进行了基于无线通信的远程控制这一拓展功能设计，将调光系统与蓝牙无线通信模块结合，实现通过手机应用对LED灯进行调光控制，增加系统的便携性和灵活性。</p>
<p>接下来将分模块具体阐述自动调光控制系统各功能设计的详细过程。</p>
<h3 id="7-1-默认电压值设置"><a href="#7-1-默认电压值设置" class="headerlink" title="7.1 默认电压值设置"></a>7.1 默认电压值设置</h3><p>在系统上电之后，输出电压默认设置为9V。之所以选择9V作为默认值，是因为这一电压能够在不消耗过多能量的情况下提供足够的亮度，同时避免由于过高或过低电压对系统性能的影响。</p>
<p>具体来说，9V的默认值具有以下几个优点：</p>
<p>（1）能耗平衡：相较于较低电压（5V），9V能够提供更高的亮度输出，同时不会像满电压（15V）那样带来显著的能量消耗，适合作为常规环境下的起始亮度。</p>
<p>（2）避免电压冲击：在系统刚启动时，设定较高的默认电压可能会导致电流冲击，影响电源和负载的寿命。9V作为中间值，有效降低了这种风险。</p>
<p>（3）用户体验优化：默认电压为9V时，灯光亮度适中，避免了开机过亮或过暗对用户造成的不适，同时为后续手动或自动调节提供了便利。</p>
<p>（4）环境适应性：在普通家庭或办公室环境下，9V的亮度通常能满足基本照明需求，而无需立即调整，增强了系统的即用性。</p>
<p>此外，9V的默认值通过主程序固化设置，确保每次系统启动时都能快速恢复到该默认电压值。这一设置不仅提高了系统的稳定性，还为后续用户操作提供了可靠的初始状态。设计中对默认电压的选择经过多次实验验证，综合考虑了实际照明需求和电源性能，最终确定了这一合理数值。</p>
<h3 id="7-2-蓝牙接口通信控制"><a href="#7-2-蓝牙接口通信控制" class="headerlink" title="7.2 蓝牙接口通信控制"></a>7.2 蓝牙接口通信控制</h3><p>在本系统中，蓝牙模块被用作与手机或其他移动设备的通信桥梁，用户可通过蓝牙实现对灯光的远程控制，增强系统的操作便利性和用户体验。蓝牙模块选用低功耗蓝牙（Bluetooth Low Energy, BLE）技术，保证了通信的可靠性和功耗优化。具体而言，蓝牙通信具有以下优点：</p>
<ul>
<li><p>便捷性：用户可通过手机远程调节灯光，无需物理接触，尤其适合家庭场景。</p>
</li>
<li><p>可扩展性：蓝牙接口支持更多功能指令的扩展，如灯光模式切换等。</p>
</li>
<li><p>低成本实现：蓝牙模块硬件成本低，结合STM32可轻松实现稳定通信。</p>
</li>
</ul>
<p>以下是蓝牙接口通信功能的详细设计：</p>
<ol>
<li>硬件接口设计</li>
</ol>
<ul>
<li><p>蓝牙模块选型：选用HC-05蓝牙模块，该模块具有支持串行通信（UART）功能，能与STM32单片机直接连接；模块通过UART接口与STM32的USART1通道连接，波特率设置为9600bps以平衡数据传输速率与稳定性。</p>
</li>
<li><p>引脚连接：蓝牙模块的TX和RX引脚分别连接STM32的RX和TX引脚，模块的VCC和GND引脚分别接单片机供电端和地线，保证模块稳定供电。</p>
</li>
</ul>
<ol start="2">
<li>软件功能设计</li>
</ol>
<p>蓝牙通信通过STM32主程序实现对蓝牙模块接收指令的解析和响应。指令的解析流程大致是这样的：主程序中设定一个蓝牙接收缓冲区，用于存储用户发送的指令；当蓝牙模块接收到数据时，触发中断，将数据写入缓冲区；程序定时轮询缓冲区，并根据指令类型解析执行以下指令以实现功能，包括灯的开关、亮度百分比调整，以及环境光自动调节的触发：</p>
<ul>
<li>“on”/“off”指令：通过电压直接跳转的方式实现即时开关</li>
</ul>
<blockquote>
<p>“on”：将输出电压设定为最大值15V，点亮灯光；</p>
<p>“off”：将输出电压设定为最小值0V，关闭灯光。</p>
</blockquote>
<ul>
<li><p>亮度调整指令：接收一个0-100的整数，表示灯光亮度为15V的百分比。程序计算目标电压时依据公式：<br>$$<br>V_{target} = \frac{百分比指令}{100} \times 15<br>$$<br>调用PWM控制函数调整Buck变换器的输出电压至目标值，实现实时亮度调节。</p>
</li>
<li><p>“LL”指令：触发光敏传感器，启动环境光度自动调节模式（详见7.3节）。</p>
</li>
</ul>
<ol start="3">
<li>通信协议设计</li>
</ol>
<p>蓝牙通信基于简单的ASCII协议，用户可通过手机APP或终端工具发送指令。每条指令均以换行符\n结尾，便于解析。以下是通信协议的具体格式：</p>
<ul>
<li><p>“on\n”：开启灯光。</p>
</li>
<li><p>“off\n”：关闭灯光。</p>
</li>
<li><p>“50\n”：将亮度设置为50%。</p>
</li>
<li><p>“LL\n”：启动环境光度自动调节模式。</p>
</li>
</ul>
<p>通过蓝牙接口通信，系统不仅支持手动调节灯光，还为后续的智能化功能扩展奠定了基础。</p>
<h3 id="7-3-基于光敏传感器的调光功能"><a href="#7-3-基于光敏传感器的调光功能" class="headerlink" title="7.3 基于光敏传感器的调光功能"></a>7.3 基于光敏传感器的调光功能</h3><p>本系统采用光敏传感器对环境光强进行实时检测，并基于检测值动态调整灯光的亮度，提供适应不同场景的自动调光功能。通过光敏传感器实现调光，既可以减少用户手动调整灯光的频率，还可以自动优化输出电压，适用多种场景需求。通过闭环控制机制，确保灯光的输出电压与环境光强度的变化相匹配，为用户提供更舒适、高效的照明体验。以下为光敏传感器调光功能的详细设计与实现过程：</p>
<ol>
<li>硬件接口设计</li>
</ol>
<ul>
<li><p>光敏传感器选型：选用光敏电阻模块，输出光强的模拟信号值。传感器将环境光强信号转换为电压信号，供STM32单片机的ADC模块读取。</p>
</li>
<li><p>传感器连接方式：光敏传感器的模拟输出端（AO口）连接到STM32单片机的PA5引脚，PA5被配置为ADC输入通道。供电引脚（VCC）连接单片机的3.3V供电，地线（GND）连接系统地，保证传感器的稳定工作。</p>
</li>
</ul>
<ol start="2">
<li>软件功能设计</li>
</ol>
<ul>
<li><p>数据采集与转换：STM32通过ADC模块以一定采样频率读取光敏传感器的模拟信号，模拟值范围为0到4095，对应电压范围为0到3.3V；可通过公式<br>$$<br>V_{target} = \frac{ADC值}{4095} \times 15<br>$$<br>将光强模拟值映射为输出电压目标值，该线性映射关系保证了灯光亮度的平滑过渡，避免突然变化对用户产生视觉不适。</p>
</li>
<li><p>调光逻辑与策略：当ADC值低于预设阈值（如1024）时，认为环境光较暗，此时系统逐步增加输出电压，以提高灯光亮度补偿环境光；当ADC值高于预设阈值（如3072）时，认为环境光较亮，此时系统逐步降低输出电压，以避免浪费电能或造成视觉不适；当光强处于中等范围时（ADC值1024到3072），输出电压以线性比例动态调节，保持环境与灯光亮度的适应性平衡。</p>
</li>
<li><p>PID闭环控制：根据光敏电阻值计算目标电压，并作为参考值输入PID控制器；PID控制器实时计算实际输出电压与目标电压之间的误差，并调整PWM信号占空比控制Buck变换器，确保输出电压快速稳定地收敛到目标值。</p>
</li>
<li><p>状态反馈与异常处理：当光敏传感器信号异常（如ADC值恒定不变或超出有效范围）时，系统进入保护模式，将输出电压设定为安全值9V，并通过蓝牙模块通知用户；传感器数据每次读取后均存储在缓冲区中，并定期更新，避免因单次采样噪声造成调光不稳定。</p>
</li>
</ul>
<p>为进一步验证调光功能的灵敏度，需要测试光敏传感器在不同光强条件下的响应时间和精度，确保其采集的光强信号与实际环境光强相符。经过调试，光敏电阻灵敏度较高，但光敏电阻的朝向会对空间中同一点的光敏传感有不同的值。解决方式为固定光敏电阻朝向位置，使其主要接收来自上方的环境光。除此之外，还需要验证在自动调光模式下，灯光亮度调整是否与环境光变化相匹配。经过我们的实验，该灯泡在8V电压以下不会发光，且为了保护电路和用户，我们将最高输出电压15V通过程序限制在12V，于是我们将光亮百分比线性映射公式修改为：<br>$$<br>V_{target} = \frac{百分比指令}{100} \times 4 + 8<br>$$<br>从而使得亮度百分比更符合实际；由于百分比电压现在被限制在8-12V，光敏需要更多的外边界，从原先0-15V电压的计算，改为5-15V电压的线性映射，光敏电阻映射公式也需要对应修改为：<br>$$<br>V_{target} = \frac{ADC值}{4095} \times 10 + 5<br>$$<br>此时由于光敏电阻在一般的环境光下位于1024-3072而并不会趋于极端值，且程序有保护设计，故一定可以限制输出电压在8-12V范围内。</p>
<p>为进一步优化用户的使用体验，还开展了用户测试实验为产品优化提供参考。实验记录了光敏传感器自动调光时用户的视觉体验，并通过调整PID参数和映射公式提高舒适性。通过光敏传感器的引入，本系统实现了基于环境光强的自动调光功能，显著提升了灯光控制的智能化水平与用户体验。</p>
<h3 id="7-4-闭环PID控制原理"><a href="#7-4-闭环PID控制原理" class="headerlink" title="7.4 闭环PID控制原理"></a>7.4 闭环PID控制原理</h3><p>闭环PID控制是本系统的核心功能之一，负责根据目标输出电压值和实际输出电压值的误差，动态调节PWM信号，从而控制Buck变换器的输出电压，实现稳定、精准的调光效果。通过PID控制算法，可以使Buck变换器的输出电压始终接近目标值，无论输入电压波动、负载变化，还是环境光强条件改变，都能够保持系统的高稳定性和快速响应性。</p>
<p>PID控制算法主要由三部分组成：比例（P）、积分（I）、微分（D），可通过公式<br>$$<br>u(t) = K_{p}e(t) + K_{i}\int_{0}^{t}{e(\tau)d\tau} + K_{d}\frac{de(t)}{dt}<br>$$<br>计算其控制输出，其中u(t)为控制信号（用于调节PWM占空比）；e(t)为当前误差值，定义为目标值与实际值之差，即<br>$$<br>e(t) = V_{target} - V_{actual}<br>$$<br>K_p,K_i,K_d分别为比例、积分、微分的调节系数，分别控制系统的响应速度、稳态误差消除能力和动态性能。</p>
<p>通过调节K_p,K_i,K_d三个参数，可以调整控制器的性能，从而实现系统响应特性的优化，提升系统控制效果。具体而言，三个参数对于响应输出的影响如下：</p>
<ul>
<li><p>比例（P）参数K_p：比例项主要控制误差对输出的直接影响，增大K_p会使系统响应更迅速，但过大可能引起震荡。本系统初始设置<br>$$<br>K_{p} = 0.1<br>$$<br>通过实验验证实现了较平滑的响应。</p>
</li>
<li><p>积分（I）参数K_i：积分项通过累积误差消除稳态误差，确保输出精度。由于积分过大会导致超调或积分饱和，本系统设置<br>$$<br>K_{i} = 0.01<br>$$</p>
</li>
<li><p>微分（D）参数K_d：微分项对误差变化率进行调节，用于改善动态性能并抑制震荡。为避免过分灵敏的微分效应引入噪声，D参数设置为较小值<br>$$<br>K_{d} = 0.01<br>$$</p>
</li>
</ul>
<p>在本项目的自动调光系统中，PID控制器的控制流程主要分为如下几个步骤：</p>
<ol>
<li><p>误差计算：STM32单片机实时采集目标电压值 V_target 和实际输出电压值 V_actual，计算误差：<br>$$<br>e(t) = V_{target} - V_{actual}<br>$$</p>
</li>
<li><p>控制信号计算：根据误差值，通过PID公式计算控制信号u(t)，调整PWM信号的占空比：<br>$$<br>u(t) = K_{p}e(t) + K_{i}\sum_{k = 0}^{t}{e(k)\mathrm{\Delta}t} + K_{d}\frac{e(t) - e(t - 1)}{\mathrm{\Delta}t}<br>$$<br>其中Δt为控制周期；∑e(k)Δt为误差累积值；(e(t)-e(t-1))/Δt为误差变化率。</p>
</li>
<li><p>PWM调节：将计算得到的u(t)映射为PWM信号的占空比，直接控制Buck变换器的输出电压。占空比范围为10%至80%，对应输出电压范围为0V至15V。</p>
</li>
<li><p>反馈调整：系统持续监测实际输出电压，更新误差值并重复上述步骤，形成闭环控制。</p>
</li>
</ol>
<p>在基于STM32单片机编写程序具体实现PID控制器算法时，还需要特别注意以下两点：</p>
<ul>
<li><p>采样频率：ADC采样频率需要设置为与main函数主循环频率同步，以保证控制系统对输入误差的快速响应。同时PID计算周期也应同步于ADC采样，以避免数据滞后影响调节效果。</p>
</li>
<li><p>保护机制：若误差值持续过大（如超出安全范围），系统触发保护模式，因此实际实现时将PWM占空比最小设为10%，最大设为80%。</p>
</li>
</ul>
<p>在实际调试验证时，主要对于控制系统的动态性能与抗干扰能力进行了测试与优化，以进一步提升自动调光功能的灵敏性与稳定性，从而优化用户体验：</p>
<ul>
<li><p>动态性能测试：在快速切换目标电压值时，观察系统的响应时间和稳定性，确保输出电压能够迅速收敛到目标值。在负载变化的情况下，验证系统能否保持输出电压的稳定。</p>
</li>
<li><p>抗干扰能力测试：模拟输入电压波动和环境光强突变，测试系统的鲁棒性和PID调节效果。</p>
</li>
</ul>
<p>最终经过多次调试与不断优化，该闭环PID控制系统实现了以下目标：</p>
<ul>
<li><p>高精度输出：在误差范围内快速稳定输出目标电压。</p>
</li>
<li><p>快速响应：对目标值或负载变化的响应时间快，满足实际调光需求。</p>
</li>
<li><p>稳定性强：在输入波动、负载变化和环境干扰下，系统保持良好的稳定性。</p>
</li>
</ul>
<h3 id="7-5-外观设计制作"><a href="#7-5-外观设计制作" class="headerlink" title="7.5 外观设计制作"></a>7.5 外观设计制作</h3><p>为了使本系统不仅具有实用性，还能满足美观性和设计感的需求，我们对外观部分进行了重新设计和制作。本节详细介绍了外观设计的灵感来源、制作过程以及技术实现中的注意事项。</p>
<p>本系统的外观设计灵感来源于游戏《无畏契约》（Valorant）中的角色”尚博勒”（Chamber）的道具”摄像头”。这一设计概念契合科技感与现代感的视觉效果，适合科技爱好者的审美需求，同时其独特的造型也为灯具的装饰性增色。我们力求将其视觉元素融入本项目，打造一款既具功能性又有极高辨识度的灯具设备。同时在外壳设计时也结合了灯泡的散热需求，保证了灯具长时间工作时的安全性和稳定性。设计中注重可拆卸性，用户可以方便地调整灯泡朝向和光照亮度。</p>
<p><img src="/images/control/media/image121.jpeg" alt="图7.3：产品外观设计原型"></p>
<p>详细的制作过程如下：</p>
<ol>
<li>原型拆解</li>
</ol>
<p>我们首先将旧灯具的灯罩部分锯下来，仅保留其内部核心组件，包括灯泡、散热装置、电路板和连接线。为确保灯具正常运行，对保留的灯泡和电路板进行功能检测，确认其性能稳定，并清理了原型中多余的固定结构，为后续的外壳重新设计预留空间。</p>
<p><img src="/images/control/media/image122.jpeg" alt="图7.4：灯具原型拆解部分过程"><img src="/images/control/media/image123.jpeg" alt="图7.4：灯具原型拆解部分过程"></p>
<ol start="2">
<li>3D建模与设计</li>
</ol>
<p>使用Fusion 360软件，根据”尚博勒摄像头”的设计特点，建模了一个以球体和多面体造型的外壳结构。模拟摄像头的结构，在灯具上设计了圆形凹陷部分，提升灯具的科技感。外壳设计了散热格栅，与灯具散热需求相结合；外壳底部设计了支撑脚架，便于放置和移动。摄像头部分设计轨道凹槽，可旋转控制摄像头方向。</p>
<p><img src="/images/control/media/image124.png" alt="图7.5：产品外形3D建模效果图"></p>
<ol start="3">
<li>材料选择与加工</li>
</ol>
<p>外壳部分采用轻质耐用的 PLA 材料，利用3D打印技术制作。打印分为两个部分：上半部分为灯具主壳，下半部分为安装支架，组装后固定。3D打印完成后，外壳表面进行手工打磨并喷涂金色亚光涂料，灯罩边缘则涂上金属漆，营造高科技感。</p>
<ol start="4">
<li>组件安装与调试</li>
</ol>
<p>将灯泡、电路板、散热器嵌入3D打印外壳中，通过卡扣、限位固定，确保结构稳固。为避免外壳对散热产生影响，在装配后对设备进行长时间运行测试，确保温度稳定在安全范围内。重新调整灯光的投射方向和亮度，使其与设计的外壳结构匹配，确保在不同环境下具备良好的照明效果。</p>
<p><img src="/images/control/media/image125.jpeg" alt="图7.6：最终产品样机实物图"></p>
<p>为进一步提升用户体验，后续将持续对产品进行深度优化，包括添加更多灯光模式（如动态光效或多色渐变）以进一步增强装饰性和互动性，或引入语音控制功能并将其与蓝牙通信相结合以提升智能化体验。</p>
<h3 id="7-6-本章小结"><a href="#7-6-本章小结" class="headerlink" title="7.6 本章小结"></a>7.6 本章小结</h3><p>本章介绍了基于直流电源调控的自动调光控制设计，通过蓝牙模块完成手动输出电压控制，通过光敏传感器进行环境光度自动调节，最终通过Buck变换器闭环PID控制完成灯的电压和光亮度稳定。</p>
<h2 id="8-基于直流电源调控的光伏MPPT控制设计"><a href="#8-基于直流电源调控的光伏MPPT控制设计" class="headerlink" title="8 基于直流电源调控的光伏MPPT控制设计"></a>8 基于直流电源调控的光伏MPPT控制设计</h2><h3 id="8-1-设计背景与系统架构"><a href="#8-1-设计背景与系统架构" class="headerlink" title="8.1 设计背景与系统架构"></a>8.1 设计背景与系统架构</h3><p>光伏发电是当前清洁能源的主流之一，最大功率点跟踪（Maximum Power Point Tracking, MPPT）是光伏系统中提高效率的关键技术。由于光伏板的输出功率受到光照强度影响，不同的光照强度下最大功率点对应的输出电压不同，需要不断通过改变输出电压来寻找最大功率点（MPP）。因此，希望通过搭建一个基于直流电源调控的光伏MPPT控制系统，结合STM32单片机和Buck变换器实现光伏阵列的最大功率点跟踪，从而使得系统维持在最大功率工作，减少不必要的能量损失，有效储存其他能量转化成的电能。</p>
<p><img src="/images/control/media/image126.jpeg" alt="图8.1：光伏发电板"></p>
<p>在该系统中，外界光照被太阳能电池板转化为电能，经功率变换电路处理后向负载供电。STM32微控制器实时采集电池板电压、电流等参数，运行MPPT算法，生成控制信号优化功率变换电路的工作状态，确保太阳能电池板始终在最大功率点运行，提高能源利用效率。</p>
<p><img src="/images/control/media/image127.png" alt="图8.2：基于直流电源调控的光伏MPPT控制系统整体架构"></p>
<h3 id="8-2-实验原理"><a href="#8-2-实验原理" class="headerlink" title="8.2 实验原理"></a>8.2 实验原理</h3><p>光伏板的输出功率会受到环境条件（如光照、温度）影响，这一点无法改变，但是输出功率同时也受到工作电流、电压的因素影响，因此可以通过调节负载电压，使光伏系统的功率维持在最大值，即工作在最大功率点（实现输入侧阻抗匹配）。在本课程使用的Buck变换器中，可以根据STM32输出PWM波的占空比来控制输出的电压，同时由于电路中在不断采集输出电压，从而可以通过设计相应的控制算法算法实现对于输出电压的精确闭环控制。</p>
<p>为了找到最大功率点，可采用扰动观察法（Perturb and Observe, P&amp;O）算法。通过降低与增加占空比来调节输出电压，由于电阻一定，可以通过计算算出变化后的功率，同时将其与变化前的功率进行比较，若功率增大，则沿当前方向继续调整占空比；否则反向调整。在每次调整占空比后，计算功率并记录趋势，从而找到最大功率点。在本项目中，采用改进的扰动观察法，通过记录功率变化并自动调整占空比，从而快速收敛到最大功率点。</p>
<p><img src="/images/control/media/image128.png" alt="图8.3：不同光照强度对光伏板的P -V曲线"></p>
<h3 id="8-3-代码逻辑"><a href="#8-3-代码逻辑" class="headerlink" title="8.3 代码逻辑"></a>8.3 代码逻辑</h3><p>在Keil5中编写的STM32主控代码主要分为如下4个主要的功能模块：</p>
<ol>
<li>系统初始化：初始化系统时钟与ADC、PWM模块，为数据采集及控制做好准备。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SystemInit(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">PWM_Init(); <span class="comment">// 初始化PWM模块</span></span><br><span class="line">AD_Init(); <span class="comment">// 初始化ADC模块</span></span><br><span class="line">_enable_irq(); <span class="comment">// 开启全局中断</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>PWM控制模块：通过实时调控PWM输出占空比实现Buck变换器输出电压的改变，从而影响光伏阵列的工作点。值得注意的是，需要调整PWM输出频率与Buck变换器相适应，同时确保输出占空比范围在0~1范围内。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; <span class="comment">// 配置为PWM模式1</span></span><br><span class="line">TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">// 设置初始占空比为0</span></span><br><span class="line">TIM_SetCompare1(TIM2, (<span class="type">uint16_t</span>)(dutyCycle * PWM_PERIOD)); <span class="comment">// 调整PWM占空比</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>ADC采样模块：将光伏阵列输出的电压信号通过ADC采样转换为数字信号并读取，再通过与电阻的计算得出电流值，以用于功率计算。值得注意的是，ADC通道需与光伏阵列信号对应，同时为确保采样精度还需事先对ADC模块进行校准。</li>
</ol>
<p><img src="/images/control/media/image129.png" alt="图8.4：ADC采样模块相关函数代码"></p>
<ol start="4">
<li>MPPT算法实现：根据扰动观察法原理，通过电流与电压相乘得到当前输出功率，与上个点的功率相比较，若大于上个点的功率，则继续增大占空比，增加输出电压，从而增加输出功率，若小于，则减小占空比，并在每次调整占空比后再次计算输出功率。循环往复进行上述流程，同时记录功率变化趋势及对应占空比，以寻找最大功率点。值得注意的是，程序中设置的步长STEP_SIZE值应适中，过大会导致振荡，而过小则会影响跟踪的速度，同时还应避免控制过程中PWM波形的占空比超出0~1范围。</li>
</ol>
<p><img src="/images/control/media/image130.png" alt="图8.5：MPPT算法实现相关函数代码"></p>
<p>在主循环main函数中编写总控代码对上述代码逻辑进行整合，每次循环都会测量电压与电流从而得到功率，再通过进行扰动观察法寻找最大功率点。</p>
<p><img src="/images/control/media/image131.png" alt="图8.6：main函数总控代码"></p>
<h3 id="8-4-实验现象"><a href="#8-4-实验现象" class="headerlink" title="8.4 实验现象"></a>8.4 实验现象</h3><p>实验时，将Buck变换器、STM32开发板与光伏阵列进行连接，并确保采样与控制电路正常工作。将代码烧录到STM32开发板，并通过调整光照强度，观察功率点变化及最大功率点跟踪效果。接下来需要进行逐步调试：</p>
<ol>
<li>使用示波器观察PWM信号及Buck变换器输出电压，验证占空比调节是否正常，并使用万用表验证电压、电流采样值是否准确；</li>
</ol>
<p><img src="/images/control/media/image132.png" alt="图8.7：PWM输出占空比调试结果"></p>
<p><img src="/images/control/media/image133.png" alt="图8.8：Buck变换器输出电压调试结果"></p>
<p>可以看到，此时PWM输出占空比为50%，占空比调节正常；光伏板输出电压为5.1V，电流为0.025A，输入功率约为0.1275W。</p>
<ol start="2">
<li>通过调整光照强度，观察功率点变化及最大功率点跟踪效果。</li>
</ol>
<p><img src="/images/control/media/image134.png" alt="图8.9：负载电压图"></p>
<p><img src="/images/control/media/image135.png" alt="图8.10：负载消耗功率图"></p>
<p>可以看到，此时所接负载为200Ω，输出电压为4.5V，输出功率约为0.12W。考虑功率损耗，光伏板输出功率约等于负载消耗功率，完成了对该光照强度下最大功率点（MPP）的准确寻找。</p>
<p>随后又对于该控制系统的动态跟踪性能进行进一步的测试，可以观察到，当外界环境的光照强度改变时，控制系统能快速做出响应并使光伏板输出功率达到最大（约为负载消耗功率），说明控制系统对于最大功率点的实时跟踪性能良好。</p>
<h3 id="8-5-本章小结"><a href="#8-5-本章小结" class="headerlink" title="8.5 本章小结"></a>8.5 本章小结</h3><p>本章主要介绍了基于直流电源调控的光伏板最大功率点追踪（MPPT）控制系统的设计，设计时主要采用递归算法，每次通过扰动当前功将率与变换前功率作比较，若大，则继续增加占空比，若小，则减少占空比，以此类推，不断循环，从而找到最大功率点。每次变化占空比的步长与延时时间影响找到最大功率点的效率，需要调试找到最佳的相应效率。同时，在步长固定的情况下，通过自适应步长控制算法也可以更有效率的寻找最大功率。通过动态追踪，显著提高了光伏发电效率。</p>
<h2 id="9-总结与展望"><a href="#9-总结与展望" class="headerlink" title="9 总结与展望"></a>9 总结与展望</h2><h3 id="9-1-课程小结"><a href="#9-1-课程小结" class="headerlink" title="9.1 课程小结"></a>9.1 课程小结</h3><p>《自动控制原理》课程作为一门项目制课程，重点围绕经典控制相关理论知识及应用实践，有效地将理论教学与设计实践结合起来。通过课程的理论学习与项目实践，我们在实践操作中对于经典控制理论的知识有了更加深刻的理解，建立了”控制”工程观与系统性分析思维，也锻炼了自己将理论应用于工程实践的能力，以及对于控制工程问题的分析与解决能力。</p>
<p>该项目制课程主要分为两个项目板块：</p>
<p>控制基础实践项目为”直流电源控制分析与系统设计”，以直流电源这一经典工程案例串联起经典控制理论知识各版块，涵盖控制系统建模（微分方程与传递函数）、时域分析、根轨迹分析、频域分析，频域校正与PID控制等，从理论分析、仿真、实验三维度强化同一理论知识点的学习，完成直流电源控制系统的分析设计以及调试。这一部分项目在理论课程学习的同时穿插完成，主要涉及到经典控制理论的学习，并将其应用到实际的Buck变换器PI闭环控制系统中、结合实际电路参数完成的PSIM电路仿真与相应的MWorks分析计算。</p>
<p>综合应用实践项目为”基于电源的综合应用系统”，以直流电源驱动系统应用为综合实践项目，运用传感、闭环控制、先进控制等硬件与算法，完成基于直流电源控制的LED自动调光与光伏最大功率跟踪（MPPT）等项目实践。这一部分项目主要以实验方式开展，最终本小组顺利完成实验与设计内容并进行课程项目汇报。</p>
<p><img src="/images/control/media/image136.jpeg" alt="图9.1：小组答辩风采展示"></p>
<p>回顾这门课程一路走来，从课程引入与理论教学，到实际实验调试与项目设计，再到最终的项目测试与汇报，我们在理论与实践的结合中扎实掌握了经典控制理论的相关知识，并锻炼了自己的电路设计分析与实践能力。我们能取得如此的进步与成就离不开两位老师与四位助教的辛勤付出，在此再次向各位老师与助教们送上最真诚的感谢，也衷心祝愿这门课程在未来能建设得越来越好。</p>
<p><img src="/images/control/media/image137.png" alt="图9.2：课程汇报班级合影留念"></p>
<h3 id="9-2-课程收获及建议"><a href="#9-2-课程收获及建议" class="headerlink" title="9.2 课程收获及建议"></a>9.2 课程收获及建议</h3><p>通过《自动控制原理》这门课程的学习，我了解到了许多经典控制理论的相关知识：从系统的数学建模入手，微分方程与传递函数是描述一个控制系统性能的基本工具；为调整系统参数以提高控制系统的稳定性，可从时域与频域两个角度分别进行分析，时域上可以使用劳斯判据进行系统稳定性的判定并根据根轨迹找到系统的临界稳定状态，频域上可以使用奈奎斯特稳定判据或依据Bode图对系统稳定性进行分析；基于频率特性，还可以从频域校正环节的设计层面调节系统的动态响应特性。理论学习之余，课程紧密穿插了相应的仿真与电路调试实验，理论与实践的结合使得我对于这些枯燥的理论知识有了更加生动而深刻的理解。</p>
<p>在课程项目中，我主要负责对于闭环控制系统的理论分析、仿真验证与参数调试，以及课程项目报告绝大部分的撰写。令我印象最深刻的是，在理论部分对系统进行频率特性分析时，使用MWorks根据系统开环传递函数绘制Bode图，得到了穿越频率与相位裕度；而在根据实际电路结构在PSIM中搭建了相应的扫频电路之后，当看到运行扫频仿真得到的结果与MWorks绘制的Bode图几乎完全一致时，我深刻体会到了理论的有效性，这代表理论的分析确实可以真实地指导实际控制系统的设计，在后续项目设计与调试时也充分利用了这一点，有效提高了设计与调试的效率。最终我们也顺利完成了基于直流电源调控的自动调光与MPPT控制系统的设计与实现，并将自动调光系统实例化为一个具有实际应用意义的产品。相信在这门课程中学到的知识与技能能够为我们未来的硬件产品开发中起到重要的作用。</p>
<p>最后感谢两位老师耐心的教学与指导以及四位助教的辛苦付出，特别是几位助教，耐心地回答我们的问题、批改我们的作业并协助我们进行硬件实物的调试，为我们的项目实践提供了丰富的参考资料，帮助我们快速上手项目。在此提出一点小小的建议，这次项目中在电路焊接方面浪费了许多时间，希望未来的课程项目设计能够在各个实现细节上更加完善，在设计与测试时考虑的更加全面；同时希望在理论课程中穿插的各种仿真作业能够与实际的控制系统结合的更加紧密，完善一些逻辑不严谨的地方（如提供的报告框架中，是否考虑电容寄生电阻这点体现的略显混乱）。但总的来说，这门课程确实是已有项目制课程中的精品，也希望能够在未来建设得越来越好。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 胡寿松主编.自动控制原理[M].科学出版社,2019:a670.</p>
<p>[2] 卢京潮主编.自动控制原理习题解答[M].清华大学出版社,2013:195.</p>
<p>[3] 王天威编著.控制之美[M].清华大学出版社,2022.</p>
<p>[4] 李昆.智能技术在室内LED照明系统中的应用研究[J].光源与照明,2024,(10):51-53.</p>
<p>[5] 郑盛梅.恒照度自动调光台灯的设计[J].光源与照明,2023,(01):69-71.</p>
<p>[6] 侯耀华,陈萍,於崇干.直流电源系统高级功能在无人值班变电站的应用[J].供用电,2015,(02):19-24.</p>
<p>[7] 许桂敏,解皓月,张子泉,等.基于Simulink的光伏电池特性及MPPT算法仿真研究[J].智能建筑电气技术,2024,18(06):36-39+60.</p>
<p>[8] 王青苗.PLC模糊PID控制系统在隧道照明节能控制中的应用[J].微型电脑应用,2024,40(06):114-118+122.</p>
<p>[9] 陈礼俊,兰志勇.单片机控制的双调控高压直流电源[J].现代电子技术,2017,40(12):165-168.</p>
<p>[10] 樊战亭,万欣,王超.太阳能电池板自动追光控制系统设计[J].咸阳师范学院学报,2024,39(06):12-16.</p>
<p>[11] Gene F. Franklin, J. David Powell, Abbas Emami-Naeini, et al. Feedback control of dynamic systems[M].Publishing House of Electronics Industry,2013:14,590.</p>
<p>[12] Karl Johan Astrom, Richard M. Murray.自动控制多学科视角[M].人民邮电出版社,2010:310.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-STM32闭环PI控制程序"><a href="#1-STM32闭环PI控制程序" class="headerlink" title="1 STM32闭环PI控制程序"></a>1 STM32闭环PI控制程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"PWM.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AD.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Serial.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_FREQUENCY 10000    <span class="comment">// PWM频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PWM_VALUE 1000     <span class="comment">// PWM最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PERIOD 3000  <span class="comment">// PWM周期为1000个计数单位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KP 0.1          <span class="comment">// 比例增益</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KI 0.01         <span class="comment">// 积分增益</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KD 0.01</span></span><br><span class="line"><span class="type">float</span> voltage_ref = <span class="number">10</span>;  <span class="comment">// 设定的输出电压 </span></span><br><span class="line"><span class="type">float</span> voltage_fb = <span class="number">0.0</span>;   <span class="comment">// 反馈的实际输出电压</span></span><br><span class="line"><span class="type">float</span> duty_cycle = <span class="number">0.0</span>;   <span class="comment">// 占空比</span></span><br><span class="line"><span class="type">float</span> error = <span class="number">0.0</span>;        <span class="comment">// 误差</span></span><br><span class="line"><span class="type">float</span> integral = <span class="number">0.0</span>;     <span class="comment">// 积分项</span></span><br><span class="line"><span class="type">float</span> control_signal = <span class="number">0.0</span>;  <span class="comment">// 控制信号</span></span><br><span class="line"><span class="type">float</span> last_error = <span class="number">0.0</span>;   <span class="comment">// 上一次的误差</span></span><br><span class="line"><span class="type">float</span> derivative = <span class="number">0.0</span>;   <span class="comment">// 微分项</span></span><br><span class="line"><span class="type">int</span> sample_index = <span class="number">0</span>;  <span class="comment">// 样本计数器</span></span><br><span class="line"><span class="type">float</span> trueVoltage=<span class="number">0.0</span>;     <span class="comment">// 实际输出电压值</span></span><br><span class="line"><span class="type">float</span> VREF;</span><br><span class="line"><span class="type">uint32_t</span> time_counter = <span class="number">0</span>;  <span class="comment">// 用于记录时间的计数器</span></span><br><span class="line"><span class="type">uint8_t</span> voltage_state = <span class="number">0</span>;  <span class="comment">// 0 表示电压为8V，1 表示电压为10V</span></span><br><span class="line"><span class="type">uint16_t</span> ADValue;</span><br><span class="line"><span class="type">float</span> Voltage;</span><br><span class="line"><span class="type">float</span> i;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">control_buck</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    voltage_fb = (<span class="type">float</span>)AD_GetValue()*<span class="number">3.3</span>/<span class="number">4096</span>;  <span class="comment">//读取ADC的值</span></span><br><span class="line">    trueVoltage = voltage_fb*<span class="number">1050</span>*<span class="number">20000</span>/<span class="number">2500</span>/<span class="number">1000</span>;  <span class="comment">// 计算实际电压 (根据外部电路参数)</span></span><br><span class="line">    error = voltage_ref*<span class="number">2500</span>*<span class="number">1000</span>/<span class="number">1050</span>/<span class="number">20000</span> - voltage_fb;  <span class="comment">// 计算误差</span></span><br><span class="line">    integral += error;  <span class="comment">// 积分计算</span></span><br><span class="line">    derivative = error - last_error;  <span class="comment">// 微分计算</span></span><br><span class="line">    control_signal = KP * error + KI * integral + KD * derivative;  <span class="comment">// PID控制输出</span></span><br><span class="line">    <span class="keyword">if</span> (control_signal &gt; <span class="number">0.8</span>)</span><br><span class="line">        control_signal = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (control_signal &lt; <span class="number">0.2</span>)</span><br><span class="line">        control_signal = <span class="number">0.2</span>;</span><br><span class="line">    duty_cycle = control_signal * PWM_PERIOD;  <span class="comment">// 更新占空比</span></span><br><span class="line">    i = (<span class="type">int</span>)duty_cycle;</span><br><span class="line">    PWM_SetCompare1(i);</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    OLED_Init();</span><br><span class="line">    PWM_Init();</span><br><span class="line">    AD_Init();</span><br><span class="line">    Delay_ms(<span class="number">10</span>);</span><br><span class="line">    NVIC_Configuration();</span><br><span class="line">    Serial_Init();  <span class="comment">// 初始化串口</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>){</span><br><span class="line">        control_buck();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-自动调光程序"><a href="#2-自动调光程序" class="headerlink" title="2 自动调光程序"></a>2 自动调光程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"PWM.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AD.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Serial.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"HC05.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_FREQUENCY 10000    <span class="comment">// PWM频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PWM_VALUE 1000     <span class="comment">// PWM最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PERIOD 3000  <span class="comment">// PWM周期为1000个计数单位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KP 0.1          <span class="comment">// 比例增益</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KI 0.01         <span class="comment">// 积分增益</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KD 0.01</span></span><br><span class="line"><span class="type">float</span> Light_Intensity = <span class="number">0.0</span>;    <span class="comment">// 光敏实际模拟量</span></span><br><span class="line"><span class="type">float</span> voltage_ref = <span class="number">5</span> * <span class="number">1.38</span>;  <span class="comment">// 设定的输出电压 </span></span><br><span class="line"><span class="type">float</span> voltage_fb = <span class="number">0.0</span>;   <span class="comment">// 反馈的实际输出电压</span></span><br><span class="line"><span class="type">float</span> duty_cycle = <span class="number">0.0</span>;   <span class="comment">// 占空比</span></span><br><span class="line"><span class="type">float</span> error = <span class="number">0.0</span>;        <span class="comment">// 误差</span></span><br><span class="line"><span class="type">float</span> integral = <span class="number">0.0</span>;     <span class="comment">// 积分项</span></span><br><span class="line"><span class="type">float</span> control_signal = <span class="number">0.0</span>;  <span class="comment">// 控制信号</span></span><br><span class="line"><span class="type">float</span> last_error = <span class="number">0.0</span>;   <span class="comment">// 上一次的误差</span></span><br><span class="line"><span class="type">float</span> derivative = <span class="number">0.0</span>;   <span class="comment">// 微分项</span></span><br><span class="line"><span class="comment">//int sample_index = 0;  // 样本计数器</span></span><br><span class="line"><span class="type">float</span> trueVoltage=<span class="number">0.0</span>;     <span class="comment">// 实际输出电压值</span></span><br><span class="line"><span class="type">float</span> VREF;</span><br><span class="line"><span class="type">uint32_t</span> time_counter = <span class="number">0</span>;  <span class="comment">// 用于记录时间的计数器</span></span><br><span class="line"><span class="type">uint8_t</span> voltage_state = <span class="number">0</span>;  <span class="comment">// 0 表示电压为8V，1 表示电压为10V</span></span><br><span class="line"><span class="type">uint16_t</span> ADValue;</span><br><span class="line"><span class="type">float</span> Voltage;</span><br><span class="line"><span class="type">float</span> i;</span><br><span class="line"><span class="type">uint8_t</span> RxSTA = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> RxData[<span class="number">100</span>] = <span class="string">"N"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">control_buck</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    voltage_fb = (<span class="type">float</span>)AD_GetValue(ADC_Channel_4)*<span class="number">3.3</span>/<span class="number">4096</span>;  <span class="comment">//读取ADC的值</span></span><br><span class="line">    trueVoltage = voltage_fb*<span class="number">1050</span>*<span class="number">20000</span>/<span class="number">2500</span>/<span class="number">1000</span>;  <span class="comment">// 计算实际电压 (根据外部电路参数)</span></span><br><span class="line">    error = voltage_ref*<span class="number">2500</span>*<span class="number">1000</span>/<span class="number">1050</span>/<span class="number">20000</span> - voltage_fb;  <span class="comment">// 计算误差</span></span><br><span class="line">    integral += error;  <span class="comment">// 积分计算</span></span><br><span class="line">    derivative = error - last_error;  <span class="comment">// 微分计算</span></span><br><span class="line">    control_signal = KP * error + KI * integral + KD * derivative;  <span class="comment">// PID控制输出</span></span><br><span class="line">    <span class="keyword">if</span> (control_signal &gt; <span class="number">0.8</span>)</span><br><span class="line">        control_signal = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (control_signal &lt; <span class="number">0</span>)</span><br><span class="line">        control_signal = <span class="number">0</span>;</span><br><span class="line">   duty_cycle = control_signal * PWM_PERIOD;  <span class="comment">// 更新占空比</span></span><br><span class="line">     i = (<span class="type">int</span>)duty_cycle;</span><br><span class="line">     PWM_SetCompare1(i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    OLED_Init();</span><br><span class="line">    PWM_Init();</span><br><span class="line">    AD_Init();</span><br><span class="line">    Delay_ms(<span class="number">10</span>);</span><br><span class="line">    NVIC_Configuration();  <span class="comment">// NVIC初始化</span></span><br><span class="line">    Serial_Init();  <span class="comment">// 初始化串口</span></span><br><span class="line">	HC05_Init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>){</span><br><span class="line">        <span class="comment">// 蓝牙读取开关</span></span><br><span class="line">        HC05_GetData(RxData);</span><br><span class="line">        <span class="keyword">if</span> (RxSTA == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(RxData, <span class="string">"LL"</span>) == <span class="number">0</span>){</span><br><span class="line">                RxSTA = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">                    <span class="comment">// 读取光敏模拟输入量</span></span><br><span class="line">                    Light_Intensity = (<span class="type">float</span>)AD_GetValue(ADC_Channel_5);</span><br><span class="line">                    voltage_ref = (Light_Intensity * <span class="number">2</span> / <span class="number">3500</span> + <span class="number">8</span>) * <span class="number">1.38</span>;</span><br><span class="line">                    control_buck();                                               </span><br><span class="line">                    HC05_GetData(RxData);</span><br><span class="line">                    <span class="keyword">if</span> (RxSTA == <span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(RxData, <span class="string">"on"</span>) == <span class="number">0</span>)</span><br><span class="line">                voltage_ref = <span class="number">10</span> * <span class="number">1.38</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(RxData, <span class="string">"off"</span>) == <span class="number">0</span>)</span><br><span class="line">                voltage_ref = <span class="number">5</span> * <span class="number">1.38</span>;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="type">int</span> num = atoi(RxData); </span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">100</span>)</span><br><span class="line">                    voltage_ref = ((<span class="type">float</span>)num / <span class="number">100</span> * <span class="number">2</span> + <span class="number">8</span>) * <span class="number">1.38</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; <span class="number">100</span>)</span><br><span class="line">                    voltage_ref = <span class="number">10</span> * <span class="number">1.38</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    voltage_ref = <span class="number">5</span> * <span class="number">1.38</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">memset</span>(RxData, <span class="number">0</span>, <span class="keyword">sizeof</span>(RxData));</span><br><span class="line">            <span class="built_in">strcpy</span>(RxData, <span class="string">"N"</span>);</span><br><span class="line">            RxSTA = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        control_buck();  <span class="comment">//      控制输出电压</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-12-05T13:31:03.000Z" title="2024/12/5 21:31:03">2024-12-05</time>发表</span><span class="level-item"><time datetime="2025-03-01T09:37:00.419Z" title="2025/3/1 17:37:00">2025-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95II/">定量工程设计方法II</a></span><span class="level-item">27 分钟读完 (大约4107个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/12/05/document/">基于STM32F407实现的信号发生与采集分析系统</a></p><div class="content"><div id="postchat_postcontent"><p>演示视频已上传至Bilibili视频平台：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wUiRYxE8z">https://www.bilibili.com/video/BV1wUiRYxE8z</a></p>
 <br>

<h2 id="一、系统功能与整体架构设计"><a href="#一、系统功能与整体架构设计" class="headerlink" title="一、系统功能与整体架构设计"></a>一、系统功能与整体架构设计</h2><h3 id="系统实现功能"><a href="#系统实现功能" class="headerlink" title="系统实现功能"></a>系统实现功能</h3><p>（1）单片机在按键控制下，产生1kHz的正弦波或方波；</p>
<p>（2）单片机能够采集波形，并且显示；</p>
<p>（3）单片机能够分析采集波形的频谱，并且显示频谱与基波频率。</p>
<h3 id="整体架构设计图"><a href="#整体架构设计图" class="headerlink" title="整体架构设计图"></a>整体架构设计图</h3><p><img src="/images/img/21.jpg"></p>
<h3 id="系统主页与按键对应功能简介"><a href="#系统主页与按键对应功能简介" class="headerlink" title="系统主页与按键对应功能简介"></a>系统主页与按键对应功能简介</h3><p><img src="/images/img/3.jpg"></p>
<p>每次启动系统都会默认直接进入该主页面：</p>
<p>（1）蓝色部分的文字为系统名称与作者姓名，这会在后续的每个功能页面中都有显示；</p>
<p>（2）黑色部分的文字为各按键对应的功能介绍。</p>
<p>正如主页的功能介绍栏所示：</p>
<p>（1）按下KEY0：PA4引脚开始持续输出1kHz的正弦波信号，并在屏幕上实时显示从PA5引脚采集到的输入信号波形；</p>
<p>（2）按下KEY1：PA4引脚开始持续输出1kHz的方波信号，并在屏幕上实时显示从PA5引脚采集到的输入信号波形；</p>
<p>（3）按下KEY2：在屏幕上实时显示从PA5引脚采集到的输入信号的频谱分析结果（幅值谱，频率范围为0~1000Hz）；</p>
<p>（3）按下KEY3（KEY_UP）：在屏幕上实时显示从PA5引脚采集到的输入信号的频谱分析结果（幅值谱，频率范围为0~8000Hz）。</p>
<br>

<h2 id="二、各部分功能实现"><a href="#二、各部分功能实现" class="headerlink" title="二、各部分功能实现"></a>二、各部分功能实现</h2><h3 id="1、1kHz正弦波与方波的产生"><a href="#1、1kHz正弦波与方波的产生" class="headerlink" title="1、1kHz正弦波与方波的产生"></a>1、1kHz正弦波与方波的产生</h3><h4 id="模块功能架构设计"><a href="#模块功能架构设计" class="headerlink" title="模块功能架构设计"></a>模块功能架构设计</h4><p><img src="/images/img/22.jpg"></p>
<p>在实际单片机编程实现时，导入并调用DSP库加速信号数组（正弦波）的计算，并通过时钟TIM6（分频）控制DMA的数据搬运过程，并设置DAC数模转换将搬运后的信号数字数据在PA4引脚以模拟信号形式输出。</p>
<h4 id="模块功能实现依据"><a href="#模块功能实现依据" class="headerlink" title="模块功能实现依据"></a>模块功能实现依据</h4><p>为使用单片机产生指定频率的波形，需要根据上述架构设置对应的参数，基本的设置逻辑如下：</p>
<p>（1）首先，这里使用定时器TIM6来控制DMA搬移数据的过程，在CubeMX中已预先设置其时钟频率为84MHz；</p>
<p>（2）在生成信号数组时，C语言程序中设定数组长度为1024（与后续采集一致，为4的整数次幂以便于进行快速傅里叶变换FFT）；</p>
<p>（3）事实上，对于信号数组长度N、定时器频率fT与信号基波频率f而言存在如下关系式：f = fT / N，这意味着以输出基波频率f = 1kH的信号为例，经过时钟分频后的定时器频率fT是可以直接确定的，进而可以确定分频倍数（时钟频率/分频后定时器频率）。</p>
<p>经过计算，当分频倍数设置为82时（实际单片机控制程序中为两次分频，取第一次分频倍数为41、第二次分频倍数为2即二分频），输出的信号基波频率f约为1000（由于数组长度为1024，在分频倍数必须取整的情况下，基波频率无法精准等于1000Hz，实际约为1000.38Hz）。</p>
<p>在MATLAB中，可以编写简单的测试程序模拟这一过程：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TIM6_Frequency = <span class="number">84000000</span>; <span class="comment">%DAC_DMA时钟TIM6频率</span></span><br><span class="line">DAC_DMA_Divide1 = <span class="number">41</span>; <span class="comment">%DAC_DMA时钟一次分频</span></span><br><span class="line">DAC_DMA_Divide2 = <span class="number">2</span>; <span class="comment">%DAC_DMA时钟二次分频</span></span><br><span class="line">DAC_DMA_Frequency = TIM6_Frequency / (DAC_DMA_Divide1 * DAC_DMA_Divide2); <span class="comment">%分频后时钟频率</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">1024</span>; <span class="comment">%数组长度与采样点数</span></span><br><span class="line"></span><br><span class="line">f = DAC_DMA_Frequency / N; <span class="comment">%产生信号频率（期望值1000）</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="模块功能实现效果"><a href="#模块功能实现效果" class="headerlink" title="模块功能实现效果"></a>模块功能实现效果</h4><p>启动系统后按压按键KEY_0启动正弦波生成，将示波器的通道正极与信号输出引脚PA4连接，示波器的通道负极与单片机的地GND连接，可在示波器上显示出如下波形：</p>
<p><img src="/images/img/1.jpg"></p>
<p>可以看到输出的波形形状为标准的正弦波，输出电平范围为0<del>3.3V（对应生成的正弦信号数组振幅为2048、偏置为2047即数据点范围位于0</del>4095），均值为1.6V，且周期约为1kHz（示波器显示1.00045kHz；一个周期大致占据五格、每格代表200us即一个周期为1ms）。</p>
<p>按压按键KEY_1切换为生成方波，可在示波器上显示出如下波形：</p>
<p><img src="/images/img/2.jpg"></p>
<p>可以看到输出的波形形状为标准的方波（占空比50%），输出低电平为0V、高电平为3.3V（对应生成的方波信号数组前一半值为0、后一半值为4095），均值为1.6V，且周期约为1kHz（示波器显示1.00043kHz；一个周期大致占据五格、每格代表200us即一个周期为1ms）。</p>
<h3 id="2、波形信号的采集与显示"><a href="#2、波形信号的采集与显示" class="headerlink" title="2、波形信号的采集与显示"></a>2、波形信号的采集与显示</h3><h4 id="模块功能架构设计-1"><a href="#模块功能架构设计-1" class="headerlink" title="模块功能架构设计"></a>模块功能架构设计</h4><p><img src="/images/img/23.jpg"></p>
<p>在实际单片机编程实现时，通过定时器控制从PA5引脚读入模拟信号，通过ADC模数转换为数字数组并通过DMA搬运将其存入长度为1024（为4的整数次幂以便于进行快速傅里叶变换FFT）的数组中，存满一次数组即中断一次DMA搬运并将该数组数据（即采集波形）显示在显示屏上，短暂延迟（控制屏幕刷新速度合适）后进行新一轮的信号采集、搬运与波形显示。</p>
<h4 id="模块功能实现依据-1"><a href="#模块功能实现依据-1" class="headerlink" title="模块功能实现依据"></a>模块功能实现依据</h4><p>为使用单片机采集信号数据并以合适的形式将波形显示在显示屏上，需要根据上述架构设置对应的参数，基本的设置逻辑如下：</p>
<p>（1）首先，控制ADC1的定时器在CubeMX中已预先设置其时钟频率为84MHz，但根据相关手册与文档，硬件上对于分频后的ADC实际频率有限制，不能高于30MHz，在这样的条件下一般取四分频（仅分频一次，以对应结构体参数hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4实现），即分频后定时器频率为21MHz；</p>
<p>（2）其次，根据相关手册与文档，完成一次采样至少会花费12个时钟周期，为调控实际采样频率通常还可以设置额外的时钟周期（库函数限制只能为特定的几个值），即实际的采样频率Fs应为：分频后定时器频率（21MHz）/一次采样花费的时钟周期数（12+额外设置的时钟周期）；</p>
<p>（3）事实上，要想控制屏幕上显示的波形不过于松散/密集，需要控制一次采样（填满数组，DMA中断）内包含的信号周期数量，这可以通过将信号产生的定时器频率fT除以采样频率Fs得到；</p>
<p>（4）另一方面还需要注意为使得采集到的波形没有失真（频域混叠）现象，要求采样频率Fs与待采集波形频率f满足：Fs≥2f。</p>
<p>经过计算与测试，当额外设置的时钟周期设置为112时（sConfig.SamplingTime = ADC_SAMPLETIME_112CYCLES），一次采样中包含（屏幕上显示）的信号周期约为6，这样的显示效果较为合理；同时此时的采样频率Fs约为42683Hz，远大于待采集波形频率f = 1000Hz的两倍，不会发生频谱混叠。</p>
<p>在MATLAB中，可以编写简单的测试程序模拟这一过程（以正弦信号为例）：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ADC_Timer_Frequency = <span class="number">84000000</span>; <span class="comment">%ADC时钟频率</span></span><br><span class="line"><span class="comment">%硬件限制：要求ADC实际时钟频率不能超过30MHz</span></span><br><span class="line">ADC_Divide = <span class="number">4</span>; <span class="comment">%取四分频，分完后达到21MHz满足要求</span></span><br><span class="line">ADC_Frequency = ADC_Timer_Frequency / ADC_Divide; <span class="comment">%分频后ADC时钟频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%完成一次采样需要多个时钟周期</span></span><br><span class="line">Collect1 = <span class="number">12</span>; <span class="comment">%固定消耗12次循环，无法更改</span></span><br><span class="line">Collect2 = <span class="number">112</span>; <span class="comment">%可设置额外消耗循环数以调整采样频率</span></span><br><span class="line">Fs = ADC_Frequency / (Collect1 + Collect2); <span class="comment">%ADC采样频率</span></span><br><span class="line"></span><br><span class="line">Cycle = DAC_DMA_Frequency / Fs; <span class="comment">%一次采样采出多少个周期</span></span><br><span class="line"></span><br><span class="line">A = <span class="number">2047</span>; <span class="comment">%幅值</span></span><br><span class="line">B = <span class="number">2048</span>; <span class="comment">%直流偏置分量</span></span><br><span class="line">t = <span class="number">0</span> : <span class="number">1</span> / Fs : (N - <span class="number">1</span>) / Fs;</span><br><span class="line">x = A * <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * f * t) + B;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制原始信号</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, x);</span><br><span class="line">title(<span class="string">'正弦波信号'</span>);</span><br><span class="line">xlabel(<span class="string">'时间 (秒)'</span>);</span><br><span class="line">ylabel(<span class="string">'幅值'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该MATLAB程序，绘制出一次采样采集到的波形如下图所示：</p>
<p><img src="/images/img/24.png"></p>
<h4 id="模块功能实现效果-1"><a href="#模块功能实现效果-1" class="headerlink" title="模块功能实现效果"></a>模块功能实现效果</h4><p>启动系统后按压按键KEY_0启动正弦波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，屏幕上显示采集波形效果如下：</p>
<p><img src="/images/img/13.jpg"></p>
<p>按压按键KEY_1切换为生成方波信号并采集，屏幕上显示采集波形效果如下：</p>
<p><img src="/images/img/9.jpg"></p>
<p>图上的横坐标单位为ms；可以看到屏幕上显示的即为6个周期的信号波形，这与MATLAB的模拟计算结果是完全一致的，且波形无失真。</p>
<h3 id="3、采集波形信号的频谱分析"><a href="#3、采集波形信号的频谱分析" class="headerlink" title="3、采集波形信号的频谱分析"></a>3、采集波形信号的频谱分析</h3><h4 id="模块功能实现依据-2"><a href="#模块功能实现依据-2" class="headerlink" title="模块功能实现依据"></a>模块功能实现依据</h4><p>在频谱分析与频谱图显示方面，有如下要点需要注意：</p>
<p>（1）首先，频谱分析依赖于对于信号的傅里叶变换，在数字信号层面对于离散的数据点则需要采用离散傅里叶变换，但这样的变换计算速度往往很感人，因此需要利用其快速算法，即快速傅里叶变换FFT，MATLAB可直接调用fft函数实现，单片机编程中在DSP库中也有相应的函数可以实现完全相同的过程，但要求信号数组的长度应为4的整数次幂，故先前均选取1024作为发生与采集信号的数组长度；</p>
<p>（2）其次，经过FFT变换后会得到一个长度相同（1024）的新数组，其中每一个数字的下标index对应的实际频率应为index*Fs/1024，这意味着如果直接将整个FFT变换结果数组作为频谱图显示到屏幕上，横坐标的跨度实际上为Fs≈42683Hz，为使得频谱图更加直观，需要限制绘制频谱图的频率范围，并对应控制绘制数组中的部分数据；</p>
<p>（3）事实上，FFT变换结果的数组中各数值并不是期望的对应频率的幅值，还需要除以数组长度1024（单片机程序中对于起始点只需要除以一半的数组长度即512）才可得到正确的幅值。</p>
<p>由于涉及到信号的基波频率检测以及方波的频谱分析，在KEY_2和KEY_UP按键分别设置了频谱频率范围为0<del>1000Hz与0</del>8000Hz两种模式。在MATLAB中，可以编写简单的测试程序模拟频谱分析过程并在0~8000Hz的频段上展示频谱：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f_range = <span class="built_in">linspace</span>(<span class="number">0</span>, Fs, N);<span class="comment">%频域横坐标，注意奈奎斯特采样定理，最大原信号最大频率不超过采样频率的一半</span></span><br><span class="line">xk = fft(x) / N; <span class="comment">%用fft得出离散傅里叶变换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算并绘制频谱</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(f_range(<span class="number">1</span>:<span class="number">50</span>),<span class="built_in">abs</span>(xk(<span class="number">1</span>:<span class="number">50</span>)));<span class="comment">%画双侧频谱幅度图</span></span><br><span class="line">title(<span class="string">'正弦波频谱'</span>);</span><br><span class="line">xlabel(<span class="string">'频率 (Hz)'</span>);</span><br><span class="line">ylabel(<span class="string">'幅度'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>运行该MATLAB程序，绘制出一次采样采集到的波形如下图所示（以正弦信号为例）：</p>
<p><img src="/images/img/25.png"></p>
<p>可以看到该信号具有直流分量（频率为0）以及1000Hz除的正弦分量，两者幅值均为2048（与产生波形时的一致）。</p>
<p>除此之外，在单片机编程中，为寻找并在屏幕上打印出信号的基波频率，还需要在显示频率波形的同时完成对于除直流分量外最高幅值对应频率的计算（数组返回最大值对应下表，算法较简单在此省略实现过程）。</p>
<h4 id="模块功能实现效果-2"><a href="#模块功能实现效果-2" class="headerlink" title="模块功能实现效果"></a>模块功能实现效果</h4><p>启动系统后按压按键KEY_0启动1000Hz正弦波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，并按压按键KEY_2可启动短频段0~1000Hz的频谱显示如下：</p>
<p><img src="/images/img/8.jpg"></p>
<p>按压按键KEY_UP可启动长频段0~8000Hz的频谱显示如下：</p>
<p><img src="/images/img/12.jpg"></p>
<p>可以看到此时只有直流分量和1000Hz的正弦分量两个尖峰，与MATLAB模拟计算结果一致。</p>
<p>按压按键KEY_1，切换为1000Hz方波波信号的生成与采集，将信号输出引脚PA4与信号输入引脚PA5连接，并按压按键KEY_2可启动短频段0~1000Hz的频谱显示如下：</p>
<p><img src="/images/img/11.jpg"></p>
<p>按压按键KEY_UP可启动长频段0~8000Hz的频谱显示如下：</p>
<p><img src="/images/img/20.jpg"></p>
<p>可以看到此时在0<del>1000Hz频段只有直流分量和1000Hz的正弦分量两个尖峰，但在0</del>8000Hz频段，由于方波实质上是不同频率的正弦信号的叠加，所以频谱会在基波的奇数倍（1、3、5……）处也有尖峰，但尖峰的幅值会远小于基波1000Hz处，且倍数越大幅值越小，这使得按照先前的算法也能识别出基波频率约为1000Hz。</p>
<h3 id="4、补充测试"><a href="#4、补充测试" class="headerlink" title="4、补充测试"></a>4、补充测试</h3><p>由于还需要对于基波频率在0~1000Hz范围内的任意输入信号进行频谱分析，经过调试后，当输入信号频率为200Hz时，为使得显示波形合理，将ADC环节设置的额外时钟周期由112调整至480，结果如下所示：</p>
<p>200Hz正弦波：</p>
<p>时域：</p>
<p><img src="/images/img/15.jpg"></p>
<p>频域：</p>
<p>短频段（0~1000Hz）：</p>
<p><img src="/images/img/6.jpg"></p>
<p>长频段（0~8000Hz）：</p>
<p><img src="/images/img/17.jpg"></p>
<p>200Hz方波：</p>
<p>时域：</p>
<p><img src="/images/img/18.jpg"></p>
<p>频域：</p>
<p>短频段（0~1000Hz）：</p>
<p><img src="/images/img/7.jpg"></p>
<p>长频段（0~8000Hz）：</p>
<p><img src="/images/img/14.jpg"></p>
<p>在ADC环节额外时钟周期设置为480的情况下，可以计算得出，对于频率为1000Hz的信号，一次采样（即屏幕内显示）包含21个周期（正好为整数），结果如下所示：</p>
<p>1000Hz正弦波：</p>
<p>时域：</p>
<p><img src="/images/img/4.jpg"></p>
<p>频域：</p>
<p>长频段（0~8000Hz）：</p>
<p><img src="/images/img/16.jpg"></p>
<p>1000Hz方波：</p>
<p>时域：</p>
<p><img src="/images/img/10.jpg"></p>
<p>频域：</p>
<p>长频段（0~8000Hz）：</p>
<p><img src="/images/img/5.jpg"></p>
<p>可以看到此时虽然时域上波形显示更加狭窄密集，但是频域上尖峰的变化过程也有了迅速的提升，且测得的基波频率也更加精准。</p>
<br>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>通过本次项目实践，不仅在实验中进一步加深了对于数字信号的产生、采集与频谱分析处理过程的理解，特别是通过期望发生信号频率去计算定时器分频系数、采样频率的计算过程以及FFT计算与频谱图像绘制的过程；而且也增加了对于STM32F407单片机开发的实战经验，在巩固了引脚GPIO与时钟配置相关内容的同时，又对于DMA内存搬运及其中断以及DAC数模转换输出与ADC模数转换输入等功能模块有了更深刻的认识，包括定时器对于这些过程的调控也涉及到相关频率的计算，所有模块的配置之间都有着密切的联系。</p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2023-06-24T21:56:58.000Z" title="2023/6/25 05:56:58">2023-06-25</time>发表</span><span class="level-item"><time datetime="2023-08-03T09:18:54.789Z" title="2023/8/3 17:18:54">2023-08-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95I/">定量工程设计方法I</a></span><span class="level-item">1 小时读完 (大约8636个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/25/QEA-Radar-Car/">小车路径规划</a></p><div class="content"><div id="postchat_postcontent"><p>本项目全部代码已同步上传至Github,仓库链接：<a target="_blank" rel="noopener" href="https://github.com/Asgard-Tim/Path-Planning">Asgard-Tim/Path-Planning: 重庆大学明月科创实验班定量工程设计方法课程项目 (github.com)</a></p>
<h4 id="一、设计要求"><a href="#一、设计要求" class="headerlink" title="一、设计要求"></a>一、设计要求</h4><hr>
<p>在本部分的课程项目中，要求我们运用LD14雷达扫描地图，在MATLAB中进行人工势场添加并对STM32小车进行路径规划，在一规定的场地中让小车避开两个矩形障碍物并以尽可能短的路径最终抵达圆形目标位置。</p>
<br>

<h4 id="二、系统方案"><a href="#二、系统方案" class="headerlink" title="二、系统方案"></a>二、系统方案</h4><hr>
<h5 id="2-1-移动底盘分析"><a href="#2-1-移动底盘分析" class="headerlink" title="2.1 移动底盘分析"></a><strong>2.1 移动底盘分析</strong></h5><p>小车为履带式小车，左右履带分别由一枚直流电机进行驱动，运动模式类似常规双轮小车，通过左右两枚电机转动的差速实现转向。该小车相对来说较为容易进行控制，只需要控制两个驱动轮的速度存在差异，即两轮差速，即可控制机器人实现无滑动摩擦的旋转，也可实现零半径转弯。</p>
<p><em>图2-1 双轮履带小车外观图</em></p>
<p><img src="/images/radarcar/2-1.jpg" alt="1"></p>
<p><em>图2-2 两轮差速式机器人运动学分析图</em></p>
<p><img src="/images/radarcar/2-2.png" alt="2"></p>
<p>对小车移动底盘的运动学分析（如上图2-2所示）：</p>
<p>小车的速度控制主要是控制 X 轴（前后方向）和 Z 轴（旋转方向）的速度， 以 Vx 和 Vz 来指代，单位分别是 m/s 和弧度/s。X 轴方向以前进记为正，Z 轴方向以右转记为正。车轮速度是使用编码器来计算和得出，读取编码器计数后再转化成车轮的速度。Vz则是通过左右电机转动的差速计算得到的。</p>
<p>图中参数分别代表：</p>
<p><img src="/images/radarcar/2-3.png" alt="3"></p>
<h5 id="2-2-电机特性分析"><a href="#2-2-电机特性分析" class="headerlink" title="2.2 电机特性分析"></a><strong>2.2 电机特性分析</strong></h5><p>在本次项目中，我们采用带有减速器与编码器的直流电机驱动小车前进。</p>
<p>直流电机的物理模型图如下图2-3所示。其中，固定部分有磁铁，这里称作主磁极；固定部分还有电刷。转动部分有环形铁心和绕在环形铁心上的绕组。 (其中 2 个小圆圈是为了方便表示该位置上的导体电势或电流的方向而设置的) 它的固定部分（定子）上，装设了一对直流励磁的静止的主磁极 N 和S，在旋转部分（转子）上装设电枢铁心。在电枢铁心上放置了两根导体连成的电枢线圈， 线圈的首端和末端分别连到两个圆弧形的铜片上，此铜片称为换向片。换向片之间 互相绝缘，由换向片构成的整体称为换向器。换向器固定在转轴上，换向片与转轴 之间亦互相绝缘。在换向片上放置着一对固定不动的电刷 B1 和 B2，当电枢旋转时，电枢线圈通过换向片和电刷与外电路接通。在电刷上施加直流电压 U,电枢线圈中的电流流向为：N 极下的有效边中的电流总是一个方向，而 S 极下的有效边中的电流总是另一个方向。这样两个有效边所受的洛伦兹力的方向一致（可以根据左手法则判定），电枢开始转动。具体来说就是，把上图中的+和-分别接到电池的正极和负极，电机即可转动；如果是把上图中的+和-分别接到电池的负极和正极，则电机会反方向转动。电机的转速可以理解为和外接的电压是正相关的（实际是由电枢电流决定）。</p>
<p>总而言之，如果我们可以调节施加在电机上面的直流电压大小，即可实现直流 电机调速，改变施加电机上面直流电压的极性，即可实现电机换向。</p>
<p><em>图2-3 直流电机的物理模型</em></p>
<p><img src="/images/radarcar/2-4.png" alt="4"></p>
<p>在具体的使用过程中，我们需要通过在特定的引脚之间（如本次项目所用电机为1/6引脚）接上一个直流电源，电机即可转动，且改变电压大小即可改变电机转速。接线方式说明如下图2-4所示。</p>
<p><img src="/images/radarcar/2-5.png" alt="5"></p>
<h5 id="2-3-电机控制策略以及PID特性分析"><a href="#2-3-电机控制策略以及PID特性分析" class="headerlink" title="2.3 电机控制策略以及PID特性分析"></a><strong>2.3 电机控制策略以及PID特性分析</strong></h5><p>小车电机驱动器芯片使用 AT8236，具有过流保护功能，并可设置电流阈值。驱动芯片只需两个逻辑输入，便可达到调速和正反转的功能，本小车中，每个电机使用两路PWM进行调速（实际上一个普通 IO 和一路 PWM 即可进行正反转 和调速）。</p>
<p>电机的速度使用 13 线霍尔编码器输出 AB 相进行测量，电机减速比为 1:30，使用 STM32 的编码器测量功能，并初始化为脉冲上升沿和下降沿都进行计数，可实现轮子转一圈输出 1560 个计数。</p>
<p>电机调速框图如下图2-5所示。</p>
<p><em>图2-5 电机调速框图</em></p>
<p><img src="/images/radarcar/2-6.png" alt="6"></p>
<p>基于2.1节提到的小车移动地盘的运动学分析，我们可以进一步讨论这些物理量之间的关系，并求出其运动学正逆解公式（如下图2-6），结合PID实现控制。</p>
<p><em>图2-6 两轮差速式机器人的运动学正逆解公式</em></p>
<p><img src="/images/radarcar/2-7.png" alt="7"></p>
<p><img src="/images/radarcar/2-8.png" alt="8"></p>
<p><img src="/images/radarcar/2-9.png" alt="9"></p>
<p><img src="/images/radarcar/2-10.png" alt="10"></p>
<p>下图2-7为PID的控制框图，每个方块代表控制系统的一个组成部分，从图中可看出系统中各组成部分的相互关系和影响，即 PID 调节系统是具有被调参数负反馈的闭环系统。当被控量 Y 受到干扰的影响而升高时，反馈信号将高于给定值 X，经过比较而到放大元件去的偏差信号 e 将为负值，控制器将发出信号而使执行元件动作，其作用方向为负，使被控量下降，这就达到了自动控制的目的。</p>
<p>图2-7中的目标速度一般我们可以通过按键或者开关等方式编程实现改变目标值，测量速度就是通过单片机定时去采集编码器的数据并清零。目标速度和测量速度之间做差这个就是目前系统的偏差。在控制过程中，需要将目标速度、测量速度与偏差三者送入 PID 控制器进行计算输出，然后再经过电机驱动的功率放大控制电机的转动去减小偏差，最终达到目标速度。</p>
<p><em>图2-7 PID控制框图</em></p>
<p><img src="/images/radarcar/2-11.png" alt="11"></p>
<p>对于上述PID控制的基于C语言的实现，我们给出以下代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">`<span class="type">int</span> <span class="title function_">Incremental_PI</span> <span class="params">(<span class="type">int</span> Encoder,<span class="type">int</span> Target)</span>` </span><br><span class="line"></span><br><span class="line">`{` </span><br><span class="line"></span><br><span class="line">`<span class="type">static</span> <span class="type">float</span> Bias,Pwm,Last_bias;` </span><br><span class="line"></span><br><span class="line">`Bias=Encoder-Target; <span class="comment">//计算偏差` </span></span><br><span class="line"></span><br><span class="line">`Pwm+=Velocity_KP*(Bias-Last_bias)+Velocity_KI*Bias;`</span><br><span class="line"></span><br><span class="line"> `<span class="comment">//增量式 PI 控制器` </span></span><br><span class="line"></span><br><span class="line">`Last_bias=Bias; <span class="comment">//保存上一次偏差` </span></span><br><span class="line"></span><br><span class="line">`<span class="keyword">return</span> Pwm; <span class="comment">//增量输出` </span></span><br><span class="line"></span><br><span class="line">`}`</span><br></pre></td></tr></tbody></table></figure>

<p>其中，入口参数为编码器的速度测量值和速度控制的目标值，返回值为电机控制 PWM。第一行是相关内部变量的定义。第二行是求出速度偏差，由测量值减去目标值。第三行使用增量 PI 控制器求出电机 PWM。第四行保存上一次偏差，便于下次调用。最后一行是返回。</p>
<h5 id="2-4-嵌入式控制系统总结分析"><a href="#2-4-嵌入式控制系统总结分析" class="headerlink" title="2.4 嵌入式控制系统总结分析"></a><strong>2.4 嵌入式控制系统总结分析</strong></h5><p>总体而言，我们基于小车本身的轮距等基本参数编写了一整套嵌入式PID控制流程与系统（基于C语言，面向STM32编程），结合PWM波控制电压，从而控制电机的转速以实现对于车轮速度的反馈调节机制，能够保证小车始终保持相对稳定的速度前进，便于后面进一步规划算法，使小车的运动更加可控。此部分编写的KEIL工程详见附件“PID.zip”。</p>
<h5 id="2-5-传感系统总结分析"><a href="#2-5-传感系统总结分析" class="headerlink" title="2.5 传感系统总结分析"></a><strong>2.5 传感系统总结分析</strong></h5><p>本次项目所采用的传感器主要为激光雷达，在此我们选用LD14雷达。LD14 主要由激光测距核心，无线传电单元，无线通讯单元，角度测量单元、电机驱动单元和机械外壳组成。LD14测距核心采用三角测量法技术，可进行每秒 2300 次的测距。每次测距时，LD14从一个固定的角度发射出红外激光，激光遇到目标物体后被反射到接收单元。通过激光、目标物体、接收单元形成的三角关系，从而解算出距离。获取到距离数据后，LD14 会融合角度测量单元测量到的角度值组成点云数据，再进行导出。</p>
<p>雷达扫描点云数据形式如下图2-8所示：</p>
<p><em>图2-8 雷达扫描点云极坐标数据形式（下图2数据为角度（角度制），右侧为距离）</em></p>
<p><img src="/images/radarcar/2-12.png" alt="12"></p>
<p><img src="/images/radarcar/2-13.png" alt="13"></p>
<p>在项目的实践过程中，我们需要通过对STM32单片机进行编程，从激光雷达读取数据并通过串口将处理后的数据传输至电脑中（用特定的软件读取串口输出信息）。STM32中烧录的KEIL工程见附件“Lidar.zip”，接线方式如下图所示。</p>
<p><em>图2-9 激光雷达与单片机接线方式对应</em></p>
<p><img src="/images/radarcar/2-14.png" alt="14"></p>
<p><img src="/images/radarcar/2-15.png" alt="15"></p>
<p>这里给出KEIL工程中main.c中的主干代码（图2-10），最终会输出数据θ和r,分别代表偏转的角度（AvoidData[i].angle）和距离原点的距离（AvoidData[i].distance）。</p>
<p><em>图2-10 读取激光雷达数据的主干代码</em></p>
<p><img src="/images/radarcar/2-16.png" alt="16"></p>
<br>

<h4 id="三、硬件电路设计"><a href="#三、硬件电路设计" class="headerlink" title="三、硬件电路设计"></a>三、硬件电路设计</h4><hr>
<p>主要运用模块电路图如下图3-1所示：</p>
<p><em>图3-1 主要模块电路图</em></p>
<p><img src="/images/radarcar/3-1.png" alt="17"></p>
<p>其中，小车的主控为STM32 F103RCT6芯片，其主控板实物图如下图3-2所示：</p>
<p><em>图3-2 STM32主控板实物图</em></p>
<p><img src="/images/radarcar/3-2.png" alt="18"></p>
<p>由于本次项目需要完成的目标较为单一，仅使用其中少部分接口和器件。</p>
<br>

<h4 id="四、软件算法设计"><a href="#四、软件算法设计" class="headerlink" title="四、软件算法设计"></a>四、软件算法设计</h4><hr>
<h5 id="4-1-任务描述"><a href="#4-1-任务描述" class="headerlink" title="4.1 任务描述"></a><strong>4.1 任务描述</strong></h5><p>在本项目中，我们需要通过激光雷达对于小车所处的地图环境（2m*2m，放置有三个正方体障碍物与一个圆柱体目标物）进行扫描，并对扫描得到的数据结果进行处理。通过一定的算法对于目标物与障碍物进行识别后，我们还需要通过人工势场法进行路径规划，使得小车能够以最优的路径绕开障碍物到达目标物。</p>
<p>本次项目任务分为静态和动态两个部分，其中动态测试过程中会对障碍物的位置进行人为的随机改动。测试过程中，小车的起点位置与目标物的位置始终不变，且可自由选定小车的初始面对方向。</p>
<h5 id="4-2-技术路径和策略"><a href="#4-2-技术路径和策略" class="headerlink" title="4.2 技术路径和策略"></a><strong>4.2 技术路径和策略</strong></h5><p>通过对于任务描述的分析，我们大致可以将静态情况下的路径规划问题拆解为以下几个部分，并给出相应的处理工具与解决策略：</p>
<ul>
<li>（1） 地图扫描：需要通过对STM32单片机进行编程（利用软件工具KEIL），利用串口通信读取激光雷达扫描所获取的周围地图环境点云的极坐标数据</li>
<li>（2） 处理数据：将串口所得到的数据导入MATLAB中，利用坐标变换将不同点位扫描的极坐标数据统一到同一个笛卡尔坐标系中以便后续处理与识别</li>
<li>（3） 识别物体：在获取扫描后得到的地图后，需要利用RANSAC算法（随机抽样一致算法）识别点云数据中的直线与圆形，并得到相应的障碍物与目标物的二维坐标</li>
<li>（4） 路径规划：在MATLAB中编程，利用得到的出发点、障碍物和目标点各自的坐标建立势场，并用梯度下降法寻找避开障碍物、到达目标点的最优路径</li>
</ul>
<p>实际上，在动态情况下的路径规划问题中，实现的步骤也与上述大致相同，只是并没有MABLAB等电脑端的辅助软件帮助其进行数据处理与路径规划，需要将这些算法通过对STM32单片机编程集成到小车上，从而实现在测试地图环境随机发生改变的情况下仍然能够按照局部最优的路线避开障碍物到达目标点。</p>
<br>

<h5 id="4-3-核心程序逻辑"><a href="#4-3-核心程序逻辑" class="headerlink" title="4.3 核心程序逻辑"></a><strong>4.3 核心程序逻辑</strong></h5><h6 id="4-3-1-激光雷达极坐标点云数据的处理与变换——得到二维地图"><a href="#4-3-1-激光雷达极坐标点云数据的处理与变换——得到二维地图" class="headerlink" title="4.3.1 激光雷达极坐标点云数据的处理与变换——得到二维地图"></a>4.3.1 激光雷达极坐标点云数据的处理与变换——得到二维地图</h6><p>在2.5节，我们给出了我们的KEIL工程。通过将其烧入至STM32内，并按照特定接线方式将激光雷达与主控板连接，利用串口通信及相关软件成功在电脑上读取了激光雷达扫描得到的点云极坐标数据（如图2-8右图）。在实际测试时，我们选取了五个坐标点分别放置小车（控制朝向相同）对周围地图环境进行扫描，获得了“data1.txt”等一系列数据文件（详见附件）。</p>
<p>在MATLAB程序的第一部分，我们首先利用importdata函数从数据文本文件中读取相应数据，并将其按列分割为“angle”和“distance”两部分。随后，我们利用MATLAB中自带的坐标变换函数pol2cart将一系列的极坐标数据转换为笛卡尔坐标系下的x-y数据（算法原理如下图4-1）。事实上，由于小车每次扫描的位置均不同，因此还需要将多次扫描的结果结合每次小车放置位置的坐标进行一系列的拼接与变换，才可得到最终的场地二维地图（效果如下图4-2）。</p>
<p><em>图4-1 利用pol2cart函数进行坐标变换的原理示意图</em></p>
<p><img src="/images/radarcar/4-1.png" alt="19"></p>
<p><em>图4-2 经拼接后得到的场地二维地图</em></p>
<p><img src="/images/radarcar/4-2.png" alt="20"></p>
<p>该部分的代码给出如下：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">%Step1:处理激光雷达扫描数据，绘制二维坐标系地图`</span></span><br><span class="line"></span><br><span class="line">`<span class="built_in">ans</span>=importdata(<span class="string">"data1.txt"</span>);`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">angle</span>=<span class="built_in">ans</span>(:,<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">angle</span>=<span class="built_in">angle</span>.*<span class="number">2.</span>*<span class="number">3.1415926</span>./<span class="number">360</span>;`</span><br><span class="line"></span><br><span class="line">`distance=<span class="built_in">ans</span>(:,<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">`[x,y] = <span class="built_in">pol2cart</span>(<span class="built_in">angle</span>,distance);`</span><br><span class="line"></span><br><span class="line">`ans1=importdata(<span class="string">"data2.txt"</span>);`</span><br><span class="line"></span><br><span class="line">`angle1=ans1(:,<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">`angle1=angle1.*<span class="number">2.</span>*<span class="number">3.1415926</span>./<span class="number">360</span>;`</span><br><span class="line"></span><br><span class="line">`distance1=ans1(:,<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">`[x1,y1] = <span class="built_in">pol2cart</span>(angle1,distance1);`</span><br><span class="line"></span><br><span class="line">`ans2=importdata(<span class="string">"data3.txt"</span>);`</span><br><span class="line"></span><br><span class="line">`angle2=ans2(:,<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">`angle2=angle2.*<span class="number">2.</span>*<span class="number">3.1415926</span>./<span class="number">360</span>;`</span><br><span class="line"></span><br><span class="line">`distance2=ans2(:,<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">`[x2,y2] = <span class="built_in">pol2cart</span>(angle2,distance2);`</span><br><span class="line"></span><br><span class="line">`ans3=importdata(<span class="string">"data4.txt"</span>);`</span><br><span class="line"></span><br><span class="line">`angle3=ans3(:,<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">`angle3=angle3.*<span class="number">2.</span>*<span class="number">3.1415926</span>./<span class="number">360</span>;`</span><br><span class="line"></span><br><span class="line">`distance3=ans3(:,<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">`[x3,y3] = <span class="built_in">pol2cart</span>(angle3,distance3);`</span><br><span class="line"></span><br><span class="line">`ans5=importdata(<span class="string">"data5.txt"</span>);`</span><br><span class="line"></span><br><span class="line">`angle5=ans5(:,<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">`angle5=angle5.*<span class="number">2.</span>*<span class="number">3.1415926</span>./<span class="number">360</span>;`</span><br><span class="line"></span><br><span class="line">`distance5=ans5(:,<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">`[x5,y5] = <span class="built_in">pol2cart</span>(angle5,distance5);`</span><br><span class="line"></span><br><span class="line">`x4 = [x;x1<span class="number">-100</span>;x2+<span class="number">1850</span>;x3+<span class="number">1400</span>;x5+<span class="number">1500</span>]/<span class="number">100</span>;`</span><br><span class="line"></span><br><span class="line">`y4 = [y;y1+<span class="number">1750</span>;y2+<span class="number">100</span>;y3+<span class="number">1650</span>;y5+<span class="number">1000</span>]/<span class="number">100</span>;`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">figure</span>(<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">scatter</span>(x4,y4,<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">hold</span> on`</span><br><span class="line"></span><br><span class="line">`axis equal`</span><br><span class="line"></span><br><span class="line">`axis( [ <span class="number">-3</span>, <span class="number">22</span>, <span class="number">-3</span>, <span class="number">22</span> ] )`</span><br></pre></td></tr></tbody></table></figure>

<h6 id="4-3-2-利用RANSAC算法识别地图中的直线和圆——获得目标点与障碍物的坐标"><a href="#4-3-2-利用RANSAC算法识别地图中的直线和圆——获得目标点与障碍物的坐标" class="headerlink" title="4.3.2 利用RANSAC算法识别地图中的直线和圆——获得目标点与障碍物的坐标"></a>4.3.2 利用RANSAC算法识别地图中的直线和圆——获得目标点与障碍物的坐标</h6><p>在成功利用激光雷达的扫描数据建立了二维地图后，我们需要让机器人知道哪里能走哪里不能走，要走向哪里，即明确目标点以及障碍物的具体坐标。在本测试项目中，设定圆柱为目标物而正方体为障碍物，所以问题的关键即为如何从二维地图中识别出圆形以及正方形（本质上为直线的拼接）并获得其坐标。</p>
<p>在之前的课程中，介绍了RANSAC这一算法。随机样本一致性(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Random_sample_consensus">Random Sample Consensus RANSAC</a>) 是一种迭代方法，用于从包含异常值的观察数据中估计出数学模型参数，因此也可以理解为一种异常值检测方法。RANSAC的一个基本假设是，数据由内点(“inliers”)和外点(“outliers”)组成，其中内点是在一定误差范围内可以通过一些模型参数来解释的数据，外点是不符合模型的数据。RANSAC的另一个假设是，随机选取的样本数据都是内点，存在一个可以估计模型参数的过程，该模型可以最佳地解释或拟合该数据。通过该算法，我们可以有效地从已有的地图（本质上是二维坐标系下的点集数据）中拟合出直线与圆的轮廓，并获取相应图形的对应坐标。</p>
<p>该算法的实现步骤如下：</p>
<p>（1） 从原始数据集S中随机选择子集s，s为假设的内点(子集s一般为最小子集，如：直线选取两个点，圆选择三个点)</p>
<p>（2） 依据子集s估计模型参数</p>
<p>（3） 遍历数据集S中除子集s外的所有数据，如果数据点在给定误差e以内，则标记为内点，否则标记为外点</p>
<p>（4）所有内点组成一致集，如果一致集中点的个数满足给定阈值T，则用一致集中所有内点重新估计模型参数，然后结束算法</p>
<p>（5）如果一致集中内点个数少于阈值T，则重新选择新的子集s，并重复步骤（1）-（4）</p>
<p>（6） 经过K次迭代，选择一个内点数量最多的一致集，用一致集中所有内点重新估计模型参数，然后结束算法</p>
<p>基于上述基本思想与步骤，我们编写了一段MATLAB代码，用于二维坐标地图中直线的识别与拟合。在此基础之上，我们根据算法原理，从点集中随机取出三个点，利用三点成圆获得圆的方程（利用自己编写的函数ThreePoint2Circle）。再对圆的轨迹赋予一个宽度，统计落入这个宽度中的点的数量，对所有的点进行逐个取点，获得最优的圆的方程。值得注意的是，由于待识别的正方形是由多条直边构成，这要求我们需要重复对于该图像进行扫描拟合，且需要在一次拟合之后将该次拟合中涉及的数据点删除以防影响下次拟合。下面将给出这一部分的代码实现以及拟合效果（如图4-3、4-4）。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">%Step2:利用RANSAC算法识别直线和圆`</span></span><br><span class="line"></span><br><span class="line">`<span class="comment">%(1)圆的识别`</span></span><br><span class="line"></span><br><span class="line">`a = [x4,y4];`</span><br><span class="line"></span><br><span class="line">`<span class="comment">% RANSCA参数：`</span></span><br><span class="line"></span><br><span class="line">`<span class="comment">% 迭代次数`</span></span><br><span class="line"></span><br><span class="line">`iter = <span class="number">0</span>;`</span><br><span class="line"></span><br><span class="line">`<span class="comment">% 查看圆数据的大小`</span></span><br><span class="line"></span><br><span class="line">`[m,n] = <span class="built_in">size</span>(a);`</span><br><span class="line"></span><br><span class="line">`<span class="comment">% 误差参数`</span></span><br><span class="line"></span><br><span class="line">`berr = <span class="number">0.02</span>;`</span><br><span class="line"></span><br><span class="line">`<span class="comment">% 拟合参数`</span></span><br><span class="line"></span><br><span class="line">`bfit = [];`</span><br><span class="line"></span><br><span class="line">`<span class="comment">% 内点个数为点数的1/3`</span></span><br><span class="line"></span><br><span class="line">`t = <span class="built_in">floor</span>(m/<span class="number">3</span>);`</span><br><span class="line"></span><br><span class="line">`<span class="comment">% 开始循环迭代`</span></span><br><span class="line"></span><br><span class="line">`<span class="keyword">while</span> iter&lt;<span class="number">100</span>`</span><br><span class="line"></span><br><span class="line">  `<span class="comment">% 随机挑选三个点，三个点不重复`</span></span><br><span class="line"></span><br><span class="line">  `<span class="comment">% 拟合圆最少需要三个点，拟合直线最少需要两个`</span></span><br><span class="line"></span><br><span class="line">  `<span class="comment">% ran为索引编号`</span></span><br><span class="line"></span><br><span class="line">  `ran = randperm(m,<span class="number">3</span>)';`</span><br><span class="line"></span><br><span class="line">  `<span class="comment">% b为索引得到的点`</span></span><br><span class="line"></span><br><span class="line">  `b = a(ran,:);`</span><br><span class="line"></span><br><span class="line">  `<span class="comment">% 根据随机得到的三个点，计算圆的半径和圆心`</span></span><br><span class="line"></span><br><span class="line">  `[r1,p1] = ThreePoint2Circle(b(<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>), b(<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>), b(<span class="number">3</span>,<span class="number">1</span>:<span class="number">2</span>));`</span><br><span class="line"></span><br><span class="line">  `<span class="comment">% 选择除了随机得到的三个点外的其他点`</span></span><br><span class="line"></span><br><span class="line">  `c = setdiff(a,b,<span class="string">"rows"</span>);`</span><br><span class="line"></span><br><span class="line">  `<span class="comment">% 计算每个点到圆心的距离dis`</span></span><br><span class="line"></span><br><span class="line">  `dis = <span class="built_in">sqrt</span>(sum((c(:,<span class="number">1</span>:<span class="number">2</span>)-p1).^<span class="number">2</span>,<span class="number">2</span>));`</span><br><span class="line"></span><br><span class="line">  `<span class="comment">% 计算 dis和拟合圆的误差`</span></span><br><span class="line"></span><br><span class="line">  `res = dis - r1;`</span><br><span class="line"></span><br><span class="line">  `<span class="comment">% 选择小于误差的点，进入到内点中`</span></span><br><span class="line"></span><br><span class="line">  `d = c(res&lt;berr,:);`</span><br><span class="line"></span><br><span class="line">  `len = <span class="built_in">length</span>(d(:,<span class="number">1</span>));`</span><br><span class="line"></span><br><span class="line">  `<span class="comment">% 判断内点数量是否满足条件`</span></span><br><span class="line"></span><br><span class="line">  `<span class="keyword">if</span> len &gt; t`</span><br><span class="line"></span><br><span class="line">​    `<span class="comment">% 满足条件时，多点拟合圆，这里用平均值计算圆心`</span></span><br><span class="line"></span><br><span class="line">​    `p = <span class="built_in">mean</span>(d);`</span><br><span class="line"></span><br><span class="line">​    `r = <span class="built_in">mean</span>(<span class="built_in">sqrt</span>(sum((d(:,<span class="number">1</span>:<span class="number">2</span>)-p(:,<span class="number">1</span>:<span class="number">2</span>)).^<span class="number">2</span>,<span class="number">2</span>)));`</span><br><span class="line"></span><br><span class="line">​    `<span class="comment">% 多点拟合的圆和随机点拟合的圆的误差`</span></span><br><span class="line"></span><br><span class="line">​    `err = <span class="built_in">sqrt</span>(sum((p-p1).^<span class="number">2</span>))+<span class="built_in">sqrt</span>((r-r1)^<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">​    `<span class="comment">% 如果误差满足条件，则可以结束循环`</span></span><br><span class="line"></span><br><span class="line">​    `<span class="comment">% 不满足则继续`</span></span><br><span class="line"></span><br><span class="line">​    `<span class="keyword">if</span> err &lt; berr`</span><br><span class="line"></span><br><span class="line">​      `bfit = [p,r];`</span><br><span class="line"></span><br><span class="line">​      `berr = err;`</span><br><span class="line"></span><br><span class="line">​      `<span class="keyword">break</span>`</span><br><span class="line"></span><br><span class="line">​    `<span class="keyword">else</span>`</span><br><span class="line"></span><br><span class="line">​      `iter = iter+<span class="number">1</span>;`</span><br><span class="line"></span><br><span class="line">​       `<span class="keyword">continue</span>`</span><br><span class="line"></span><br><span class="line">​    `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">  `<span class="keyword">else</span>`</span><br><span class="line"></span><br><span class="line">​    `iter = iter+<span class="number">1</span>;`</span><br><span class="line"></span><br><span class="line">  `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">`<span class="comment">%绘图`</span></span><br><span class="line"></span><br><span class="line">`para = [p(<span class="number">1</span>)-r, p(<span class="number">2</span>)-r, <span class="number">2</span>*r, <span class="number">2</span>*r];`</span><br><span class="line"></span><br><span class="line">`rectangle(<span class="string">'Position'</span>, para, <span class="string">'Curvature'</span>, [<span class="number">1</span> <span class="number">1</span>]);` </span><br><span class="line"></span><br><span class="line">`<span class="comment">%（2）直线的识别`</span></span><br><span class="line"></span><br><span class="line">`iter = <span class="number">100</span>;`</span><br><span class="line"></span><br><span class="line">`data1=transpose(x4);`</span><br><span class="line"></span><br><span class="line">`data2=transpose(y4);`</span><br><span class="line"></span><br><span class="line">`data=[data1;data2];`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">for</span> t=<span class="number">1</span>:<span class="number">10</span>`</span><br><span class="line"></span><br><span class="line"> `number = <span class="built_in">size</span>(data,<span class="number">2</span>); <span class="comment">% 总点数`</span></span><br><span class="line"></span><br><span class="line"> `bestParameter1=<span class="number">0</span>; bestParameter2=<span class="number">0</span>; <span class="comment">% 最佳匹配的参数`</span></span><br><span class="line"></span><br><span class="line"> `sigma = <span class="number">1</span>;`</span><br><span class="line"></span><br><span class="line"> `pretotal=<span class="number">0</span>;   <span class="comment">%符合拟合模型的数据的个数`</span></span><br><span class="line"></span><br><span class="line"> `<span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:iter`</span><br><span class="line"></span><br><span class="line"> `<span class="comment">%随机选择两个点`</span></span><br><span class="line"></span><br><span class="line">   `idx = randperm(number,<span class="number">2</span>);` </span><br><span class="line"></span><br><span class="line">   `sample = data(:,idx);` </span><br><span class="line"></span><br><span class="line">   `<span class="comment">%拟合直线方程 y=kx+b`</span></span><br><span class="line"></span><br><span class="line">   `line = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">3</span>);`</span><br><span class="line"></span><br><span class="line">   `x = sample(:, <span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">   `y = sample(:, <span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">   `k=(y(<span class="number">1</span>)-y(<span class="number">2</span>))/(x(<span class="number">1</span>)-x(<span class="number">2</span>));   <span class="comment">%直线斜率`</span></span><br><span class="line"></span><br><span class="line">   `b = y(<span class="number">1</span>) - k*x(<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">   `line = [k <span class="number">-1</span> b];`</span><br><span class="line"></span><br><span class="line">   `mask=<span class="built_in">abs</span>(line*[data; <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">size</span>(data,<span class="number">2</span>))]);  <span class="comment">%求每个数据到拟合直线的距离`</span></span><br><span class="line"></span><br><span class="line">   `total=sum(mask&lt;sigma);       <span class="comment">%计算数据距离直线小于一定阈值的数据的个数`</span></span><br><span class="line"></span><br><span class="line">   `<span class="keyword">if</span> total&gt;pretotal      <span class="comment">%找到符合拟合直线数据最多的拟合直线`</span></span><br><span class="line"></span><br><span class="line">​     `pretotal=total;`</span><br><span class="line"></span><br><span class="line">​     `bestline=line;     <span class="comment">%找到最好的拟合直线`</span></span><br><span class="line"></span><br><span class="line">  `<span class="keyword">end</span>` </span><br><span class="line"></span><br><span class="line"> `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">`<span class="comment">%显示符合最佳拟合的数据`</span></span><br><span class="line"></span><br><span class="line"> `mask=<span class="built_in">abs</span>(bestline*[data; <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">size</span>(data,<span class="number">2</span>))])&lt;sigma;`  </span><br><span class="line"></span><br><span class="line"> `<span class="built_in">hold</span> on;`</span><br><span class="line"></span><br><span class="line"> `k=<span class="number">1</span>;`</span><br><span class="line"></span><br><span class="line"> `index=[];`</span><br><span class="line"></span><br><span class="line"> `<span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(mask)`</span><br><span class="line"></span><br><span class="line">  `<span class="keyword">if</span> mask(<span class="built_in">i</span>)`</span><br><span class="line"></span><br><span class="line">​    `inliers(<span class="number">1</span>,k) = data(<span class="number">1</span>,<span class="built_in">i</span>);`</span><br><span class="line"></span><br><span class="line">​    `k=k+<span class="number">1</span>;`</span><br><span class="line"></span><br><span class="line">​    `index=[index <span class="built_in">i</span>];`</span><br><span class="line"></span><br><span class="line">  `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line"> `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line"> `<span class="comment">%删除完成拟合的点以进行下一次拟合`</span></span><br><span class="line"></span><br><span class="line"> `<span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(index)`</span><br><span class="line"></span><br><span class="line">  `data(:,index(<span class="built_in">i</span>))=[];`</span><br><span class="line"></span><br><span class="line">  `<span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">length</span>(index)`</span><br><span class="line"></span><br><span class="line">​    `<span class="keyword">if</span>(index(<span class="built_in">j</span>)&gt;index(<span class="built_in">i</span>))`</span><br><span class="line"></span><br><span class="line">​      `index(<span class="built_in">j</span>)=index(<span class="built_in">j</span>)<span class="number">-1</span>;`</span><br><span class="line"></span><br><span class="line">​    `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">  `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line"> `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line"> `<span class="comment">% 绘制最佳匹配曲线`</span></span><br><span class="line"></span><br><span class="line"> `bestParameter1 = -bestline(<span class="number">1</span>)/bestline(<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line"> `bestParameter2 = -bestline(<span class="number">3</span>)/bestline(<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line"> `xAxis = <span class="built_in">min</span>(inliers(<span class="number">1</span>,:)):<span class="built_in">max</span>(inliers(<span class="number">1</span>,:));`</span><br><span class="line"></span><br><span class="line"> `yAxis = bestParameter1*xAxis + bestParameter2;`</span><br><span class="line"></span><br><span class="line"> `<span class="built_in">plot</span>(xAxis,yAxis,<span class="string">'r-'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">`<span class="function"><span class="keyword">function</span> <span class="params">[R,P0]</span> = <span class="title">ThreePoint2Circle</span><span class="params">(P1, P2, P3)</span>`</span></span><br><span class="line"></span><br><span class="line">`<span class="comment">%% 求圆心和半径，三个点可以求圆心和半径`</span></span><br><span class="line"></span><br><span class="line">  `x1 = P1(<span class="number">1</span>);  x2 = P2(<span class="number">1</span>);  x3 = P3(<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">  `y1 = P1(<span class="number">2</span>);  y2 = P2(<span class="number">2</span>);  y3 = P3(<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">  `z1 = x2^<span class="number">2</span> + y2^<span class="number">2</span> - x1^<span class="number">2</span> - y1^<span class="number">2</span>;`</span><br><span class="line"></span><br><span class="line">  `z2 = x3^<span class="number">2</span> + y3^<span class="number">2</span> - x1^<span class="number">2</span> - y1^<span class="number">2</span>;`</span><br><span class="line"></span><br><span class="line">  `z3 = x3^<span class="number">2</span> + y3^<span class="number">2</span> - x2^<span class="number">2</span> - y2^<span class="number">2</span>;`</span><br><span class="line"></span><br><span class="line">  `A = [(x2-x1), (y2-y1); (x3-x1), (y3-y1); (x3-x2), (y3-y2)];`</span><br><span class="line"></span><br><span class="line">  `B = <span class="number">0.5</span>*[z1; z2; z3];`</span><br><span class="line"></span><br><span class="line">  `P0 = (A'*A)\A'*B;`</span><br><span class="line"></span><br><span class="line">  `R1 = <span class="built_in">sqrt</span>( (P0(<span class="number">1</span>) - P1(<span class="number">1</span>))^<span class="number">2</span> + (P0(<span class="number">2</span>) - P1(<span class="number">2</span>))^<span class="number">2</span> );`</span><br><span class="line"></span><br><span class="line">  `R2 = <span class="built_in">sqrt</span>( (P0(<span class="number">1</span>) - P2(<span class="number">1</span>))^<span class="number">2</span> + (P0(<span class="number">2</span>) - P2(<span class="number">2</span>))^<span class="number">2</span> );`</span><br><span class="line"></span><br><span class="line">  `R3 = <span class="built_in">sqrt</span>( (P0(<span class="number">1</span>) - P3(<span class="number">1</span>))^<span class="number">2</span> + (P0(<span class="number">2</span>) - P3(<span class="number">2</span>))^<span class="number">2</span> );`</span><br><span class="line"></span><br><span class="line">  `R = (R1 + R2 + R3)/<span class="number">3</span>;`</span><br><span class="line"></span><br><span class="line">  `P0 = P0';`</span><br><span class="line"></span><br><span class="line">`End`</span><br></pre></td></tr></tbody></table></figure>

<p><em>图4-3（上） 对于二维地图中一条直线的拟合（红线为拟合结果）</em></p>
<p><em>（可以看到拟合效果相对良好）</em></p>
<p>  <img src="/images/radarcar/4-3.png" alt="21"></p>
<p><em>图4-4（右） 对于给定圆坐标数据的RANSAC拟合（上图为给定的圆，下图为拟合出的圆）</em></p>
<p><em>（说明该算法实现的有效性）</em></p>
<p><img src="/images/radarcar/4-4.png" alt="22"></p>
<h6 id="4-3-3-建立势场并利用梯度下降法确定最优路径（人工势场法）"><a href="#4-3-3-建立势场并利用梯度下降法确定最优路径（人工势场法）" class="headerlink" title="4.3.3 建立势场并利用梯度下降法确定最优路径（人工势场法）"></a>4.3.3 建立势场并利用梯度下降法确定最优路径（人工势场法）</h6><p>人工势场法引入了物理中斥力场和引力场的思想，把工作环境抽象为一个电磁场，而机器人则是其中的一个电荷，机器人在磁场力的作用下移动。人工势场法会在障碍物周围构建斥力场、在目标点周围构建引力场；这样，机器人便能够在斥力场和引力场的作用下向目标点移动。同时，当障碍物和目标点太近时，机器人很可能会因为刹不住车而出现无法到达目标点等问题，这也就出现了一堆相应的优化算法。</p>
<p>通过利用RANSAC算法对于地图中具有特定形状的边界、障碍物与目标物进行识别，我们成功获得了障碍物与目标点的坐标。在此基础之上，我们基于原型函数<img src="/images/radarcar/4-5.png" alt="23">（a,b即为障碍物/目标点的x,y坐标）建立势场。通过观察不难发现，在以（a,b）为圆心、半径为1的圆之外的地方该势函数均为正，反之为负。事实上，对于场地内的3个障碍物以及1个目标物而言，所形成的是一个叠加场，由原型函数作用于不同的点叠加而成。在此，我们不妨认为势场为正处具有排斥力而势场为负处具有吸引力，需要吸引小车向目标点走去而花费尽量少的能量。在这样的算法理念基础上，我们需要在代表目标点的原型函数部分加上负号；更进一步的，我们还希望这个吸引力足够大而防止被障碍物阻断，因此在建立势场时，不妨在代表目标点的原型函数前乘上一定的系数以保证其足够强大的吸引力。最终，我们根据地图实际情况，建立了整个势场叠加后的函数方程：F=log(sqrt((x-4.75).^2+(y-12.5).^2))+log(sqrt((x-12).^2+(y-7.6).^2))+log(sqrt((x-11.2).^2+(y-13).^2))-5*log(sqrt((x-16.5).^2+(y-18.5).^2))，并根据该函数绘制了势能图（如图4-5）与等势线图（如图4-6)。</p>
<p><em>图4-5 势场函数势能图</em></p>
<p><img src="/images/radarcar/4-6.png" alt="24"></p>
<p><em>图4-6 势场函数等势线图</em></p>
<p><img src="/images/radarcar/4-7.png" alt="25"></p>
<p>该部分代码如下：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">%Step3:通过识别得到的障碍物和目标坐标建立势场`</span></span><br><span class="line"></span><br><span class="line">`v=<span class="number">-2</span>:<span class="number">1</span>:<span class="number">22</span>;`</span><br><span class="line"></span><br><span class="line">`[x,y]=<span class="built_in">meshgrid</span>(v);`</span><br><span class="line"></span><br><span class="line">`F=<span class="built_in">log</span>(<span class="built_in">sqrt</span>((x<span class="number">-4.75</span>).^<span class="number">2</span>+(y<span class="number">-12.5</span>).^<span class="number">2</span>))+<span class="built_in">log</span>(<span class="built_in">sqrt</span>((x<span class="number">-12</span>).^<span class="number">2</span>+(y<span class="number">-7.6</span>).^<span class="number">2</span>))+<span class="built_in">log</span>(<span class="built_in">sqrt</span>((x<span class="number">-11.2</span>).^<span class="number">2</span>+(y<span class="number">-13</span>).^<span class="number">2</span>))<span class="number">-5</span>*<span class="built_in">log</span>(<span class="built_in">sqrt</span>((x<span class="number">-16.5</span>).^<span class="number">2</span>+(y<span class="number">-18.5</span>).^<span class="number">2</span>));`</span><br><span class="line"></span><br><span class="line">`[px,py]=gradient(F,<span class="number">1</span>,<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">`contour(x,y,F);`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">hold</span> on;`</span><br><span class="line"></span><br><span class="line">`title(<span class="string">'人工势场法路径规划'</span>);`</span><br><span class="line"></span><br><span class="line">`quiver(x,y,px,py,<span class="number">0</span>);`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">figure</span>(<span class="number">2</span>);`</span><br><span class="line"></span><br><span class="line">`surf(x,y,-F);`</span><br></pre></td></tr></tbody></table></figure>

<p>在建立完势场之后，由于我们需要寻找的是避开障碍物而通往目标点的最优路径，实际上即为所耗费能量最少的路径，我们引入了梯度下降法，通过间隔相同距离的不断迭代，在每一处都寻找能量下降最快的方向（即为梯度方向）前进（在MATLAB中通过调用函数文件path_plan.m与computP.m实现该功能），最终得到了如下图4-7绿色线所示的最优路径。</p>
<p><em>图4-7 人工势场法路径规划结果（绿色即为规划出的最优路径）</em></p>
<p><img src="/images/radarcar/4-8.png" alt="26"></p>
<p>其中，path_plan函数是整个算法过程中的关键，也是梯度下降思想的集中体现，其大致实现思路流程如下：</p>
<p>1）起点、终点 、障碍物、迭代次数、取点半径等参数的设定</p>
<p>2）以起点为中心，作半径为r的圆，从圆上取八个均布的点</p>
<p>3）分别计算八个点的前进“代价”—— 终点对其的引力+所有障碍物对其的斥力</p>
<p>4）取“代价”最小的点的坐标，结合现有起点，计算得到新的起点，然后重复上述内容</p>
<p>5）当发现 一个点距离终点很近 or 迭代的次数计算完 程序停止。</p>
<p>该部分的实现代码如下：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">%Step4:通过人工势场法确定最优路径`</span></span><br><span class="line"></span><br><span class="line">`axis([<span class="number">-3</span> <span class="number">22</span> <span class="number">-3</span> <span class="number">22</span>]);`</span><br><span class="line"></span><br><span class="line">`begin=[<span class="number">0</span>;<span class="number">0</span>]<span class="comment">%起始点坐标`</span></span><br><span class="line"></span><br><span class="line">`over=[<span class="number">16.5</span>;<span class="number">18.5</span>];<span class="comment">%目标点坐标`</span></span><br><span class="line"></span><br><span class="line">`<span class="built_in">figure</span>(<span class="number">1</span>);`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">hold</span> on;`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">plot</span>(begin(<span class="number">1</span>),begin(<span class="number">2</span>),<span class="string">'*b'</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span>);`</span><br><span class="line"></span><br><span class="line">`<span class="built_in">plot</span>(over(<span class="number">1</span>),over(<span class="number">2</span>),<span class="string">'*b'</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span>);`</span><br><span class="line"></span><br><span class="line">`obstacle=[<span class="number">4.75</span>,<span class="number">12</span>,<span class="number">11.35</span>;<span class="number">12.75</span>,<span class="number">7.5</span>,<span class="number">12</span>];<span class="comment">%障碍物坐标`</span></span><br><span class="line"></span><br><span class="line">`point= path_plan(begin,over,obstacle);`</span><br><span class="line"></span><br><span class="line">`<span class="function"><span class="keyword">function</span> <span class="params">[ point ]</span> = <span class="title">path_plan</span><span class="params">(begin,over,obstacle)</span>`</span></span><br><span class="line"></span><br><span class="line">`iters=<span class="number">1</span>; <span class="comment">%迭代次数`</span></span><br><span class="line"></span><br><span class="line">`curr=begin;`</span><br><span class="line"></span><br><span class="line">`testR=<span class="number">0.1</span>;  <span class="comment">%测试8点的圆的半径为0.1`</span></span><br><span class="line"></span><br><span class="line">`<span class="keyword">while</span> (norm(curr-over)&gt;<span class="number">0.2</span>) &amp;&amp; (iters&lt;=<span class="number">2000</span>)`</span><br><span class="line"></span><br><span class="line">  `point(:,iters)=curr;`</span><br><span class="line"></span><br><span class="line">`<span class="comment">%   attr=attractive(curr,over);`</span></span><br><span class="line"></span><br><span class="line">`<span class="comment">%   repu=repulsion(curr,obstacle);`</span></span><br><span class="line"></span><br><span class="line">`<span class="comment">%curoutput=computP(curr,over,obstacle);`</span></span><br><span class="line"></span><br><span class="line">  `<span class="comment">%计算当前点附近半径为0.2的8个点的势能，然后让当前点的势能减去8个点的势能取差值最大的，确定这个方向，就是下一步迭代的点`</span></span><br><span class="line"></span><br><span class="line">  `<span class="comment">%先求这八个点的坐标`</span></span><br><span class="line"></span><br><span class="line">  `<span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">8</span>    testPoint(:,<span class="built_in">i</span>)=[testR*<span class="built_in">sin</span>((<span class="built_in">i</span><span class="number">-1</span>)*<span class="built_in">pi</span>/<span class="number">4</span>)+curr(<span class="number">1</span>);testR*<span class="built_in">cos</span>((<span class="built_in">i</span><span class="number">-1</span>)*<span class="built_in">pi</span>/<span class="number">4</span>)+curr(<span class="number">2</span>)];`</span><br><span class="line"></span><br><span class="line">​    `testOut(:,<span class="built_in">i</span>)=computP(testPoint(:,<span class="built_in">i</span>),over,obstacle);`</span><br><span class="line"></span><br><span class="line">​    `<span class="comment">%找出来最小的就可以了`</span></span><br><span class="line"></span><br><span class="line">  `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">  `[temp num]=<span class="built_in">min</span>(testOut);`</span><br><span class="line"></span><br><span class="line">  `<span class="comment">%迭代的距离为0.1`</span></span><br><span class="line"></span><br><span class="line">  `curr=(curr+testPoint(:,num))/<span class="number">2</span>;`</span><br><span class="line"></span><br><span class="line">  `<span class="built_in">plot</span>(curr(<span class="number">1</span>),curr(<span class="number">2</span>),<span class="string">'og'</span>);`</span><br><span class="line"></span><br><span class="line">  `iters=iters+<span class="number">1</span>;`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">`<span class="function"><span class="keyword">function</span> <span class="params">[ output ]</span> = <span class="title">computP</span><span class="params">( curr,over,obstacle )</span>`</span></span><br><span class="line"></span><br><span class="line"> `k_att=<span class="number">1</span>;`</span><br><span class="line"></span><br><span class="line">`repu=<span class="number">0</span>;`</span><br><span class="line"></span><br><span class="line">`k_rep=<span class="number">100</span>;`</span><br><span class="line"></span><br><span class="line">`Q_star=<span class="number">2</span>;`</span><br><span class="line"></span><br><span class="line">`<span class="comment">%计算当前点距离终点的引力`</span></span><br><span class="line"></span><br><span class="line">`attr=<span class="number">1</span>/<span class="number">2</span>*k_att*(norm(curr-over))^<span class="number">2</span>;`</span><br><span class="line"></span><br><span class="line">`<span class="comment">%计算障碍点与当前点的斥力`</span></span><br><span class="line"></span><br><span class="line">`<span class="comment">%设定障碍的斥力作用半径为2`</span></span><br><span class="line"></span><br><span class="line">`<span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">size</span>(obstacle,<span class="number">2</span>)`</span><br><span class="line"></span><br><span class="line">   `<span class="keyword">if</span> norm(curr-obstacle(:,<span class="built_in">i</span>))&lt;=Q_star`</span><br><span class="line"></span><br><span class="line">​    `repu=repu+<span class="number">1</span>/<span class="number">2</span>*k_rep*(<span class="number">1</span>/norm(curr-obstacle(:,<span class="built_in">i</span>))<span class="number">-1</span>/Q_star)^<span class="number">2</span>;`</span><br><span class="line"></span><br><span class="line">  `<span class="keyword">else</span>`</span><br><span class="line"></span><br><span class="line">​    `repu=repu+<span class="number">0</span>;`</span><br><span class="line"></span><br><span class="line">  `<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">end</span>`</span><br><span class="line"></span><br><span class="line">`output=attr+repu;`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">end</span>`</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-4-实现的实际效果"><a href="#4-4-实现的实际效果" class="headerlink" title="4.4 实现的实际效果"></a>4.4 实现的实际效果</h5><p>事实上，尽管RANSAC算法在理论上已经具备足够的拟合精度，但在实际的识别过程中，由于激光雷达扫描获取的数据过多而导致干扰噪点的数量达到了一定规模，以及在算法参数设置上考虑到算力有限等因素而没有采用精确度最高的设置，诸如此类的干扰因素导致在多条直线识别时出现了互相覆盖与识别错误的情况，识别圆形时也并未识别出目标点的圆柱所在处，因此在实际的测试过程中，利用RANSAC算法识别圆与直线以获取目标点和障碍物坐标这一过程并未取得特别良好的效果。为了后面的路径规划算法顺利开展，我们最终采用人工识别的方式，分别给出了起点、障碍物以及目标点的大致坐标，并顺利实现了利用人工势场法进行路径规划的算法，合理规划出了从起点避开障碍物到达目标点停下的最优路径，并通过STM32单片机编程成功驱动了小车按照规划好的路径进行运动，顺利完成开环测试。</p>
<br>

<h4 id="五、实验结果及分析"><a href="#五、实验结果及分析" class="headerlink" title="五、实验结果及分析"></a><strong>五、实验结果及分析</strong></h4><hr>
<p>经过几次测试，在进行4至5个位置的扫描之后，通过将数据进行变换与拼接，可以得到一张较为完整的二维地图，再将地图中通过RANSAC算法识别出的特定点位数据读入程序运行，可以得到一条较为合理的最优路径。</p>
<p>事实上，在前面的嵌入式控制系统设计部分，我们计划采用PID方式对于小车与电机进行反馈调节控制，但在实际的测试中，PID的控制方式实现的效果并不尽如人意，无法合理利用MATLAB路径规划所得到的数据结果顺利完成测试。于是我们果断选择了重新使用PWM的方式，依托于MATLAB程序运行规划出的路径对应的相关数据计算所需要的PWM以及延时的时间。最终采用的代码如下图5-1所示（具体KEIL工程内容详见Run.zip附件)。</p>
<p><em>图5-1 PWM电机驱动部分实现代码</em></p>
<p><img src="/images/radarcar/5-1.png" alt="27"></p>
<p><img src="/images/radarcar/5-2.png" alt="28"></p>
<p>通过调整PWM的方式对小车进行开环运动控制，最终可以较好达到项目要求。（实现效果见下图5-2及视频附件“测试.mp4”）</p>
<p><em>图5-2 静态路径规划实现效果实地测试</em></p>
<p><img src="/images/radarcar/5-3.jpg" alt="29"></p>
<p><img src="/images/radarcar/5-4.jpg" alt="30"></p>
<p>虽然静态路径规划部分完成情况相对较好，但遗憾的是，由于对于C语言编程不是特别熟悉，包括受限于对库的了解、算法的时间复杂度较高、实现繁琐以及对于STM32内部利用效率的不完全开发等因素，最终并没有能够成功完成动态部分的路径规划。事实上，动态情况下的路径规划更符合我们在日常生活中常见的应用场景，不论是扫地机器人还是汽车导航，本身所应对的环境都在时刻发生着改变，因此动态的路径规划问题仍然值得在课程结束之后继续进行深挖和探索。希望在未来的工程实践中，我们能够以更加定量化的思维去分析和思考问题，同时更加熟练的掌握相关的算法设计，提高自己的硬件嵌入式编程能力。</p>
<br>

<h4 id="六、个人总结"><a href="#六、个人总结" class="headerlink" title="六、个人总结"></a><strong>六、个人总结</strong></h4><hr>
<p>在路径规划这一阶段的课程中，我在前半段主要负责的是STM32单片机的一些基础开发，对于其基本的开发流程以及GPIO等基本的功能模块有了一定的了解并能进行一些简单的32单片机编程；在后半段，我主要负责整体路径规划项目的思路整理与算法设计，结合课堂上介绍的RANSAC识别算法以及人工势场法规划路径，课下积极结合概念的巩固以及相关资料的查询，阅读了相关的示例代码，并根据算法的整体思路自己动手实现了RANSAC算法对于直线与圆的识别拟合以及在建立的势场中利用梯度下降法实现路径规划的MATLAB程序，积极将自己的算法实现与队友编写的STM32 C语言程序融合在一起，在与队友的充分交流沟通与合作的基础上共同完成了该项目。在死亡之桥的测试项目中，我在一个人调试了单片机程序许久未果后，与队友进行了积极的沟通与合作，也基本确定了由我负责编写MATLAB算法程序给队友的单片机编程提供数据支持的合作模式，对于我们团队的所有人来说都是一次难忘的经历。在利用激光雷达扫描地图的过程中，我们也充分信任彼此，在他们编写好了读取雷达数据的相关程序后，我结合着MATLAB程序的需求对于KEIL代码的输出格式部分进行了一定的修改，在通力合作下最终圆满完成了该项任务。除此之外，也非常感谢整个课程阶段过程中凌睿老师在算法思路方面对我们进行的一系列教学与指导以及助教学长们在答疑时的倾力相助。</p>
</div></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/head2.png" alt="Jinghua Xu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jinghua Xu</p><p class="is-size-6 is-block">明月科创实验班人工智能专业 本科大三在读</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>重庆 重庆大学国家卓越工程师学院</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">32</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">91</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Asgard-Tim" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Asgard-Tim"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://www.weibo.com/u/6315188431"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/171895120"><i class="fab fa-bilibili"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:20224546@stu.cqu.edu.cn"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Phone" href="tel:+86 19132050174"><i class="fas fa-phone"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2025/04/23/project02/"><img src="/images/project2/1.png" alt="图像插值算法及其优化"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-22T18:07:03.000Z">2025-04-23</time></p><p class="title"><a href="/2025/04/23/project02/">图像插值算法及其优化</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">工程数值分析</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/04/18/3DVLA/"><img src="/images/3dvla/6.png" alt="3D-VLA： A 3DVision-Language-Action Generative World Model"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-18T11:00:03.000Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/3DVLA/">3D-VLA： A 3DVision-Language-Action Generative World Model</a></p><p class="categories"><a href="/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">具身智能论文阅读</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/04/10/project01/"><img src="/images/project01/17.png" alt="求矩阵特征值与特征向量：乘幂法及其改进算法"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-10T09:44:03.000Z">2025-04-10</time></p><p class="title"><a href="/2025/04/10/project01/">求矩阵特征值与特征向量：乘幂法及其改进算法</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/">课程项目</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">工程数值分析</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/04/07/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><img src="/images/phi.png" alt="第二章 数据结构"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-07T05:26:58.000Z">2025-04-07</time></p><p class="title"><a href="/2025/04/07/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">第二章 数据结构</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/">算法基础课</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/04/06/RT-1/"><img src="/images/rt1/1.png" alt="RT-1：Robotics Transformer for Real-world Control at Scale"></a></figure><div class="media-content"><p class="date"><time datetime="2025-04-06T09:24:03.000Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/RT-1/">RT-1：Robotics Transformer for Real-world Control at Scale</a></p><p class="categories"><a href="/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">具身智能论文阅读</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/About-XJH/"><span class="level-start"><span class="level-item">About XJH</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/About-XJH/%E6%98%8E%E6%85%B5/"><span class="level-start"><span class="level-item">明慵</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/About-XJH/%E6%98%8E%E8%AF%9A/"><span class="level-start"><span class="level-item">明诚</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">个人项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"><span class="level-start"><span class="level-item">具身智能论文阅读</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">动手学深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"><span class="level-start"><span class="level-item">算法基础课</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">课程项目</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">产品设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95I/"><span class="level-start"><span class="level-item">定量工程设计方法I</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95II/"><span class="level-start"><span class="level-item">定量工程设计方法II</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E6%95%88%E5%AD%A6/"><span class="level-start"><span class="level-item">工效学</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">工程原理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">工程数值分析</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">工程设计</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"><span class="level-start"><span class="level-item">数学物理方法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"><span class="level-start"><span class="level-item">智能图像处理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">机器人基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"><span class="level-start"><span class="level-item">概率论与数理统计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"><span class="level-start"><span class="level-item">线性代数</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">自动控制原理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">软件设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">七月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/3D-VLA/"><span class="tag">3D-VLA</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ADS1292/"><span class="tag">ADS1292</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Buck%E5%8F%98%E6%8D%A2%E5%99%A8/"><span class="tag">Buck变换器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C51/"><span class="tag">C51</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/COMSOL/"><span class="tag">COMSOL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ChatGPT/"><span class="tag">ChatGPT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FIR/"><span class="tag">FIR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FPGA/"><span class="tag">FPGA</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FreeRTOS/"><span class="tag">FreeRTOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IIR/"><span class="tag">IIR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Logistic%E5%9B%9E%E5%BD%92/"><span class="tag">Logistic回归</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MATLAB/"><span class="tag">MATLAB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Matlab/"><span class="tag">Matlab</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PID%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/"><span class="tag">PID闭环控制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QQbot/"><span class="tag">QQbot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RANSAC/"><span class="tag">RANSAC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ROS/"><span class="tag">ROS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Robotics-Transformer/"><span class="tag">Robotics Transformer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/R%E8%AF%AD%E8%A8%80/"><span class="tag">R语言</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STM32/"><span class="tag">STM32</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shewhart%E6%8E%A7%E5%88%B6%E5%9B%BE/"><span class="tag">Shewhart控制图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ubuntu/"><span class="tag">Ubuntu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Unity/"><span class="tag">Unity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VLA/"><span class="tag">VLA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XJH/"><span class="tag">XJH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B9%98%E5%B9%82%E6%B3%95/"><span class="tag">乘幂法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E7%B1%BB/"><span class="tag">二分类</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%A7%E5%93%81%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"><span class="tag">产品质量管理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"><span class="tag">人机交互</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BC%A0%E7%83%AD%E5%AD%A6/"><span class="tag">传热学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"><span class="tag">信号与系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"><span class="tag">假设检验</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"><span class="tag">傅里叶变换</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%89%E4%BC%8FMPPT/"><span class="tag">光伏MPPT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD/"><span class="tag">具身智能</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F/"><span class="tag">动力学仿真</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">动手学深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"><span class="tag">单片机</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"><span class="tag">卷积神经网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8C%E4%B8%89%E6%AC%A1%E6%8F%92%E5%80%BC/"><span class="tag">双三次插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/"><span class="tag">双线性插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"><span class="tag">可视化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%9B%E5%B9%B3%E9%9D%A2%E6%8F%92%E5%80%BC/"><span class="tag">四平面插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC/"><span class="tag">图像插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%83%8F%E6%94%BE%E5%A4%A7/"><span class="tag">图像放大</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC/"><span class="tag">图像旋转</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"><span class="tag">图像识别</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B/"><span class="tag">多模态大模型</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="tag">学习笔记</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90/"><span class="tag">定量分析</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E8%BD%A6/"><span class="tag">小车</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E7%A8%8B%E7%83%AD%E5%8A%9B%E5%AD%A6/"><span class="tag">工程热力学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%83%E7%94%B5%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86/"><span class="tag">心电信号采集</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%AB%E9%80%9F%E6%88%AA%E6%96%ADHuber%E6%8D%9F%E5%A4%B1/"><span class="tag">快速截断Huber损失</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%89%A9%E6%95%A3%E6%96%B9%E7%A8%8B/"><span class="tag">扩散方程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"><span class="tag">支持向量机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%91%E7%81%BE%E6%9C%BA%E5%99%A8%E4%BA%BA/"><span class="tag">救灾机器人</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%80%BC%E8%BF%AD%E4%BB%A3%E6%B1%82%E8%A7%A3/"><span class="tag">数值迭代求解</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"><span class="tag">数字信号处理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"><span class="tag">数据处理分析</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%91%E5%8A%A8%E6%9C%BA/"><span class="tag">斯特林发动机</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%BE%AA%E7%8E%AF/"><span class="tag">斯特林循环</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E8%BF%91%E9%82%BB%E6%8F%92%E5%80%BC/"><span class="tag">最近邻插值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%89%E9%99%90%E5%85%83%E4%BB%BF%E7%9C%9F/"><span class="tag">有限元仿真</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%AC%E5%BE%81%E5%80%BC%E6%B1%82%E8%A7%A3/"><span class="tag">本征值求解</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/"><span class="tag">机械臂</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E6%A2%B0%E8%AE%BE%E8%AE%A1/"><span class="tag">机械设计</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9F%94%E6%80%A7%E5%A5%97%E7%B4%A2%E6%83%A9%E7%BD%9A/"><span class="tag">柔性套索惩罚</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BB%A4%E6%B3%A2%E5%99%A8/"><span class="tag">滤波器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%9F%E9%9B%BE%E6%89%A9%E6%95%A3/"><span class="tag">烟雾扩散</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/"><span class="tag">电机控制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A9%E9%98%B5%E7%89%B9%E5%BE%81%E5%80%BC/"><span class="tag">矩阵特征值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">算法与数据结构</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"><span class="tag">线性代数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%9F%E8%AE%A1%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6/"><span class="tag">统计过程控制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"><span class="tag">自动控制原理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%B0%83%E5%85%89/"><span class="tag">自动调光</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/"><span class="tag">自编码器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%88%B9/"><span class="tag">船</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"><span class="tag">计算机视觉</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/"><span class="tag">设计思维</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%9D%E7%A6%BB%E7%89%B9%E6%80%A7/"><span class="tag">距离特性</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="tag">路径规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/"><span class="tag">闭环控制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/"><span class="tag">频谱分析</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E6%96%AF%E6%A0%B8%E5%87%BD%E6%95%B0/"><span class="tag">高斯核函数</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/title1.png" alt="Homepage of Jinghua Xu" height="28"></a><p class="is-size-7"><span>© 2025 Tim</span>&nbsp;&nbsp;Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>&nbsp;&amp;&nbsp;<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© Copyright by Jinghua Xu</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Asgard-Tim"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer=""></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer=""></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer=""></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer=""></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer=""></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer=""></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer=""></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer=""></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/chitose.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script>
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = 'S-TA3IX28M1ZT7TILW';
        let tianliGPT_postSelector = '#postchat_postcontent';
        let tianliGPT_Title = '文章摘要';
        let tianliGPT_postURL = '/^https?://[^/]+/[0-9]{4}/[0-9]{2}/[0-9]{2}/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '1000';
        let tianliGPT_typingAnimate = true;
        let tianliGPT_theme = 'default';
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: true,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "PostChat",
          userDesc: "如果你对网站的内容有任何疑问，可以来问我哦～",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://ai.tianli0.top/static/img/PostChat.webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };
    </script>
    <script data-postchat_key="S-TA3IX28M1ZT7TILW" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>